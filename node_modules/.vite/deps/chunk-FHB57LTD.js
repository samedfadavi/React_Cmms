import {
  A,
  N as N2,
  b,
  k as k2,
  w as w3,
  y as y4
} from "./chunk-PM3JMBUP.js";
import {
  h as h3,
  u as u5,
  y as y3
} from "./chunk-4CS2XXGQ.js";
import {
  h as h4
} from "./chunk-XOGASIUG.js";
import {
  l as l3
} from "./chunk-PO74HSB6.js";
import {
  i as i3
} from "./chunk-GRVB2MLZ.js";
import {
  I as I2
} from "./chunk-5BIU5HC2.js";
import {
  E,
  F,
  X as X2
} from "./chunk-4K57JS64.js";
import {
  e as e7,
  o as o2
} from "./chunk-DOINOMWZ.js";
import {
  e as e3
} from "./chunk-NSJBY6SI.js";
import {
  t as t2
} from "./chunk-KWTQCB43.js";
import {
  M,
  N,
  X
} from "./chunk-OUWBUGHV.js";
import {
  a as a6,
  g as g3,
  s as s3,
  u as u4
} from "./chunk-3ZIQJRQY.js";
import {
  c as c4
} from "./chunk-GE4FYJHC.js";
import {
  a as a5,
  i as i2
} from "./chunk-MKSCPZ7O.js";
import {
  G as G2,
  J,
  L as L2,
  S as S2,
  Y,
  k,
  q,
  v as v2,
  w as w2
} from "./chunk-UPW2DNCP.js";
import {
  a as a7,
  e as e6,
  t as t3
} from "./chunk-LSYTXHXV.js";
import {
  u as u3
} from "./chunk-D7WIM7VD.js";
import {
  a as a4
} from "./chunk-XIC3SN6R.js";
import {
  e as e5
} from "./chunk-WX4IZMIC.js";
import {
  e as e4
} from "./chunk-T5CIHLIU.js";
import {
  n as n6
} from "./chunk-PNPG5IXD.js";
import {
  D as D2,
  I,
  O as O2,
  c as c3,
  f,
  p
} from "./chunk-T4EIRKFE.js";
import {
  l as l2
} from "./chunk-FJPG3YI6.js";
import {
  D,
  c as c2,
  i
} from "./chunk-BJHLU2MM.js";
import {
  m
} from "./chunk-YTTIKQNA.js";
import {
  d,
  v
} from "./chunk-7PMYO342.js";
import {
  V
} from "./chunk-3DBICPHD.js";
import {
  n as n2
} from "./chunk-XFBTC3BA.js";
import {
  j
} from "./chunk-VRHSV3YE.js";
import {
  a as a3
} from "./chunk-OVORXUCO.js";
import {
  n as n4
} from "./chunk-WLUQPLAY.js";
import {
  h as h2
} from "./chunk-6N5YXCNN.js";
import {
  O,
  S,
  _ as _2,
  e2,
  g as g2,
  l,
  n as n5,
  o,
  r,
  u as u2,
  y2,
  z
} from "./chunk-MJ2NSPP7.js";
import {
  _,
  n as n3,
  w
} from "./chunk-66KCMKB5.js";
import {
  L,
  W2 as W
} from "./chunk-X3IFQMC4.js";
import {
  G,
  Rt
} from "./chunk-WC4SPMPL.js";
import {
  a as a2,
  t,
  y
} from "./chunk-TJUEGVVG.js";
import {
  a3 as a
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  c2 as c,
  g,
  h,
  s as s2,
  u
} from "./chunk-VMWKLHJD.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-YNL57W4I.js";

// ../node_modules/@arcgis/core/geometry/support/meshErrors.js
var t4 = "Mesh must be loaded before applying operations";
var e8 = "Provided component is not part of the list of components";
var n7 = "Expected polygon to be a Polygon instance";
var s4 = "Expected location to be a Point instance";
var i4 = class extends s {
  constructor() {
    super("invalid-input:location", s4);
  }
};

// ../node_modules/@arcgis/core/geometry/support/polygonUtils.js
function c5(t6, o4, s5) {
  const i6 = e9(f2, t6, o4, s5) ? F(f2) : [0, 0, 1];
  return Math.abs(i6[2]) > Math.cos(h2(80)) ? n4.Z : Math.abs(i6[1]) > Math.abs(i6[0]) ? n4.Y : n4.X;
}
function e9(r2, a10, i6, n8) {
  const c8 = ((r3) => !Array.isArray(r3[0]))(a10) ? (r3, t6) => a10[3 * r3 + t6] : (r3, t6) => a10[r3][t6], e10 = n8 ? W(n8) / L(n8) : 1;
  return X2(r2, (r3, t6) => o(r3, c8(t6, 0) * e10, c8(t6, 1) * e10, c8(t6, 2)), i6);
}
var f2 = E();

// ../node_modules/@arcgis/core/geometry/support/triangulationUtils.js
function f3(t6) {
  const e10 = a8(t6.rings, t6.hasZ, p2.CCW_IS_HOLE, t6.spatialReference), s5 = new Array();
  let l4 = 0, f6 = 0;
  for (const r2 of e10.polygons) {
    const t7 = r2.count, c8 = r2.index, h9 = a7(e10.position, 3 * c8, 3 * t7), a10 = r2.holeIndices.map((n8) => n8 - c8), g9 = t2(i3(h9, a10, 3));
    s5.push({ position: h9, faces: g9 }), l4 += h9.length, f6 += g9.length;
  }
  const g8 = h5(s5, l4, f6), u10 = Array.isArray(g8.position) ? e3(g8.position, 3, { originalIndices: g8.faces }) : e3(g8.position.buffer, 6, { originalIndices: g8.faces });
  return g8.position = e6(new Float64Array(u10.buffer)), g8.faces = u10.indices, g8;
}
function h5(n8, t6, e10) {
  if (1 === n8.length) return n8[0];
  const o4 = t3(t6), r2 = new Array(e10);
  let l4 = 0, c8 = 0, f6 = 0;
  for (const s5 of n8) {
    for (let n9 = 0; n9 < s5.position.length; n9++) o4[l4++] = s5.position[n9];
    for (const n9 of s5.faces) r2[c8++] = n9 + f6;
    f6 = l4 / 3;
  }
  return { position: o4, faces: t2(r2) };
}
function a8(n8, t6, e10, o4) {
  const r2 = n8.length, i6 = new Array(r2), l4 = new Array(r2), c8 = new Array(r2);
  let f6 = 0;
  for (let s5 = 0; s5 < r2; ++s5) f6 += n8[s5].length;
  let h9 = 0, a10 = 0, m5 = 0;
  const d4 = t3(3 * f6);
  let y7 = 0;
  for (let s5 = r2 - 1; s5 >= 0; s5--) {
    const f7 = n8[s5], A4 = e10 === p2.CCW_IS_HOLE && u6(f7, t6, o4);
    if (A4 && 1 !== r2) i6[h9++] = f7;
    else {
      let n9 = f7.length;
      for (let t7 = 0; t7 < h9; ++t7) n9 += i6[t7].length;
      const e11 = { index: y7, pathLengths: new Array(h9 + 1), count: n9, holeIndices: new Array(h9) };
      e11.pathLengths[0] = f7.length, f7.length > 0 && (c8[m5++] = { index: y7, count: f7.length }), y7 = A4 ? g4(f7, f7.length - 1, -1, d4, y7, f7.length, t6) : g4(f7, 0, 1, d4, y7, f7.length, t6);
      for (let o5 = 0; o5 < h9; ++o5) {
        const n10 = i6[o5];
        e11.holeIndices[o5] = y7, e11.pathLengths[o5 + 1] = n10.length, n10.length > 0 && (c8[m5++] = { index: y7, count: n10.length }), y7 = g4(n10, 0, 1, d4, y7, n10.length, t6);
      }
      h9 = 0, e11.count > 0 && (l4[a10++] = e11);
    }
  }
  for (let s5 = 0; s5 < h9; ++s5) {
    const n9 = i6[s5];
    n9.length > 0 && (c8[m5++] = { index: y7, count: n9.length }), y7 = g4(n9, 0, 1, d4, y7, n9.length, t6);
  }
  return l4.length = a10, c8.length = m5, { position: d4, polygons: l4, outlines: c8 };
}
function g4(n8, t6, e10, o4, r2, s5, i6) {
  r2 *= 3;
  for (let l4 = 0; l4 < s5; ++l4) {
    const s6 = n8[t6];
    o4[r2++] = s6[0], o4[r2++] = s6[1], o4[r2++] = i6 ? s6[2] : 0, t6 += e10;
  }
  return r2 / 3;
}
function u6(n8, o4, r2) {
  if (!o4) return !a3(n8);
  const s5 = n8.length - 1;
  switch (c5(n8, s5, r2)) {
    case n4.X:
      return !a3(n8, n4.Y, n4.Z);
    case n4.Y:
      return !a3(n8, n4.X, n4.Z);
    case n4.Z:
      return !a3(n8, n4.X, n4.Y);
  }
}
var p2;
!function(n8) {
  n8[n8.NONE = 0] = "NONE", n8[n8.CCW_IS_HOLE = 1] = "CCW_IS_HOLE";
}(p2 || (p2 = {}));

// ../node_modules/@arcgis/core/geometry/support/meshUtils/bounds.js
function o3([e10, n8, r2, I4, o4, m5], u10, a10, s5) {
  i5 ?? (i5 = new Float64Array(24));
  const T3 = i5;
  return T3[0] = e10, T3[1] = n8, T3[2] = r2, T3[3] = e10, T3[4] = o4, T3[5] = r2, T3[6] = I4, T3[7] = o4, T3[8] = r2, T3[9] = I4, T3[10] = n8, T3[11] = r2, T3[12] = e10, T3[13] = n8, T3[14] = m5, T3[15] = e10, T3[16] = o4, T3[17] = m5, T3[18] = I4, T3[19] = o4, T3[20] = m5, T3[21] = I4, T3[22] = n8, T3[23] = m5, J({ positions: T3, transform: u10, vertexSpace: a10, inSpatialReference: s5, outSpatialReference: s5, outPositions: T3 }), N3(T3, s5);
}
var i5 = null;
function m2(e10) {
  if (0 === e10.length) return D;
  const t6 = i([Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, -Number.POSITIVE_INFINITY, -Number.POSITIVE_INFINITY, -Number.POSITIVE_INFINITY]);
  return c2(t6, e10), t6;
}
function N3(n8, r2) {
  const [I4, t6, o4, i6, N5, u10] = m2(n8);
  return new w({ xmin: I4, ymin: t6, zmin: o4, xmax: i6, ymax: N5, zmax: u10, spatialReference: r2 });
}

// ../node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function t5(o4, t6, i6, a10) {
  if (void 0 !== a10) {
    a2(o4(), "option: geographic", { replacement: "Use mesh `vertexSpace` and spatial reference to control how operations are performed instead.", version: "4.30", warnOnce: true });
    const c8 = "local" === t6.type;
    if (!a6(t6) || a10 === c8) return i6.isGeographic || i6.isWebMercator && a10;
    o4().warnOnce(`Specifying the 'geographic' parameter (${a10}) for a Mesh vertex space of type "${t6.type}" is not supported. This parameter will be ignored.`);
  }
  switch (t6.type) {
    case "georeferenced":
      return i6.isGeographic;
    case "local":
      return i6.isGeographic || i6.isWebMercator;
  }
}

// ../node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var g5 = () => n.getLogger("esri.geometry.support.meshUtils.centerAt");
function u7(e10, t6, r2) {
  var _a;
  if (!((_a = e10.vertexAttributes) == null ? void 0 : _a.position)) return;
  const { vertexSpace: i6 } = e10, o4 = (r2 == null ? void 0 : r2.origin) ?? e10.anchor, n8 = t5(g5, i6, o4.spatialReference, r2 == null ? void 0 : r2.geographic);
  a6(i6) ? x(e10, t6, o4) : n8 ? v3(e10, t6, o4) : R(e10, t6, o4);
}
function x(e10, o4, s5) {
  const { vertexSpace: c8 } = e10;
  if (!a6(c8)) return;
  const f6 = b2, m5 = h6;
  if (!c4(o4, m5, e10.spatialReference)) return void S2(g5(), o4.spatialReference, e10.spatialReference, L2);
  if (!c4(s5, f6, e10.spatialReference)) {
    const t6 = e10.origin;
    return f6[0] = t6.x, f6[1] = t6.y, f6[2] = t6.z, void S2(g5(), s5.spatialReference, e10.spatialReference, L2);
  }
  const u10 = e2(A2, m5, f6);
  c8.origin = u2(n5(), c8.origin, u10);
}
function v3(e10, t6, r2) {
  const i6 = r(r2.x, r2.y, r2.z ?? 0), n8 = M(e10, new a5({ origin: i6 }));
  if (!n8) return;
  const a10 = r(t6.x, t6.y, t6.z ?? 0), f6 = M({ vertexAttributes: n8, spatialReference: e10.spatialReference, vertexSpace: new a5({ origin: a10 }) }, new i2());
  if (!f6) return;
  const { position: p5, normal: l4, tangent: g8 } = f6;
  e10.vertexAttributes.position = p5, e10.vertexAttributes.normal = l4, e10.vertexAttributes.tangent = g8, e10.vertexAttributesChanged();
}
function R(e10, t6, r2) {
  const i6 = b2, o4 = h6;
  if (c4(t6, o4, e10.spatialReference)) {
    if (!c4(r2, i6, e10.spatialReference)) {
      const t7 = e10.origin;
      return i6[0] = t7.x, i6[1] = t7.y, i6[2] = t7.z, void S2(g5(), r2.spatialReference, e10.spatialReference, L2);
    }
    j2(e10.vertexAttributes.position, o4, i6), e10.vertexAttributesChanged();
  } else S2(g5(), t6.spatialReference, e10.spatialReference, L2);
}
function j2(e10, t6, r2) {
  if (e10) for (let i6 = 0; i6 < e10.length; i6 += 3) for (let o4 = 0; o4 < 3; o4++) e10[i6 + o4] += t6[o4] - r2[o4];
}
var h6 = n5();
var b2 = n5();
var A2 = n5();

// ../node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function c6(e10, n8, r2) {
  const { source: o4 } = n8, { loadGLTFMesh: i6 } = await h(import("./loadGLTFMesh-EHQLHZJ3.js"), r2), a10 = await f4(o4, r2);
  s2(r2);
  const c8 = i6(new _({ x: 0, y: 0, z: 0, spatialReference: e10.spatialReference }), a10.url, { resolveFile: u8(a10), signal: r2 == null ? void 0 : r2.signal, expectedType: a10.type });
  c8.then(() => a10.dispose(), () => a10.dispose());
  const { vertexAttributes: m5, components: p5 } = await c8;
  e10.vertexAttributes = m5, e10.components = p5;
}
function u8(e10) {
  const t6 = Rt(e10.url);
  return (s5) => {
    const n8 = G(s5, t6, t6), r2 = n8 ? n8.replace(/^ *\.\//, "") : null;
    return (r2 ? e10.files.get(r2) : null) ?? s5;
  };
}
async function f4(t6, s5) {
  if (Array.isArray(t6)) {
    if (!t6.length) throw new s("mesh-load-external:missing-assets", "There must be at least one file to load");
    return t6[0] instanceof File ? h7(t6) : y5(t6, s5);
  }
  return p3(t6);
}
async function m3(e10, t6) {
  const { parts: n8, assetMimeType: r2, assetName: o4 } = e10;
  if (1 === n8.length) return new j3(n8[0].partUrl);
  const i6 = await e10.toBlob(t6);
  return s2(t6), j3.fromBlob(i6, x2(o4, r2));
}
function p3(e10) {
  return j3.fromBlob(e10, x2(e10.name, e10.type));
}
function h7(e10) {
  return T(e10.map((e11) => ({ name: e11.name, mimeType: e11.type, source: p3(e11) })));
}
async function y5(e10, t6) {
  const i6 = await g(e10.map(async (e11) => {
    const n8 = await m3(e11);
    return s2(t6), { name: e11.assetName, mimeType: e11.assetMimeType, source: n8 };
  }));
  if (c(t6)) throw i6.forEach((e11) => e11.source.dispose()), u();
  return T(i6);
}
var w4 = /^model\/gltf\+json$/;
var d2 = /^model\/gltf-binary$/;
var g6 = /\.gltf$/i;
var b3 = /\.glb$/i;
function T(t6) {
  const s5 = /* @__PURE__ */ new Map();
  let n8, r2 = null;
  for (const { name: e10, mimeType: o4, source: i6 } of t6) null === r2 && (w4.test(o4) || g6.test(e10) ? (r2 = i6.url, n8 = "gltf") : (d2.test(o4) || b3.test(e10)) && (r2 = i6.url, n8 = "glb")), s5.set(e10, i6.url), i6.files.forEach((e11, t7) => s5.set(t7, e11));
  if (null == r2) throw new s("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new j3(r2, () => t6.forEach(({ source: e10 }) => e10.dispose()), s5, n8);
}
var j3 = class _j {
  constructor(e10, t6 = () => {
  }, s5 = /* @__PURE__ */ new Map(), n8) {
    this.url = e10, this.dispose = t6, this.files = s5, this.type = n8;
  }
  static fromBlob(e10, t6) {
    const s5 = URL.createObjectURL(e10);
    return new _j(s5, () => URL.revokeObjectURL(s5), void 0, t6);
  }
};
function x2(e10, t6) {
  return w4.test(t6) || g6.test(e10) ? "gltf" : d2.test(t6) || g6.test(e10) ? "glb" : void 0;
}

// ../node_modules/@arcgis/core/geometry/support/meshUtils/Metadata.js
var a9 = class extends l2 {
  constructor(e10) {
    super(e10), this.externalSources = new V(), this._explicitDisplaySource = null, this.addHandles(v(() => this.externalSources, "after-remove", ({ item: e11 }) => {
      e11 === this._explicitDisplaySource && (this._explicitDisplaySource = null);
    }, { sync: true, onListenerRemove: () => this._explicitDisplaySource = null }));
  }
  get displaySource() {
    return this._explicitDisplaySource ?? this._implicitDisplaySource;
  }
  set displaySource(e10) {
    if (null != e10 && !u5(e10)) throw new Error("Cannot use this source for display: it is not in a supported format.");
    this._explicitDisplaySource = e10, e10 && this.externalSources.every((r2) => !y3(r2, e10)) && this.externalSources.add(e10);
  }
  clearSources() {
    this.externalSources.removeAll();
  }
  getExternalSourcesOnService(e10) {
    return this.externalSources.items.filter((r2) => h3(r2, e10));
  }
  get _implicitDisplaySource() {
    return this.externalSources.find(u5);
  }
};
e([y()], a9.prototype, "externalSources", void 0), e([y()], a9.prototype, "displaySource", null), e([y()], a9.prototype, "_implicitDisplaySource", null), e([y()], a9.prototype, "_explicitDisplaySource", void 0), a9 = e([a("esri.geometry.support.meshUtils.Metadata")], a9);

// ../node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function c7() {
  const { faceDescriptions: t6, faceVertexOffsets: e10, uvScales: r2 } = F2, n8 = 4 * t6.length, o4 = new Float64Array(3 * n8), s5 = new Float32Array(3 * n8), a10 = new Float32Array(2 * n8), i6 = new Uint32Array(2 * t6.length * 3);
  let l4 = 0, c8 = 0, f6 = 0, u10 = 0;
  for (let h9 = 0; h9 < t6.length; h9++) {
    const n9 = t6[h9], p5 = l4 / 3;
    for (const t7 of e10) i6[u10++] = p5 + t7;
    const m5 = n9.corners;
    for (let t7 = 0; t7 < 4; t7++) {
      const e11 = m5[t7];
      let i7 = 0;
      a10[f6++] = 0.25 * r2[t7][0] + n9.uvOrigin[0], a10[f6++] = n9.uvOrigin[1] - 0.25 * r2[t7][1];
      for (let t8 = 0; t8 < 3; t8++) 0 !== n9.axis[t8] ? (o4[l4++] = 0.5 * n9.axis[t8], s5[c8++] = n9.axis[t8]) : (o4[l4++] = 0.5 * e11[i7++], s5[c8++] = 0);
    }
  }
  return { position: o4, normal: s5, uv: a10, faces: i6 };
}
function f5(t6, e10) {
  const r2 = t6.components[0], n8 = r2.faces, s5 = b4[e10], a10 = 6 * s5, i6 = new Array(6), l4 = new Array(n8.length - 6);
  let c8 = 0, f6 = 0;
  for (let o4 = 0; o4 < n8.length; o4++) o4 >= a10 && o4 < a10 + 6 ? i6[c8++] = n8[o4] : l4[f6++] = n8[o4];
  if (null != t6.vertexAttributes.uv) {
    const e11 = new Float32Array(t6.vertexAttributes.uv), r3 = 4 * s5 * 2, n9 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let t7 = 0; t7 < n9.length; t7++) e11[r3 + t7] = n9[t7];
    t6.vertexAttributes.uv = e11;
  }
  return t6.components = [new h4({ faces: i6, material: r2.material }), new h4({ faces: l4 })], t6;
}
function u9(t6 = 0) {
  const e10 = Math.round(8 * 2 ** t6), r2 = 2 * e10, n8 = (e10 - 1) * (r2 + 1) + 2 * r2, o4 = new Float64Array(3 * n8), s5 = new Float32Array(3 * n8), a10 = new Float32Array(2 * n8), i6 = new Uint32Array(3 * ((e10 - 1) * r2 * 2));
  let l4 = 0, c8 = 0, f6 = 0, u10 = 0;
  for (let h9 = 0; h9 <= e10; h9++) {
    const t7 = h9 / e10 * Math.PI + 0.5 * Math.PI, n9 = Math.cos(t7), p5 = Math.sin(t7);
    O3[2] = p5;
    const m5 = 0 === h9 || h9 === e10, w6 = m5 ? r2 - 1 : r2;
    for (let v5 = 0; v5 <= w6; v5++) {
      const t8 = v5 / w6 * 2 * Math.PI;
      O3[0] = -Math.sin(t8) * n9, O3[1] = Math.cos(t8) * n9;
      for (let e11 = 0; e11 < 3; e11++) o4[l4] = 0.5 * O3[e11], s5[l4] = O3[e11], ++l4;
      a10[c8++] = (v5 + (m5 ? 0.5 : 0)) / r2, a10[c8++] = h9 / e10, 0 !== h9 && v5 !== r2 && (h9 !== e10 && (i6[f6++] = u10, i6[f6++] = u10 + 1, i6[f6++] = u10 - r2), 1 !== h9 && (i6[f6++] = u10, i6[f6++] = u10 - r2, i6[f6++] = u10 - r2 - 1)), u10++;
    }
  }
  return { position: o4, normal: s5, uv: a10, faces: i6 };
}
function h8(t6 = 0) {
  const e10 = 5, r2 = Math.round(16 * 2 ** t6), n8 = (e10 - 1) * (r2 + 1) + 2 * r2, o4 = new Float64Array(3 * n8), s5 = new Float32Array(3 * n8), a10 = new Float32Array(2 * n8), i6 = new Uint32Array(3 * (4 * r2));
  let l4 = 0, c8 = 0, f6 = 0, u10 = 0, h9 = 0;
  for (let p5 = 0; p5 <= e10; p5++) {
    const t7 = 0 === p5 || p5 === e10, n9 = p5 <= 1 || p5 >= e10 - 1, m5 = 2 === p5 || 4 === p5, w6 = t7 ? r2 - 1 : r2;
    for (let v5 = 0; v5 <= w6; v5++) {
      const g8 = v5 / w6 * 2 * Math.PI, A4 = t7 ? 0 : 0.5;
      O3[0] = A4 * Math.sin(g8), O3[1] = A4 * -Math.cos(g8), O3[2] = p5 <= 2 ? 0.5 : -0.5;
      for (let t8 = 0; t8 < 3; t8++) o4[l4++] = O3[t8], s5[c8++] = n9 ? 2 === t8 ? p5 <= 1 ? 1 : -1 : 0 : 2 === t8 ? 0 : O3[t8] / A4;
      a10[f6++] = (v5 + (t7 ? 0.5 : 0)) / r2, a10[f6++] = p5 <= 1 ? 1 * p5 / 3 : p5 <= 3 ? 1 * (p5 - 2) / 3 + 1 / 3 : 1 * (p5 - 4) / 3 + 2 / 3, m5 || 0 === p5 || v5 === r2 || (p5 !== e10 && (i6[u10++] = h9, i6[u10++] = h9 + 1, i6[u10++] = h9 - r2), 1 !== p5 && (i6[u10++] = h9, i6[u10++] = h9 - r2, i6[u10++] = h9 - r2 - 1)), h9++;
    }
  }
  return { position: o4, normal: s5, uv: a10, faces: i6 };
}
function p4(t6, e10) {
  const r2 = "number" == typeof e10 ? e10 : null != e10 ? e10.width : 1, n8 = "number" == typeof e10 ? e10 : null != e10 ? e10.height : 1;
  switch (t6) {
    case "up":
    case "down":
      return { width: r2, depth: n8 };
    case "north":
    case "south":
      return { width: r2, height: n8 };
    case "east":
    case "west":
      return { depth: r2, height: n8 };
  }
}
function m4(t6) {
  const e10 = A3.facingAxisOrderSwap[t6], r2 = A3.position, n8 = A3.normal, o4 = new Float64Array(r2.length), s5 = new Float32Array(n8.length);
  let a10 = 0;
  for (let i6 = 0; i6 < 4; i6++) {
    const t7 = a10;
    for (let i7 = 0; i7 < 3; i7++) {
      const l4 = e10[i7], c8 = Math.abs(l4) - 1, f6 = l4 >= 0 ? 1 : -1;
      o4[a10] = r2[t7 + c8] * f6, s5[a10] = n8[t7 + c8] * f6, a10++;
    }
  }
  return { position: o4, normal: s5, uv: new Float32Array(A3.uv), faces: new Uint32Array(A3.faces), isPlane: true };
}
var w5 = 1;
var v4 = 2;
var g7 = 3;
var A3 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [g7, w5, v4], west: [-g7, -w5, v4], north: [-w5, g7, v4], south: [w5, -g7, v4], up: [w5, v4, g7], down: [w5, -v4, -g7] } };
function x3(t6, e10, r2) {
  t6.isPlane || y6(t6), M2(t6, d3(r2 == null ? void 0 : r2.size, r2 == null ? void 0 : r2.unit, e10.spatialReference));
  const n8 = s3(e10, r2), l4 = e10.spatialReference.isGeographic ? s3(e10) : n8, c8 = M({ vertexAttributes: t6, vertexSpace: l4, spatialReference: e10.spatialReference }, n8, { allowBufferReuse: true });
  return { vertexAttributes: new l3({ ...c8, uv: t6.uv }), vertexSpace: n8, components: [new h4({ faces: t6.faces, material: (r2 == null ? void 0 : r2.material) || null })], spatialReference: e10.spatialReference };
}
function y6(t6) {
  for (let e10 = 0; e10 < t6.position.length; e10 += 3) t6.position[e10 + 2] += 0.5;
}
function d3(t6, e10, r2) {
  const n8 = X(e10, r2);
  if (null == t6 && 1 === n8) return null;
  if (null == t6) return [n8, n8, n8];
  if ("number" == typeof t6) {
    const e11 = t6 * n8;
    return [e11, e11, e11];
  }
  return [null != t6.width ? t6.width * n8 : n8, null != t6.depth ? t6.depth * n8 : n8, null != t6.height ? t6.height * n8 : n8];
}
function M2(t6, n8) {
  if (null != n8) {
    S3[0] = n8[0], S3[4] = n8[1], S3[8] = n8[2];
    for (let r2 = 0; r2 < t6.position.length; r2 += 3) {
      for (let e10 = 0; e10 < 3; e10++) O3[e10] = t6.position[r2 + e10];
      S(O3, O3, S3);
      for (let e10 = 0; e10 < 3; e10++) t6.position[r2 + e10] = O3[e10];
    }
    if (n8[0] !== n8[1] || n8[1] !== n8[2]) {
      S3[0] = 1 / n8[0], S3[4] = 1 / n8[1], S3[8] = 1 / n8[2];
      for (let n9 = 0; n9 < t6.normal.length; n9 += 3) {
        for (let e10 = 0; e10 < 3; e10++) O3[e10] = t6.normal[n9 + e10];
        S(O3, O3, S3), z(O3, O3);
        for (let e10 = 0; e10 < 3; e10++) t6.normal[n9 + e10] = O3[e10];
      }
    }
  }
}
var F2 = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var b4 = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var O3 = n5();
var S3 = e4();

// ../node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var O4 = () => n.getLogger("esri.geometry.support.meshUtils.rotate");
function B(t6, e10, r2) {
  var _a;
  if (!((_a = t6.vertexAttributes) == null ? void 0 : _a.position) || 0 === e10[3]) return;
  const { spatialReference: o4, vertexSpace: i6 } = t6, n8 = (r2 == null ? void 0 : r2.origin) ?? t6.anchor, s5 = r2 == null ? void 0 : r2.geographic, a10 = t5(O4, i6, o4, s5);
  g3(t6) ? G3(t6, e10, n8) : a10 ? H(t6, e10, n8) : I3(t6, e10, n8);
}
function G3(t6, e10, r2) {
  t6.transform ?? (t6.transform = new N2());
  const { vertexSpace: l4, transform: c8, spatialReference: f6 } = t6, [g8, x4, A4] = l4.origin, R2 = new _({ x: g8, y: x4, z: A4, spatialReference: f6 }), d4 = K;
  if (R2.equals(r2)) o(d4, 0, 0, 0);
  else if (!N(d4, r2, t6)) return void S2(O4(), r2.spatialReference, f6, L2);
  I2(Z, y4(e10), A(e10));
  const y7 = D2(N4, Z, l, _2, d4), { localMatrix: U } = c8, q3 = c3(N4, y7, U);
  c8.scale = O2(n5(), q3), f(q3, q3, y2(K, c8.scale));
  const z3 = c8.rotationAxis;
  c8.rotation = k2(q3), 0 === c8.rotationAngle && (c8.rotationAxis = z3), c8.translation = I(n5(), q3);
}
function H(t6, r2, o4) {
  const i6 = t6.spatialReference, n8 = a4(i6), s5 = Y2;
  if (!c4(o4, s5, n8) && (S2(O4(), o4.spatialReference, n8, "Falling back to mesh origin"), !c4(t6.origin, s5, n8))) return void S2(O4(), t6.origin.spatialReference, n8);
  const a10 = t6.vertexAttributes.position, l4 = t6.vertexAttributes.normal, c8 = t6.vertexAttributes.tangent, m5 = new Float64Array(a10.length), f6 = null != l4 ? new Float32Array(l4.length) : null, p5 = null != c8 ? new Float32Array(c8.length) : null;
  u3(n8, s5, W2, n8), n6(X3, W2);
  const u10 = Q;
  S(y4(Q), y4(r2), X3), u10[3] = r2[3], w2(a10, i6, m5) && (null == l4 || null == f6 || v2(l4, a10, m5, i6, f6)) && (null == c8 || null == p5 || Y(c8, a10, m5, i6, p5)) ? (J2(m5, u10, 3, s5), G2(m5, a10, i6) && (null == l4 || null == f6 || (J2(f6, u10, 3), k(f6, a10, m5, i6, l4))) && (null == c8 || null == p5 || (J2(p5, u10, 4), q(p5, a10, m5, i6, c8))) ? t6.vertexAttributesChanged() : S2(O4(), n8, i6)) : S2(O4(), i6, n8);
}
function I3(t6, e10, r2) {
  const o4 = Y2;
  if (!c4(r2, o4, t6.spatialReference)) {
    const e11 = t6.origin;
    return o4[0] = e11.x, o4[1] = e11.y, o4[2] = e11.z, void S2(O4(), r2.spatialReference, t6.spatialReference, L2);
  }
  J2(t6.vertexAttributes.position, e10, 3, o4), J2(t6.vertexAttributes.normal, e10, 3), J2(t6.vertexAttributes.tangent, e10, 4), t6.vertexAttributesChanged();
}
function J2(t6, e10, r2, o4 = l) {
  if (null != t6) {
    p(W2, A(e10), y4(e10));
    for (let e11 = 0; e11 < t6.length; e11 += r2) {
      for (let r3 = 0; r3 < 3; r3++) K[r3] = t6[e11 + r3] - o4[r3];
      O(K, K, W2);
      for (let r3 = 0; r3 < 3; r3++) t6[e11 + r3] = K[r3] + o4[r3];
    }
  }
}
var K = n5();
var N4 = e5();
var Q = b();
var W2 = e5();
var X3 = e4();
var Y2 = n5();
var Z = e7();

// ../node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var k3 = () => n.getLogger("esri.geometry.support.meshUtils.scale");
function q2(e10, t6, r2) {
  var _a;
  if (!((_a = e10.vertexAttributes) == null ? void 0 : _a.position)) return;
  const { vertexSpace: o4, spatialReference: i6 } = e10, n8 = (r2 == null ? void 0 : r2.origin) ?? e10.anchor, s5 = r2 == null ? void 0 : r2.geographic, a10 = t5(k3, o4, i6, s5);
  g3(e10) ? z2(e10, t6, n8) : a10 ? L3(e10, t6, n8) : M3(e10, t6, n8);
}
function z2(e10, s5, f6) {
  e10.transform ?? (e10.transform = new N2());
  const { vertexSpace: g8, transform: x4, spatialReference: h9 } = e10, [A4, d4, y7] = g8.origin, w6 = new _({ x: A4, y: d4, z: y7, spatialReference: h9 }), F3 = T2;
  if (w6.equals(f6)) o(F3, 0, 0, 0);
  else if (!N(F3, f6, e10)) return void S2(k3(), f6.spatialReference, h9, L2);
  const S4 = o(V2, s5, s5, s5), U = D2(D3, o2, l, S4, F3), { localMatrix: q3 } = x4, z3 = c3(D3, U, q3);
  x4.scale = O2(n5(), z3), f(z3, z3, y2(T2, x4.scale));
  const L4 = x4.rotationAxis;
  x4.rotation = k2(z3), 0 === x4.rotationAngle && (x4.rotationAxis = L4), x4.translation = I(n5(), z3);
}
function L3(e10, t6, r2) {
  const o4 = e10.spatialReference, i6 = a4(o4), n8 = E2;
  if (!c4(r2, n8, i6) && (S2(k3(), r2.spatialReference, i6, "Falling back to mesh origin"), !c4(e10.origin, n8, i6))) return void S2(k3(), e10.origin.spatialReference, i6);
  const s5 = e10.vertexAttributes.position, a10 = e10.vertexAttributes.normal, l4 = e10.vertexAttributes.tangent, c8 = new Float64Array(s5.length), f6 = null != a10 ? new Float32Array(a10.length) : null, m5 = null != l4 ? new Float32Array(l4.length) : null;
  w2(s5, o4, c8) && (null == a10 || null == f6 || v2(a10, s5, c8, o4, f6)) && (null == l4 || null == m5 || Y(l4, s5, c8, o4, m5)) ? (P(c8, t6, n8), G2(c8, s5, o4) && (null == a10 || null == f6 || k(f6, s5, c8, o4, a10)) && (null == l4 || null == m5 || q(m5, s5, c8, o4, l4)) ? e10.vertexAttributesChanged() : S2(k3(), i6, o4)) : S2(k3(), o4, i6);
}
function M3(e10, t6, r2) {
  const o4 = E2;
  if (!c4(r2, o4, e10.spatialReference)) {
    const t7 = e10.origin;
    return o4[0] = t7.x, o4[1] = t7.y, o4[2] = t7.z, void S2(k3(), r2.spatialReference, e10.spatialReference, L2);
  }
  P(e10.vertexAttributes.position, t6, o4), e10.vertexAttributesChanged();
}
function P(e10, t6, r2 = l) {
  if (e10) for (let o4 = 0; o4 < e10.length; o4 += 3) {
    for (let t7 = 0; t7 < 3; t7++) T2[t7] = e10[o4 + t7] - r2[t7];
    g2(T2, T2, t6);
    for (let t7 = 0; t7 < 3; t7++) e10[o4 + t7] = T2[t7] + r2[t7];
  }
}
var T2 = n5();
var V2 = n5();
var D3 = e5();
var E2 = n5();

// ../node_modules/@arcgis/core/geometry/Mesh.js
var H2;
var K2 = "esri.geometry.Mesh";
function J3() {
  return n.getLogger(K2);
}
var Q2 = { base: null, key: "type", defaultKeyValue: "georeferenced", typeMap: { georeferenced: i2, local: a5 } };
var X4 = H2 = class extends m.LoadableMixin(n2(n3)) {
  constructor(e10) {
    super(e10), this.components = null, this.vertexSpace = new i2(), this.transform = null, this.metadata = new a9(), this.hasZ = true, this.hasM = false, this.vertexAttributes = new l3(), this.type = "mesh";
  }
  initialize() {
    (0 === this.metadata.externalSources.length || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.addHandles(d(() => {
        var _a;
        return { vertexAttributes: this.vertexAttributes, components: (_a = this.components) == null ? void 0 : _a.map((e10) => e10.clone()) };
      }, () => this._clearSources(), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    var _a;
    return this.loaded ? this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0) : null != ((_a = this.metadata.displaySource) == null ? void 0 : _a.extent);
  }
  get _transformedExtent() {
    const { components: e10, spatialReference: t6, vertexAttributes: r2, vertexSpace: o4 } = this, s5 = r2.position;
    if (0 === s5.length || e10 && 0 === e10.length) return new w({ xmin: 0, ymin: 0, zmin: 0, xmax: 0, ymax: 0, zmax: 0, spatialReference: t6 });
    if (a6(o4)) {
      const { _untransformedBounds: e11, transform: r3 } = this;
      return o3(e11, r3, o4, t6);
    }
    return N3(s5, t6);
  }
  get _untransformedBounds() {
    return m2(this.vertexAttributes.position);
  }
  get anchor() {
    const e10 = u4(this.vertexSpace, this.spatialReference);
    if (null != e10) return e10;
    const { center: t6, zmin: r2 } = this._transformedExtent;
    return new _({ x: t6.x, y: t6.y, z: r2, spatialReference: this.spatialReference });
  }
  get origin() {
    const e10 = u4(this.vertexSpace, this.spatialReference);
    return null != e10 ? e10 : this._transformedExtent.center;
  }
  get extent() {
    var _a, _b;
    return this.loaded || null == ((_b = (_a = this.metadata) == null ? void 0 : _a.displaySource) == null ? void 0 : _b.extent) ? this._transformedExtent : this.metadata.displaySource.extent.clone();
  }
  addComponent(e10) {
    this._checkIfLoaded("addComponent()") && (this.components || (this.components = []), this.components.push(h4.from(e10)), this.notifyChange("components"));
  }
  removeComponent(e10) {
    if (this._checkIfLoaded("removeComponent()")) {
      if (this.components) {
        const t6 = this.components.indexOf(e10);
        if (-1 !== t6) return this.components.splice(t6, 1), void this.notifyChange("components");
      }
      J3().error("removeComponent()", e8);
    }
  }
  rotate(e10, t6, r2, o4) {
    return w3(e10, t6, r2, Y3), B(this, Y3, o4), this;
  }
  offset(e10, t6, r2) {
    if (!this._checkIfLoaded("offset()")) return this;
    const { vertexSpace: o4, vertexAttributes: s5 } = this, n8 = s5 == null ? void 0 : s5.position;
    if (!n8) return this;
    if (a6(o4)) {
      const [s6, n9, i6] = o4.origin;
      o4.origin = r(s6 + e10, n9 + t6, i6 + r2);
    } else {
      for (let o5 = 0; o5 < n8.length; o5 += 3) n8[o5] += e10, n8[o5 + 1] += t6, n8[o5 + 2] += r2;
      this.vertexAttributesChanged();
    }
    return this;
  }
  scale(e10, t6) {
    return this._checkIfLoaded("scale()") ? (q2(this, e10, t6), this) : this;
  }
  centerAt(e10, t6) {
    return this._checkIfLoaded("centerAt()") ? (u7(this, e10, t6), this) : this;
  }
  load(e10) {
    const { metadata: { displaySource: t6 } } = this;
    return t6 && this.addResolvingPromise(c6(this, t6, e10)), Promise.resolve(this);
  }
  addExternalSources(e10) {
    this.metadata.externalSources.addMany(e10);
  }
  updateDisplaySource(e10) {
    this.metadata.displaySource = e10;
  }
  clone() {
    return this.cloneAndModifyVertexAttributes(this.vertexAttributes.clone(), this.vertexSpace.clone());
  }
  cloneAndModifyVertexAttributes(e10, t6) {
    var _a;
    let r2 = null;
    if (this.components) {
      const e11 = /* @__PURE__ */ new Map(), t7 = /* @__PURE__ */ new Map();
      r2 = this.components.map((r3) => r3.cloneWithDeduplication(e11, t7));
    }
    const o4 = { components: r2, spatialReference: this.spatialReference, vertexAttributes: e10, vertexSpace: t6, transform: ((_a = this.transform) == null ? void 0 : _a.clone()) ?? null, metadata: this.metadata.clone() };
    return new H2(o4);
  }
  cloneShallow() {
    return new H2({ components: this.components, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes, vertexSpace: this.vertexSpace.clone(), transform: this.transform, metadata: this.metadata });
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e10) {
    const [{ toBinaryGLTF: t6 }] = await Promise.all([import("./gltfexport-RHLQI2JX.js"), this.load(e10)]);
    return s2(e10), await t6(this, e10);
  }
  get memoryUsage() {
    let e10 = 0;
    if (e10 += this.vertexAttributes.memoryUsage, null != this.components) for (const t6 of this.components) e10 += t6.memoryUsage;
    return e10;
  }
  _clearSources() {
    this.metadata.clearSources();
  }
  _checkIfLoaded(e10) {
    return !!this.loaded || (J3().error(e10, t4), false);
  }
  static createBox(e10, t6) {
    if (!(e10 instanceof _)) return J3().error(".createBox()", s4), null;
    const r2 = new H2(x3(c7(), e10, t6));
    return (t6 == null ? void 0 : t6.imageFace) && "all" !== t6.imageFace ? f5(r2, t6.imageFace) : r2;
  }
  static createSphere(e10, t6) {
    return e10 instanceof _ ? new H2(x3(u9((t6 == null ? void 0 : t6.densificationFactor) || 0), e10, t6)) : (J3().error(".createSphere()", s4), null);
  }
  static createCylinder(e10, t6) {
    return e10 instanceof _ ? new H2(x3(h8((t6 == null ? void 0 : t6.densificationFactor) || 0), e10, t6)) : (J3().error(".createCylinder()", s4), null);
  }
  static createPlane(e10, t6) {
    if (!(e10 instanceof _)) return J3().error(".createPlane()", s4), null;
    const r2 = (t6 == null ? void 0 : t6.facing) ?? "up", o4 = p4(r2, t6 == null ? void 0 : t6.size);
    return new H2(x3(m4(r2), e10, { ...t6, size: o4 }));
  }
  static createFromPolygon(e10, t6) {
    if (!(e10 instanceof j)) return J3().error(".createFromPolygon()", n7), null;
    const r2 = f3(e10);
    return new H2({ vertexAttributes: new l3({ position: r2.position }), components: [new h4({ faces: r2.faces, shading: "flat", material: (t6 == null ? void 0 : t6.material) ?? null })], spatialReference: e10.spatialReference, vertexSpace: new i2() });
  }
  static async createFromGLTF(e10, t6, r2) {
    if (!(e10 instanceof _)) {
      const e11 = new i4();
      throw J3().error(".createfromGLTF()", e11.message), e11;
    }
    const { loadGLTFMesh: o4 } = await h(import("./loadGLTFMesh-EHQLHZJ3.js"), r2);
    return new H2(await o4(e10, t6, r2));
  }
  static async createFromFiles(e10, o4, s5) {
    t(J3(), "`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'", { replacement: "SceneLayer.convertMesh", version: "4.29" });
    const n8 = (e11) => J3().error(".createFromFiles()", e11.message);
    if (!(e10 instanceof _)) {
      const e11 = new i4();
      throw n8(e11), e11;
    }
    if (!(s5 == null ? void 0 : s5.layer)) throw new s("invalid:no-layer", "SceneLayer required for file to mesh conversion.");
    return s5.layer.convertMesh(o4, { location: e10, ...s5 });
  }
  static createWithExternalSource(e10, t6, r2) {
    var _a;
    const o4 = (r2 == null ? void 0 : r2.extent) ?? null, { spatialReference: s5 } = e10, n8 = ((_a = r2 == null ? void 0 : r2.transform) == null ? void 0 : _a.clone()) ?? new N2(), i6 = s3(e10, r2), a10 = { source: t6, extent: o4 }, c8 = new a9();
    return c8.externalSources.push(a10), new H2({ metadata: c8, transform: n8, vertexSpace: i6, spatialReference: s5 });
  }
  static createIncomplete(e10, t6) {
    var _a;
    const { spatialReference: o4 } = e10, s5 = ((_a = t6 == null ? void 0 : t6.transform) == null ? void 0 : _a.clone()) ?? new N2(), n8 = s3(e10, t6), i6 = new H2({ transform: s5, vertexSpace: n8, spatialReference: o4 });
    return i6.addResolvingPromise(Promise.reject(new s("mesh-incomplete", "Mesh resources are not complete"))), i6;
  }
};
e([y({ type: [h4], json: { write: true } })], X4.prototype, "components", void 0), e([y({ nonNullable: true, types: Q2, constructOnly: true, json: { write: true } })], X4.prototype, "vertexSpace", void 0), e([y({ type: N2, json: { write: true } })], X4.prototype, "transform", void 0), e([y({ constructOnly: true })], X4.prototype, "metadata", void 0), e([y()], X4.prototype, "hasExtent", null), e([y()], X4.prototype, "_transformedExtent", null), e([y()], X4.prototype, "_untransformedBounds", null), e([y()], X4.prototype, "anchor", null), e([y()], X4.prototype, "origin", null), e([y({ readOnly: true, json: { read: false } })], X4.prototype, "extent", null), e([y({ readOnly: true, json: { read: false, write: true, default: true } })], X4.prototype, "hasZ", void 0), e([y({ readOnly: true, json: { read: false, write: true, default: false } })], X4.prototype, "hasM", void 0), e([y({ type: l3, nonNullable: true, json: { write: true } })], X4.prototype, "vertexAttributes", void 0), X4 = H2 = e([a(K2)], X4);
var Y3 = b();
var $ = X4;

export {
  $
};
//# sourceMappingURL=chunk-FHB57LTD.js.map
