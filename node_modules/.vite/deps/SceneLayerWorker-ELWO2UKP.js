import "./chunk-NRWOW5I4.js";
import "./chunk-4RKJDHFK.js";
import "./chunk-GRO6TRQ6.js";
import "./chunk-BMX34DUY.js";
import "./chunk-2CZAGFZF.js";
import "./chunk-V4RHVJ2H.js";
import "./chunk-2PUGZZAH.js";
import "./chunk-CL2YKTVD.js";
import "./chunk-3MDFTQ3N.js";
import "./chunk-ZEOXREFF.js";
import "./chunk-5BIU5HC2.js";
import "./chunk-4K57JS64.js";
import "./chunk-DOINOMWZ.js";
import "./chunk-RRSX64BO.js";
import "./chunk-GE4FYJHC.js";
import {
  a,
  i
} from "./chunk-MKSCPZ7O.js";
import {
  y
} from "./chunk-LSYTXHXV.js";
import {
  f as f2,
  l
} from "./chunk-VJBBHRSD.js";
import "./chunk-D7WIM7VD.js";
import "./chunk-XIC3SN6R.js";
import "./chunk-WX4IZMIC.js";
import "./chunk-T5CIHLIU.js";
import "./chunk-CBN77ZVG.js";
import "./chunk-TNRF7MOE.js";
import "./chunk-PNPG5IXD.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import "./chunk-LLJZCFHW.js";
import "./chunk-VIUFBDIY.js";
import "./chunk-TXIL3QUC.js";
import "./chunk-2ASAB4KA.js";
import "./chunk-IGNUVZ34.js";
import "./chunk-LTSQHA4C.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-T4EIRKFE.js";
import "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-4AGGGL2W.js";
import "./chunk-FJPG3YI6.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-BL2UGYYZ.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import "./chunk-AZ7WOCBW.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import {
  _
} from "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import {
  f
} from "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import {
  n
} from "./chunk-K4UOG562.js";
import "./chunk-WC4SPMPL.js";
import "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import "./chunk-GEH2VXFC.js";
import "./chunk-BJY5ADVY.js";
import "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/libs/i3s/enums.js
var n2;
var e;
!function(n4) {
  n4[n4.None = 0] = "None", n4[n4.Int16 = 1] = "Int16", n4[n4.Int32 = 2] = "Int32";
}(n2 || (n2 = {})), function(n4) {
  n4[n4.Replace = 0] = "Replace", n4[n4.Outside = 1] = "Outside", n4[n4.Inside = 2] = "Inside", n4[n4.Finished = 3] = "Finished";
}(e || (e = {}));

// ../node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n3 || (n3 = new Promise((t) => import("./i3s-GKJWRUL4.js").then((t2) => t2.i).then(({ default: e4 }) => {
    const n4 = e4({ locateFile: i2, onRuntimeInitialized: () => t(n4) });
    delete n4.then;
  })).catch((t) => {
    throw t;
  })), n3;
}
function i2(e4) {
  return n(`esri/libs/i3s/${e4}`);
}
var n3;

// ../node_modules/@arcgis/core/views/3d/layers/i3s/I3SNode.js
var o;
var r2;
var a2;
var d;
var c;
!function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.Culled = 1] = "Culled", e4[e4.NotChecked = 2] = "NotChecked";
}(o || (o = {})), function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.PotentiallyModified = 1] = "PotentiallyModified", e4[e4.Culled = 2] = "Culled", e4[e4.Unknown = 3] = "Unknown", e4[e4.NotChecked = 4] = "NotChecked";
}(r2 || (r2 = {}));
!function(e4) {
  e4[e4.Unknown = 0] = "Unknown", e4[e4.Uncached = 1] = "Uncached", e4[e4.Cached = 2] = "Cached";
}(a2 || (a2 = {})), function(e4) {
  e4[e4.None = 0] = "None", e4[e4.MaxScreenThreshold = 1] = "MaxScreenThreshold", e4[e4.ScreenSpaceRelative = 2] = "ScreenSpaceRelative", e4[e4.RemovedFeatureDiameter = 3] = "RemovedFeatureDiameter", e4[e4.DistanceRangeFromDefaultCamera = 4] = "DistanceRangeFromDefaultCamera";
}(d || (d = {})), function(e4) {
  e4[e4.Hole = 0] = "Hole", e4[e4.Leaf = 1] = "Leaf";
}(c || (c = {}));

// ../node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function l2(e4) {
  w = await x();
  const r3 = [e4.geometryBuffer];
  return { result: j(w, e4, r3), transferList: r3 };
}
async function u(e4) {
  var _a;
  w = await x();
  const r3 = [e4.geometryBuffer], { geometryBuffer: t } = e4, o2 = t.byteLength, n4 = w._malloc(o2), s = new Uint8Array(w.HEAPU8.buffer, n4, o2);
  s.set(new Uint8Array(t));
  const i3 = w.dracoDecompressPointCloudData(n4, s.byteLength);
  if (w._free(n4), i3.error.length > 0) throw new Error(`i3s.wasm: ${i3.error}`);
  const a3 = ((_a = i3.featureIds) == null ? void 0 : _a.length) > 0 ? i3.featureIds.slice() : null, f3 = i3.positions.slice();
  return a3 && r3.push(a3.buffer), r3.push(f3.buffer), { result: { positions: f3, featureIds: a3 }, transferList: r3 };
}
async function m(e4) {
  await x(), L(e4);
  const r3 = { buffer: e4.buffer };
  return { result: r3, transferList: [r3.buffer] };
}
async function y2(e4) {
  await x(), E(e4);
}
async function p(e4) {
  w = await x(), w.setLegacySchema(e4.context, e4.jsonSchema);
}
async function d2(e4) {
  const { localMatrix: s, origin: i3, positions: a3, vertexSpace: f3, localMode: c2 } = e4, l3 = f.fromJSON(e4.inSpatialReference), u2 = f.fromJSON(e4.outSpatialReference);
  let m2;
  const [{ projectBuffer: y3 }, { initializeProjection: p2 }] = await Promise.all([import("./projectBuffer-WAP34KGM.js"), import("./projection-AJPE4CLM.js")]);
  await p2(l3, u2);
  const d3 = [0, 0, 0];
  if (!y3(i3, l3, 0, d3, u2, 0, 1)) throw new Error("Failed to project");
  if ("georeferenced" === f3.type && null == f3.origin) {
    if (m2 = new Float64Array(a3.length), !y3(a3, l3, 0, m2, u2, 0, m2.length / 3)) throw new Error("Failed to project");
  } else {
    const e5 = "georeferenced" === f3.type ? i.fromJSON(f3) : a.fromJSON(f3), { project: r3 } = await import("./projection-OCAF3YJU.js"), i4 = r3({ positions: a3, transform: s ? { localMatrix: s } : void 0, vertexSpace: e5, inSpatialReference: l3, outSpatialReference: u2, localMode: c2 });
    if (!i4) throw new Error("Failed to project");
    m2 = y(i4);
  }
  const b2 = m2.length, [h2, g2, w2] = d3;
  for (let r3 = 0; r3 < b2; r3 += 3) m2[r3] -= h2, m2[r3 + 1] -= g2, m2[r3 + 2] -= w2;
  return { result: { projected: m2, original: a3, projectedOrigin: d3 }, transferList: [m2.buffer, a3.buffer] };
}
async function b({ normalMatrix: r3, normals: t }) {
  const o2 = new Float32Array(t.length);
  return f2(o2, t, r3), _(r3) && l(o2, o2), { result: { transformed: o2, original: t }, transferList: [o2.buffer, t.buffer] };
}
function h(e4) {
  I(e4);
}
var g;
var w;
function E(e4) {
  if (!w) return;
  const r3 = e4.modifications, t = w._malloc(8 * r3.length), o2 = new Float64Array(w.HEAPU8.buffer, t, r3.length);
  for (let n4 = 0; n4 < r3.length; ++n4) o2[n4] = r3[n4];
  w.setModifications(e4.context, t, r3.length, e4.isGeodetic), w._free(t);
}
function j(e4, r3, t) {
  const { context: o2, globalTrafo: n4, mbs: s, obbData: i3, elevationOffset: f3, geometryBuffer: c2, geometryDescriptor: l3, indexToVertexProjector: u2, vertexToRenderProjector: m2 } = r3, y3 = e4._malloc(c2.byteLength), p2 = 33, d3 = e4._malloc(p2 * Float64Array.BYTES_PER_ELEMENT), b2 = new Uint8Array(e4.HEAPU8.buffer, y3, c2.byteLength);
  b2.set(new Uint8Array(c2));
  const h2 = new Float64Array(e4.HEAPU8.buffer, d3, p2);
  S(h2, [NaN, NaN, NaN]);
  let g2 = h2.byteOffset + 3 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2);
  S(w2, n4), g2 += 16 * h2.BYTES_PER_ELEMENT, w2 = new Float64Array(h2.buffer, g2), S(w2, s), g2 += 4 * h2.BYTES_PER_ELEMENT, i3 && (w2 = new Float64Array(h2.buffer, g2), S(w2, i3));
  const E2 = l3, j2 = { isDraco: false, isLegacy: false, color: r3.layouts.some((e5) => e5.some((e6) => "color" === e6.name)), normal: r3.needNormals && r3.layouts.some((e5) => e5.some((e6) => "normalCompressed" === e6.name)), uv0: r3.layouts.some((e5) => e5.some((e6) => "uv0" === e6.name)), uvRegion: r3.layouts.some((e5) => e5.some((e6) => "uvRegion" === e6.name)), featureIndex: E2.featureIndex }, A2 = e4.process(o2, !!r3.obbData, y3, b2.byteLength, E2, j2, d3, f3, u2, m2, r3.normalReferenceFrame);
  if (e4._free(d3), e4._free(y3), A2.error.length > 0) throw new Error(`i3s.wasm: ${A2.error}`);
  if (A2.discarded) return null;
  const L2 = A2.componentOffsets.length > 0 ? A2.componentOffsets.slice() : null, I2 = A2.featureIds.length > 0 ? A2.featureIds.slice() : null, _3 = A2.anchorIds.length > 0 ? Array.from(A2.anchorIds) : null, x2 = A2.anchors.length > 0 ? Array.from(A2.anchors) : null, M2 = A2.interleavedVertedData.slice().buffer, N = A2.indicesType === n2.Int16 ? new Uint16Array(A2.indices.buffer, A2.indices.byteOffset, A2.indices.byteLength / 2).slice() : new Uint32Array(A2.indices.buffer, A2.indices.byteOffset, A2.indices.byteLength / 4).slice(), P = A2.positions.slice(), U = A2.positionIndicesType === n2.Int16 ? new Uint16Array(A2.positionIndices.buffer, A2.positionIndices.byteOffset, A2.positionIndices.byteLength / 2).slice() : new Uint32Array(A2.positionIndices.buffer, A2.positionIndices.byteOffset, A2.positionIndices.byteLength / 4).slice(), T = { layout: r3.layouts[0], interleavedVertexData: M2, indices: N, hasColors: A2.hasColors, hasModifications: A2.hasModifications, positionData: { data: P, indices: U } };
  return I2 && t.push(I2.buffer), L2 && t.push(L2.buffer), t.push(M2), t.push(N.buffer), t.push(P.buffer), t.push(U.buffer), { componentOffsets: L2, featureIds: I2, anchorIds: _3, anchors: x2, transformedGeometry: T, obb: A2.obb, globalTrafo: n4 };
}
function A(e4) {
  return 0 === e4 ? r2.Unmodified : 1 === e4 ? r2.PotentiallyModified : 2 === e4 ? r2.Culled : r2.Unknown;
}
function L(e4) {
  if (!w) return;
  const { context: r3, buffer: t } = e4, o2 = w._malloc(t.byteLength), n4 = t.byteLength / Float64Array.BYTES_PER_ELEMENT, s = new Float64Array(w.HEAPU8.buffer, o2, n4), i3 = new Float64Array(t);
  s.set(i3), w.filterOBBs(r3, o2, n4), i3.set(s), w._free(o2);
}
function I(e4) {
  w && 0 === w.destroy(e4) && (w = null);
}
function S(e4, r3) {
  for (let t = 0; t < r3.length; ++t) e4[t] = r3[t];
}
async function _2() {
  w || await x();
}
function x() {
  return w ? Promise.resolve(w) : (g || (g = e2().then((e4) => (w = e4, g = null, w))), g);
}
var M = { transform: (e4, r3) => w && j(w, e4, r3), destroy: I };
export {
  h as destroyContext,
  u as dracoDecompressPointCloudData,
  m as filterObbsForModifications,
  L as filterObbsForModificationsSync,
  _2 as initialize,
  A as interpretObbModificationResults,
  l2 as process,
  d2 as project,
  p as setLegacySchema,
  y2 as setModifications,
  E as setModificationsSync,
  M as test,
  b as transformNormals
};
//# sourceMappingURL=SceneLayerWorker-ELWO2UKP.js.map
