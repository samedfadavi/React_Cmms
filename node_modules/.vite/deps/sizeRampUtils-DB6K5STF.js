import {
  i,
  l,
  p,
  r as r2,
  u as u2,
  w
} from "./chunk-M34OMJ77.js";
import {
  I,
  m,
  y2
} from "./chunk-YVOD4VRJ.js";
import "./chunk-A2WMIQD6.js";
import "./chunk-MGJTYDNO.js";
import {
  r
} from "./chunk-YYWBDW7S.js";
import "./chunk-KRKDK2RA.js";
import "./chunk-FO4JQZA5.js";
import "./chunk-D6KE2FST.js";
import "./chunk-OPCT64AO.js";
import "./chunk-WO4V65CJ.js";
import "./chunk-QUNQAVSE.js";
import "./chunk-MB5H6D2S.js";
import "./chunk-LVH66MEH.js";
import "./chunk-4FW6GTBF.js";
import "./chunk-E5ZJCKHO.js";
import "./chunk-YUQFVZCH.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-T4EIRKFE.js";
import "./chunk-PHVKM5OH.js";
import "./chunk-KQ5GHUVQ.js";
import "./chunk-JQIB7GFW.js";
import {
  x
} from "./chunk-7OW2VNCC.js";
import "./chunk-AFBYZF6Q.js";
import {
  d,
  y
} from "./chunk-IJ42YN7D.js";
import {
  u
} from "./chunk-4AGGGL2W.js";
import "./chunk-FJPG3YI6.js";
import "./chunk-BJHLU2MM.js";
import "./chunk-E5KBRIJQ.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-TW7VY7XV.js";
import "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import "./chunk-BL2UGYYZ.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import "./chunk-WC4SPMPL.js";
import "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import "./chunk-GEH2VXFC.js";
import "./chunk-BJY5ADVY.js";
import "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  a
} from "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/smartMapping/renderers/support/referenceSizeUtils.js
var o;
function s2(e) {
  switch (e) {
    case "circle":
      return { rings: [[[8.5, 0.2], [7.06, 0.33], [5.66, 0.7], [4.35, 1.31], [3.16, 2.14], [2.14, 3.16], [1.31, 4.35], [0.7, 5.66], [0.33, 7.06], [0.2, 8.5], [0.33, 9.94], [0.7, 11.34], [1.31, 12.65], [2.14, 13.84], [3.16, 14.86], [4.35, 15.69], [5.66, 16.3], [7.06, 16.67], [8.5, 16.8], [9.94, 16.67], [11.34, 16.3], [12.65, 15.69], [13.84, 14.86], [14.86, 13.84], [15.69, 12.65], [16.3, 11.34], [16.67, 9.94], [16.8, 8.5], [16.67, 7.06], [16.3, 5.66], [15.69, 4.35], [14.86, 3.16], [13.84, 2.14], [12.65, 1.31], [11.34, 0.7], [9.94, 0.33], [8.5, 0.2]]] };
    case "square":
      return { rings: [[[0.5, 0.5], [0.5, 16.5], [16.5, 16.5], [16.5, 0.5], [0.5, 0.5]]] };
    case "diamond":
      return { rings: [[[8.5, 0.5], [0.2, 8.5], [8.5, 16.5], [16.5, 8.5], [8.5, 0.5]]] };
    case "hexagon-pointy":
      return { rings: [[[15.86, 12.75], [15.86, 4.25], [8.5, 0], [1.14, 4.25], [1.14, 12.75], [8.5, 17], [15.86, 12.75]]] };
    case "hexagon-flat":
      return { rings: [[[12.75, 15.86], [17, 8.5], [12.75, 1.14], [4.25, 1.14], [0, 8.5], [4.25, 15.86], [12.75, 15.86]]] };
  }
}
function y3(e) {
  var _a;
  return "CIMVectorMarker" === (e == null ? void 0 : e.type) ? (_a = e.markerGraphics) == null ? void 0 : _a[0] : void 0;
}
function p2(e) {
  var _a, _b;
  return "CIMPolygonSymbol" === ((_a = e == null ? void 0 : e.symbol) == null ? void 0 : _a.type) ? (_b = e.symbol.symbolLayers) == null ? void 0 : _b[0] : void 0;
}
function f(e, r3) {
  "CIMVectorMarker" === (e == null ? void 0 : e.type) && null != r3 && (e.size = r3);
}
function v(e, r3) {
  const n = y3(e);
  n && null != r3 && (n.geometry = s2(r3));
}
function S(e, r3) {
  const n = p2(y3(e));
  n && null != r3 && (n.color = r3.toArray());
}
function z(e, r3, n) {
  const t = p2(y3(e));
  t && null != r3 && n && (t.colorLocked = r3);
}
function d3(e, n) {
  var _a;
  const { outerRingSize: t, innerDotSize: i2, type: a3, color: l2, colorLocked: s3, primitiveOverrides: m2 } = n, c = "CIMPolygonSymbol" === ((_a = e.data.symbol) == null ? void 0 : _a.type) ? e.data.symbol.symbolLayers : null;
  if (2 === (c == null ? void 0 : c.length)) for (const r3 of c) {
    const e2 = r3.primitiveName === o.OuterRing;
    f(r3, e2 ? t : i2), v(r3, a3), S(r3, l2), z(r3, s3, e2);
  }
  return null != t && null != i2 && (e.data.primitiveOverrides = null), void 0 !== m2 && (e.data.primitiveOverrides = a(m2)), e;
}
!function(e) {
  e.OuterRing = "reference-size-outer-ring", e.InnerDot = "reference-size-inner-dot";
}(o || (o = {}));

// ../node_modules/@arcgis/core/widgets/Legend/support/sizeRampUtils.js
var b = 30;
var h = 12;
var d4 = 24;
var w2 = [255, 255, 255];
var S2 = [200, 200, 200];
var g = [128, 128, 128];
var v2 = 20;
var z2 = 5;
function j(e) {
  return "esri.symbols.SimpleMarkerSymbol" === e.declaredClass;
}
function k(e) {
  return "esri.symbols.PictureMarkerSymbol" === e.declaredClass;
}
function V(e) {
  return "esri.symbols.SimpleLineSymbol" === e.declaredClass;
}
function x2(e) {
  return "esri.symbols.TextSymbol" === e.declaredClass;
}
function I2(e, l2) {
  const t = e.length - 1;
  return e.map((e2, n) => r2(e2, n, t, l2));
}
async function L(e, l2, n, o2, i2, s3, c) {
  const m2 = l2.legendOptions, p3 = m2 == null ? void 0 : m2.customValues, f2 = c || await D(e, n), y4 = l2.stops, b2 = !!f2, h2 = !!p3, w3 = null != l2.minSize && null != l2.maxSize, S3 = y4 && y4.length > 1, g2 = !!l2.target;
  if (!b2 || !h2 && !(w3 || S3 && !g2)) return;
  const v3 = y2(f2);
  let z3 = false, j2 = null, k2 = null;
  j2 = v3 && !S3 ? u2([l2.minDataValue, l2.maxDataValue]) : p3 ?? await T(l2, f2, o2, i2 == null ? void 0 : i2.type);
  const V2 = e == null ? void 0 : e.authoringInfo, x3 = "univariate-color-size" === (V2 == null ? void 0 : V2.type), L2 = x3 && "above-and-below" === (V2 == null ? void 0 : V2.univariateTheme), q2 = !!w(e);
  if (!j2 && S3 && (j2 = y4.map((e2) => e2.value), z3 = y4.some((e2) => !!e2.label), "flow" === e.type && (j2 = u2(j2)), z3 && (k2 = y4.map((e2) => e2.label))), v3 && null != j2 && (j2 == null ? void 0 : j2.length) > 2 && !L2 && (j2 = [j2[0], j2[j2.length - 1]]), !j2) return null;
  x3 && 5 !== (j2 == null ? void 0 : j2.length) && (j2 = P({ minSize: j2[0], maxSize: j2[j2.length - 1] }));
  const B2 = v3 ? U(e, j2) : null, E2 = m(f2), R2 = z3 ? null : I2(j2, s3);
  return (await Promise.all(j2.map(async (t, s4) => {
    const r3 = v3 ? B2[s4] : await H(l2, f2, t, o2, i2 == null ? void 0 : i2.type);
    return { value: t, symbol: !q2 || "class-breaks" !== e.type && "unique-value" !== e.type ? O(L2 && "class-breaks" === e.type ? C(e, s4) : f2, r3) : M(e, r3, l2.maxSize, n) ?? f2, label: z3 ? k2[s4] : R2[s4], size: q2 ? d4 : r3, outlineSize: E2 };
  }))).reverse();
}
function U(e, l2) {
  const t = e == null ? void 0 : e.authoringInfo, n = "univariate-color-size" === (t == null ? void 0 : t.type);
  let o2 = [h, b];
  if (n) {
    const e2 = l2[0], t2 = l2[l2.length - 1], n2 = h, i2 = b;
    o2 = l2.map((l3) => n2 + (l3 - e2) / (t2 - e2) * (i2 - n2));
  }
  return n && "below" === (t == null ? void 0 : t.univariateTheme) && o2.reverse(), o2;
}
function M(l2, t, n, o2) {
  var _a, _b, _c, _d, _e, _f;
  const s3 = "class-breaks" === l2.type, r3 = s3 ? (_c = (_b = (_a = l2.classBreakInfos) == null ? void 0 : _a[0]) == null ? void 0 : _b.symbol) == null ? void 0 : _c.clone() : (_f = (_e = (_d = l2.uniqueValueInfos) == null ? void 0 : _d[0]) == null ? void 0 : _e.symbol) == null ? void 0 : _f.clone();
  return r3 && "type" in r3 && "cim" === r3.type ? (d3(r3, { color: o2 ?? (s3 ? null : new u(S2)), innerDotSize: t * (d4 / n) || 1, outerRingSize: d4 }), r3) : null;
}
function C(e, l2) {
  const t = e.classBreakInfos, n = t.length, o2 = n < 2 || !(l2 >= 2) ? t[0].symbol.clone() : t[n - 1].symbol.clone();
  return e.visualVariables.some((e2) => "color" === e2.type) && (o2.type.includes("3d") ? B(o2) : E(o2)), o2;
}
async function D(e, l2) {
  var _a, _b;
  if ("flow" === e.type) return p(e, l2);
  if ("pie-chart" === e.type) return new y({ color: null, outline: ((_a = e.outline) == null ? void 0 : _a.width) ? e.outline : new d() });
  let t = null, n = null;
  if ("simple" === e.type) t = e.symbol;
  else if ("class-breaks" === e.type) {
    const l3 = e.classBreakInfos;
    t = l3 && l3[0] && l3[0].symbol, n = l3.length > 1;
  } else if ("unique-value" === e.type) {
    const l3 = e.uniqueValueInfos;
    t = (_b = l3 == null ? void 0 : l3[0]) == null ? void 0 : _b.symbol, n = null != l3 && l3.length > 1;
  }
  return !t || q(t) ? null : (t = t.clone(), (l2 || n) && (t.type.includes("3d") ? B(t) : E(t)), t);
}
function q(e) {
  if (e) {
    if (x(e)) {
      return !!e.symbolLayers && e.symbolLayers.some((e2) => e2 && "fill" === e2.type);
    }
    return e.type.includes("fill");
  }
  return false;
}
function B(e) {
  "line-3d" === e.type ? e.symbolLayers.forEach((e2) => {
    e2.material = { color: g };
  }) : e.symbolLayers.forEach((e2) => {
    var _a;
    "icon" !== e2.type || ((_a = e2.resource) == null ? void 0 : _a.href) ? e2.material = { color: S2 } : (e2.material = { color: w2 }, e2.outline = { color: g, size: 1.5 });
  });
}
function E(l2) {
  var _a, _b;
  const t = r();
  if ("cim" === l2.type) I(l2, new u(S2));
  else if (l2.type.includes("line")) l2.color = g;
  else if (l2.color = t ? g : w2, "simple-marker" === l2.type) if (l2.outline) {
    const e = (_b = (_a = l2.outline) == null ? void 0 : _a.color) == null ? void 0 : _b.toHex();
    "#ffffff" === e && (l2.outline.color = g);
  } else l2.outline = { color: g, width: 1.5 };
}
async function T(e, l2, n, o2) {
  const i2 = (await import("./visualVariableUtils-UXXQJZUU.js")).getSizeRangeAtScale(e, n, o2), s3 = i2 && P(i2);
  if (!i2 || !s3) return;
  let r3 = s3.map((l3) => R(l3, e, i2));
  r3 = u2(r3);
  for (let t = 1; t < r3.length - 1; t++) {
    const i3 = await A(e, l2, r3[t], r3[t - 1], n, o2);
    i3 && (r3[t] = i3[0], s3[t] = i3[1]);
  }
  return r3;
}
function P(e) {
  const l2 = e.minSize, t = e.maxSize, n = z2, o2 = (t - l2) / (n - 1), i2 = [];
  for (let s3 = 0; s3 < n; s3++) i2.push(l2 + o2 * s3);
  return i2;
}
function R(e, l2, t) {
  const n = t.minSize, o2 = t.maxSize, i2 = l2.minDataValue, s3 = l2.maxDataValue;
  let r3;
  if (e <= n) r3 = i2;
  else if (e >= o2) r3 = s3;
  else {
    r3 = (e - n) / (o2 - n) * (s3 - i2) + i2;
  }
  return r3;
}
async function A(e, l2, i2, s3, r3, a3) {
  const u3 = await H(e, l2, i2, r3, a3), c = await H(e, l2, s3, r3, a3), m2 = i(i2), p3 = m2.fractional, f2 = v2;
  let y4 = m2.integer, b2 = null, h2 = null;
  i2 > 0 && i2 < 1 && (b2 = 10 ** p3, y4 = i(i2 *= b2).integer);
  for (let n = y4 - 1; n >= 0; n--) {
    const s4 = 10 ** n;
    let m3 = Math.floor(i2 / s4) * s4, p4 = Math.ceil(i2 / s4) * s4;
    null != b2 && (m3 /= b2, p4 /= b2);
    let y5 = (m3 + p4) / 2;
    [, y5] = u2([m3, y5, p4], { indexes: [1] });
    const d5 = await H(e, l2, m3, r3, a3), w3 = await H(e, l2, p4, r3, a3), S3 = await H(e, l2, y5, r3, a3), g2 = l(u3, d5, c, null), v3 = l(u3, w3, c, null), z3 = l(u3, S3, c, null);
    let j2 = g2.previous <= f2, k2 = v3.previous <= f2;
    if (j2 && k2 && (g2.previous <= v3.previous ? (j2 = true, k2 = false) : (k2 = true, j2 = false)), j2 ? h2 = [m3, d5] : k2 ? h2 = [p4, w3] : z3.previous <= f2 && (h2 = [y5, S3]), h2) break;
  }
  return h2;
}
async function H(e, l2, t, n, o2) {
  const { getSize: i2 } = await import("./visualVariableUtils-UXXQJZUU.js");
  return i2(e, t, { scale: n, view: o2, shape: "simple-marker" === l2.type ? l2.style : null });
}
function O(e, t) {
  const n = e.clone();
  if (x(n)) y2(n) || n.symbolLayers.forEach((e2) => {
    "fill" !== e2.type && (e2.size = t);
  });
  else if (j(n)) n.size = t;
  else if (k(n)) {
    const e2 = n.width, l2 = n.height;
    n.height = t, n.width = t * (e2 / l2);
  } else V(n) ? n.width = t : x2(n) && n.font && (n.font.size = t);
  return n;
}
export {
  L as getRampStops,
  M as getReferenceSizeSymbol,
  b as realWorldMaxSize,
  h as realWorldMinSize
};
//# sourceMappingURL=sizeRampUtils-DB6K5STF.js.map
