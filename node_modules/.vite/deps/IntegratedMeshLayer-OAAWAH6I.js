import {
  j as j3
} from "./chunk-W45JEAP5.js";
import "./chunk-2SR7SQVX.js";
import {
  a as a4,
  m,
  p as p2,
  y as y2
} from "./chunk-LM32XFFX.js";
import {
  C as C2,
  L
} from "./chunk-7VIMGDT3.js";
import {
  $,
  Z,
  w
} from "./chunk-2RXPQJAL.js";
import "./chunk-OXBW45CN.js";
import "./chunk-UPDXKN2W.js";
import "./chunk-LAB5SETU.js";
import "./chunk-7W2VQZZM.js";
import "./chunk-XPEOBWSB.js";
import "./chunk-PYM2YVDF.js";
import "./chunk-JSJ34DFQ.js";
import "./chunk-YHUE64L3.js";
import {
  i
} from "./chunk-NGPLQQSE.js";
import {
  l
} from "./chunk-HN3UL7DT.js";
import {
  e as e2
} from "./chunk-TJWXOPWU.js";
import {
  j as j2
} from "./chunk-5LNCGIUN.js";
import {
  t
} from "./chunk-HNXXFTFZ.js";
import {
  b
} from "./chunk-KVPS4KFB.js";
import {
  d
} from "./chunk-NSXZC33R.js";
import {
  S
} from "./chunk-E7HFITKU.js";
import "./chunk-ZFQCSBZ4.js";
import "./chunk-4PAHN45R.js";
import "./chunk-G5U2OA3R.js";
import "./chunk-7TO4QD67.js";
import "./chunk-RM4VMFVT.js";
import {
  f as f2
} from "./chunk-EA74CF7B.js";
import "./chunk-IGNUVZ34.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-OHUWK5XV.js";
import "./chunk-PHVKM5OH.js";
import "./chunk-KQ5GHUVQ.js";
import {
  J,
  on
} from "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-ZK2DM5OJ.js";
import "./chunk-MNMU4ARP.js";
import "./chunk-E5KBRIJQ.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import {
  p
} from "./chunk-PNUUOKAJ.js";
import {
  C,
  v
} from "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import {
  V
} from "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import {
  j
} from "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import "./chunk-66KCMKB5.js";
import {
  o
} from "./chunk-ZART2Y5J.js";
import {
  r
} from "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import {
  I,
  U
} from "./chunk-WC4SPMPL.js";
import {
  f2 as f,
  u3 as u,
  y
} from "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import {
  a3 as a2,
  s3 as s2
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  a as a3
} from "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/layers/support/SceneModification.js
var l2;
var y3 = l2 = class extends f {
  constructor(e3) {
    super(e3), this.geometry = null, this.type = "clip";
  }
  writeGeometry(e3, r2, o2, s3) {
    var _a;
    if (((_a = s3.layer) == null ? void 0 : _a.spatialReference) && !s3.layer.spatialReference.equals(this.geometry.spatialReference)) {
      if (!J(e3.spatialReference, s3.layer.spatialReference)) return void ((s3 == null ? void 0 : s3.messages) && s3.messages.push(new s2("scenemodification:unsupported", "Scene modifications with incompatible spatial references are not supported", { modification: this, spatialReference: s3.layer.spatialReference, context: s3 })));
      const p3 = new j();
      on(e3, p3, s3.layer.spatialReference), r2[o2] = p3.toJSON(s3);
    } else r2[o2] = e3.toJSON(s3);
    delete r2[o2].spatialReference;
  }
  clone() {
    return new l2({ geometry: a(this.geometry), type: this.type });
  }
};
e([y({ type: j }), j3()], y3.prototype, "geometry", void 0), e([r(["web-scene", "portal-item"], "geometry")], y3.prototype, "writeGeometry", null), e([y({ type: ["clip", "mask", "replace"], nonNullable: true }), j3()], y3.prototype, "type", void 0), y3 = l2 = e([a2("esri.layers.support.SceneModification")], y3);
var f3 = y3;

// ../node_modules/@arcgis/core/layers/support/SceneModifications.js
var m2;
var n2 = m2 = class extends u(V.ofType(f3)) {
  constructor(r2) {
    super(r2), this.url = null;
  }
  clone() {
    return new m2({ url: this.url, items: this.items.map((r2) => r2.clone()) });
  }
  toJSON(r2) {
    return this.toArray().map((o2) => o2.toJSON(r2)).filter((r3) => !!r3.geometry);
  }
  static fromJSON(r2, o2) {
    const t2 = new m2();
    for (const e3 of r2) t2.add(f3.fromJSON(e3, o2));
    return t2;
  }
  static async fromUrl(r2, t2, e3) {
    const i2 = { url: I(r2), origin: "service" }, c = await U(r2, { responseType: "json", signal: e3 == null ? void 0 : e3.signal }), n3 = t2.toJSON(), a6 = [];
    for (const o2 of c.data) a6.push(f3.fromJSON({ ...o2, geometry: { ...o2.geometry, spatialReference: n3 } }, i2));
    return new m2({ url: r2, items: a6 });
  }
};
e([y({ type: String })], n2.prototype, "url", void 0), n2 = m2 = e([a2("esri.layers.support.SceneModifications")], n2);
var a5 = n2;

// ../node_modules/@arcgis/core/layers/IntegratedMeshLayer.js
var A = class extends L(l(b(j2(t(S(e2(i(f2)))))))) {
  constructor(...e3) {
    super(...e3), this.geometryType = "mesh", this.operationalLayerType = "IntegratedMeshLayer", this.type = "integrated-mesh", this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.profile = "mesh-pyramids", this.modifications = null, this._modificationsSource = null, this.path = null;
  }
  initialize() {
    this.addHandles(v(() => this.modifications, "after-changes", () => this.modifications = this.modifications, C));
  }
  normalizeCtorArgs(e3, t2) {
    return "string" == typeof e3 ? { url: e3, ...t2 } : e3;
  }
  readModifications(e3, t2, o2) {
    this._modificationsSource = { url: p(e3, o2), context: o2 };
  }
  set elevationInfo(e3) {
    this._set("elevationInfo", e3), this._validateElevationInfo();
  }
  async load(e3) {
    return this.addResolvingPromise(this._doLoad(e3)), this;
  }
  async _doLoad(e3) {
    const t2 = e3 == null ? void 0 : e3.signal;
    try {
      await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e3);
    } catch (o2) {
      a3(o2);
    }
    if (await this._fetchService(t2), null != this._modificationsSource) {
      const t3 = await a5.fromUrl(this._modificationsSource.url, this.spatialReference, e3);
      this.setAtOrigin("modifications", t3, this._modificationsSource.context.origin), this._modificationsSource = null;
    }
    await this._fetchIndexAndUpdateExtent(this.nodePages, t2);
  }
  beforeSave() {
    if (null != this._modificationsSource) return this.load().then(() => {
    }, () => {
    });
  }
  async saveAs(e3, t2) {
    return this._debouncedSaveOperations(C2.SAVE_AS, { ...t2, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" }, e3);
  }
  async save() {
    const e3 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "integrated-mesh" };
    return this._debouncedSaveOperations(C2.SAVE, e3);
  }
  validateLayer(e3) {
    if (e3.layerType && "IntegratedMesh" !== e3.layerType) throw new s("integrated-mesh-layer:layer-type-not-supported", "IntegratedMeshLayer does not support this layer type", { layerType: e3.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor)) throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
    if (this.version.major > 1) throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x" });
  }
  _getTypeKeywords() {
    return ["IntegratedMeshLayer"];
  }
  _validateElevationInfo() {
    const e3 = this.elevationInfo, t2 = "Integrated mesh layers";
    $(n.getLogger(this), Z(t2, "absolute-height", e3)), $(n.getLogger(this), w(t2, e3));
  }
};
e([y({ type: String, readOnly: true })], A.prototype, "geometryType", void 0), e([y({ type: ["show", "hide"] })], A.prototype, "listMode", void 0), e([y({ type: ["IntegratedMeshLayer"] })], A.prototype, "operationalLayerType", void 0), e([y({ json: { read: false }, readOnly: true })], A.prototype, "type", void 0), e([y({ type: p2, readOnly: true })], A.prototype, "nodePages", void 0), e([y({ type: [a4], readOnly: true })], A.prototype, "materialDefinitions", void 0), e([y({ type: [y2], readOnly: true })], A.prototype, "textureSetDefinitions", void 0), e([y({ type: [m], readOnly: true })], A.prototype, "geometryDefinitions", void 0), e([y({ readOnly: true })], A.prototype, "serviceUpdateTimeStamp", void 0), e([y({ type: a5 }), j3({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "modifications" })], A.prototype, "modifications", void 0), e([o(["web-scene", "portal-item"], "modifications")], A.prototype, "readModifications", null), e([y(d)], A.prototype, "elevationInfo", null), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true }, "portal-item": { read: true, write: true } }, read: false } })], A.prototype, "path", void 0), A = e([a2("esri.layers.IntegratedMeshLayer")], A);
var P = A;
export {
  P as default
};
//# sourceMappingURL=IntegratedMeshLayer-OAAWAH6I.js.map
