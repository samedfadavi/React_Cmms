import {
  S,
  a as a2,
  c,
  y
} from "./chunk-5N3PW5XK.js";
import {
  M,
  T,
  ee
} from "./chunk-X5IXAJYK.js";
import {
  L2 as L,
  h2 as h,
  j,
  m3 as m
} from "./chunk-W4QC7UYU.js";
import {
  D,
  E,
  R,
  U,
  W,
  f2 as f,
  g,
  s3 as s2,
  u3 as u
} from "./chunk-CCWDVTAF.js";
import "./chunk-2FW7ECQ2.js";
import "./chunk-LGQJAMGK.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import "./chunk-TXIL3QUC.js";
import "./chunk-2ASAB4KA.js";
import {
  s
} from "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-JQIB7GFW.js";
import "./chunk-4AGGGL2W.js";
import {
  o
} from "./chunk-Z32PAECZ.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import {
  _,
  w
} from "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import "./chunk-WC4SPMPL.js";
import "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import {
  a3 as a
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e2;
var a3 = e2 = class extends a2 {
  constructor() {
    super(...arguments), this.type = "identity";
  }
  clone() {
    return new e2();
  }
};
e([o({ IdentityXform: "identity" })], a3.prototype, "type", void 0), a3 = e2 = e([a("esri.layers.support.rasterTransforms.IdentityTransform")], a3);
var p = a3;

// ../node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var o2 = { GCSShiftXform: c, IdentityXform: p, PolynomialXform: y };
var e3 = Object.keys(o2);
function i(r) {
  const t = r == null ? void 0 : r.type;
  if (!t) return null;
  const n = o2[r == null ? void 0 : r.type];
  if (n) {
    const t2 = new n();
    return t2.read(r), t2;
  }
  return null;
}

// ../node_modules/@arcgis/core/layers/support/RasterWorker.js
var J = class {
  convertVectorFieldData(r) {
    const t = g.fromJSON(r.pixelBlock), s3 = f(t, r.type);
    return Promise.resolve(null != s3 ? s3.toJSON() : null);
  }
  computeStatisticsHistograms(r) {
    const t = g.fromJSON(r.pixelBlock), s3 = m(t);
    return Promise.resolve(s3);
  }
  async decode(r) {
    const e4 = await j(r.data, r.options);
    return e4 && e4.toJSON();
  }
  symbolize(r) {
    r.pixelBlock = g.fromJSON(r.pixelBlock), r.extent = r.extent ? w.fromJSON(r.extent) : null;
    const t = this.symbolizer.symbolize(r);
    return Promise.resolve(null != t ? t.toJSON() : null);
  }
  async updateSymbolizer(r) {
    var _a;
    this.symbolizer = L.fromJSON(r.symbolizerJSON), r.histograms && "rasterStretch" === ((_a = this.symbolizer) == null ? void 0 : _a.rendererJSON.type) && (this.symbolizer.rendererJSON.histograms = r.histograms);
  }
  async updateRasterFunction(r) {
    this.rasterFunction = S(r.rasterFunctionJSON);
  }
  async process(r) {
    var _a;
    const t = this.rasterFunction.process({ extent: w.fromJSON(r.extent), primaryPixelBlocks: r.primaryPixelBlocks.map((r2) => null != r2 ? g.fromJSON(r2) : null), primaryPixelSizes: (_a = r.primaryPixelSizes) == null ? void 0 : _a.map((r2) => null != r2 ? _.fromJSON(r2) : null), primaryRasterIds: r.primaryRasterIds });
    return null != t ? t.toJSON() : null;
  }
  stretch(r) {
    const t = this.symbolizer.simpleStretch(g.fromJSON(r.srcPixelBlock), r.stretchParams);
    return Promise.resolve(t == null ? void 0 : t.toJSON());
  }
  estimateStatisticsHistograms(r) {
    const t = h(g.fromJSON(r.srcPixelBlock));
    return Promise.resolve(t);
  }
  split(r) {
    const t = W(g.fromJSON(r.srcPixelBlock), r.tileSize, r.maximumPyramidLevel ?? 0, false === r.useBilinear);
    return t && t.forEach((r2, e4) => {
      t.set(e4, r2 == null ? void 0 : r2.toJSON());
    }), Promise.resolve(t);
  }
  clipTile(r) {
    const t = g.fromJSON(r.pixelBlock), s3 = E({ ...r, pixelBlock: t });
    return Promise.resolve(s3 == null ? void 0 : s3.toJSON());
  }
  async mosaicAndTransform(r) {
    const t = r.srcPixelBlocks.map((r2) => r2 ? new g(r2) : null), s3 = U(t, r.srcMosaicSize, { blockWidths: r.blockWidths, alignmentInfo: r.alignmentInfo, clipOffset: r.clipOffset, clipSize: r.clipSize });
    let o3, l = s3;
    return r.coefs && (l = D(s3, r.destDimension, r.coefs, r.sampleSpacing, r.interpolation)), r.projectDirections && r.gcsGrid && (o3 = R(r.destDimension, r.gcsGrid), l = u(l, r.isUV ? "vector-uv" : "vector-magdir", o3)), { pixelBlock: l == null ? void 0 : l.toJSON(), localNorthDirections: o3 };
  }
  async createFlowMesh(r, e4) {
    const t = { data: new Float32Array(r.flowData.buffer), mask: new Uint8Array(r.flowData.maskBuffer), width: r.flowData.width, height: r.flowData.height }, { vertexData: s3, indexData: o3 } = await s2(r.meshType, r.simulationSettings, t, e4.signal);
    return { result: { vertexBuffer: s3.buffer, indexBuffer: o3.buffer }, transferList: [s3.buffer, o3.buffer] };
  }
  async getProjectionOffsetGrid(e4) {
    const t = w.fromJSON(e4.projectedExtent), s3 = w.fromJSON(e4.srcBufferExtent);
    let o3 = null;
    e4.datumTransformationSteps && (o3 = new s({ steps: e4.datumTransformationSteps })), (e4.includeGCSGrid || M(t.spatialReference, s3.spatialReference, o3)) && await T();
    const i2 = e4.rasterTransform ? i(e4.rasterTransform) : null;
    return ee({ ...e4, projectedExtent: t, srcBufferExtent: s3, datumTransformation: o3, rasterTransform: i2 });
  }
};
export {
  J as default
};
//# sourceMappingURL=RasterWorker-4NV4YE6F.js.map
