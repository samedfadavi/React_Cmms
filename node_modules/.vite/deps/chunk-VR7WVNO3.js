import {
  I,
  P as P3,
  S as S3,
  a as a6,
  b,
  g,
  h as h2,
  j,
  j2,
  n as n3,
  n2 as n4,
  t as t2,
  v as v4,
  x,
  y as y4
} from "./chunk-5T4GYCDT.js";
import {
  t
} from "./chunk-P6AJLPW7.js";
import {
  ot
} from "./chunk-F54TE5DA.js";
import {
  e as e3
} from "./chunk-5YPRHJQA.js";
import {
  e as e2
} from "./chunk-ZVC7ZICV.js";
import {
  w
} from "./chunk-C5TCSNRO.js";
import {
  $,
  B,
  C as C3,
  E,
  P as P2,
  T,
  U,
  c as c2,
  d as d2,
  f as f2,
  k,
  p as p2,
  v as v3
} from "./chunk-PFCHMQMS.js";
import {
  O
} from "./chunk-DDQ2RCGU.js";
import {
  r as r4
} from "./chunk-YJXOPMOL.js";
import {
  R
} from "./chunk-P3MZKJDB.js";
import {
  Z
} from "./chunk-LXDJBJSP.js";
import {
  e as e4,
  h,
  r as r3
} from "./chunk-OPCT64AO.js";
import {
  s as s4
} from "./chunk-JNGB7HKP.js";
import {
  i
} from "./chunk-2ASAB4KA.js";
import {
  Y
} from "./chunk-RTULPMO3.js";
import {
  C as C2,
  O as O2,
  i as i2,
  o
} from "./chunk-BJHLU2MM.js";
import {
  Fe,
  Ie,
  be,
  ge,
  i as i3,
  ye
} from "./chunk-CAC7FEOV.js";
import {
  f,
  m,
  y as y3
} from "./chunk-ZH4RVBER.js";
import {
  P,
  d,
  p
} from "./chunk-7PMYO342.js";
import {
  l as l4,
  r as r2
} from "./chunk-VRHSV3YE.js";
import {
  a as a5,
  l as l5,
  v as v2
} from "./chunk-BTSZKQPH.js";
import {
  a as a4,
  u as u3
} from "./chunk-AL3F322A.js";
import {
  G,
  N,
  W2 as W
} from "./chunk-X3IFQMC4.js";
import {
  S as S2,
  a2 as a3,
  r,
  s2,
  y as y2
} from "./chunk-TJUEGVVG.js";
import {
  n as n2
} from "./chunk-FXNOKZ3B.js";
import {
  a3 as a2
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  C,
  S,
  c2 as c,
  l as l3,
  s as s3,
  u as u2
} from "./chunk-VMWKLHJD.js";
import {
  l,
  u
} from "./chunk-5AEITAWU.js";
import {
  l as l2
} from "./chunk-G36SOMYZ.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-YNL57W4I.js";
import {
  v,
  y
} from "./chunk-2PA5UPTB.js";

// ../node_modules/@arcgis/core/core/sql/WhereClauseCache.js
var r5 = class {
  constructor(e7, r6) {
    this._cache = new e4(e7), this._invalidCache = new e4(r6);
  }
  get(t5, r6) {
    const i5 = `${r6.uid}:${t5}`, c6 = this._cache.get(i5);
    if (c6) return c6;
    if (null != this._invalidCache.get(i5)) return null;
    try {
      const c7 = O.create(t5, r6);
      return this._cache.put(i5, c7), c7;
    } catch (n6) {
      return this._invalidCache.put(i5, n6), null;
    }
  }
  getError(t5, e7) {
    const r6 = `${e7.uid}:${t5}`;
    return this._invalidCache.get(r6) ?? null;
  }
};

// ../node_modules/@arcgis/core/layers/graphics/data/attributeSupport.js
var s5 = new r5(50, 500);
var t3 = "unsupported-query";
var n5 = " as ";
var o2 = /* @__PURE__ */ new Set(["esriFieldTypeOID", "esriFieldTypeSmallInteger", "esriFieldTypeBigInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeLong"]);
var a7 = /* @__PURE__ */ new Set(["esriFieldTypeDate", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"]);
var l6 = /* @__PURE__ */ new Set(["esriFieldTypeString", "esriFieldTypeGUID", "esriFieldTypeGlobalID", ...o2, ...a7]);
function d3(i5, r6, n6 = {}) {
  const o5 = c3(r6, i5);
  if (!o5) {
    const n7 = s5.getError(r6, i5);
    throw new s(t3, "invalid SQL expression", { expression: r6, error: n7 });
  }
  const a9 = n6.expressionName || "expression";
  if (n6.validateStandardized && !o5.isStandardized) throw new s(t3, `${a9} is not standard`, { expression: r6 });
  if (n6.validateAggregate && !o5.isAggregate) throw new s(t3, `${a9} does not contain a valid aggregate function`, { expression: r6 });
  return o5.fieldNames;
}
function p3(e7, i5, r6, s6) {
  if (!r6) return true;
  const t5 = "where clause";
  return g2(e7, i5, d3(e7, r6, { validateStandardized: true, expressionName: t5 }), { expressionName: t5, query: s6 }), true;
}
function f3(i5, r6, s6, n6, o5) {
  if (!s6) return true;
  const a9 = "having clause", l7 = d3(i5, s6, { validateAggregate: true, expressionName: a9 });
  g2(i5, r6, l7, { expressionName: a9, query: o5 });
  const p6 = c3(s6, i5), f6 = p6 == null ? void 0 : p6.getExpressions().every((e7) => {
    var _a;
    const { aggregateType: r7, field: s7 } = e7, t5 = (_a = i5.get(s7)) == null ? void 0 : _a.name;
    return n6.some((e8) => {
      var _a2;
      const { onStatisticField: s8, statisticType: n7 } = e8, o6 = (_a2 = i5.get(s8)) == null ? void 0 : _a2.name;
      return o6 === t5 && n7.toLowerCase().trim() === r7;
    });
  });
  if (!f6) throw new s(t3, "expressions in having clause should also exist in outStatistics", { having: s6 });
  return true;
}
function c3(e7, i5) {
  return e7 ? s5.get(e7, i5) : null;
}
function u4(e7) {
  return /\((.*?)\)/.test(e7) ? e7 : e7.split(n5)[0];
}
function y5(e7) {
  return e7.split(n5)[1];
}
function g2(i5, r6, s6, n6 = {}) {
  const o5 = /* @__PURE__ */ new Map();
  if (m2(o5, i5, r6, n6.allowedFieldTypes ?? l6, s6), o5.size) {
    const i6 = n6.expressionName ?? "expression";
    throw new s(t3, `${i6} contains invalid or missing fields`, { errors: Array.from(o5.values()), query: n6.query });
  }
}
function m2(e7, i5, r6, s6, t5) {
  const n6 = t5.includes("*") ? [...r6, ...t5.filter((e8) => "*" !== e8)] : t5;
  for (const a9 of n6) {
    if (i5.get(a9)) T2(e7, i5, r6, s6, a9);
    else try {
      const t6 = d3(i5, u4(a9), { validateStandardized: true });
      for (const n7 of t6) T2(e7, i5, r6, s6, n7);
    } catch (o5) {
      e7.set(a9, { type: "expression-error", expression: a9, error: o5 });
    }
  }
}
function T2(e7, i5, s6, t5, n6) {
  const o5 = i5.get(n6);
  o5 ? s6.has(o5.name) ? "all" !== t5 && false === (t5 == null ? void 0 : t5.has(o5.type)) && e7.set(n6, { type: "invalid-type", fieldName: o5.name, fieldType: i.fromJSON(o5.type), allowedFieldTypes: Array.from(t5, (e8) => i.fromJSON(e8)) }) : e7.set(n6, { type: "missing-field", fieldName: o5.name }) : e7.set(n6, { type: "invalid-field", fieldName: n6 });
}

// ../node_modules/@arcgis/core/layers/graphics/data/AttributesBuilder.js
var c4 = class {
  constructor(s6, a9, l7) {
    this._fieldDataCache = /* @__PURE__ */ new Map(), this._returnDistinctMap = /* @__PURE__ */ new Map(), this.returnDistinctValues = s6.returnDistinctValues ?? false, this.fieldsIndex = l7, this.featureAdapter = a9;
    const r6 = s6.outFields;
    if (r6 && !r6.includes("*")) {
      this.outFields = r6;
      let s7 = 0;
      for (const a10 of r6) {
        const r7 = u4(a10), n6 = this.fieldsIndex.get(r7), u6 = n6 ? null : c3(r7, l7), o5 = n6 ? n6.name : y5(a10) || "FIELD_EXP_" + s7++;
        this._fieldDataCache.set(a10, { alias: o5, clause: u6 });
      }
    }
  }
  countDistinctValues(t5) {
    return this.returnDistinctValues ? (t5.forEach((t6) => this.getAttributes(t6)), this._returnDistinctMap.size) : t5.length;
  }
  getAttributes(t5) {
    const e7 = this._processAttributesForOutFields(t5);
    return this._processAttributesForDistinctValues(e7);
  }
  getFieldValue(t5, i5, s6) {
    var _a;
    const a9 = s6 ? s6.name : i5;
    let l7 = null;
    return this._fieldDataCache.has(a9) ? l7 = (_a = this._fieldDataCache.get(a9)) == null ? void 0 : _a.clause : s6 || (l7 = c3(i5, this.fieldsIndex), this._fieldDataCache.set(a9, { alias: a9, clause: l7 })), s6 ? this.featureAdapter.getAttribute(t5, a9) : l7 == null ? void 0 : l7.calculateValue(t5, this.featureAdapter);
  }
  getDataValues(t5, e7, i5 = true) {
    const s6 = e7.normalizationType, d5 = e7.normalizationTotal, c6 = this.fieldsIndex.get(e7.field), h4 = Fe(c6) || Ie(c6), f6 = be(c6);
    return t5.map((t6) => {
      let a9 = e7.field && this.getFieldValue(t6, e7.field, this.fieldsIndex.get(e7.field));
      if (e7.field2 ? (a9 = `${c2(a9)}${e7.fieldDelimiter}${c2(this.getFieldValue(t6, e7.field2, this.fieldsIndex.get(e7.field2)))}`, e7.field3 && (a9 = `${a9}${e7.fieldDelimiter}${c2(this.getFieldValue(t6, e7.field3, this.fieldsIndex.get(e7.field3)))}`)) : "string" == typeof a9 && i5 && (h4 ? a9 = a9 ? new Date(a9).getTime() : null : f6 && (a9 = a9 ? w(a9) : null)), s6 && Number.isFinite(a9)) {
        const i6 = "field" === s6 && e7.normalizationField ? this.getFieldValue(t6, e7.normalizationField, this.fieldsIndex.get(e7.normalizationField)) : null;
        a9 = B(a9, s6, i6, d5);
      }
      return a9;
    });
  }
  async getExpressionValues(t5, e7, i5, a9, l7) {
    const { arcadeUtils: r6 } = await i3(), n6 = r6.hasGeometryOperations(e7);
    n6 && await r6.enableGeometryOperations();
    const u6 = r6.createFunction(e7), o5 = r6.getViewInfo(i5), c6 = { fields: this.fieldsIndex.fields };
    return t5.map((t6) => {
      const e8 = { attributes: this.featureAdapter.getAttributes(t6), layer: c6, geometry: n6 ? { ...a6(a9.geometryType, a9.hasZ, a9.hasM, this.featureAdapter.getGeometry(t6)), spatialReference: i5 == null ? void 0 : i5.spatialReference } : null }, d5 = r6.createExecContext(e8, o5, l7);
      return r6.executeFunction(u6, d5);
    });
  }
  validateItem(t5, i5) {
    var _a, _b;
    return this._fieldDataCache.has(i5) || this._fieldDataCache.set(i5, { alias: i5, clause: c3(i5, this.fieldsIndex) }), ((_b = (_a = this._fieldDataCache.get(i5)) == null ? void 0 : _a.clause) == null ? void 0 : _b.testFeature(t5, this.featureAdapter)) ?? false;
  }
  validateItems(t5, i5) {
    var _a, _b;
    return this._fieldDataCache.has(i5) || this._fieldDataCache.set(i5, { alias: i5, clause: c3(i5, this.fieldsIndex) }), ((_b = (_a = this._fieldDataCache.get(i5)) == null ? void 0 : _a.clause) == null ? void 0 : _b.testSet(t5, this.featureAdapter)) ?? false;
  }
  _processAttributesForOutFields(t5) {
    const e7 = this.outFields;
    if (!(e7 == null ? void 0 : e7.length)) return this.featureAdapter.getAttributes(t5);
    const i5 = {};
    for (const s6 of e7) {
      const { alias: e8, clause: a9 } = this._fieldDataCache.get(s6);
      i5[e8] = a9 ? a9.calculateValue(t5, this.featureAdapter) : this.featureAdapter.getAttribute(t5, e8);
    }
    return i5;
  }
  _processAttributesForDistinctValues(t5) {
    if (null == t5 || !this.returnDistinctValues) return t5;
    const e7 = this.outFields, i5 = [];
    if (e7) for (const l7 of e7) {
      const { alias: e8 } = this._fieldDataCache.get(l7);
      i5.push(t5[e8]);
    }
    else for (const l7 in t5) i5.push(t5[l7]);
    const s6 = `${(e7 || ["*"]).join(",")}=${i5.join(",")}`;
    let a9 = this._returnDistinctMap.get(s6) || 0;
    return this._returnDistinctMap.set(s6, ++a9), a9 > 1 ? null : t5;
  }
};

// ../node_modules/@arcgis/core/layers/graphics/data/SnappingCandidate.js
function t4(t5, e7, r6) {
  return { objectId: t5, target: e7, distance: r6, type: "vertex" };
}
function e5(t5, e7, r6, n6, d5, a9 = false) {
  return { objectId: t5, target: e7, distance: r6, type: "edge", start: n6, end: d5, draped: a9 };
}

// ../node_modules/@arcgis/core/layers/graphics/data/QueryEngineResult.js
var q = class {
  constructor(e7, t5, s6) {
    this.items = e7, this.query = t5, this.geometryType = s6.geometryType, this.hasM = s6.hasM, this.hasZ = s6.hasZ, this.fieldsIndex = s6.fieldsIndex, this.objectIdField = s6.objectIdField, this.spatialReference = s6.spatialReference, this.featureAdapter = s6.featureAdapter;
  }
  get size() {
    return this.items.length;
  }
  createQueryResponseForCount() {
    const e7 = new c4(this.query, this.featureAdapter, this.fieldsIndex);
    if (!this.query.outStatistics) return e7.countDistinctValues(this.items);
    const { groupByFieldsForStatistics: t5, having: s6, outStatistics: i5 } = this.query, a9 = t5 == null ? void 0 : t5.length;
    if (!!!a9) return 1;
    const r6 = /* @__PURE__ */ new Map(), n6 = /* @__PURE__ */ new Map(), o5 = /* @__PURE__ */ new Set();
    for (const l7 of i5) {
      const { statisticType: i6 } = l7, a10 = "exceedslimit" !== i6 ? l7.onStatisticField : void 0;
      if (!n6.has(a10)) {
        const s7 = [];
        for (const i7 of t5) {
          const t6 = this._getAttributeValues(e7, i7, r6);
          s7.push(t6);
        }
        n6.set(a10, this._calculateUniqueValues(s7, e7.returnDistinctValues));
      }
      const u6 = n6.get(a10);
      for (const t6 in u6) {
        const { data: i7, items: a11 } = u6[t6], r7 = i7.join(",");
        s6 && !e7.validateItems(a11, s6) || o5.add(r7);
      }
    }
    return o5.size;
  }
  async createQueryResponse() {
    let e7;
    if (this.query.outStatistics) {
      e7 = this.query.outStatistics.some((e8) => "exceedslimit" === e8.statisticType) ? this._createExceedsLimitQueryResponse(this.query) : await this._createStatisticsQueryResponse(this.query);
    } else e7 = this._createFeatureQueryResponse(this.query);
    if (this.query.returnQueryGeometry) {
      const t5 = this.query.geometry;
      N(this.query.outSR) && !G(t5.spatialReference, this.query.outSR) ? e7.queryGeometry = h2({ spatialReference: this.query.outSR, ...j(t5, t5.spatialReference, this.query.outSR) }) : e7.queryGeometry = h2({ spatialReference: this.query.outSR, ...t5 });
    }
    return e7;
  }
  createSnappingResponse(e7, t5) {
    const s6 = this.featureAdapter, i5 = C4(this.hasZ, this.hasM), { point: a9, mode: r6 } = e7, n6 = "number" == typeof e7.distance ? e7.distance : e7.distance.x, o5 = "number" == typeof e7.distance ? e7.distance : e7.distance.y, l7 = { candidates: [] }, u6 = "esriGeometryPolygon" === this.geometryType, c6 = this._getPointCreator(r6, this.spatialReference, t5), d5 = new G2(null, 0), m4 = new G2(null, 0), f6 = { x: 0, y: 0, z: 0 };
    for (const p6 of this.items) {
      const t6 = s6.getGeometry(p6);
      if (null == t6) continue;
      const { coords: r7, lengths: y7 } = t6;
      if (d5.coords = r7, m4.coords = r7, e7.returnEdge) {
        let e8 = 0;
        for (let t7 = 0; t7 < y7.length; t7++) {
          const r8 = y7[t7];
          for (let t8 = 0; t8 < r8; t8++, e8 += i5) {
            const u7 = d5;
            if (u7.coordsIndex = e8, t8 !== r8 - 1) {
              const t9 = m4;
              t9.coordsIndex = e8 + i5;
              const r9 = f6;
              N2(f6, a9, u7, t9);
              const d6 = (a9.x - r9.x) / n6, g3 = (a9.y - r9.y) / o5, y8 = d6 * d6 + g3 * g3;
              y8 <= 1 && l7.candidates.push(e5(s6.getObjectId(p6), c6(r9), Math.sqrt(y8), c6(u7), c6(t9)));
            }
          }
        }
      }
      if ("none" !== e7.vertexMode) {
        const t7 = u6 ? r7.length - i5 : r7.length;
        if ("all" === e7.vertexMode) for (let e8 = 0; e8 < t7; e8 += i5) {
          const t8 = d5;
          t8.coordsIndex = e8;
          const i6 = (a9.x - t8.x) / n6, r8 = (a9.y - t8.y) / o5, u7 = i6 * i6 + r8 * r8;
          u7 <= 1 && l7.candidates.push(t4(s6.getObjectId(p6), c6(t8), Math.sqrt(u7)));
        }
        else if ("ends" === e7.vertexMode) {
          const e8 = [0];
          u6 || e8.push(r7.length - i5);
          for (const t8 of e8) {
            const e9 = d5;
            e9.coordsIndex = t8;
            const i6 = (a9.x - e9.x) / n6, r8 = (a9.y - e9.y) / o5, u7 = i6 * i6 + r8 * r8;
            u7 <= 1 && l7.candidates.push(t4(s6.getObjectId(p6), c6(e9), Math.sqrt(u7)));
          }
        }
      }
    }
    return l7.candidates.sort((e8, t6) => e8.distance - t6.distance), l7;
  }
  _getPointCreator(e7, t5, s6) {
    const i5 = null == s6 || G(t5, s6) ? (e8) => e8 : (e8) => j(e8, t5, s6), { hasZ: a9 } = this, r6 = 0;
    return "3d" === e7 ? a9 ? ({ x: e8, y: t6, z: s7 }) => i5({ x: e8, y: t6, z: s7 }) : ({ x: e8, y: t6 }) => i5({ x: e8, y: t6, z: r6 }) : ({ x: e8, y: t6 }) => i5({ x: e8, y: t6 });
  }
  async createSummaryStatisticsResponse(e7) {
    const { field: t5, valueExpression: s6, normalizationField: i5, normalizationType: a9, normalizationTotal: r6, minValue: n6, maxValue: o5, scale: l7, timeZone: u6 } = e7, c6 = this.fieldsIndex.get(t5), d5 = ge(c6) || Fe(c6) || Ie(c6), m4 = await this._getDataValues({ field: t5, valueExpression: s6, normalizationField: i5, normalizationType: a9, normalizationTotal: r6, scale: l7, timeZone: u6 }), h4 = f2({ normalizationType: a9, normalizationField: i5, minValue: n6, maxValue: o5 }), g3 = { value: 0.5, fieldType: c6 == null ? void 0 : c6.type }, I4 = ye(c6) ? d2({ values: m4, supportsNullCount: h4, percentileParams: g3 }) : p2({ values: m4, minValue: n6, maxValue: o5, useSampleStdDev: !a9, supportsNullCount: h4, percentileParams: g3 });
    return C3(I4, d5);
  }
  async createUniqueValuesResponse(e7) {
    const { field: t5, valueExpression: s6, domains: i5, returnAllCodedValues: a9, scale: r6, timeZone: n6 } = e7, o5 = await this._getDataValues({ field: t5, field2: e7.field2, field3: e7.field3, fieldDelimiter: e7.fieldDelimiter, valueExpression: s6, scale: r6, timeZone: n6 }, false), l7 = k(o5);
    return $(l7, i5, a9, e7.fieldDelimiter);
  }
  async createClassBreaksResponse(e7) {
    const { field: t5, valueExpression: s6, normalizationField: i5, normalizationType: a9, normalizationTotal: r6, classificationMethod: n6, standardDeviationInterval: o5, minValue: l7, maxValue: u6, numClasses: c6, scale: d5, timeZone: m4 } = e7, h4 = await this._getDataValues({ field: t5, valueExpression: s6, normalizationField: i5, normalizationType: a9, normalizationTotal: r6, scale: d5, timeZone: m4 }), g3 = E(h4, { field: t5, normalizationField: i5, normalizationType: a9, normalizationTotal: r6, classificationMethod: n6, standardDeviationInterval: o5, minValue: l7, maxValue: u6, numClasses: c6 });
    return P2(g3, n6);
  }
  async createHistogramResponse(e7) {
    const { field: t5, valueExpression: s6, normalizationField: i5, normalizationType: a9, normalizationTotal: r6, classificationMethod: n6, standardDeviationInterval: o5, minValue: l7, maxValue: u6, numBins: c6, scale: d5, timeZone: m4 } = e7, h4 = await this._getDataValues({ field: t5, valueExpression: s6, normalizationField: i5, normalizationType: a9, normalizationTotal: r6, scale: d5, timeZone: m4 });
    return U(h4, { field: t5, normalizationField: i5, normalizationType: a9, normalizationTotal: r6, classificationMethod: n6, standardDeviationInterval: o5, minValue: l7, maxValue: u6, numBins: c6 });
  }
  _sortFeatures(e7, t5, s6) {
    if (e7.length > 1 && (t5 == null ? void 0 : t5.length)) for (const i5 of t5.reverse()) {
      const t6 = i5.split(" "), a9 = t6[0], r6 = this.fieldsIndex.get(a9), n6 = !!t6[1] && "desc" === t6[1].toLowerCase(), o5 = T(r6 == null ? void 0 : r6.type, n6);
      e7.sort((e8, t7) => {
        const i6 = s6(e8, a9, r6), n7 = s6(t7, a9, r6);
        return o5(i6, n7);
      });
    }
  }
  _createFeatureQueryResponse(e7) {
    const t5 = this.items, { geometryType: s6, hasM: i5, hasZ: a9, objectIdField: n6, spatialReference: o5 } = this, { outFields: l7, outSR: c6, quantizationParameters: d5, resultRecordCount: m4, resultOffset: h4, returnZ: g3, returnM: f6 } = e7, p6 = null != m4 && t5.length > (h4 || 0) + m4, y7 = l7 && (l7.includes("*") ? [...this.fieldsIndex.fields] : l7.map((e8) => this.fieldsIndex.get(e8)));
    return { exceededTransferLimit: p6, features: this._createFeatures(e7, t5), fields: y7, geometryType: s6, hasM: i5 && f6, hasZ: a9 && g3, objectIdFieldName: n6, spatialReference: h2(c6 || o5), transform: d5 && s4(d5) || null };
  }
  _createFeatures(e7, t5) {
    const s6 = new c4(e7, this.featureAdapter, this.fieldsIndex), { hasM: i5, hasZ: a9 } = this, { orderByFields: n6, quantizationParameters: o5, returnGeometry: u6, returnCentroid: m4, maxAllowableOffset: h4, resultOffset: g3, resultRecordCount: f6, returnZ: p6 = false, returnM: y7 = false } = e7, x2 = a9 && p6, I4 = i5 && y7;
    let T3 = [], V = 0;
    const F2 = [...t5];
    if (this._sortFeatures(F2, n6, (e8, t6, i6) => s6.getFieldValue(e8, t6, i6)), this.geometryType && (u6 || m4)) {
      const e8 = s4(o5) ?? void 0, t6 = "esriGeometryPolygon" === this.geometryType || "esriGeometryPolyline" === this.geometryType;
      if (u6 && !m4) for (const i6 of F2) {
        const a10 = this.featureAdapter.getGeometry(i6), r6 = { attributes: s6.getAttributes(i6), geometry: a6(this.geometryType, this.hasZ, this.hasM, a10, h4, e8, x2, I4) };
        t6 && a10 && !r6.geometry && (r6.centroid = y4(this, this.featureAdapter.getCentroid(i6, this), e8)), T3[V++] = r6;
      }
      else if (!u6 && m4) for (const i6 of F2) T3[V++] = { attributes: s6.getAttributes(i6), centroid: y4(this, this.featureAdapter.getCentroid(i6, this), e8) };
      else for (const i6 of F2) T3[V++] = { attributes: s6.getAttributes(i6), centroid: y4(this, this.featureAdapter.getCentroid(i6, this), e8), geometry: a6(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(i6), h4, e8, x2, I4) };
    } else for (const r6 of F2) {
      const e8 = s6.getAttributes(r6);
      e8 && (T3[V++] = { attributes: e8 });
    }
    const S5 = g3 || 0;
    if (null != f6) {
      const e8 = S5 + f6;
      T3 = T3.slice(S5, Math.min(T3.length, e8));
    }
    return T3;
  }
  _createExceedsLimitQueryResponse(e7) {
    let t5 = false, s6 = Number.POSITIVE_INFINITY, i5 = Number.POSITIVE_INFINITY, a9 = Number.POSITIVE_INFINITY;
    for (const r6 of e7.outStatistics ?? []) if ("exceedslimit" === r6.statisticType) {
      s6 = null != r6.maxPointCount ? r6.maxPointCount : Number.POSITIVE_INFINITY, i5 = null != r6.maxRecordCount ? r6.maxRecordCount : Number.POSITIVE_INFINITY, a9 = null != r6.maxVertexCount ? r6.maxVertexCount : Number.POSITIVE_INFINITY;
      break;
    }
    if ("esriGeometryPoint" === this.geometryType) t5 = this.items.length > s6;
    else if (this.items.length > i5) t5 = true;
    else {
      const e8 = C4(this.hasZ, this.hasM), s7 = this.featureAdapter;
      t5 = this.items.reduce((e9, t6) => {
        const i6 = s7.getGeometry(t6);
        return e9 + (null != i6 && i6.coords.length || 0);
      }, 0) / e8 > a9;
    }
    return { fields: [{ name: "exceedslimit", type: "esriFieldTypeInteger", alias: "exceedslimit", sqlType: "sqlTypeInteger", domain: null, defaultValue: null }], features: [{ attributes: { exceedslimit: Number(t5) } }] };
  }
  async _createStatisticsQueryResponse(e7) {
    var _a;
    const t5 = { attributes: {} }, s6 = [], i5 = /* @__PURE__ */ new Map(), a9 = /* @__PURE__ */ new Map(), r6 = /* @__PURE__ */ new Map(), n6 = /* @__PURE__ */ new Map(), o5 = new c4(e7, this.featureAdapter, this.fieldsIndex), u6 = e7.outStatistics, { groupByFieldsForStatistics: c6, having: d5, orderByFields: m4, resultRecordCount: h4 } = e7, g3 = c6 == null ? void 0 : c6.length, f6 = !!g3, p6 = f6 ? c6[0] : null, y7 = f6 && !this.fieldsIndex.get(p6);
    for (const l7 of u6 ?? []) {
      const { outStatisticFieldName: e8, statisticType: u7 } = l7, m5 = l7, h5 = "exceedslimit" !== u7 ? l7.onStatisticField : void 0, I5 = "percentile_disc" === u7 || "percentile_cont" === u7, T3 = "EnvelopeAggregate" === u7 || "CentroidAggregate" === u7 || "ConvexHullAggregate" === u7, V = f6 && 1 === g3 && (h5 === p6 || y7) && "count" === u7;
      if (f6) {
        if (!r6.has(h5)) {
          const e9 = [];
          for (const t7 of c6) {
            const s8 = this._getAttributeValues(o5, t7, i5);
            e9.push(s8);
          }
          r6.set(h5, this._calculateUniqueValues(e9, !T3 && o5.returnDistinctValues));
        }
        const t6 = r6.get(h5);
        if (!t6) continue;
        const s7 = Object.keys(t6);
        for (const a10 of s7) {
          const { count: s8, data: r7, items: l8, itemPositions: u8 } = t6[a10], g4 = r7.join(",");
          if (!d5 || o5.validateItems(l8, d5)) {
            const t7 = n6.get(g4) || { attributes: {} };
            if (T3) {
              t7.aggregateGeometries || (t7.aggregateGeometries = {});
              const { aggregateGeometries: e9, outStatisticFieldName: s9 } = await this._getAggregateGeometry(m5, l8);
              t7.aggregateGeometries[s9] = e9;
            } else {
              let a12 = null;
              if (V) a12 = s8;
              else {
                const e9 = this._getAttributeValues(o5, h5, i5), t8 = u8.map((t9) => e9[t9]);
                a12 = I5 && "statisticParameters" in m5 ? this._getPercentileValue(m5, t8) : this._getStatisticValue(m5, t8, null, o5.returnDistinctValues);
              }
              t7.attributes[e8] = a12;
            }
            let a11 = 0;
            c6.forEach((e9, s9) => t7.attributes[this.fieldsIndex.get(e9) ? e9 : "EXPR_" + ++a11] = r7[s9]), n6.set(g4, t7);
          }
        }
      } else if (T3) {
        t5.aggregateGeometries || (t5.aggregateGeometries = {});
        const { aggregateGeometries: e9, outStatisticFieldName: s7 } = await this._getAggregateGeometry(m5, this.items);
        t5.aggregateGeometries[s7] = e9;
      } else {
        const s7 = this._getAttributeValues(o5, h5, i5);
        t5.attributes[e8] = I5 && "statisticParameters" in m5 ? this._getPercentileValue(m5, s7) : this._getStatisticValue(m5, s7, a9, o5.returnDistinctValues);
      }
      const F2 = "min" !== u7 && "max" !== u7 || !ye(this.fieldsIndex.get(h5)) && !this._isAnyDateField(h5) ? null : (_a = this.fieldsIndex.get(h5)) == null ? void 0 : _a.type;
      s6.push({ name: e8, alias: e8, type: F2 || "esriFieldTypeDouble" });
    }
    const I4 = f6 ? Array.from(n6.values()) : [t5];
    return this._sortFeatures(I4, m4, (e8, t6) => e8.attributes[t6]), h4 && (I4.length = Math.min(h4, I4.length)), { fields: s6, features: I4 };
  }
  _isAnyDateField(e7) {
    const t5 = this.fieldsIndex.get(e7);
    return ge(t5) || Fe(t5) || Ie(t5) || be(t5);
  }
  async _getAggregateGeometry(e7, r6) {
    const { convexHull: n6, union: o5 } = await import("./geometryEngineJSON-2NHTEQ5O.js"), { statisticType: l7, outStatisticFieldName: u6 } = e7, { featureAdapter: d5, spatialReference: m4, geometryType: h4, hasZ: g3, hasM: f6 } = this, p6 = r6.map((e8) => a6(h4, g3, f6, d5.getGeometry(e8))), y7 = n6(m4, p6, true)[0], x2 = { aggregateGeometries: null, outStatisticFieldName: null };
    if ("EnvelopeAggregate" === l7) {
      const e8 = y7 ? v2(y7) : l5(o5(m4, p6));
      x2.aggregateGeometries = { ...e8, spatialReference: m4 }, x2.outStatisticFieldName = u6 || "extent";
    } else if ("CentroidAggregate" === l7) {
      const e8 = y7 ? l4(y7) : r2(l5(o5(m4, p6)));
      x2.aggregateGeometries = { x: e8[0], y: e8[1], spatialReference: m4 }, x2.outStatisticFieldName = u6 || "centroid";
    } else "ConvexHullAggregate" === l7 && (x2.aggregateGeometries = y7, x2.outStatisticFieldName = u6 || "convexHull");
    return x2;
  }
  _getStatisticValue(e7, t5, s6, i5) {
    const { onStatisticField: a9, statisticType: r6 } = e7;
    let n6 = null;
    n6 = (s6 == null ? void 0 : s6.has(a9)) ? s6.get(a9) : ye(this.fieldsIndex.get(a9)) || this._isAnyDateField(a9) ? d2({ values: t5, returnDistinct: i5 }) : p2({ values: i5 ? [...new Set(t5)] : t5, minValue: null, maxValue: null, useSampleStdDev: true }), s6 && s6.set(a9, n6);
    return n6["var" === r6 ? "variance" : r6];
  }
  _getPercentileValue(e7, t5) {
    const { onStatisticField: s6, statisticParameters: i5, statisticType: a9 } = e7, { value: r6, orderBy: n6 } = i5, o5 = this.fieldsIndex.get(s6);
    return v3(t5, { value: r6, orderBy: n6, fieldType: o5 == null ? void 0 : o5.type, isDiscrete: "percentile_disc" === a9 });
  }
  _getAttributeValues(e7, t5, s6) {
    if (s6.has(t5)) return s6.get(t5);
    const i5 = this.fieldsIndex.get(t5), a9 = this.items.map((s7) => e7.getFieldValue(s7, t5, i5));
    return s6.set(t5, a9), a9;
  }
  _calculateUniqueValues(e7, t5) {
    const s6 = {}, i5 = this.items, a9 = i5.length;
    for (let r6 = 0; r6 < a9; r6++) {
      const a10 = i5[r6], n6 = [];
      for (const t6 of e7) n6.push(t6[r6]);
      const o5 = n6.join(",");
      null == s6[o5] ? s6[o5] = { count: 1, data: n6, items: [a10], itemPositions: [r6] } : (t5 || s6[o5].count++, s6[o5].items.push(a10), s6[o5].itemPositions.push(r6));
    }
    return s6;
  }
  async _getDataValues(t5, s6 = true) {
    const i5 = new c4(this.query, this.featureAdapter, this.fieldsIndex), { valueExpression: a9, scale: r6, timeZone: n6 } = t5;
    return a9 ? i5.getExpressionValues(this.items, a9, { viewingMode: "map", scale: r6, spatialReference: this.query.outSR || this.spatialReference }, { geometryType: this.geometryType, hasZ: this.hasZ, hasM: this.hasM }, n6) : i5.getDataValues(this.items, a(t5), s6);
  }
};
function N2(e7, t5, s6, i5) {
  const a9 = i5.x - s6.x, r6 = i5.y - s6.y, n6 = a9 * a9 + r6 * r6, o5 = (t5.x - s6.x) * a9 + (t5.y - s6.y) * r6, l7 = Math.min(1, Math.max(0, o5 / n6));
  e7.x = s6.x + a9 * l7, e7.y = s6.y + r6 * l7;
}
function C4(e7, t5) {
  return e7 ? t5 ? 4 : 3 : t5 ? 3 : 2;
}
var G2 = class {
  constructor(e7, t5) {
    this.coords = e7, this.coordsIndex = t5;
  }
  get x() {
    return this.coords[this.coordsIndex];
  }
  get y() {
    return this.coords[this.coordsIndex + 1];
  }
  get z() {
    return this.coords[this.coordsIndex + 2];
  }
};

// ../node_modules/@arcgis/core/layers/graphics/data/queryValidationUtils.js
var u5 = "unsupported-query";
async function p4(t5, { fieldsIndex: i5, geometryType: s6, spatialReference: r6, availableFields: o5 }) {
  if ((t5.distance ?? 0) < 0 || null != t5.geometryPrecision || t5.multipatchOption && "xyFootprint" !== t5.multipatchOption || t5.pixelSize || t5.relationParam || t5.text) throw new s(u5, "Unsupported query options", { query: t5 });
  return c5(i5, o5, t5), f4(i5, o5, t5), Promise.all([P3(t5, s6, r6), x(r6, t5.outSR)]).then(() => t5);
}
function c5(t5, i5, o5) {
  const { outFields: n6, orderByFields: a9, returnDistinctValues: l7, outStatistics: p6 } = o5, c6 = p6 ? p6.map((e7) => e7.outStatisticFieldName && e7.outStatisticFieldName.toLowerCase()).filter(Boolean) : [];
  if (a9 && a9.length > 0) {
    const e7 = " asc", r6 = " desc", n7 = a9.map((t6) => {
      const i6 = t6.toLowerCase();
      return i6.includes(e7) ? i6.split(e7)[0] : i6.includes(r6) ? i6.split(r6)[0] : t6;
    }).filter((e8) => !c6.includes(e8));
    g2(t5, i5, n7, { expressionName: "orderByFields", query: o5 });
  }
  if (n6 && n6.length > 0) g2(t5, i5, n6, { expressionName: "outFields", query: o5, allowedFieldTypes: "all" });
  else if (l7) throw new s(u5, "outFields should be specified for returnDistinctValues", { query: o5 });
  p3(t5, i5, o5.where, o5);
}
var d4 = /* @__PURE__ */ new Set([...o2, ...a7]);
function f4(t5, i5, r6) {
  const { outStatistics: n6, groupByFieldsForStatistics: a9, having: l7 } = r6, p6 = a9 == null ? void 0 : a9.length, c6 = n6 == null ? void 0 : n6.length;
  if (l7) {
    if (!p6 || !c6) throw new s(u5, "outStatistics and groupByFieldsForStatistics should be specified with having", { query: r6 });
    f3(t5, i5, l7, n6, r6);
  }
  if (c6) {
    if (!h3(n6)) return;
    const o5 = n6.map((e7) => e7.onStatisticField).filter(Boolean);
    g2(t5, i5, o5, { expressionName: "onStatisticFields", query: r6 }), p6 && g2(t5, i5, a9, { expressionName: "groupByFieldsForStatistics", query: r6 });
    for (const a10 of n6) {
      const { onStatisticField: o6, statisticType: n7 } = a10;
      if (("percentile_disc" === n7 || "percentile_cont" === n7) && "statisticParameters" in a10) {
        const { statisticParameters: t6 } = a10;
        if (!t6) throw new s(u5, "statisticParameters should be set for percentile type", { definition: a10, query: r6 });
      } else t5.get(o6) && "count" !== n7 && "min" !== n7 && "max" !== n7 && g2(t5, i5, [o6], { expressionName: `outStatistics with '${n7}' statistic type`, allowedFieldTypes: d4, query: r6 });
    }
  }
}
async function m3(t5, i5, { fieldsIndex: s6, geometryType: r6, spatialReference: o5, availableFields: l7 }) {
  if ((t5.distance ?? 0) < 0 || null != t5.geometryPrecision || t5.multipatchOption || t5.pixelSize || t5.relationParam || t5.text || t5.outStatistics || t5.groupByFieldsForStatistics || t5.having || t5.orderByFields) throw new s(u5, "Unsupported query options", { query: t5 });
  return c5(s6, l7, t5), Promise.all([y6(s6, l7, i5, t5), P3(t5, r6, o5), x(o5, t5.outSR)]).then(() => t5);
}
async function y6(t5, i5, r6, o5) {
  let n6 = [];
  if (r6.valueExpression) {
    const { arcadeUtils: e7 } = await i3();
    n6 = e7.extractFieldNames(r6.valueExpression);
  }
  if (r6.field && n6.push(r6.field), r6.field2 && n6.push(r6.field2), r6.field3 && n6.push(r6.field3), r6.normalizationField && n6.push(r6.normalizationField), !n6.length && !r6.valueExpression) throw new s(u5, "field or valueExpression is required", { params: r6 });
  g2(t5, i5, n6, { expressionName: "statistics", query: o5 });
}
function h3(e7) {
  return null != e7 && e7.every((e8) => "exceedslimit" !== e8.statisticType);
}

// ../node_modules/@arcgis/core/views/support/Yield.js
var o3 = Symbol("Yield");

// ../node_modules/@arcgis/core/layers/support/PromiseQueue.js
var i4 = class {
  constructor() {
    this._tasks = new Array(), this._runningTasks = r4(0);
  }
  get length() {
    return this._tasks.length;
  }
  get running() {
    return this._runningTasks.value > 0;
  }
  destroy() {
    this.cancelAll();
  }
  runTask(s6) {
    if (0 === this.length) return o3;
    for (; !s6.done && this._process(s6); ) s6.madeProgress();
  }
  push(s6, t5, e7) {
    return ++this._runningTasks.value, new Promise((r6, n6) => this._tasks.push(new a8(r6, n6, s6, t5, e7))).finally(() => --this._runningTasks.value);
  }
  unshift(s6, t5, e7) {
    return ++this._runningTasks.value, new Promise((r6, n6) => this._tasks.unshift(new a8(r6, n6, s6, t5, e7))).finally(() => --this._runningTasks.value);
  }
  _process(r6) {
    var _a;
    if (0 === this._tasks.length) return false;
    const n6 = this._tasks.shift();
    try {
      const i5 = c(n6.signal);
      if (i5 && !n6.abortCallback) n6.reject(u2());
      else {
        const s6 = i5 ? (_a = n6.abortCallback) == null ? void 0 : _a.call(n6, u2()) : n6.callback(r6);
        S(s6) ? s6.then(n6.resolve, n6.reject) : n6.resolve(s6);
      }
    } catch (i5) {
      n6.reject(i5);
    }
    return true;
  }
  cancelAll() {
    const s6 = u2();
    for (const t5 of this._tasks) if (t5.abortCallback) {
      const e7 = t5.abortCallback(s6);
      t5.resolve(e7);
    } else t5.reject(s6);
    this._tasks.length = 0;
  }
};
var a8 = class {
  constructor(s6, t5, e7, r6 = void 0, n6 = void 0) {
    this.resolve = s6, this.reject = t5, this.callback = e7, this.signal = r6, this.abortCallback = n6;
  }
};

// ../node_modules/@arcgis/core/views/support/debugFlags.js
var e6 = class extends S2 {
  constructor() {
    super(...arguments), this.SCHEDULER_LOG_SLOW_TASKS = false, this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES = false;
  }
};
e([y2()], e6.prototype, "SCHEDULER_LOG_SLOW_TASKS", void 0), e([y2()], e6.prototype, "FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES", void 0), e6 = e([a2("esri.views.support.debugFlags")], e6);
var E2 = new e6();

// ../node_modules/@arcgis/core/views/support/RenderState.js
var I2;
!function(I4) {
  I4[I4.ANIMATING = 0] = "ANIMATING", I4[I4.INTERACTING = 1] = "INTERACTING", I4[I4.IDLE = 2] = "IDLE";
}(I2 || (I2 = {}));

// ../node_modules/@arcgis/core/views/support/Scheduler.js
var I3;
!function(e7) {
  e7.RESOURCE_CONTROLLER_IMMEDIATE = "immediate", e7.RESOURCE_CONTROLLER = "schedule", e7.SLIDE = "slide", e7.STREAM_DATA_LOADER = "stream loader", e7.ELEVATION_QUERY = "elevation query", e7.TERRAIN_SURFACE = "terrain", e7.SURFACE_GEOMETRY_UPDATES = "surface geometry updates", e7.LOD_RENDERER = "LoD renderer", e7.GRAPHICS_CORE = "Graphics3D", e7.I3S_CONTROLLER = "I3S", e7.POINT_CLOUD_LAYER = "point cloud", e7.FEATURE_TILE_FETCHER = "feature fetcher", e7.OVERLAY = "overlay", e7.STAGE = "stage", e7.GRAPHICS_DECONFLICTOR = "graphics deconflictor", e7.FILTER_VISIBILITY = "Graphics3D filter visibility", e7.SCALE_VISIBILITY = "Graphics3D scale visibility", e7.FRUSTUM_VISIBILITY = "Graphics3D frustum visibility", e7.POINT_OF_INTEREST_FREQUENT = "POI frequent", e7.POINT_OF_INTEREST_INFREQUENT = "POI infrequent", e7.LABELER = "labeler", e7.FEATURE_QUERY_ENGINE = "feature query", e7.FEATURE_TILE_TREE = "feature tile tree", e7.FEATURE_TILE_TREE_ACTIVE = "fast feature tile tree", e7.ELEVATION_ALIGNMENT = "elevation alignment", e7.ELEVATION_ALIGNMENT_SCENE = "elevation alignment scene", e7.TEXT_TEXTURE_ATLAS = "text texture atlas", e7.TEXTURE_UNLOAD = "texture unload", e7.LINE_OF_SIGHT_TOOL = "line of sight tool", e7.LINE_OF_SIGHT_TOOL_INTERACTIVE = "interactive line of sight tool", e7.ELEVATION_PROFILE = "elevation profile", e7.SNAPPING = "snapping", e7.SHADOW_ACCUMULATOR = "shadow accumulator", e7.CLOUDS_GENERATOR = "clouds generator", e7[e7.NONE = 0] = "NONE", e7[e7.TEST_PRIO = 1] = "TEST_PRIO";
}(I3 || (I3 = {}));
var R2 = 0;
var p5 = /* @__PURE__ */ new Map([[I3.RESOURCE_CONTROLLER_IMMEDIATE, R2], [I3.RESOURCE_CONTROLLER, 4], [I3.SLIDE, R2], [I3.STREAM_DATA_LOADER, R2], [I3.ELEVATION_QUERY, R2], [I3.TERRAIN_SURFACE, 1], [I3.SURFACE_GEOMETRY_UPDATES, 1], [I3.LOD_RENDERER, 2], [I3.GRAPHICS_CORE, 2], [I3.I3S_CONTROLLER, 2], [I3.POINT_CLOUD_LAYER, 2], [I3.FEATURE_TILE_FETCHER, 2], [I3.OVERLAY, 4], [I3.STAGE, 4], [I3.GRAPHICS_DECONFLICTOR, 4], [I3.FILTER_VISIBILITY, 4], [I3.SCALE_VISIBILITY, 4], [I3.FRUSTUM_VISIBILITY, 4], [I3.CLOUDS_GENERATOR, 4], [I3.POINT_OF_INTEREST_FREQUENT, 6], [I3.POINT_OF_INTEREST_INFREQUENT, 30], [I3.LABELER, 8], [I3.FEATURE_QUERY_ENGINE, 8], [I3.FEATURE_TILE_TREE, 16], [I3.FEATURE_TILE_TREE_ACTIVE, R2], [I3.ELEVATION_ALIGNMENT, 12], [I3.ELEVATION_ALIGNMENT_SCENE, 14], [I3.TEXT_TEXTURE_ATLAS, 12], [I3.TEXTURE_UNLOAD, 12], [I3.LINE_OF_SIGHT_TOOL, 16], [I3.LINE_OF_SIGHT_TOOL_INTERACTIVE, R2], [I3.SNAPPING, R2], [I3.SHADOW_ACCUMULATOR, 30]]);
function f5(e7) {
  return p5.has(e7) ? p5.get(e7) : "number" == typeof e7 ? e7 : 1;
}
var A = n2(6.5);
var L = n2(1);
var N3 = n2(30);
var O3 = n2(1e3 / 30);
var S4 = n2(100);
var b2 = 0.9;
var k2;
var U2;
!function(a9) {
  class n6 {
    get updating() {
      return this._updating.value;
    }
    _updatingChanged() {
      this._updating.value = this._tasks.some((e7) => e7.needsUpdate);
    }
    constructor() {
      this._updating = r4(true), this._microTaskQueued = false, this._frameNumber = 0, this.performanceInfo = { total: new s2("total"), tasks: /* @__PURE__ */ new Map() }, this._frameTaskTimes = /* @__PURE__ */ new Map(), this._budget = new g3(), this._state = I2.INTERACTING, this._tasks = new l2(), this._runQueue = new l2(), this._load = 0, this._idleStateCallbacks = new l2(), this._idleUpdatesStartFired = false, this._forceTask = false, this._debug = false, this._debugHandle = d(() => E2.SCHEDULER_LOG_SLOW_TASKS, (e7) => this._debug = e7, P);
      for (const e7 of Object.keys(I3)) this.performanceInfo.tasks.set(I3[e7], new s2(I3[e7]));
    }
    destroy() {
      this._tasks.toArray().forEach((e7) => e7.remove()), this._tasks.clear(), l(this._debugHandle), this._microTaskQueued = false, this._updatingChanged();
    }
    taskRunningChanged(e7) {
      this._updatingChanged(), e7 && this._budget.remaining > 0 && !this._microTaskQueued && (this._microTaskQueued = true, queueMicrotask(() => {
        this._microTaskQueued && (this._microTaskQueued = false, this._budget.remaining > 0 && this._schedule() && this.frame());
      }));
    }
    registerTask(e7, t5) {
      const s6 = new _(this, e7, t5);
      return this._tasks.push(s6), this._updatingChanged(), this.performanceInfo.tasks.has(e7) || this.performanceInfo.tasks.set(e7, new s2(e7)), s6;
    }
    registerIdleStateCallbacks(e7, t5) {
      const s6 = { idleBegin: e7, idleEnd: t5 };
      this._idleStateCallbacks.push(s6), this.state === I2.IDLE && this._idleUpdatesStartFired && s6.idleBegin();
      const r6 = this;
      return { remove: () => this._removeIdleStateCallbacks(s6), set idleBegin(e8) {
        r6._idleUpdatesStartFired && (s6.idleEnd(), r6._state === I2.IDLE && e8()), s6.idleBegin = e8;
      }, set idleEnd(e8) {
        s6.idleEnd = e8;
      } };
    }
    get load() {
      return this._load;
    }
    set state(e7) {
      this._state !== e7 && (this._state = e7, this.state !== I2.IDLE && this._idleUpdatesStartFired && (this._idleUpdatesStartFired = false, this._idleStateCallbacks.forAll((e8) => e8.idleEnd())));
    }
    get state() {
      return this._state;
    }
    updateBudget(e7) {
      ++this._frameNumber;
      let t5 = A, s6 = e7.frameDuration, r6 = L;
      switch (this.state) {
        case I2.IDLE:
          t5 = n2(0), s6 = n2(Math.max(S4, e7.frameDuration)), r6 = N3;
          break;
        case I2.INTERACTING:
          s6 = n2(Math.max(O3, e7.frameDuration));
        case I2.ANIMATING:
      }
      return s6 = n2(s6 - e7.elapsedFrameTime - t5), this.state !== I2.IDLE && s6 < L && !this._forceTask ? (this._forceTask = true, false) : (s6 = n2(Math.max(s6, r6)), this._budget.reset(s6, this.state), this._updateLoad(), this._schedule());
    }
    frame() {
      switch (this._forceTask = false, this._microTaskQueued = false, this.state) {
        case I2.IDLE:
          this._idleUpdatesStartFired || (this._idleUpdatesStartFired = true, this._idleStateCallbacks.forAll((e7) => e7.idleBegin())), this._runIdle();
          break;
        case I2.INTERACTING:
          this._runInteracting();
          break;
        default:
          this._runAnimating();
      }
    }
    stopFrame() {
      this._budget.reset(n2(0), this._state), this._budget.madeProgress();
    }
    _removeIdleStateCallbacks(e7) {
      this._idleUpdatesStartFired && e7.idleEnd(), this._idleStateCallbacks.removeUnordered(e7);
    }
    removeTask(e7) {
      this._tasks.removeUnordered(e7), this._runQueue.removeUnordered(e7), this._updatingChanged();
    }
    _updateTask(e7) {
      this._tasks.forAll((t5) => {
        t5.name === e7 && t5.setPriority(e7);
      });
    }
    _getState(e7) {
      if (this._runQueue.some((t6) => t6.name === e7)) return U2.SCHEDULED;
      let t5 = U2.IDLE;
      return this._tasks.forAll((s6) => {
        s6.name === e7 && s6.needsUpdate && (s6.schedulePriority <= 1 ? t5 = U2.READY : t5 !== U2.READY && (t5 = U2.WAITING));
      }), t5;
    }
    _getRuntime(e7) {
      let t5 = 0;
      return this._tasks.forAll((s6) => {
        s6.name === e7 && (t5 += s6.runtime);
      }), t5;
    }
    _resetRuntimes() {
      this._tasks.forAll((e7) => e7.runtime = 0);
    }
    _getRunning() {
      const e7 = /* @__PURE__ */ new Map();
      if (this._tasks.forAll((t6) => {
        t6.needsUpdate && e7.set(t6.name, (e7.get(t6.name) || 0) + 1);
      }), 0 === e7.size) return null;
      let t5 = "";
      return e7.forEach((e8, s6) => {
        t5 += e8 > 1 ? ` ${e8}x ${s6}` : ` ${s6}`;
      }), t5;
    }
    _runIdle() {
      this._run();
    }
    _runInteracting() {
      this._run();
    }
    _runAnimating() {
      this._run();
    }
    _updateLoad() {
      const e7 = this._tasks.reduce((e8, t5) => t5.needsUpdate ? ++e8 : e8, 0);
      this._load = this._load * b2 + e7 * (1 - b2);
    }
    _schedule() {
      for (this._runQueue.filterInPlace((e7) => !!e7.needsUpdate || (e7.schedulePriority = e7.basePriority, false)), this._tasks.forAll((e7) => {
        e7.basePriority === R2 && e7.needsUpdate && !this._runQueue.includes(e7) && e7.blockFrame !== this._frameNumber && this._runQueue.unshift(e7);
      }); 0 === this._runQueue.length; ) {
        let e7 = false, t5 = 0;
        if (this._tasks.forAll((s6) => {
          if (s6.needsUpdate && 0 !== s6.schedulePriority && s6.basePriority !== R2 && s6.blockFrame !== this._frameNumber) if (e7 = true, t5 = Math.max(t5, s6.basePriority), 1 === s6.schedulePriority) s6.schedulePriority = 0, this._runQueue.push(s6);
          else --s6.schedulePriority;
        }), !e7) return this._updatingChanged(), false;
      }
      return this._updatingChanged(), true;
    }
    _run() {
      const e7 = this._budget.now();
      this._startFrameTaskTimes();
      do {
        for (; this._runQueue.length > 0; ) {
          const r6 = this._budget.now(), i5 = this._runQueue.pop();
          this._budget.resetProgress();
          try {
            i5.task.runTask(this._budget) === o3 && (i5.blockFrame = this._frameNumber);
          } catch (s6) {
            n.getLogger("esri.views.support.Scheduler").error(`Exception in task "${i5.name}"`, s6), i5.blockFrame = this._frameNumber;
          }
          !this._budget.hasProgressed && i5.blockFrame !== this._frameNumber && i5.needsUpdate && (i5.name, I3.I3S_CONTROLLER, i5.blockFrame = this._frameNumber), i5.schedulePriority = i5.basePriority;
          const a10 = this._budget.now() - r6;
          if (i5.runtime += a10, this._frameTaskTimes.set(i5.priority, this._frameTaskTimes.get(i5.priority) + a10), this._budget.remaining <= 0) return this._updatingChanged(), void this._recordFrameTaskTimes(this._budget.now() - e7);
        }
      } while (this._schedule());
      this._updatingChanged(), this._recordFrameTaskTimes(this._budget.now() - e7);
    }
    _startFrameTaskTimes() {
      for (const e7 of Object.keys(I3)) this._frameTaskTimes.set(I3[e7], 0);
    }
    _recordFrameTaskTimes(e7) {
      this._frameTaskTimes.forEach((e8, t5) => this.performanceInfo.tasks.get(t5).record(e8)), this.performanceInfo.total.record(e7);
    }
    get test() {
    }
  }
  a9.Scheduler = n6;
  class _ {
    get task() {
      return this._task.value;
    }
    get updating() {
      return this._queue.running;
    }
    constructor(t5, s6, r6) {
      this._scheduler = t5, this.name = s6, this.blockFrame = 0, this.runtime = 0, this._queue = new i4(), this._handles = new r(), this._basePriority = f5(s6), this.schedulePriority = this._basePriority, this._task = r4(null != r6 ? r6 : this._queue), this._handles.add(p(() => this.task.running, (e7) => t5.taskRunningChanged(e7)));
    }
    remove() {
      this.processQueue(C5), this._scheduler.removeTask(this), this.schedule = F.schedule, this.reschedule = F.reschedule, this._handles.destroy();
    }
    get basePriority() {
      return this._basePriority;
    }
    setPriority(e7) {
      if (this.name === e7) return;
      this.name = e7;
      const t5 = f5(e7);
      this._basePriority !== R2 && 0 === this.schedulePriority || (this.schedulePriority = t5), this._basePriority = t5;
    }
    get priority() {
      return this.name;
    }
    set priority(e7) {
      this.setPriority(e7);
    }
    get needsUpdate() {
      return this.updating || this.task.running;
    }
    schedule(e7, t5, s6) {
      return this._queue.push(e7, t5, s6);
    }
    reschedule(e7, t5, s6) {
      return this._queue.unshift(e7, t5, s6);
    }
    processQueue(e7) {
      return this._queue.runTask(e7);
    }
  }
  class g3 {
    constructor() {
      this._begin = "undefined" != typeof performance ? performance.now() : 0, this._budget = 0, this._state = I2.IDLE, this._done = false, this._progressed = false, this._enabled = true;
    }
    run(e7) {
      return !this.done && (true === e7() && this.madeProgress(), true);
    }
    get done() {
      return this._done;
    }
    get budget() {
      return this._budget;
    }
    madeProgress() {
      return this._progressed = true, this._done = this.elapsed >= this._budget && this._enabled, this._done;
    }
    get state() {
      return this._state;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(e7) {
      this._enabled = e7;
    }
    reset(e7, t5) {
      this._begin = this.now(), this._budget = e7, this._state = t5, this.resetProgress();
    }
    get remaining() {
      return Math.max(this._budget - this.elapsed, 0);
    }
    now() {
      return performance.now();
    }
    get elapsed() {
      return this.now() - this._begin;
    }
    resetProgress() {
      this._progressed = false, this._done = false;
    }
    get hasProgressed() {
      return this._progressed;
    }
  }
  a9.Budget = g3;
}(k2 || (k2 = {})), function(e7) {
  e7.SCHEDULED = "s", e7.READY = "r", e7.WAITING = "w", e7.IDLE = "i";
}(U2 || (U2 = {}));
var C5 = (() => {
  const e7 = new k2.Budget();
  return e7.enabled = false, e7;
})();
var P4 = class {
  remove() {
  }
  processQueue() {
  }
  schedule(e7, t5, s6) {
    try {
      if (c(t5)) {
        const e8 = u2();
        return s6 ? Promise.resolve(s6(e8)) : Promise.reject(e8);
      }
      return C(e7(C5));
    } catch (r6) {
      return Promise.reject(r6);
    }
  }
  reschedule(e7, t5, s6) {
    return this.schedule(e7, t5, s6);
  }
};
var F = new P4();

// ../node_modules/@arcgis/core/layers/graphics/data/QueryEngine.js
var L2 = "unsupported-query";
var D = new h(2e6);
var W2 = 0;
var $2 = class {
  constructor(e7) {
    this._geometryQueryCache = null, this._changeHandle = null, this.capabilities = { query: t }, this.geometryType = e7.geometryType, this.hasM = !!e7.hasM, this.hasZ = !!e7.hasZ, this.objectIdField = e7.objectIdField, this.spatialReference = e7.spatialReference, this.definitionExpression = e7.definitionExpression, this.featureStore = e7.featureStore, this.aggregateAdapter = e7.aggregateAdapter, this._changeHandle = this.featureStore.events.on("changed", () => this.clearCache()), this.timeInfo = e7.timeInfo, e7.cacheSpatialQueries && (this._geometryQueryCache = new r3(W2++ + "$$", D)), this.fieldsIndex = a3(e7.fieldsIndex) ? e7.fieldsIndex : Z.fromJSON(e7.fieldsIndex), !e7.availableFields || 1 === e7.availableFields.length && "*" === e7.availableFields[0] ? this.availableFields = new Set(this.fieldsIndex.fields.map((e8) => e8.name)) : this.availableFields = new Set(e7.availableFields.map((e8) => {
      var _a;
      return (_a = this.fieldsIndex.get(e8)) == null ? void 0 : _a.name;
    }).filter((e8) => null != e8)), e7.scheduler && e7.priority && (this._frameTask = e7.scheduler.registerTask(e7.priority));
  }
  destroy() {
    this._frameTask = l(this._frameTask), this.clearCache(), u(this._geometryQueryCache), this._changeHandle = l(this._changeHandle);
  }
  get featureAdapter() {
    return this.featureStore.featureAdapter;
  }
  clearCache() {
    var _a;
    (_a = this._geometryQueryCache) == null ? void 0 : _a.clear(), this._allFeaturesPromise = null, this._timeExtentPromise = null, this._fullExtentPromise = null;
  }
  async executeQuery(e7, t5) {
    const i5 = l3(t5);
    try {
      return (await this._executeQuery(e7, {}, i5)).createQueryResponse();
    } catch (s6) {
      if (s6 !== g) throw s6;
      return new q([], e7, this).createQueryResponse();
    }
  }
  async executeQueryForCount(e7 = {}, t5) {
    const i5 = l3(t5);
    try {
      return (await this._executeQuery(e7, { returnGeometry: false, returnCentroid: false, outSR: null }, i5)).createQueryResponseForCount();
    } catch (s6) {
      if (s6 !== g) throw s6;
      return 0;
    }
  }
  async executeQueryForExtent(e7, t5) {
    const i5 = l3(t5), s6 = e7.outSR;
    try {
      const t6 = await this._executeQuery(e7, { returnGeometry: true, returnCentroid: false, outSR: null }, i5), r6 = t6.size;
      if (!r6) return { count: 0, extent: null };
      return { count: r6, extent: await this._getBounds(t6.items, t6.spatialReference, s6 || this.spatialReference) };
    } catch (r6) {
      if (r6 === g) return { count: 0, extent: null };
      throw r6;
    }
  }
  async executeQueryForIds(e7, t5) {
    return this.executeQueryForIdSet(e7, t5).then((e8) => Array.from(e8));
  }
  async executeQueryForIdSet(e7, t5) {
    const i5 = l3(t5);
    try {
      const t6 = await this._executeQuery(e7, { returnGeometry: true, returnCentroid: false, outSR: null }, i5), s6 = t6.items, r6 = /* @__PURE__ */ new Set();
      return await this._reschedule(() => {
        for (const e8 of s6) r6.add(t6.featureAdapter.getObjectId(e8));
      }, i5), r6;
    } catch (s6) {
      if (s6 === g) return /* @__PURE__ */ new Set();
      throw s6;
    }
  }
  async executeQueryForSnapping(e7, t5) {
    const i5 = l3(t5), { point: s6, distance: a9, returnEdge: n6, vertexMode: l7 } = e7;
    if (!n6 && "none" === l7) return { candidates: [] };
    let u6 = a(e7.query);
    u6 = await this._schedule(() => j2(u6, this.definitionExpression, this.spatialReference), i5), u6 = await this._reschedule(() => p4(u6, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), i5);
    const h4 = !G(s6.spatialReference, this.spatialReference);
    h4 && await x(s6.spatialReference, this.spatialReference);
    const c6 = "number" == typeof a9 ? a9 : a9.x, m4 = "number" == typeof a9 ? a9 : a9.y, f6 = { xmin: s6.x - c6, xmax: s6.x + c6, ymin: s6.y - m4, ymax: s6.y + m4, spatialReference: s6.spatialReference }, y7 = h4 ? j(f6, this.spatialReference) : f6;
    if (!y7) return { candidates: [] };
    const p6 = (await R(y3(s6), null, { signal: i5 }))[0], d5 = (await R(y3(y7), null, { signal: i5 }))[0];
    if (null == p6 || null == d5) return { candidates: [] };
    const g3 = new q(await this._reschedule(() => this._searchFeatures(K(d5.toJSON())), i5), u6, this);
    await this._reschedule(() => this._executeObjectIdsQuery(g3), i5), await this._reschedule(() => this._executeTimeQuery(g3), i5), await this._reschedule(() => this._executeAttributesQuery(g3), i5), await this._reschedule(() => this._executeGeometryQueryForSnapping(g3, i5), i5);
    const x2 = p6.toJSON(), _ = h4 ? j(x2, this.spatialReference) : x2, F2 = h4 ? Math.max(y7.xmax - y7.xmin, y7.ymax - y7.ymin) / 2 : a9;
    return g3.createSnappingResponse({ ...e7, point: _, distance: F2 }, s6.spatialReference);
  }
  async executeQueryForLatestObservations(e7, t5) {
    var _a;
    const s6 = l3(t5);
    if (!((_a = this.timeInfo) == null ? void 0 : _a.trackIdField)) throw new s(L2, "Missing timeInfo or timeInfo.trackIdField", { query: e7, timeInfo: this.timeInfo });
    try {
      const t6 = await this._executeQuery(e7, {}, s6);
      return await this._reschedule(() => this._filterLatest(t6), s6), t6.createQueryResponse();
    } catch (r6) {
      if (r6 !== g) throw r6;
      return new q([], e7, this).createQueryResponse();
    }
  }
  async executeQueryForSummaryStatistics(e7 = {}, t5, i5) {
    const s6 = l3(i5), { field: r6, normalizationField: a9, valueExpression: n6 } = t5;
    return (await this._executeQueryForStatistics(e7, { field: r6, normalizationField: a9, valueExpression: n6 }, s6)).createSummaryStatisticsResponse(t5);
  }
  async executeQueryForUniqueValues(e7 = {}, t5, i5) {
    const s6 = l3(i5), { field: r6, field2: a9, field3: n6, valueExpression: l7 } = t5;
    return (await this._executeQueryForStatistics(e7, { field: r6, field2: a9, field3: n6, valueExpression: l7 }, s6)).createUniqueValuesResponse(t5);
  }
  async executeQueryForClassBreaks(e7 = {}, t5, i5) {
    const s6 = l3(i5), { field: r6, normalizationField: a9, valueExpression: n6 } = t5;
    return (await this._executeQueryForStatistics(e7, { field: r6, normalizationField: a9, valueExpression: n6 }, s6)).createClassBreaksResponse(t5);
  }
  async executeQueryForHistogram(e7 = {}, t5, i5) {
    const s6 = l3(i5), { field: r6, normalizationField: a9, valueExpression: n6 } = t5;
    return (await this._executeQueryForStatistics(e7, { field: r6, normalizationField: a9, valueExpression: n6 }, s6)).createHistogramResponse(t5);
  }
  async fetchRecomputedExtents(e7) {
    const t5 = l3(e7);
    this._timeExtentPromise || (this._timeExtentPromise = n4(this.timeInfo, this.featureStore));
    const [i5, s6] = await Promise.all([this._getFullExtent(), this._timeExtentPromise]);
    return s3(t5), { fullExtent: i5, timeExtent: s6 };
  }
  async _getBounds(e7, t5, i5) {
    const s6 = O2(i2(), C2);
    await this.featureStore.forEachBounds(e7, (e8) => o(s6, e8));
    const r6 = { xmin: s6[0], ymin: s6[1], xmax: s6[3], ymax: s6[4], spatialReference: h2(this.spatialReference) };
    this.hasZ && isFinite(s6[2]) && isFinite(s6[5]) && (r6.zmin = s6[2], r6.zmax = s6[5], r6.hasZ = true);
    const a9 = j(r6, t5, i5);
    if (a9.spatialReference = h2(i5), a9.xmax - a9.xmin == 0) {
      const e8 = W(a9.spatialReference);
      a9.xmin -= e8, a9.xmax += e8;
    }
    if (a9.ymax - a9.ymin == 0) {
      const e8 = W(a9.spatialReference);
      a9.ymin -= e8, a9.ymax += e8;
    }
    if (this.hasZ && null != a9.zmin && null != a9.zmax && a9.zmax - a9.zmin == 0) {
      const e8 = W(a9.spatialReference);
      a9.zmin -= e8, a9.zmax += e8;
    }
    return a9;
  }
  _getFullExtent() {
    return this._fullExtentPromise || (this._fullExtentPromise = "getFullExtent" in this.featureStore && this.featureStore.getFullExtent ? Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)) : this._getAllFeatures().then((e7) => this._getBounds(e7, this.spatialReference, this.spatialReference))), this._fullExtentPromise;
  }
  async _schedule(e7, t5) {
    return null != this._frameTask ? this._frameTask.schedule(e7, t5) : e7(C5);
  }
  async _reschedule(e7, t5) {
    return null != this._frameTask ? this._frameTask.reschedule(e7, t5) : e7(C5);
  }
  async _getAllFeaturesQueryEngineResult(e7) {
    return new q(await this._getAllFeatures(), e7, this);
  }
  async _getAllFeatures() {
    if (null == this._allFeaturesPromise) {
      const e8 = [];
      this._allFeaturesPromise = (async () => {
        await this.featureStore.forEach((t6) => e8.push(t6));
      })().then(() => e8);
    }
    const e7 = this._allFeaturesPromise, t5 = await e7;
    return e7 === this._allFeaturesPromise ? t5.slice() : this._getAllFeatures();
  }
  async _executeQuery(e7, t5, i5) {
    e7 = a(e7), e7 = await this._schedule(() => S3(e7, this.definitionExpression, this.spatialReference), i5), e7 = await this._reschedule(() => p4(e7, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), i5), e7 = { ...e7, ...t5 };
    const s6 = await this._reschedule(() => this._executeSceneFilterQuery(e7, i5), i5), a9 = await this._reschedule(() => this._executeGeometryQuery(e7, s6, i5), i5);
    return await this._reschedule(() => this._executeAggregateIdsQuery(a9), i5), await this._reschedule(() => this._executeObjectIdsQuery(a9), i5), await this._reschedule(() => this._executeTimeQuery(a9), i5), await this._reschedule(() => this._executeAttributesQuery(a9), i5), a9;
  }
  async _executeSceneFilterQuery(e7, t5) {
    if (null == e7.sceneFilter) return null;
    const { outSR: i5, returnGeometry: s6, returnCentroid: r6 } = e7, a9 = this.featureStore.featureSpatialReference, n6 = e7.sceneFilter.geometry, l7 = null == a9 || G(a9, n6.spatialReference) ? n6 : j(n6, a9);
    if (!l7) return null;
    const u6 = s6 || r6, o5 = N(i5) && !G(this.spatialReference, i5) && u6 ? async (e8) => this._project(e8, i5) : (e8) => e8, h4 = this.featureAdapter, c6 = await this._reschedule(() => this._searchFeatures(K(l7)), t5);
    if ("disjoint" === e7.sceneFilter.spatialRelationship) {
      if (!c6.length) return null;
      const i6 = /* @__PURE__ */ new Set();
      for (const e8 of c6) i6.add(h4.getObjectId(e8));
      const s7 = await this._reschedule(() => this._getAllFeatures(), t5), r7 = await this._reschedule(async () => {
        const r8 = await v4("esriSpatialRelDisjoint", l7, this.geometryType, this.hasZ, this.hasM), a10 = (e8) => !i6.has(h4.getObjectId(e8)) || r8(h4.getGeometry(e8)), n7 = await this._runSpatialFilter(s7, a10, t5);
        return new q(n7, e7, this);
      }, t5);
      return o5(r7);
    }
    if (!c6.length) return new q([], e7, this);
    if (this._canExecuteSinglePass(l7, e7)) return o5(new q(c6, e7, this));
    const m4 = await v4("esriSpatialRelContains", l7, this.geometryType, this.hasZ, this.hasM), f6 = await this._runSpatialFilter(c6, (e8) => m4(h4.getGeometry(e8)), t5);
    return o5(new q(f6, e7, this));
  }
  async _executeGeometryQuery(i5, s6, r6) {
    if (null != s6 && 0 === s6.items.length) return s6;
    i5 = null != s6 ? s6.query : i5;
    const { geometry: a9, outSR: n6, spatialRel: l7, returnGeometry: u6, returnCentroid: o5 } = i5, h4 = this.featureStore.featureSpatialReference, c6 = !a9 || null == h4 || G(h4, a9.spatialReference) ? a9 : j(a9, h4), m4 = u6 || o5, f6 = N(n6) && !G(this.spatialReference, n6), y7 = this._geometryQueryCache && null == s6 ? f6 && m4 ? JSON.stringify({ originalFilterGeometry: a9, spatialRelationship: l7, outSpatialReference: n6 }) : JSON.stringify({ originalFilterGeometry: a9, spatialRelationship: l7 }) : null, p6 = y7 ? this._geometryQueryCache.get(y7) : null;
    if (null != p6) return new q(p6, i5, this);
    const d5 = async (e7) => (f6 && m4 && await this._project(e7, n6), y7 && this._geometryQueryCache.put(y7, e7.items, e7.items.length + 1), e7);
    if (!c6) return d5(null != s6 ? s6 : await this._getAllFeaturesQueryEngineResult(i5));
    const g3 = this.featureAdapter;
    let x2 = await this._reschedule(() => this._searchFeatures(K(a9)), r6);
    if ("esriSpatialRelDisjoint" === l7) {
      if (!x2.length) return d5(null != s6 ? s6 : await this._getAllFeaturesQueryEngineResult(i5));
      const e7 = /* @__PURE__ */ new Set();
      for (const i6 of x2) e7.add(g3.getObjectId(i6));
      const t5 = null != s6 ? s6.items : await this._reschedule(() => this._getAllFeatures(), r6), a10 = await this._reschedule(async () => {
        const s7 = await v4(l7, c6, this.geometryType, this.hasZ, this.hasM), a11 = (t6) => !e7.has(g3.getObjectId(t6)) || s7(g3.getGeometry(t6)), n7 = await this._runSpatialFilter(t5, a11, r6);
        return new q(n7, i5, this);
      }, r6);
      return d5(a10);
    }
    if (null != s6) {
      const i6 = new v();
      x2 = x2.filter((t5) => y(s6.items, t5, s6.items.length, i6) >= 0);
    }
    if (!x2.length) {
      const e7 = new q([], i5, this);
      return y7 && this._geometryQueryCache.put(y7, e7.items, 1), e7;
    }
    if (this._canExecuteSinglePass(c6, i5)) return d5(new q(x2, i5, this));
    const _ = await v4(l7, c6, this.geometryType, this.hasZ, this.hasM), w2 = await this._runSpatialFilter(x2, (e7) => _(g3.getGeometry(e7)), r6);
    return d5(new q(w2, i5, this));
  }
  async _executeGeometryQueryForSnapping(e7, t5) {
    var _a;
    const { query: i5 } = e7, { spatialRel: s6 } = i5;
    if (!((_a = e7 == null ? void 0 : e7.items) == null ? void 0 : _a.length) || !i5.geometry || !s6) return;
    const r6 = await v4(s6, i5.geometry, this.geometryType, this.hasZ, this.hasM), a9 = await this._runSpatialFilter(e7.items, (e8) => r6(e8.geometry), t5);
    e7.items = a9;
  }
  _executeAggregateIdsQuery(e7) {
    var _a;
    if (0 === e7.items.length || !((_a = e7.query.aggregateIds) == null ? void 0 : _a.length) || null == this.aggregateAdapter) return;
    const t5 = /* @__PURE__ */ new Set();
    for (const s6 of e7.query.aggregateIds) {
      this.aggregateAdapter.getFeatureObjectIds(s6).forEach((e8) => t5.add(e8));
    }
    const i5 = this.featureAdapter.getObjectId;
    e7.items = e7.items.filter((e8) => t5.has(i5(e8)));
  }
  _executeObjectIdsQuery(e7) {
    var _a;
    if (0 === e7.items.length || !((_a = e7.query.objectIds) == null ? void 0 : _a.length)) return;
    const t5 = new Set(e7.query.objectIds), i5 = this.featureAdapter.getObjectId;
    e7.items = e7.items.filter((e8) => t5.has(i5(e8)));
  }
  _executeTimeQuery(e7) {
    if (0 === e7.items.length) return;
    const t5 = t2(this.timeInfo, e7.query.timeExtent, this.featureAdapter);
    null != t5 && (e7.items = e7.items.filter(t5));
  }
  _executeAttributesQuery(e7) {
    if (0 === e7.items.length) return;
    const t5 = c3(e7.query.where, this.fieldsIndex);
    if (t5) {
      if (!t5.isStandardized) throw new TypeError("Where clause is not standardized");
      e7.items = e7.items.filter((e8) => t5.testFeature(e8, this.featureAdapter));
    }
  }
  async _runSpatialFilter(e7, t5, i5) {
    if (!t5) return e7;
    if (null == this._frameTask) return e7.filter((e8) => t5(e8));
    let s6 = 0;
    const r6 = new Array(), a9 = async (n6) => {
      for (; s6 < e7.length; ) {
        const l7 = e7[s6++];
        t5(l7) && (r6.push(l7), n6.madeProgress()), n6.done && await this._reschedule((e8) => a9(e8), i5);
      }
    };
    return this._reschedule((e8) => a9(e8), i5).then(() => r6);
  }
  _filterLatest(e7) {
    const { trackIdField: t5, startTimeField: i5, endTimeField: s6 } = this.timeInfo, r6 = s6 || i5, a9 = /* @__PURE__ */ new Map(), n6 = this.featureAdapter.getAttribute;
    for (const l7 of e7.items) {
      const e8 = n6(l7, t5), i6 = n6(l7, r6), s7 = a9.get(e8);
      (!s7 || i6 > n6(s7, r6)) && a9.set(e8, l7);
    }
    e7.items = Array.from(a9.values());
  }
  _canExecuteSinglePass(e7, t5) {
    const { spatialRel: i5 } = t5;
    return I(e7) && ("esriSpatialRelEnvelopeIntersects" === i5 || "esriGeometryPoint" === this.geometryType && ("esriSpatialRelIntersects" === i5 || "esriSpatialRelContains" === i5));
  }
  async _project(e7, t5) {
    if (!t5 || G(this.spatialReference, t5)) return e7;
    const i5 = this.featureAdapter;
    let s6;
    try {
      const e8 = await this._getFullExtent();
      s6 = Y(this.spatialReference, t5, e8);
    } catch {
    }
    const r6 = await b(e7.items.map((e8) => a6(this.geometryType, this.hasZ, this.hasM, i5.getGeometry(e8))), this.spatialReference, t5, s6);
    return e7.items = r6.map((t6, s7) => i5.cloneWithGeometry(e7.items[s7], ot(t6, this.hasZ, this.hasM))), e7;
  }
  async _searchFeatures(e7) {
    const t5 = /* @__PURE__ */ new Set();
    await Promise.all(e7.map((e8) => this.featureStore.forEachInBounds(e8, (e9) => t5.add(e9))));
    const i5 = Array.from(t5.values());
    return t5.clear(), i5;
  }
  async _executeQueryForStatistics(e7, t5, i5) {
    e7 = a(e7);
    try {
      e7 = await this._schedule(() => S3(e7, this.definitionExpression, this.spatialReference), i5), e7 = await this._reschedule(() => m3(e7, t5, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), i5);
      const s6 = await this._reschedule(() => this._executeSceneFilterQuery(e7, i5), i5), r6 = await this._reschedule(() => this._executeGeometryQuery(e7, s6, i5), i5);
      return await this._reschedule(() => this._executeAggregateIdsQuery(r6), i5), await this._reschedule(() => this._executeObjectIdsQuery(r6), i5), await this._reschedule(() => this._executeTimeQuery(r6), i5), await this._reschedule(() => this._executeAttributesQuery(r6), i5), r6;
    } catch (s6) {
      if (s6 !== g) throw s6;
      return new q([], e7, this);
    }
  }
};
function K(e7) {
  if (I(e7)) {
    if (m(e7)) return [a4(Math.min(e7.xmin, e7.xmax), Math.min(e7.ymin, e7.ymax), Math.max(e7.xmin, e7.xmax), Math.max(e7.ymin, e7.ymax))];
    if (f(e7)) return e7.rings.map((e8) => a4(Math.min(e8[0][0], e8[2][0]), Math.min(e8[0][1], e8[2][1]), Math.max(e8[0][0], e8[2][0]), Math.max(e8[0][1], e8[2][1])));
  }
  return [a5(u3(), e7)];
}

// ../node_modules/@arcgis/core/layers/graphics/data/optimizedFeatureQueryEngineAdapter.js
var o4 = { getObjectId: (t5) => t5.objectId, getAttributes: (t5) => t5.attributes, getAttribute: (t5, e7) => t5.attributes[e7], cloneWithGeometry: (t5, r6) => new e3(r6, t5.attributes, null, t5.objectId), getGeometry: (t5) => t5.geometry, getCentroid: (e7, o5) => (null == e7.centroid && (e7.centroid = n3(new e2(), e7.geometry, o5.hasZ, o5.hasM)), e7.centroid) };

export {
  o4 as o,
  $2 as $
};
//# sourceMappingURL=chunk-VR7WVNO3.js.map
