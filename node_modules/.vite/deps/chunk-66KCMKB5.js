import {
  o
} from "./chunk-ZART2Y5J.js";
import {
  f as f2,
  r as r2
} from "./chunk-F4OBDVPS.js";
import {
  A,
  C,
  G,
  s,
  s3,
  w
} from "./chunk-X3IFQMC4.js";
import {
  s as s2
} from "./chunk-4ZEH5SNV.js";
import {
  f2 as f,
  y
} from "./chunk-TJUEGVVG.js";
import {
  a as a2,
  a3
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  a,
  n2 as n,
  r
} from "./chunk-YNL57W4I.js";

// ../node_modules/@arcgis/core/geometry/Geometry.js
var c = class extends f {
  constructor(...e4) {
    super(...e4), this.type = null, this.hasM = false, this.hasZ = false, this.spatialReference = f2.WGS84;
  }
  get cache() {
    return this.commitProperty("spatialReference"), {};
  }
  get extent() {
    return null;
  }
  readSpatialReference(e4, r4) {
    if (e4 instanceof f2) return e4;
    if (null != e4) {
      const t2 = new f2();
      return t2.read(e4, r4), t2;
    }
    return e4;
  }
  clone() {
    return console.warn(".clone() is not implemented for " + this.declaredClass), null;
  }
  clearCache() {
    this.notifyChange("cache");
  }
  getCacheValue(e4) {
    return this.cache[e4];
  }
  setCacheValue(e4, r4) {
    this.cache[e4] = r4;
  }
};
e([y()], c.prototype, "type", void 0), e([y({ readOnly: true })], c.prototype, "cache", null), e([y({ readOnly: true })], c.prototype, "extent", null), e([y({ type: Boolean, json: { write: { overridePolicy: (e4) => ({ enabled: e4 }) } } })], c.prototype, "hasM", void 0), e([y({ type: Boolean, json: { write: { overridePolicy: (e4) => ({ enabled: e4 }) } } })], c.prototype, "hasZ", void 0), e([y({ type: f2, json: { write: true }, value: f2.WGS84 })], c.prototype, "spatialReference", void 0), e([o("spatialReference")], c.prototype, "readSpatialReference", null), c = e([a3("esri.geometry.Geometry")], c);
var n2 = c;

// ../node_modules/@arcgis/core/geometry/support/webMercatorUtils.js
var a4 = 57.29577951308232;
var o2 = 0.017453292519943;
function u(n4) {
  return n4 * a4;
}
function l(n4) {
  return n4 * o2;
}
function f3(n4) {
  return Math.PI / 2 - 2 * Math.atan(Math.exp(-n4 / s.radius));
}
function c2(n4) {
  return null != n4.wkid || null != n4.wkt;
}
var h = [0, 0];
function m(n4, t2, e4, i4, r4) {
  const s6 = n4, a6 = r4;
  if (a6.spatialReference = e4, "x" in s6 && "x" in a6) [a6.x, a6.y] = t2(s6.x, s6.y, h, i4);
  else if ("xmin" in s6 && "xmin" in a6) [a6.xmin, a6.ymin] = t2(s6.xmin, s6.ymin, h, i4), [a6.xmax, a6.ymax] = t2(s6.xmax, s6.ymax, h, i4);
  else if ("paths" in s6 && "paths" in a6 || "rings" in s6 && "rings" in a6) {
    const n5 = "paths" in s6 ? s6.paths : s6.rings, e5 = [];
    let r5;
    for (let s7 = 0; s7 < n5.length; s7++) {
      const a7 = n5[s7];
      r5 = [], e5.push(r5);
      for (let n6 = 0; n6 < a7.length; n6++) r5.push(t2(a7[n6][0], a7[n6][1], [0, 0], i4)), a7[n6].length > 2 && r5[n6].push(a7[n6][2]), a7[n6].length > 3 && r5[n6].push(a7[n6][3]);
    }
    "paths" in a6 ? a6.paths = e5 : a6.rings = e5;
  } else if ("points" in s6 && "points" in a6) {
    const n5 = s6.points, e5 = [];
    for (let r5 = 0; r5 < n5.length; r5++) e5[r5] = t2(n5[r5][0], n5[r5][1], [0, 0], i4), n5[r5].length > 2 && e5[r5].push(n5[r5][2]), n5[r5].length > 3 && e5[r5].push(n5[r5][3]);
    a6.points = e5;
  }
  return r4;
}
function x(n4, t2) {
  const e4 = n4 && (c2(n4) ? n4 : n4.spatialReference), a6 = t2 && (c2(t2) ? t2 : t2.spatialReference);
  return !(n4 && "type" in n4 && "mesh" === n4.type || t2 && "type" in t2 && "mesh" === t2.type || !e4 || !a6) && (!!G(a6, e4) || (w(a6) && C(e4) || w(e4) && C(a6)));
}
function g(e4, a6) {
  if (null == e4) return null;
  const o6 = e4.spatialReference, u6 = a6 && (c2(a6) ? a6 : a6.spatialReference);
  return x(o6, u6) ? G(o6, u6) ? a(e4) : w(u6) ? m(e4, M, f2.WebMercator, false, a(e4)) : C(u6) ? m(e4, y2, f2.WGS84, false, a(e4)) : null : null;
}
function M(n4, t2, i4 = [0, 0]) {
  t2 > 89.99999 ? t2 = 89.99999 : t2 < -89.99999 && (t2 = -89.99999);
  const r4 = l(t2);
  return i4[0] = l(n4) * s.radius, i4[1] = s.halfSemiMajorAxis * Math.log((1 + Math.sin(r4)) / (1 - Math.sin(r4))), i4;
}
function y2(n4, t2, i4 = [0, 0], r4 = false) {
  const s6 = u(n4 / s.radius);
  return i4[0] = r4 ? s6 : s6 - 360 * Math.floor((s6 + 180) / 360), i4[1] = u(Math.PI / 2 - 2 * Math.atan(Math.exp(-t2 / s.radius))), i4;
}
function d(e4, i4 = false, r4 = a(e4)) {
  return m(e4, M, f2.WebMercator, i4, r4);
}
function R(e4, i4 = false, r4 = a(e4)) {
  return m(e4, y2, f2.WGS84, i4, r4);
}

// ../node_modules/@arcgis/core/geometry/support/pointUtils.js
function e2(n4, r4) {
  const t2 = n4.x - r4.x, e4 = n4.y - r4.y, u6 = null != n4.z && null != r4.z ? n4.z - r4.z : 0;
  return Math.sqrt(t2 * t2 + e4 * e4 + u6 * u6);
}
function u2(n4) {
  var _a;
  return ((_a = i(n4, o3)) == null ? void 0 : _a[0]) ?? null;
}
function l2(n4) {
  var _a;
  return ((_a = i(n4, o3)) == null ? void 0 : _a[1]) ?? null;
}
function i({ x: e4, y: u6, spatialReference: l4 }, i4 = [0, 0]) {
  if (l4) {
    if (w(l4)) return y2(e4, u6, i4);
    if (A(l4)) return i4[0] = e4, i4[1] = u6, i4;
  }
  return null;
}
var o3 = [0, 0];

// ../node_modules/@arcgis/core/geometry/Point.js
var f4;
var g2 = [0, 0];
function w2(t2) {
  return t2 && ("esri.geometry.SpatialReference" === t2.declaredClass || null != t2.wkid);
}
var x2 = f4 = class extends n2 {
  static copy(t2, e4) {
    e4._set("x", t2._get("x")), e4._set("y", t2._get("y")), e4._set("z", t2._get("z")), e4._set("m", t2._get("m"));
    const r4 = t2._get("spatialReference");
    e4._set("spatialReference", Object.isFrozen(r4) ? r4 : r4.clone());
  }
  constructor(...t2) {
    super(...t2), this.x = 0, this.y = 0, this.z = void 0, this.m = void 0, this.type = "point";
  }
  normalizeCtorArgs(t2, r4, s6, i4, o6) {
    let l4;
    if (Array.isArray(t2)) l4 = t2, o6 = r4, t2 = l4[0], r4 = l4[1], s6 = l4[2], i4 = l4[3];
    else if (t2 && "object" == typeof t2) {
      if (l4 = t2, t2 = null != l4.x ? l4.x : l4.longitude, r4 = null != l4.y ? l4.y : l4.latitude, s6 = l4.z, i4 = l4.m, (o6 = l4.spatialReference) && "esri.geometry.SpatialReference" !== o6.declaredClass && (o6 = new f2(o6)), null != l4.longitude || null != l4.latitude) {
        if (null == l4.longitude) n.getLogger(this).warn(".longitude=", "Latitude was defined without longitude");
        else if (null == l4.latitude) n.getLogger(this).warn(".latitude=", "Longitude was defined without latitude");
        else if (!l4.declaredClass && (o6 == null ? void 0 : o6.isWebMercator)) {
          const e4 = M(l4.longitude, l4.latitude, g2);
          t2 = e4[0], r4 = e4[1];
        }
      }
    } else w2(s6) ? (o6 = s6, s6 = null) : w2(i4) && (o6 = i4, i4 = null);
    const a6 = { x: t2, y: r4 };
    return null == a6.x && null != a6.y ? n.getLogger(this).warn(".y=", "Y coordinate was defined without an X coordinate") : null == a6.y && null != a6.x && n.getLogger(this).warn(".x=", "X coordinate was defined without a Y coordinate"), null != o6 && (a6.spatialReference = o6), null != s6 && (a6.z = s6), null != i4 && (a6.m = i4), a6;
  }
  get cache() {
    return this.commitProperty("x"), this.commitProperty("y"), this.commitProperty("z"), this.commitProperty("m"), this.commitProperty("spatialReference"), {};
  }
  get hasM() {
    return void 0 !== this.m;
  }
  set hasM(t2) {
    t2 !== (void 0 !== this._get("m")) && (this._set("m", t2 ? 0 : void 0), this._set("hasM", t2));
  }
  get hasZ() {
    return void 0 !== this.z;
  }
  set hasZ(t2) {
    t2 !== (void 0 !== this._get("z")) && (this._set("z", t2 ? 0 : void 0), this._set("hasZ", t2));
  }
  get latitude() {
    return l2(this);
  }
  set latitude(t2) {
    const { spatialReference: e4, x: r4 } = this;
    null != t2 && e4 && (e4.isWebMercator ? this._set("y", M(r4, t2, g2)[1]) : e4.isGeographic && this._set("y", t2), this._set("latitude", t2));
  }
  get longitude() {
    return u2(this);
  }
  set longitude(t2) {
    const { y: e4, spatialReference: r4 } = this;
    null != t2 && r4 && (r4.isWebMercator ? this._set("x", M(t2, e4, g2)[0]) : r4.isGeographic && this._set("x", t2), this._set("longitude", t2));
  }
  writeX(t2, e4, r4) {
    e4[r4] = isNaN(t2) ? "NaN" : t2;
  }
  readX(t2) {
    return "string" == typeof t2 ? NaN : t2;
  }
  clone() {
    const t2 = new f4();
    return t2.x = this.x, t2.y = this.y, t2.z = this.z, t2.m = this.m, t2.spatialReference = this.spatialReference, t2;
  }
  copy(t2) {
    return f4.copy(t2, this), this;
  }
  equals(t2) {
    if (null == t2) return false;
    const { x: e4, y: r4, z: s6, m: i4, spatialReference: o6 } = this, { z: l4, m: a6 } = t2;
    let { x: n4, y: u6, spatialReference: p2 } = t2;
    if (!o6.equals(p2)) if (o6.isWebMercator && p2.isWGS84) [n4, u6] = M(n4, u6), p2 = o6;
    else {
      if (!o6.isWGS84 || !p2.isWebMercator) return false;
      [n4, u6] = y2(n4, u6), p2 = o6;
    }
    return e4 === n4 && r4 === u6 && s6 === l4 && i4 === a6 && o6.wkid === p2.wkid;
  }
  offset(t2, e4, r4) {
    return this.x += t2, this.y += e4, null != r4 && (this.z = (this.z ?? 0) + r4), this;
  }
  normalize() {
    if (!this.spatialReference) return this;
    const t2 = s3(this.spatialReference);
    if (!t2) return this;
    let e4 = this.x;
    const [r4, s6] = t2.valid, i4 = 2 * s6;
    let o6;
    return e4 > s6 ? (o6 = Math.ceil(Math.abs(e4 - s6) / i4), e4 -= o6 * i4) : e4 < r4 && (o6 = Math.ceil(Math.abs(e4 - r4) / i4), e4 += o6 * i4), this._set("x", e4), this;
  }
  distance(t2) {
    return e2(this, t2);
  }
  toArray() {
    const t2 = this.hasZ, e4 = this.hasM;
    return t2 && e4 ? [this.x, this.y, this.z, this.m] : t2 ? [this.x, this.y, this.z] : e4 ? [this.x, this.y, this.m] : [this.x, this.y];
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
};
e([y({ readOnly: true })], x2.prototype, "cache", null), e([y({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], x2.prototype, "hasM", null), e([y({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], x2.prototype, "hasZ", null), e([y({ type: Number })], x2.prototype, "latitude", null), e([y({ type: Number })], x2.prototype, "longitude", null), e([y({ type: Number, json: { type: [Number, String], write: { isRequired: true, allowNull: true } } }), s2((t2) => isNaN(t2) ? t2 : a2(t2))], x2.prototype, "x", void 0), e([r2("x")], x2.prototype, "writeX", null), e([o("x")], x2.prototype, "readX", null), e([y({ type: Number, json: { write: true } })], x2.prototype, "y", void 0), e([y({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], x2.prototype, "z", void 0), e([y({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], x2.prototype, "m", void 0), x2 = f4 = e([a3("esri.geometry.Point")], x2), x2.prototype.toJSON.isDefaultToJSON = true;
var _ = x2;

// ../node_modules/@arcgis/core/geometry/support/contains.js
var n3 = [0, 0];
function t(n4, t2) {
  return null != t2 && e3(n4, t2.x, t2.y, t2.z);
}
function r3(n4, t2) {
  if (!t2.points || t2.points.length) return false;
  for (const r4 of t2.points) if (!i2(n4, r4)) return false;
  return true;
}
function u3(n4, t2) {
  const { xmin: r4, ymin: u6, zmin: i4, xmax: o6, ymax: f8, zmax: c5 } = t2;
  return n4.hasZ && t2.hasZ ? e3(n4, r4, u6, i4) && e3(n4, r4, f8, i4) && e3(n4, o6, f8, i4) && e3(n4, o6, u6, i4) && e3(n4, r4, u6, c5) && e3(n4, r4, f8, c5) && e3(n4, o6, f8, c5) && e3(n4, o6, u6, c5) : e3(n4, r4, u6) && e3(n4, r4, f8) && e3(n4, o6, f8) && e3(n4, o6, u6);
}
function i2(n4, t2) {
  return e3(n4, t2[0], t2[1]);
}
function o4(n4, t2) {
  return e3(n4, t2[0], t2[1], t2[2]);
}
function e3(n4, t2, r4, u6) {
  return t2 >= n4.xmin && t2 <= n4.xmax && r4 >= n4.ymin && r4 <= n4.ymax && (null == u6 || !n4.hasZ || u6 >= n4.zmin && u6 <= n4.zmax);
}
function f5(t2, r4) {
  return n3[1] = r4.y, n3[0] = r4.x, c3(t2, n3);
}
function c3(n4, t2) {
  return s4(n4.rings, t2);
}
function s4(n4, t2) {
  if (!n4) return false;
  if (x3(n4)) return m2(false, n4, t2);
  let r4 = false;
  for (let u6 = 0, i4 = n4.length; u6 < i4; u6++) r4 = m2(r4, n4[u6], t2);
  return r4;
}
function x3(n4) {
  return !Array.isArray(n4[0][0]);
}
function m2(n4, t2, r4) {
  const [u6, i4] = r4;
  let o6 = n4, e4 = 0;
  for (let f8 = 0, c5 = t2.length; f8 < c5; f8++) {
    e4++, e4 === c5 && (e4 = 0);
    const [n5, r5] = t2[f8], [s6, x5] = t2[e4];
    (r5 < i4 && x5 >= i4 || x5 < i4 && r5 >= i4) && n5 + (i4 - r5) / (x5 - r5) * (s6 - n5) < u6 && (o6 = !o6);
  }
  return o6;
}

// ../node_modules/@arcgis/core/geometry/support/intersectsBase.js
function i3(t2, e4) {
  return t(t2, e4);
}
function o5(n4, t2) {
  const e4 = n4.hasZ && t2.hasZ;
  let r4, i4, o6;
  if (n4.xmin <= t2.xmin) {
    if (r4 = t2.xmin, n4.xmax < r4) return false;
  } else if (r4 = n4.xmin, t2.xmax < r4) return false;
  if (n4.ymin <= t2.ymin) {
    if (i4 = t2.ymin, n4.ymax < i4) return false;
  } else if (i4 = n4.ymin, t2.ymax < i4) return false;
  if (e4 && t2.hasZ) {
    if (n4.zmin <= t2.zmin) {
      if (o6 = t2.zmin, n4.zmax < o6) return false;
    } else if (o6 = n4.zmin, t2.zmax < o6) return false;
  }
  return true;
}
function f6(n4, t2) {
  const { points: i4, hasZ: o6 } = t2, f8 = o6 ? o4 : i2;
  for (const e4 of i4) if (f8(n4, e4)) return true;
  return false;
}
var s5 = [0, 0];
var u4 = [0, 0];
var c4 = [0, 0];
var m3 = [0, 0];
var l3 = [s5, u4, c4, m3];
var a5 = [[c4, s5], [s5, u4], [u4, m3], [m3, c4]];
function x4(n4, t2) {
  return y3(n4, t2.rings);
}
function y3(n4, r4) {
  s5[0] = n4.xmin, s5[1] = n4.ymax, u4[0] = n4.xmax, u4[1] = n4.ymax, c4[0] = n4.xmin, c4[1] = n4.ymin, m3[0] = n4.xmax, m3[1] = n4.ymin;
  for (const e4 of l3) if (s4(r4, e4)) return true;
  for (const t2 of r4) {
    if (!t2.length) continue;
    let r5 = t2[0];
    if (i2(n4, r5)) return true;
    for (let i4 = 1; i4 < t2.length; i4++) {
      const o6 = t2[i4];
      if (i2(n4, o6) || z(r5, o6, a5)) return true;
      r5 = o6;
    }
  }
  return false;
}
function h2(n4, t2) {
  s5[0] = n4.xmin, s5[1] = n4.ymax, u4[0] = n4.xmax, u4[1] = n4.ymax, c4[0] = n4.xmin, c4[1] = n4.ymin, m3[0] = n4.xmax, m3[1] = n4.ymin;
  const r4 = t2.paths;
  for (const i4 of r4) {
    if (!r4.length) continue;
    let t3 = i4[0];
    if (i2(n4, t3)) return true;
    for (let r5 = 1; r5 < i4.length; r5++) {
      const o6 = i4[r5];
      if (i2(n4, o6) || z(t3, o6, a5)) return true;
      t3 = o6;
    }
  }
  return false;
}
var g3 = [0, 0];
function p(n4) {
  for (let t2 = 0; t2 < n4.length; t2++) {
    const e4 = n4[t2];
    for (let i4 = 0; i4 < e4.length - 1; i4++) {
      const r5 = e4[i4], o6 = e4[i4 + 1];
      for (let e5 = t2 + 1; e5 < n4.length; e5++) for (let t3 = 0; t3 < n4[e5].length - 1; t3++) {
        const i5 = n4[e5][t3], f8 = n4[e5][t3 + 1];
        if (G2(r5, o6, i5, f8, g3) && !(g3[0] === r5[0] && g3[1] === r5[1] || g3[0] === i5[0] && g3[1] === i5[1] || g3[0] === o6[0] && g3[1] === o6[1] || g3[0] === f8[0] && g3[1] === f8[1])) return true;
      }
    }
    const r4 = e4.length;
    if (!(r4 <= 4)) for (let n5 = 0; n5 < r4 - 3; n5++) {
      let t3 = r4 - 1;
      0 === n5 && (t3 = r4 - 2);
      const i4 = e4[n5], o6 = e4[n5 + 1];
      for (let r5 = n5 + 2; r5 < t3; r5++) {
        const n6 = e4[r5], t4 = e4[r5 + 1];
        if (G2(i4, o6, n6, t4, g3) && !(g3[0] === i4[0] && g3[1] === i4[1] || g3[0] === n6[0] && g3[1] === n6[1] || g3[0] === o6[0] && g3[1] === o6[1] || g3[0] === t4[0] && g3[1] === t4[1])) return true;
      }
    }
  }
  return false;
}
function z(n4, t2, e4) {
  for (let r4 = 0; r4 < e4.length; r4++) if (G2(n4, t2, e4[r4][0], e4[r4][1])) return true;
  return false;
}
function G2(n4, t2, e4, r4, i4) {
  const [o6, f8] = n4, [s6, u6] = t2, [c5, m4] = e4, [l4, a6] = r4, x5 = l4 - c5, y4 = o6 - c5, h3 = s6 - o6, g4 = a6 - m4, p2 = f8 - m4, z3 = u6 - f8, G3 = g4 * h3 - x5 * z3;
  if (0 === G3) return false;
  const Z2 = (x5 * p2 - g4 * y4) / G3, P = (h3 * p2 - z3 * y4) / G3;
  return Z2 >= 0 && Z2 <= 1 && P >= 0 && P <= 1 && (i4 && (i4[0] = o6 + Z2 * (s6 - o6), i4[1] = f8 + Z2 * (u6 - f8)), true);
}
function Z(n4) {
  switch (n4) {
    case "esriGeometryEnvelope":
    case "extent":
      return o5;
    case "esriGeometryMultipoint":
    case "multipoint":
      return f6;
    case "esriGeometryPoint":
    case "point":
      return i3;
    case "esriGeometryPolygon":
    case "polygon":
      return x4;
    case "esriGeometryPolyline":
    case "polyline":
      return h2;
  }
}

// ../node_modules/@arcgis/core/geometry/Extent.js
var u5;
function f7(t2) {
  return t2 && ("esri.geometry.SpatialReference" === t2.declaredClass || null != t2.wkid);
}
function d2(t2, i4, e4) {
  return null == i4 ? e4 : null == e4 ? i4 : t2(i4, e4);
}
var z2 = u5 = class extends n2 {
  constructor(...t2) {
    super(...t2), this.type = "extent", this.xmin = 0, this.ymin = 0, this.mmin = void 0, this.zmin = void 0, this.xmax = 0, this.ymax = 0, this.mmax = void 0, this.zmax = void 0;
  }
  normalizeCtorArgs(t2, i4, e4, s6, n4) {
    return f7(t2) ? { spatialReference: t2, xmin: 0, ymin: 0, xmax: 0, ymax: 0 } : "object" == typeof t2 ? (t2.spatialReference = null == t2.spatialReference ? f2.WGS84 : t2.spatialReference, t2) : { xmin: t2, ymin: i4, xmax: e4, ymax: s6, spatialReference: n4 ?? f2.WGS84 };
  }
  static fromBounds(t2, i4) {
    return new u5({ xmin: t2[0], ymin: t2[1], xmax: t2[2], ymax: t2[3], spatialReference: i4 });
  }
  static fromPoint(t2) {
    return new u5({ xmin: t2.x, ymin: t2.y, zmin: t2.z, xmax: t2.x, ymax: t2.y, zmax: t2.z, spatialReference: t2.spatialReference });
  }
  get cache() {
    return this.commitProperty("xmin"), this.commitProperty("ymin"), this.commitProperty("zmin"), this.commitProperty("mmin"), this.commitProperty("xmax"), this.commitProperty("ymax"), this.commitProperty("zmax"), this.commitProperty("mmax"), this.commitProperty("spatialReference"), {};
  }
  get center() {
    const t2 = new _({ x: 0.5 * (this.xmin + this.xmax), y: 0.5 * (this.ymin + this.ymax), spatialReference: this.spatialReference });
    return this.hasZ && (t2.z = 0.5 * (this.zmin + this.zmax)), this.hasM && (t2.m = 0.5 * (this.mmin + this.mmax)), t2;
  }
  get extent() {
    return this.clone();
  }
  get hasM() {
    return null != this.mmin && null != this.mmax;
  }
  get hasZ() {
    return null != this.zmin && null != this.zmax;
  }
  get height() {
    return Math.abs(this.ymax - this.ymin);
  }
  get width() {
    return Math.abs(this.xmax - this.xmin);
  }
  centerAt(t2) {
    const i4 = this.center;
    return null != t2.z && this.hasZ ? this.offset(t2.x - i4.x, t2.y - i4.y, t2.z - i4.z) : this.offset(t2.x - i4.x, t2.y - i4.y);
  }
  clone() {
    const t2 = new u5();
    return t2.xmin = this.xmin, t2.ymin = this.ymin, t2.xmax = this.xmax, t2.ymax = this.ymax, t2.spatialReference = this.spatialReference, null != this.zmin && (t2.zmin = this.zmin, t2.zmax = this.zmax), null != this.mmin && (t2.mmin = this.mmin, t2.mmax = this.mmax), t2;
  }
  contains(t2) {
    if (!t2) return false;
    const i4 = this.spatialReference, e4 = t2.spatialReference;
    return i4 && e4 && !i4.equals(e4) && x(i4, e4) && (t2 = i4.isWebMercator ? d(t2) : R(t2, true)), "point" === t2.type ? t(this, t2) : "extent" === t2.type && u3(this, t2);
  }
  equals(t2) {
    if (this === t2) return true;
    if (null == t2) return false;
    const i4 = this.spatialReference, e4 = t2.spatialReference;
    return i4 && e4 && !i4.equals(e4) && x(i4, e4) && (t2 = i4.isWebMercator ? d(t2) : R(t2, true)), this.xmin === t2.xmin && this.ymin === t2.ymin && this.zmin === t2.zmin && this.mmin === t2.mmin && this.xmax === t2.xmax && this.ymax === t2.ymax && this.zmax === t2.zmax && this.mmax === t2.mmax;
  }
  expand(t2) {
    const i4 = 0.5 * (1 - t2), e4 = this.width * i4, s6 = this.height * i4;
    if (this.xmin += e4, this.ymin += s6, this.xmax -= e4, this.ymax -= s6, this.hasZ) {
      const t3 = (this.zmax - this.zmin) * i4;
      this.zmin += t3, this.zmax -= t3;
    }
    if (this.hasM) {
      const t3 = (this.mmax - this.mmin) * i4;
      this.mmin += t3, this.mmax -= t3;
    }
    return this;
  }
  intersects(t2) {
    if (null == t2) return false;
    "mesh" === t2.type && (t2 = t2.extent);
    const i4 = this.spatialReference, e4 = t2.spatialReference;
    i4 && e4 && !G(i4, e4) && x(i4, e4) && (t2 = i4.isWebMercator ? d(t2) : R(t2, true));
    return Z(t2.type)(this, t2);
  }
  normalize() {
    const t2 = this._normalize(false, true);
    return Array.isArray(t2) ? t2 : [t2];
  }
  offset(t2, i4, e4) {
    return this.xmin += t2, this.ymin += i4, this.xmax += t2, this.ymax += i4, null != e4 && (this.zmin += e4, this.zmax += e4), this;
  }
  shiftCentralMeridian() {
    return this._normalize(true);
  }
  union(t2) {
    return this === t2 || (this.xmin = Math.min(this.xmin, t2.xmin), this.ymin = Math.min(this.ymin, t2.ymin), this.xmax = Math.max(this.xmax, t2.xmax), this.ymax = Math.max(this.ymax, t2.ymax), (this.hasZ || t2.hasZ) && (this.zmin = d2(Math.min, this.zmin, t2.zmin), this.zmax = d2(Math.max, this.zmax, t2.zmax)), (this.hasM || t2.hasM) && (this.mmin = d2(Math.min, this.mmin, t2.mmin), this.mmax = d2(Math.max, this.mmax, t2.mmax))), this;
  }
  intersection(t2) {
    return this === t2 ? this : null != t2 && this.intersects(t2) ? (this.xmin = Math.max(this.xmin, t2.xmin), this.ymin = Math.max(this.ymin, t2.ymin), this.xmax = Math.min(this.xmax, t2.xmax), this.ymax = Math.min(this.ymax, t2.ymax), (this.hasZ || t2.hasZ) && (this.zmin = d2(Math.max, this.zmin, t2.zmin), this.zmax = d2(Math.min, this.zmax, t2.zmax)), (this.hasM || t2.hasM) && (this.mmin = d2(Math.max, this.mmin, t2.mmin), this.mmax = d2(Math.min, this.mmax, t2.mmax)), this) : null;
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
  _shiftCM(t2 = s3(this.spatialReference)) {
    if (!t2 || !this.spatialReference) return this;
    const e4 = this.spatialReference, s6 = this._getCM(t2);
    if (s6) {
      const n4 = e4.isWebMercator ? R(s6) : s6;
      this.xmin -= s6.x, this.xmax -= s6.x, e4.isWebMercator || (n4.x = M2(n4.x, t2).x), this.spatialReference = new f2(r((e4.isWGS84 ? t2.altTemplate : null) ?? t2.wkTemplate, { Central_Meridian: n4.x }));
    }
    return this;
  }
  _getCM(t2) {
    let i4 = null;
    const [e4, s6] = t2.valid, n4 = this.xmin, m4 = this.xmax;
    return n4 >= e4 && n4 <= s6 && (m4 >= e4 && m4 <= s6) || (i4 = this.center), i4;
  }
  _normalize(t2, i4, e4) {
    const s6 = this.spatialReference;
    if (!s6) return this;
    const n4 = e4 ?? s3(s6);
    if (null == n4) return this;
    const m4 = this._getParts(n4).map((t3) => t3.extent);
    if (m4.length < 2) return m4[0] || this;
    if (m4.length > 2) return t2 ? this._shiftCM(n4) : this.set({ xmin: n4.valid[0], xmax: n4.valid[1] });
    if (t2) return this._shiftCM(n4);
    if (i4) return m4;
    let r4 = true, a6 = true;
    return m4.forEach((t3) => {
      t3.hasZ || (r4 = false), t3.hasM || (a6 = false);
    }), { rings: m4.map((t3) => {
      const i5 = [[t3.xmin, t3.ymin], [t3.xmin, t3.ymax], [t3.xmax, t3.ymax], [t3.xmax, t3.ymin], [t3.xmin, t3.ymin]];
      if (r4) {
        const e5 = (t3.zmax - t3.zmin) / 2;
        for (let t4 = 0; t4 < i5.length; t4++) i5[t4].push(e5);
      }
      if (a6) {
        const e5 = (t3.mmax - t3.mmin) / 2;
        for (let t4 = 0; t4 < i5.length; t4++) i5[t4].push(e5);
      }
      return i5;
    }), hasZ: r4, hasM: a6, spatialReference: s6 };
  }
  _getParts(t2) {
    let i4 = this.cache._parts;
    if (!i4) {
      i4 = [];
      const { ymin: e5, ymax: s7, spatialReference: n4 } = this, m4 = this.width, r4 = this.xmin, a6 = this.xmax;
      let h3;
      t2 = t2 || s3(n4);
      const [o6, x5] = t2.valid;
      h3 = M2(this.xmin, t2);
      const c5 = h3.x, p2 = h3.frameId;
      h3 = M2(this.xmax, t2);
      const y4 = h3.x, f8 = h3.frameId, d3 = c5 === y4 && m4 > 0;
      if (m4 > 2 * x5) {
        const t3 = new u5(r4 < a6 ? c5 : y4, e5, x5, s7, n4), m5 = new u5(o6, e5, r4 < a6 ? y4 : c5, s7, n4), h4 = new u5(0, e5, x5, s7, n4), l4 = new u5(o6, e5, 0, s7, n4), d4 = [], z3 = [];
        t3.contains(h4) && d4.push(p2), t3.contains(l4) && z3.push(p2), m5.contains(h4) && d4.push(f8), m5.contains(l4) && z3.push(f8);
        for (let i5 = p2 + 1; i5 < f8; i5++) d4.push(i5), z3.push(i5);
        i4.push({ extent: t3, frameIds: [p2] }, { extent: m5, frameIds: [f8] }, { extent: h4, frameIds: d4 }, { extent: l4, frameIds: z3 });
      } else c5 > y4 || d3 ? i4.push({ extent: new u5(c5, e5, x5, s7, n4), frameIds: [p2] }, { extent: new u5(o6, e5, y4, s7, n4), frameIds: [f8] }) : i4.push({ extent: new u5(c5, e5, y4, s7, n4), frameIds: [p2] });
      this.cache._parts = i4;
    }
    const e4 = this.hasZ, s6 = this.hasM;
    if (e4 || s6) {
      const t3 = {};
      e4 && (t3.zmin = this.zmin, t3.zmax = this.zmax), s6 && (t3.mmin = this.mmin, t3.mmax = this.mmax);
      for (let e5 = 0; e5 < i4.length; e5++) i4[e5].extent.set(t3);
    }
    return i4;
  }
};
function M2(t2, i4) {
  const [e4, s6] = i4.valid, n4 = 2 * s6;
  let m4, r4 = 0;
  return t2 > s6 ? (m4 = Math.ceil(Math.abs(t2 - s6) / n4), t2 -= m4 * n4, r4 = m4) : t2 < e4 && (m4 = Math.ceil(Math.abs(t2 - e4) / n4), t2 += m4 * n4, r4 = -m4), { x: t2, frameId: r4 };
}
e([y({ readOnly: true })], z2.prototype, "cache", null), e([y({ readOnly: true })], z2.prototype, "center", null), e([y({ readOnly: true })], z2.prototype, "extent", null), e([y({ readOnly: true, json: { write: { enabled: false, overridePolicy: null } } })], z2.prototype, "hasM", null), e([y({ readOnly: true, json: { write: { enabled: false, overridePolicy: null } } })], z2.prototype, "hasZ", null), e([y({ readOnly: true })], z2.prototype, "height", null), e([y({ readOnly: true })], z2.prototype, "width", null), e([y({ type: Number, json: { type: [Number, String], write: { enabled: true, allowNull: true } } })], z2.prototype, "xmin", void 0), e([y({ type: Number, json: { write: true } })], z2.prototype, "ymin", void 0), e([y({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], z2.prototype, "mmin", void 0), e([y({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], z2.prototype, "zmin", void 0), e([y({ type: Number, json: { write: true } })], z2.prototype, "xmax", void 0), e([y({ type: Number, json: { write: true } })], z2.prototype, "ymax", void 0), e([y({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], z2.prototype, "mmax", void 0), e([y({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], z2.prototype, "zmax", void 0), z2 = u5 = e([a3("esri.geometry.Extent")], z2), z2.prototype.toJSON.isDefaultToJSON = true;
var w3 = z2;

export {
  n2 as n,
  f3 as f,
  x,
  g,
  M,
  y2 as y,
  d,
  R,
  e2 as e,
  _,
  t,
  r3 as r,
  f5 as f2,
  s4 as s,
  o5 as o,
  x4 as x2,
  p,
  G2 as G,
  Z,
  w3 as w
};
//# sourceMappingURL=chunk-66KCMKB5.js.map
