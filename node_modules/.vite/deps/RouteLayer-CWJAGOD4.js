import {
  C,
  D as D2,
  M,
  P,
  R as R2,
  S as S4,
  T,
  U as U2,
  a as a2,
  b as b3,
  c,
  c2,
  c3,
  j as j3,
  j2 as j4,
  l as l2,
  m as m2,
  n as n4,
  o as o5,
  o2 as o6,
  q,
  r as r2,
  w as w2,
  w2 as w3,
  y as y5
} from "./chunk-XCWKIMEO.js";
import {
  i as i2
} from "./chunk-LAB5SETU.js";
import "./chunk-7W2VQZZM.js";
import {
  R
} from "./chunk-P3MZKJDB.js";
import "./chunk-JWA73VK6.js";
import {
  o as o4
} from "./chunk-S7J6OTBX.js";
import "./chunk-GMJ4G37M.js";
import "./chunk-LNOEFEG3.js";
import "./chunk-WF67GKPJ.js";
import "./chunk-4HOM27T6.js";
import "./chunk-FO4JQZA5.js";
import "./chunk-XEELLOJE.js";
import {
  d as d2
} from "./chunk-647CGSDX.js";
import "./chunk-2FW7ECQ2.js";
import "./chunk-LGQJAMGK.js";
import "./chunk-D6KE2FST.js";
import "./chunk-W3XB5XWO.js";
import "./chunk-6QBE4YDH.js";
import "./chunk-LXDJBJSP.js";
import "./chunk-OPCT64AO.js";
import {
  j as j2
} from "./chunk-5LNCGIUN.js";
import {
  l
} from "./chunk-VEAHCP5W.js";
import "./chunk-WO4V65CJ.js";
import "./chunk-QUNQAVSE.js";
import {
  t as t2
} from "./chunk-HNXXFTFZ.js";
import {
  b as b2
} from "./chunk-KVPS4KFB.js";
import "./chunk-NSXZC33R.js";
import {
  S as S2
} from "./chunk-E7HFITKU.js";
import "./chunk-ZFQCSBZ4.js";
import "./chunk-4PAHN45R.js";
import "./chunk-CRUGTXEH.js";
import "./chunk-CPGVDDHW.js";
import "./chunk-VEOZVJAT.js";
import "./chunk-3D32E2TW.js";
import "./chunk-ACWF4COQ.js";
import "./chunk-P35RWHDU.js";
import "./chunk-G5U2OA3R.js";
import "./chunk-OIFKYPGO.js";
import "./chunk-JNGB7HKP.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import {
  f as f3
} from "./chunk-7TO4QD67.js";
import "./chunk-DZNQTDMC.js";
import "./chunk-URNMKNS6.js";
import {
  f as f5,
  i as i3
} from "./chunk-3QWMYL5A.js";
import "./chunk-TXIL3QUC.js";
import "./chunk-2ASAB4KA.js";
import {
  f as f4
} from "./chunk-EA74CF7B.js";
import "./chunk-IGNUVZ34.js";
import "./chunk-LTSQHA4C.js";
import "./chunk-YUQFVZCH.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-T4EIRKFE.js";
import {
  y as y3
} from "./chunk-OHUWK5XV.js";
import "./chunk-PHVKM5OH.js";
import {
  S
} from "./chunk-KQ5GHUVQ.js";
import {
  K,
  N
} from "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-JQIB7GFW.js";
import {
  d as d3
} from "./chunk-CJJCN7PA.js";
import {
  k as k2
} from "./chunk-IJUFAIOF.js";
import "./chunk-MNMU4ARP.js";
import {
  D,
  L,
  k2 as k
} from "./chunk-7OW2VNCC.js";
import "./chunk-AFBYZF6Q.js";
import {
  S as S3,
  d,
  y as y4
} from "./chunk-IJ42YN7D.js";
import "./chunk-4AGGGL2W.js";
import {
  i
} from "./chunk-FJPG3YI6.js";
import "./chunk-BJHLU2MM.js";
import "./chunk-E5KBRIJQ.js";
import {
  o as o3
} from "./chunk-Z32PAECZ.js";
import "./chunk-TW7VY7XV.js";
import "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import "./chunk-BL2UGYYZ.js";
import {
  n as n3
} from "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import {
  y as y2
} from "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import {
  C as C2
} from "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import {
  v
} from "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import {
  V
} from "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import {
  m,
  u
} from "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import {
  _,
  w
} from "./chunk-66KCMKB5.js";
import {
  o as o2
} from "./chunk-ZART2Y5J.js";
import {
  f as f2,
  r
} from "./chunk-F4OBDVPS.js";
import {
  g as g2,
  j
} from "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import {
  n as n2
} from "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import {
  I,
  U,
  qt
} from "./chunk-WC4SPMPL.js";
import {
  f2 as f,
  o,
  y
} from "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import {
  a3 as a,
  g
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  b
} from "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  e as e2,
  n2 as n,
  s,
  s2,
  t
} from "./chunk-YNL57W4I.js";
import {
  O
} from "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p = class extends f {
  constructor(o7) {
    super(o7), this.break = new y4({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new y4({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new y4({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new y4({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new y4({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new y4({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
e([y({ types: D })], p.prototype, "break", void 0), e([y({ types: D })], p.prototype, "first", void 0), e([y({ types: D })], p.prototype, "unlocated", void 0), e([y({ types: D })], p.prototype, "last", void 0), e([y({ types: D })], p.prototype, "middle", void 0), e([y({ types: D })], p.prototype, "waypoint", void 0), p = e([a("esri.layers.support.RouteStopSymbols")], p);
var l3 = p;

// ../node_modules/@arcgis/core/layers/support/RouteSymbols.js
var y6 = class extends f {
  constructor(o7) {
    super(o7), this.directionLines = new d({ color: [0, 122, 194], width: 6 }), this.directionPoints = new y4({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new y4({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new S3({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new d({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new d({ width: 8, color: [20, 89, 127] }), this.stops = new l3();
  }
};
e([y({ types: L })], y6.prototype, "directionLines", void 0), e([y({ types: D })], y6.prototype, "directionPoints", void 0), e([y({ types: D })], y6.prototype, "pointBarriers", void 0), e([y({ types: k })], y6.prototype, "polygonBarriers", void 0), e([y({ types: L })], y6.prototype, "polylineBarriers", void 0), e([y({ types: L })], y6.prototype, "routeInfo", void 0), e([y({ type: l3 })], y6.prototype, "stops", void 0), y6 = e([a("esri.layers.support.RouteSymbols")], y6);
var d4 = y6;

// ../node_modules/@arcgis/core/rest/support/NetworkAttribute.js
var m3 = class extends f {
  constructor(t4) {
    super(t4), this.dataType = null, this.name = null, this.parameterNames = null, this.restrictionUsageParameterName = null, this.timeNeutralAttributeName = null, this.trafficSupport = null, this.units = null, this.usageType = null;
  }
};
e([y({ type: String })], m3.prototype, "dataType", void 0), e([o3(w2, { ignoreUnknown: false })], m3.prototype, "name", void 0), e([y({ type: [String] })], m3.prototype, "parameterNames", void 0), e([y({ type: String })], m3.prototype, "restrictionUsageParameterName", void 0), e([o3(D2, { ignoreUnknown: false })], m3.prototype, "timeNeutralAttributeName", void 0), e([y({ type: String })], m3.prototype, "trafficSupport", void 0), e([o3(o5)], m3.prototype, "units", void 0), e([o3(q)], m3.prototype, "usageType", void 0), m3 = e([a("esri.rest.support.NetworkAttribute")], m3);
var u2 = m3;

// ../node_modules/@arcgis/core/rest/support/NetworkDataset.js
var p2 = class extends f {
  constructor(t4) {
    super(t4), this.buildTime = null, this.name = null, this.networkAttributes = null, this.networkSources = null, this.state = null;
  }
};
e([y({ type: Number })], p2.prototype, "buildTime", void 0), e([y({ type: String })], p2.prototype, "name", void 0), e([y({ type: [u2] })], p2.prototype, "networkAttributes", void 0), e([y()], p2.prototype, "networkSources", void 0), e([y({ type: String })], p2.prototype, "state", void 0), p2 = e([a("esri.rest.support.NetworkDataset")], p2);
var i4 = p2;

// ../node_modules/@arcgis/core/rest/support/NetworkServiceDescription.js
var c4 = class extends f {
  constructor(t4) {
    super(t4), this.accumulateAttributeNames = null, this.attributeParameterValues = null, this.currentVersion = null, this.defaultTravelMode = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsSupportedLanguages = null, this.directionsTimeAttribute = null, this.hasZ = null, this.impedance = null, this.networkDataset = null, this.supportedTravelModes = null;
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => w2.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e3, r3) {
    (t4 == null ? void 0 : t4.length) && (e3[r3] = t4.map((t5) => w2.toJSON(t5)));
  }
  get capabilities() {
    return { supportsNow: (this.currentVersion ?? 10) >= 10.81 };
  }
  readDefaultTravelMode(t4, e3) {
    var _a, _b;
    const r3 = ((_a = e3.supportedTravelModes) == null ? void 0 : _a.find(({ id: t5 }) => t5 === e3.defaultTravelMode)) ?? ((_b = e3.supportedTravelModes) == null ? void 0 : _b.find(({ itemId: t5 }) => t5 === e3.defaultTravelMode));
    return r3 ? j3.fromJSON(r3) : null;
  }
};
e([y()], c4.prototype, "accumulateAttributeNames", void 0), e([o2("accumulateAttributeNames")], c4.prototype, "readAccumulateAttributes", null), e([r("accumulateAttributeNames")], c4.prototype, "writeAccumulateAttributes", null), e([y()], c4.prototype, "attributeParameterValues", void 0), e([y()], c4.prototype, "capabilities", null), e([y()], c4.prototype, "currentVersion", void 0), e([y()], c4.prototype, "defaultTravelMode", void 0), e([o2("defaultTravelMode", ["defaultTravelMode", "supportedTravelModes"])], c4.prototype, "readDefaultTravelMode", null), e([y()], c4.prototype, "directionsLanguage", void 0), e([o3(a2)], c4.prototype, "directionsLengthUnits", void 0), e([y()], c4.prototype, "directionsSupportedLanguages", void 0), e([o3(D2, { ignoreUnknown: false })], c4.prototype, "directionsTimeAttribute", void 0), e([y()], c4.prototype, "hasZ", void 0), e([o3(w2, { ignoreUnknown: false })], c4.prototype, "impedance", void 0), e([y({ type: i4 })], c4.prototype, "networkDataset", void 0), e([y({ type: [j3] })], c4.prototype, "supportedTravelModes", void 0), c4 = e([a("esri.rest.support.NetworkServiceDescription")], c4);
var m4 = c4;

// ../node_modules/@arcgis/core/rest/networkService.js
var l4 = () => n.getLogger("esri.rest.networkService");
function u3(e3, r3, t4, o7) {
  o7[t4] = [r3.length, r3.length + e3.length], e3.forEach((e4) => {
    r3.push(e4.geometry);
  });
}
function f6(e3, r3) {
  for (let t4 = 0; t4 < r3.length; t4++) {
    const o7 = e3[r3[t4]];
    if (o7 && o7.length) for (const e4 of o7) e4.z = void 0;
  }
  l4().warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.");
}
function c5(e3, r3) {
  for (let t4 = 0; t4 < r3.length; t4++) {
    const o7 = e3[r3[t4]];
    if (o7 && o7.length) {
      for (const e4 of o7) if (null != e4 && e4.hasZ) return true;
    }
  }
  return false;
}
async function d5(t4, o7, s4) {
  if (!t4) throw new s2("network-service:missing-url", "Url to Network service is missing");
  const n6 = i3({ f: "json", token: o7 }, s4), { data: l7 } = await U(t4, n6), u7 = l7.currentVersion >= 10.4 ? p3(t4, o7, s4) : v2(t4, s4), { defaultTravelMode: f7, supportedTravelModes: c15 } = await u7;
  return l7.defaultTravelMode = f7, l7.supportedTravelModes = c15, m4.fromJSON(l7);
}
async function v2(r3, t4) {
  var _a, _b, _c;
  const i8 = i3({ f: "json" }, t4), { data: l7 } = await U(r3.replace(/\/rest\/.*$/i, "/info"), i8);
  if (!(l7 == null ? void 0 : l7.owningSystemUrl)) return { supportedTravelModes: [], defaultTravelMode: null };
  const { owningSystemUrl: u7 } = l7, f7 = qt(u7) + "/sharing/rest/portals/self", { data: c15 } = await U(f7, i8), d6 = t("helperServices.routingUtilities.url", c15);
  if (!d6) return { supportedTravelModes: [], defaultTravelMode: null };
  const v3 = f5(u7), p8 = /\/solve$/i.test(v3.path) ? "Route" : /\/solveclosestfacility$/i.test(v3.path) ? "ClosestFacility" : "ServiceAreas", m9 = i3({ f: "json", serviceName: p8 }, t4), h = qt(d6) + "/GetTravelModes/execute", g3 = await U(h, m9), w4 = [];
  let T2 = null;
  if ((_b = (_a = g3 == null ? void 0 : g3.data) == null ? void 0 : _a.results) == null ? void 0 : _b.length) {
    const e3 = g3.data.results;
    for (const r4 of e3) if ("supportedTravelModes" === r4.paramName) {
      if ((_c = r4.value) == null ? void 0 : _c.features) {
        for (const { attributes: e4 } of r4.value.features) if (e4) {
          const r5 = JSON.parse(e4.TravelMode);
          w4.push(r5);
        }
      }
    } else "defaultTravelMode" === r4.paramName && (T2 = r4.value);
  }
  return { supportedTravelModes: w4, defaultTravelMode: T2 };
}
async function p3(t4, o7, n6) {
  try {
    const r3 = i3({ f: "json", token: o7 }, n6), i8 = qt(t4) + "/retrieveTravelModes", { data: { supportedTravelModes: l7, defaultTravelMode: u7 } } = await U(i8, r3);
    return { supportedTravelModes: l7, defaultTravelMode: u7 };
  } catch (i8) {
    throw new s2("network-service:retrieveTravelModes", "Could not get to the NAServer's retrieveTravelModes.", { error: i8 });
  }
}

// ../node_modules/@arcgis/core/rest/support/GPMessage.js
var p4 = new n2({ esriJobMessageTypeInformative: "informative", esriJobMessageTypeProcessDefinition: "process-definition", esriJobMessageTypeProcessStart: "process-start", esriJobMessageTypeProcessStop: "process-stop", esriJobMessageTypeWarning: "warning", esriJobMessageTypeError: "error", esriJobMessageTypeEmpty: "empty", esriJobMessageTypeAbort: "abort" });
var i5 = class extends f {
  constructor(e3) {
    super(e3), this.description = null, this.type = null;
  }
};
e([y({ type: String, json: { write: true } })], i5.prototype, "description", void 0), e([y({ type: String, json: { read: p4.read, write: p4.write } })], i5.prototype, "type", void 0), i5 = e([a("esri.rest.support.GPMessage")], i5);
var a3 = i5;

// ../node_modules/@arcgis/core/rest/support/NAMessage.js
var p5 = new n2({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c6 = class extends a3 {
  constructor(r3) {
    super(r3), this.type = null;
  }
};
e([y({ type: String, json: { read: p5.read, write: p5.write } })], c6.prototype, "type", void 0), c6 = e([a("esri.rest.support.NAMessage")], c6);
var i6 = c6;

// ../node_modules/@arcgis/core/rest/support/DirectionsString.js
var c7 = class extends f {
  constructor(r3) {
    super(r3);
  }
};
e([y({ json: { read: { source: "string" } } })], c7.prototype, "text", void 0), e([o3(P, { name: "stringType" })], c7.prototype, "type", void 0), c7 = e([a("esri.rest.support.DirectionsString")], c7);
var i7 = c7;

// ../node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a4 = class extends f {
  constructor(r3) {
    super(r3), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r3, e3) {
    return n4(e3.ETA, e3.arriveTimeUTC);
  }
  readGeometry(r3, e3) {
    return _.fromJSON(e3.point);
  }
};
e([y({ type: Date, json: { read: { source: "arriveTimeUTC" } } })], a4.prototype, "arriveTime", void 0), e([y()], a4.prototype, "arriveTimeOffset", void 0), e([o2("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a4.prototype, "readArriveTimeOffset", null), e([y({ type: _ })], a4.prototype, "geometry", void 0), e([o2("geometry", ["point"])], a4.prototype, "readGeometry", null), e([y({ type: [i7] })], a4.prototype, "strings", void 0), a4 = e([a("esri.rest.support.DirectionsEvent")], a4);
var c8 = a4;

// ../node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function c9(r3) {
  if (null == r3 || "" === r3) return null;
  let e3 = 0, t4 = 0, s4 = 0, o7 = 0;
  const p8 = [];
  let n6, i8, c15, a6, m9, l7, u7, f7, d6 = 0, y8 = 0, h = 0;
  if (m9 = r3.match(/((\+|-)[^+\-|]+|\|)/g), m9 || (m9 = []), 0 === parseInt(m9[d6], 32)) {
    d6 = 2;
    const r4 = parseInt(m9[d6], 32);
    d6++, l7 = parseInt(m9[d6], 32), d6++, 1 & r4 && (y8 = m9.indexOf("|") + 1, u7 = parseInt(m9[y8], 32), y8++), 2 & r4 && (h = m9.indexOf("|", y8) + 1, f7 = parseInt(m9[h], 32), h++);
  } else l7 = parseInt(m9[d6], 32), d6++;
  for (; d6 < m9.length && "|" !== m9[d6]; ) {
    n6 = parseInt(m9[d6], 32) + e3, d6++, e3 = n6, i8 = parseInt(m9[d6], 32) + t4, d6++, t4 = i8;
    const r4 = [n6 / l7, i8 / l7];
    y8 && (a6 = parseInt(m9[y8], 32) + s4, y8++, s4 = a6, r4.push(a6 / u7)), h && (c15 = parseInt(m9[h], 32) + o7, h++, o7 = c15, r4.push(c15 / f7)), p8.push(r4);
  }
  return { paths: [p8], hasZ: y8 > 0, hasM: h > 0 };
}
var a5 = class extends d3 {
  constructor(r3) {
    super(r3), this.events = null, this.strings = null;
  }
  readGeometry(r3, e3) {
    const t4 = c9(e3.compressedGeometry);
    return null != t4 ? m.fromJSON(t4) : null;
  }
};
e([y({ type: [c8] })], a5.prototype, "events", void 0), e([o2("geometry", ["compressedGeometry"])], a5.prototype, "readGeometry", null), e([y({ type: [i7] })], a5.prototype, "strings", void 0), a5 = e([a("esri.rest.support.DirectionsFeature")], a5);
var m5 = a5;

// ../node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function m6(e3, t4) {
  if (0 === e3.length) return new m({ spatialReference: t4 });
  const r3 = [];
  for (const n6 of e3) for (const e4 of n6.paths) r3.push(...e4);
  const o7 = [];
  r3.forEach((e4, t5) => {
    0 !== t5 && e4[0] === r3[t5 - 1][0] && e4[1] === r3[t5 - 1][1] || o7.push(e4);
  });
  const { hasM: s4, hasZ: a6 } = e3[0];
  return new m({ hasM: s4, hasZ: a6, paths: [o7], spatialReference: t4 });
}
var u4 = class extends d2 {
  constructor(e3) {
    super(e3), this.extent = null, this.features = [], this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e3, t4) {
    if (!e3) return [];
    const r3 = t4.summary.envelope.spatialReference ?? t4.spatialReference, o7 = r3 && f2.fromJSON(r3);
    return e3.map((e4) => {
      const t5 = m5.fromJSON(e4);
      if (null != t5.geometry && (t5.geometry.spatialReference = o7), null != t5.events) for (const r4 of t5.events) null != r4.geometry && (r4.geometry.spatialReference = o7);
      return t5;
    });
  }
  get mergedGeometry() {
    if (!this.features) return null;
    return m6(this.features.map(({ geometry: e3 }) => e3), this.extent.spatialReference);
  }
  get strings() {
    return this.features.flatMap(({ strings: e3 }) => e3).filter(O);
  }
};
e([y({ type: w, json: { read: { source: "summary.envelope" } } })], u4.prototype, "extent", void 0), e([y({ nonNullable: true })], u4.prototype, "features", void 0), e([o2("features")], u4.prototype, "readFeatures", null), e([y()], u4.prototype, "geometryType", void 0), e([y({ readOnly: true })], u4.prototype, "mergedGeometry", null), e([y()], u4.prototype, "routeId", void 0), e([y()], u4.prototype, "routeName", void 0), e([y({ value: null, readOnly: true })], u4.prototype, "strings", null), e([y({ json: { read: { source: "summary.totalDriveTime" } } })], u4.prototype, "totalDriveTime", void 0), e([y({ json: { read: { source: "summary.totalLength" } } })], u4.prototype, "totalLength", void 0), e([y({ json: { read: { source: "summary.totalTime" } } })], u4.prototype, "totalTime", void 0), u4 = e([a("esri.rest.support.DirectionsFeatureSet")], u4);
var c10 = u4;

// ../node_modules/@arcgis/core/rest/support/RouteResult.js
var n5 = class extends f {
  constructor(t4) {
    super(t4), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
e([y({ type: d2, json: { write: true } })], n5.prototype, "directionLines", void 0), e([y({ type: d2, json: { write: true } })], n5.prototype, "directionPoints", void 0), e([y({ type: c10, json: { write: true } })], n5.prototype, "directions", void 0), e([y({ type: d3, json: { write: true } })], n5.prototype, "route", void 0), e([y({ type: String, json: { write: true } })], n5.prototype, "routeName", void 0), e([y({ type: [d3], json: { write: true } })], n5.prototype, "stops", void 0), e([y({ type: d2, json: { write: true } })], n5.prototype, "traversedEdges", void 0), e([y({ type: d2, json: { write: true } })], n5.prototype, "traversedJunctions", void 0), e([y({ type: d2, json: { write: true } })], n5.prototype, "traversedTurns", void 0), n5 = e([a("esri.rest.support.RouteResult")], n5);
var u5 = n5;

// ../node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function u6(r3) {
  return r3 ? d2.fromJSON(r3).features.filter(O) : [];
}
var m7 = class extends f {
  constructor(r3) {
    super(r3), this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r3, o7) {
    return u6(o7.barriers);
  }
  readPolylineBarriers(r3) {
    return u6(r3);
  }
  readPolygonBarriers(r3) {
    return u6(r3);
  }
};
e([y({ type: [i6] })], m7.prototype, "messages", void 0), e([y({ type: [d3] })], m7.prototype, "pointBarriers", void 0), e([o2("pointBarriers", ["barriers"])], m7.prototype, "readPointBarriers", null), e([y({ type: [d3] })], m7.prototype, "polylineBarriers", void 0), e([o2("polylineBarriers")], m7.prototype, "readPolylineBarriers", null), e([y({ type: [d3] })], m7.prototype, "polygonBarriers", void 0), e([o2("polygonBarriers")], m7.prototype, "readPolygonBarriers", null), e([y({ type: [u5] })], m7.prototype, "routeResults", void 0), m7 = e([a("esri.rest.support.RouteSolveResult")], m7);
var y7 = m7;

// ../node_modules/@arcgis/core/rest/route.js
function c11(e3) {
  return e3 instanceof d2;
}
async function l5(f7, p8, l7) {
  const y8 = [], d6 = [], g3 = {}, h = {}, R4 = f5(f7), { path: v3 } = R4;
  c11(p8.stops) && u3(p8.stops.features, d6, "stops.features", g3), c11(p8.pointBarriers) && u3(p8.pointBarriers.features, d6, "pointBarriers.features", g3), c11(p8.polylineBarriers) && u3(p8.polylineBarriers.features, d6, "polylineBarriers.features", g3), c11(p8.polygonBarriers) && u3(p8.polygonBarriers.features, d6, "polygonBarriers.features", g3);
  const B = await R(d6);
  for (const e3 in g3) {
    const r3 = g3[e3];
    y8.push(e3), h[e3] = B.slice(r3[0], r3[1]);
  }
  if (c5(h, y8)) {
    let e3 = null;
    try {
      e3 = await d5(v3, p8.apiKey, l7);
    } catch {
    }
    e3 && !e3.hasZ && f6(h, y8);
  }
  for (const e3 in h) h[e3].forEach((t4, s4) => {
    o(p8, e3)[s4].geometry = t4;
  });
  const E = { ...l7, query: { ...R4.query, ...o6(p8), f: "json" } }, T2 = v3.endsWith("/solve") ? v3 : `${v3}/solve`, { data: b4 } = await U(T2, E);
  return m8(b4);
}
function m8(e3) {
  const { barriers: r3, directionLines: t4, directionPoints: s4, directions: o7, messages: a6, polygonBarriers: i8, polylineBarriers: n6, routes: u7, stops: f7, traversedEdges: c15, traversedJunctions: l7, traversedTurns: m9 } = e3, y8 = (e4) => {
    const r4 = g3.find((r5) => r5.routeName === e4);
    if (null != r4) return r4;
    const t5 = { routeId: g3.length + 1, routeName: e4 };
    return g3.push(t5), t5;
  }, d6 = (e4) => {
    const r4 = g3.find((r5) => r5.routeId === e4);
    if (null != r4) return r4;
    const t5 = { routeId: e4, routeName: null };
    return g3.push(t5), t5;
  }, g3 = [];
  u7 == null ? void 0 : u7.features.forEach((e4, r4) => {
    e4.geometry.spatialReference = u7.spatialReference ?? void 0;
    const t5 = e4.attributes.Name, s5 = r4 + 1;
    g3.push({ routeId: s5, routeName: t5, route: e4 });
  }), o7 == null ? void 0 : o7.forEach((e4) => {
    const { routeName: r4 } = e4;
    y8(r4).directions = e4;
  });
  const h = ((f7 == null ? void 0 : f7.features.every((e4) => null == e4.attributes.RouteName)) ?? false) && g3.length > 0 ? g3[0].routeName : null;
  return f7 == null ? void 0 : f7.features.forEach((e4) => {
    var _a;
    e4.geometry && ((_a = e4.geometry).spatialReference ?? (_a.spatialReference = f7.spatialReference ?? void 0));
    const r4 = h ?? e4.attributes.RouteName, t5 = y8(r4);
    t5.stops ?? (t5.stops = []), t5.stops.push(e4);
  }), t4 == null ? void 0 : t4.features.forEach((e4) => {
    const r4 = e4.attributes.RouteID, s5 = d6(r4), { geometryType: o8, spatialReference: a7 } = t4;
    s5.directionLines ?? (s5.directionLines = { features: [], geometryType: o8, spatialReference: a7 }), s5.directionLines.features.push(e4);
  }), s4 == null ? void 0 : s4.features.forEach((e4) => {
    const r4 = e4.attributes.RouteID, t5 = d6(r4), { geometryType: o8, spatialReference: a7 } = s4;
    t5.directionPoints ?? (t5.directionPoints = { features: [], geometryType: o8, spatialReference: a7 }), t5.directionPoints.features.push(e4);
  }), c15 == null ? void 0 : c15.features.forEach((e4) => {
    const r4 = e4.attributes.RouteID, t5 = d6(r4), { geometryType: s5, spatialReference: o8 } = c15;
    t5.traversedEdges ?? (t5.traversedEdges = { features: [], geometryType: s5, spatialReference: o8 }), t5.traversedEdges.features.push(e4);
  }), l7 == null ? void 0 : l7.features.forEach((e4) => {
    const r4 = e4.attributes.RouteID, t5 = d6(r4), { geometryType: s5, spatialReference: o8 } = l7;
    t5.traversedJunctions ?? (t5.traversedJunctions = { features: [], geometryType: s5, spatialReference: o8 }), t5.traversedJunctions.features.push(e4);
  }), m9 == null ? void 0 : m9.features.forEach((e4) => {
    const r4 = e4.attributes.RouteID, t5 = d6(r4);
    t5.traversedTurns ?? (t5.traversedTurns = { features: [] }), t5.traversedTurns.features.push(e4);
  }), y7.fromJSON({ routeResults: g3, barriers: r3, polygonBarriers: i8, polylineBarriers: n6, messages: a6 });
}

// ../node_modules/@arcgis/core/rest/support/commonProperties.js
var t3 = { type: String, json: { read: { source: "token" }, write: { target: "token" } } };

// ../node_modules/@arcgis/core/rest/support/DataLayer.js
var l6 = class extends i(f) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.geometry = null, this.geometryType = null, this.name = null, this.spatialRelationship = null, this.type = "layer", this.where = null;
  }
};
e([y({ type: Boolean, json: { write: true } })], l6.prototype, "doNotLocateOnRestrictedElements", void 0), e([y({ types: n3, json: { read: y2, write: true } })], l6.prototype, "geometry", void 0), e([o3(b3)], l6.prototype, "geometryType", void 0), e([y({ type: String, json: { name: "layerName", write: true } })], l6.prototype, "name", void 0), e([o3(R2, { name: "spatialRel" })], l6.prototype, "spatialRelationship", void 0), e([y({ type: String, json: { write: true } })], l6.prototype, "type", void 0), e([y({ type: String, json: { write: true } })], l6.prototype, "where", void 0), l6 = e([a("esri.rest.support.DataLayer")], l6);
var c12 = l6;

// ../node_modules/@arcgis/core/rest/support/NetworkFeatureSet.js
var s3;
var c13 = s3 = class extends d2 {
  constructor(e3) {
    super(e3), this.doNotLocateOnRestrictedElements = null;
  }
  clone() {
    return new s3({ doNotLocateOnRestrictedElements: this.doNotLocateOnRestrictedElements, ...this.cloneProperties() });
  }
};
e([y({ type: Boolean, json: { write: true } })], c13.prototype, "doNotLocateOnRestrictedElements", void 0), c13 = s3 = e([a("esri.rest.support.NetworkFeatureSet")], c13);
var p6 = c13;

// ../node_modules/@arcgis/core/rest/support/NetworkUrl.js
var p7 = class extends i(f) {
  constructor(o7) {
    super(o7), this.doNotLocateOnRestrictedElements = null, this.url = null;
  }
};
e([y({ type: Boolean, json: { write: true } })], p7.prototype, "doNotLocateOnRestrictedElements", void 0), e([y({ type: String, json: { write: true } })], p7.prototype, "url", void 0), p7 = e([a("esri.rest.support.NetworkUrl")], p7);
var c14 = p7;

// ../node_modules/@arcgis/core/rest/support/RouteParameters.js
var N2;
var P2 = N2 = class extends i(f) {
  constructor(t4) {
    super(t4), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = "true-shape", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = false, this.returnDirections = false, this.returnPolygonBarriers = false, this.returnPolylineBarriers = false, this.returnRoutes = true, this.returnStops = false, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = true, this.startTime = null, this.startTimeIsUTC = true, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;
  }
  static from(t4) {
    return g(N2, t4);
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => w2.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e3, r3) {
    (t4 == null ? void 0 : t4.length) && (e3[r3] = t4.map((t5) => w2.toJSON(t5)));
  }
  writePointBarriers(t4, e3, r3) {
    k3(t4, e3, r3);
  }
  writePolygonBarrier(t4, e3, r3) {
    k3(t4, e3, r3);
  }
  writePolylineBarrier(t4, e3, r3) {
    k3(t4, e3, r3);
  }
  readRestrictionAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => M.fromJSON(t5));
  }
  writeRestrictionAttributes(t4, e3, r3) {
    (t4 == null ? void 0 : t4.length) && (e3[r3] = t4.map((t5) => M.toJSON(t5)));
  }
  readStartTime(t4, e3) {
    const { startTime: r3 } = e3;
    return null == r3 ? null : "now" === r3 ? "now" : new Date(r3);
  }
  writeStartTime(t4, e3) {
    null != t4 && (e3.startTime = "now" === t4 ? "now" : t4.getTime());
  }
  readStops(t4, e3) {
    return C3(e3.stops);
  }
  writeStops(t4, e3, r3) {
    k3(t4, e3, r3);
  }
};
e([y({ type: [String], json: { name: "accumulateAttributeNames", write: true } })], P2.prototype, "accumulateAttributes", void 0), e([o2("accumulateAttributes")], P2.prototype, "readAccumulateAttributes", null), e([r("accumulateAttributes")], P2.prototype, "writeAccumulateAttributes", null), e([y(t3)], P2.prototype, "apiKey", void 0), e([y({ json: { write: true } })], P2.prototype, "attributeParameterValues", void 0), e([y({ type: String, json: { write: true } })], P2.prototype, "directionsLanguage", void 0), e([o3(a2)], P2.prototype, "directionsLengthUnits", void 0), e([o3(l2)], P2.prototype, "directionsOutputType", void 0), e([o3(U2)], P2.prototype, "directionsStyleName", void 0), e([o3(D2, { name: "directionsTimeAttributeName", ignoreUnknown: false })], P2.prototype, "directionsTimeAttribute", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "findBestSequence", void 0), e([y({ type: Number, json: { write: true } })], P2.prototype, "geometryPrecision", void 0), e([y({ type: Number, json: { write: true } })], P2.prototype, "geometryPrecisionM", void 0), e([y({ type: Number, json: { write: true } })], P2.prototype, "geometryPrecisionZ", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "ignoreInvalidLocations", void 0), e([o3(w2, { name: "impedanceAttributeName", ignoreUnknown: false })], P2.prototype, "impedanceAttribute", void 0), e([y({ type: Number, json: { write: true } })], P2.prototype, "outputGeometryPrecision", void 0), e([o3(r2)], P2.prototype, "outputGeometryPrecisionUnits", void 0), e([o3(c)], P2.prototype, "outputLines", void 0), e([y({ type: f2, json: { name: "outSR", write: true } })], P2.prototype, "outSpatialReference", void 0), e([y({ json: { write: true } })], P2.prototype, "overrides", void 0), e([y({ json: { name: "barriers", write: true } })], P2.prototype, "pointBarriers", void 0), e([r("pointBarriers")], P2.prototype, "writePointBarriers", null), e([y({ json: { write: true } })], P2.prototype, "polygonBarriers", void 0), e([r("polygonBarriers")], P2.prototype, "writePolygonBarrier", null), e([y({ json: { write: true } })], P2.prototype, "polylineBarriers", void 0), e([r("polylineBarriers")], P2.prototype, "writePolylineBarrier", null), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "preserveFirstStop", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "preserveLastStop", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "preserveObjectID", void 0), e([y({ type: [String], json: { name: "restrictionAttributeNames", write: true } })], P2.prototype, "restrictionAttributes", void 0), e([o2("restrictionAttributes")], P2.prototype, "readRestrictionAttributes", null), e([r("restrictionAttributes")], P2.prototype, "writeRestrictionAttributes", null), e([o3(m2)], P2.prototype, "restrictUTurns", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnBarriers", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnDirections", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnPolygonBarriers", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnPolylineBarriers", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnRoutes", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnStops", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnTraversedEdges", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnTraversedJunctions", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnTraversedTurns", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "returnZ", void 0), e([y({ json: { write: true } })], P2.prototype, "startTime", void 0), e([o2("startTime")], P2.prototype, "readStartTime", null), e([r("startTime")], P2.prototype, "writeStartTime", null), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "startTimeIsUTC", void 0), e([y({ json: { write: true } })], P2.prototype, "stops", void 0), e([o2("stops")], P2.prototype, "readStops", null), e([r("stops")], P2.prototype, "writeStops", null), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "timeWindowsAreUTC", void 0), e([y({ type: j3, json: { write: true } })], P2.prototype, "travelMode", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "useHierarchy", void 0), e([y({ type: Boolean, json: { write: true } })], P2.prototype, "useTimeWindows", void 0), P2 = N2 = e([a("esri.rest.support.RouteParameters")], P2);
var O2 = P2;
function J(t4) {
  return t4 && "type" in t4;
}
function L2(t4) {
  return t4 && "features" in t4 && "doNotLocateOnRestrictedElements" in t4;
}
function R3(t4) {
  return t4 && "url" in t4;
}
function U3(t4) {
  return t4 && "features" in t4;
}
function C3(t4) {
  return J(t4) ? c12.fromJSON(t4) : R3(t4) ? c14.fromJSON(t4) : L2(t4) ? p6.fromJSON(t4) : U3(t4) ? d2.fromJSON(t4) : null;
}
function k3(t4, e3, o7) {
  null != t4 && (e3[o7] = V.isCollection(t4) ? { features: t4.toArray().map((t5) => t5.toJSON()) } : t4.toJSON());
}

// ../node_modules/@arcgis/core/layers/RouteLayer.js
function z(e3) {
  return e3.length ? e3 : null;
}
function H(e3) {
  switch (e3) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: H("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: H("esriGeometryPolyline") };
  }
}
function K2(e3) {
  return "layers" in e3;
}
function Q(e3) {
  return "esri.rest.support.FeatureSet" === e3.declaredClass;
}
function Y(e3) {
  return "esri.rest.support.NetworkFeatureSet" === e3.declaredClass;
}
function Z(e3, t4, r3) {
  var _a, _b, _c, _d, _e, _f;
  const o7 = (_a = t4.networkDataset) == null ? void 0 : _a.networkAttributes, i8 = (o7 == null ? void 0 : o7.filter(({ usageType: e4 }) => "cost" === e4)) ?? [], s4 = r3.travelMode ?? t4.defaultTravelMode;
  if (null == s4) return void ue().warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
  const { timeAttributeName: n6, distanceAttributeName: a6 } = s4, u7 = i8.find(({ name: e4 }) => e4 === n6), p8 = i8.find(({ name: e4 }) => e4 === a6), c15 = ((_b = r3.travelMode) == null ? void 0 : _b.impedanceAttributeName) ?? r3.impedanceAttribute ?? t4.impedance, m9 = u7 == null ? void 0 : u7.units, y8 = p8 == null ? void 0 : p8.units;
  if (!m9 || !y8) throw new s2("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
  const f7 = r3.directionsLanguage ?? t4.directionsLanguage, d6 = r3.accumulateAttributes ?? t4.accumulateAttributeNames ?? [], h = new Set(i8.filter(({ name: e4 }) => e4 === n6 || e4 === a6 || e4 === c15 || null != e4 && d6.includes(e4)).map(({ name: e4 }) => e4)), w4 = (e4) => {
    for (const t5 in e4) h.has(t5) || delete e4[t5];
  };
  for (const l7 of e3.pointBarriers) null != l7.costs && (l7.addedCost = l7.costs[c15] ?? 0, w4(l7.costs));
  for (const l7 of e3.polygonBarriers) null != l7.costs && (l7.scaleFactor = l7.costs[c15] ?? 1, w4(l7.costs));
  for (const l7 of e3.polylineBarriers) null != l7.costs && (l7.scaleFactor = l7.costs[c15] ?? 1, w4(l7.costs));
  const { routeInfo: S5 } = e3, { findBestSequence: g3, preserveFirstStop: b4, preserveLastStop: v3, startTimeIsUTC: B, timeWindowsAreUTC: P3 } = r3;
  S5.analysisSettings = new c3({ accumulateAttributes: d6, directionsLanguage: f7, findBestSequence: g3, preserveFirstStop: b4, preserveLastStop: v3, startTimeIsUTC: B, timeWindowsAreUTC: P3, travelMode: s4 }), S5.totalDuration = X(((_c = S5.totalCosts) == null ? void 0 : _c[n6]) ?? 0, m9), S5.totalDistance = ee(((_d = S5.totalCosts) == null ? void 0 : _d[a6]) ?? 0, y8), S5.totalLateDuration = X(((_e = S5.totalViolations) == null ? void 0 : _e[n6]) ?? 0, m9), S5.totalWaitDuration = X(((_f = S5.totalWait) == null ? void 0 : _f[n6]) ?? 0, m9), null != S5.totalCosts && w4(S5.totalCosts), null != S5.totalViolations && w4(S5.totalViolations), null != S5.totalWait && w4(S5.totalWait);
  for (const l7 of e3.stops) null != l7.serviceCosts && (l7.serviceDuration = X(l7.serviceCosts[n6] ?? 0, m9), l7.serviceDistance = ee(l7.serviceCosts[a6] ?? 0, y8), w4(l7.serviceCosts)), null != l7.cumulativeCosts && (l7.cumulativeDuration = X(l7.cumulativeCosts[n6] ?? 0, m9), l7.cumulativeDistance = ee(l7.cumulativeCosts[a6] ?? 0, y8), w4(l7.cumulativeCosts)), null != l7.violations && (l7.lateDuration = X(l7.violations[n6] ?? 0, m9), w4(l7.violations)), null != l7.wait && (l7.waitDuration = X(l7.wait[n6] ?? 0, m9), w4(l7.wait));
}
async function $(e3) {
  const t4 = f2.WGS84;
  return await N(e3.spatialReference, t4), K(e3, t4);
}
function X(e3, t4) {
  switch (t4) {
    case "seconds":
      return e3 / 60;
    case "hours":
      return 60 * e3;
    case "days":
      return 60 * e3 * 24;
    default:
      return e3;
  }
}
function ee(e3, t4) {
  return "decimal-degrees" === t4 || "points" === t4 || "unknown" === t4 ? e3 : j(e3, t4, "meters");
}
function te(e3) {
  const { attributes: t4, geometry: r3, popupTemplate: o7, symbol: i8 } = e3.toGraphic().toJSON();
  return { attributes: t4, geometry: r3, popupInfo: o7, symbol: i8 };
}
var re = V.ofType(c2);
var oe = V.ofType(y5);
var ie = V.ofType(C);
var se = V.ofType(T);
var ne = V.ofType(j4);
var le = V.ofType(w3);
var ae = "esri.layers.RouteLayer";
var ue = () => n.getLogger(ae);
var pe = class extends l(t2(b2(j2(S2(f4))))) {
  constructor(e3) {
    super(e3), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.defaultSymbols = new d4(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new ie(), this.polygonBarriers = new se(), this.polylineBarriers = new ne(), this.routeInfo = null, this.spatialReference = f2.WGS84, this.stops = new le(), this.type = "route";
    const t4 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(v(() => this.stops, "change", t4, { sync: true, onListenerAdd: t4 }));
  }
  writeFeatureCollectionWebmap(e3, t4, r3, o7) {
    const i8 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e4) => !!e4), s4 = i8.map((e4, t5) => t5), n6 = "web-map" === o7.origin ? "featureCollection.layers" : "layers";
    e2(n6, i8, t4), t4.opacity = this.opacity, t4.visibility = this.visible, t4.visibleLayers = s4;
  }
  readDirectionLines(e3, t4) {
    return this._getNetworkFeatures(t4, "DirectionLines", (e4) => c2.fromGraphic(e4));
  }
  readDirectionPoints(e3, t4) {
    return this._getNetworkFeatures(t4, "DirectionPoints", (e4) => y5.fromGraphic(e4));
  }
  get fullExtent() {
    var _a;
    const e3 = new w({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: f2.WGS84 });
    if (null != ((_a = this.routeInfo) == null ? void 0 : _a.geometry)) return this.routeInfo.geometry.extent ?? e3;
    if (null == this.stops) return e3;
    const t4 = this.stops.filter((e4) => null != e4.geometry);
    if (t4.length < 2) return e3;
    const { spatialReference: r3 } = t4.at(0).geometry;
    if (null == r3) return e3;
    const o7 = t4.toArray().map((e4) => {
      const t5 = e4.geometry;
      return [t5.x, t5.y];
    });
    return new u({ points: o7, spatialReference: r3 }).extent;
  }
  readMaxScale(e3, t4) {
    var _a;
    const r3 = K2(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o7 = r3 == null ? void 0 : r3.find((e4) => null != e4.layerDefinition.maxScale);
    return (o7 == null ? void 0 : o7.layerDefinition.maxScale) ?? 0;
  }
  readMinScale(e3, t4) {
    var _a;
    const r3 = K2(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o7 = r3 == null ? void 0 : r3.find((e4) => null != e4.layerDefinition.minScale);
    return (o7 == null ? void 0 : o7.layerDefinition.minScale) ?? 0;
  }
  readPointBarriers(e3, t4) {
    return this._getNetworkFeatures(t4, "Barriers", (e4) => C.fromGraphic(e4));
  }
  readPolygonBarriers(e3, t4) {
    return this._getNetworkFeatures(t4, "PolygonBarriers", (e4) => T.fromGraphic(e4));
  }
  readPolylineBarriers(e3, t4) {
    return this._getNetworkFeatures(t4, "PolylineBarriers", (e4) => j4.fromGraphic(e4));
  }
  readRouteInfo(e3, t4) {
    return this._getNetworkFeatures(t4, "RouteInfo", (e4) => S4.fromGraphic(e4)).at(0) ?? null;
  }
  readSpatialReference(e3, t4) {
    var _a, _b;
    const r3 = K2(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers;
    if (!(r3 == null ? void 0 : r3.length)) return f2.WGS84;
    const { layerDefinition: o7, featureSet: i8 } = r3[0], s4 = i8.features[0], n6 = ((_b = s4 == null ? void 0 : s4.geometry) == null ? void 0 : _b.spatialReference) ?? i8.spatialReference ?? o7.spatialReference ?? o7.extent.spatialReference ?? g2;
    return f2.fromJSON(n6);
  }
  readStops(e3, t4) {
    return this._getNetworkFeatures(t4, "Stops", (e4) => w3.fromGraphic(e4), (e4) => this._setStopSymbol(e4));
  }
  get title() {
    var _a;
    return ((_a = this.routeInfo) == null ? void 0 : _a.name) ?? "Route";
  }
  set title(e3) {
    this._overrideIfSome("title", e3);
  }
  get url() {
    return s.routeServiceUrl;
  }
  set url(e3) {
    null != e3 ? this._set("url", y3(e3, ue())) : this._set("url", s.routeServiceUrl);
  }
  load(e3) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e3)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    null != this.directionLines && (this.directionLines.removeAll(), this._set("directionLines", null)), null != this.directionPoints && (this.directionPoints.removeAll(), this._set("directionPoints", null)), null != this.routeInfo && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e3, portalItem: t4 } = this;
    if (!t4) throw new s2("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t4.id) throw new s2("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t4.type) throw new s2("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (null == this.routeInfo) throw new s2("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r3 } = t4;
    await r3.signIn(), r3.user || await t4.reload();
    const { itemUrl: o7, itemControl: i8 } = t4;
    if ("admin" !== i8 && "update" !== i8) throw new s2("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const s4 = { messages: [], origin: "portal-item", portal: r3, url: o7 ? I(o7) : void 0, writtenProperties: [] }, n6 = this.write(void 0, s4);
    return t4.extent = await $(e3), t4.title = this.title, await t4.update({ data: n6 }), t4;
  }
  async saveAs(e3, t4 = {}) {
    var _a;
    if (await this.load(), null == this.routeInfo) throw new s2("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r3 = S.from(e3).clone();
    r3.extent ?? (r3.extent = await $(this.fullExtent)), r3.id = null, r3.portal ?? (r3.portal = C2.getDefault()), r3.title ?? (r3.title = this.title), r3.type = "Feature Collection", r3.typeKeywords = ["Data", "Feature Collection", f3.MULTI_LAYER, "Route Layer"];
    const { portal: o7 } = r3, i8 = { messages: [], origin: "portal-item", portal: o7, url: null, writtenProperties: [] };
    await o7.signIn();
    const s4 = t4 == null ? void 0 : t4.folder, n6 = this.write(void 0, i8);
    return await ((_a = o7.user) == null ? void 0 : _a.addItem({ item: r3, folder: s4, data: n6 })), this.portalItem = r3, i2(i8), i8.portalItem = r3, r3;
  }
  async solve(e3, t4) {
    const r3 = (e3 == null ? void 0 : e3.stops) ?? this.stops, o7 = (e3 == null ? void 0 : e3.pointBarriers) ?? z(this.pointBarriers), i8 = (e3 == null ? void 0 : e3.polylineBarriers) ?? z(this.polylineBarriers), s4 = (e3 == null ? void 0 : e3.polygonBarriers) ?? z(this.polygonBarriers);
    if (null == r3) throw new s2("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((Q(r3) || Y(r3)) && r3.features.length < 2 || V.isCollection(r3) && r3.length < 2) throw new s2("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (V.isCollection(r3)) for (const n6 of r3) n6.routeName = null;
    const a6 = e3 == null ? void 0 : e3.apiKey, u7 = this.url, c15 = await this._getServiceDescription(u7, a6, t4), m9 = (e3 == null ? void 0 : e3.travelMode) ?? c15.defaultTravelMode, y8 = (e3 == null ? void 0 : e3.accumulateAttributes) ?? [];
    null != m9 && (y8.push(m9.distanceAttributeName), m9.timeAttributeName && y8.push(m9.timeAttributeName));
    const f7 = { accumulateAttributes: y8, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o7, polylineBarriers: i8, polygonBarriers: s4, preserveFirstStop: true, preserveLastStop: true, returnBarriers: !!o7, returnDirections: true, returnPolygonBarriers: !!s4, returnPolylineBarriers: !!i8, returnRoutes: true, returnStops: true, stops: r3 }, d6 = O2.from(e3 ?? {});
    let h;
    d6.set(f7);
    try {
      h = await l5(u7, d6, t4);
    } catch (S5) {
      throw b(S5) ? S5 : new s2("routelayer:failed-route-request", "the routing request failed", { error: S5 });
    }
    const w4 = this._toRouteLayerSolution(h);
    return this._isOverridden("title") || (this.title = w4.routeInfo.name ?? "Route"), Z(w4, c15, d6), w4;
  }
  update(e3) {
    const { stops: t4, directionLines: r3, directionPoints: o7, pointBarriers: i8, polylineBarriers: s4, polygonBarriers: n6, routeInfo: l7 } = e3;
    this.set({ stops: t4, pointBarriers: i8, polylineBarriers: s4, polygonBarriers: n6 }), this._set("directionLines", r3), this._set("directionPoints", o7), this._set("routeInfo", l7), null != l7.geometry && (this.spatialReference = l7.geometry.spatialReference);
  }
  _getNetworkFeatures(e3, t4, s4, l7) {
    var _a;
    const a6 = K2(e3) ? e3.layers : (_a = e3.featureCollection) == null ? void 0 : _a.layers, u7 = a6 == null ? void 0 : a6.find((e4) => e4.layerDefinition.name === t4);
    if (null == u7) return new V();
    const { layerDefinition: p8, popupInfo: c15, featureSet: m9 } = u7, y8 = p8.drawingInfo.renderer, { features: f7 } = m9, d6 = m9.spatialReference ?? p8.spatialReference ?? p8.extent.spatialReference ?? g2, h = y8 && o4(y8), w4 = f2.fromJSON(d6), S5 = f7.map((e4) => {
      const i8 = d3.fromJSON(e4);
      null != i8.geometry && null != e4.geometry && null == e4.geometry.spatialReference && (i8.geometry.spatialReference = w4);
      const n6 = s4(i8);
      return n6.symbol ?? (n6.symbol = (h == null ? void 0 : h.getSymbol(i8)) ?? this._getNetworkSymbol(t4)), n6.popupTemplate ?? (n6.popupTemplate = c15 && k2.fromJSON(c15)), n6;
    });
    return l7 && S5.some(({ symbol: e4 }) => !e4) && l7(S5), new V(S5);
  }
  _getNetworkSymbol(e3) {
    switch (e3) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e3, t4, r3) {
    if (null != this._cachedServiceDescription && this._cachedServiceDescription.url === e3) return this._cachedServiceDescription.serviceDescription;
    const o7 = await d5(e3, t4, r3);
    return this._cachedServiceDescription = { serviceDescription: o7, url: e3 }, o7;
  }
  _setStopSymbol(e3) {
    if (!e3 || 0 === e3.length) return;
    if (null == this.defaultSymbols.stops) return;
    if (e3.every(({ symbol: e4 }) => null != e4)) return;
    const { first: t4, last: r3, middle: o7, unlocated: i8, waypoint: s4, break: n6 } = this.defaultSymbols.stops;
    if (null == this.routeInfo || 1 === e3.length) return void e3.forEach((i9, s5) => {
      switch (s5) {
        case 0:
          i9.symbol = t4;
          break;
        case e3.length - 1:
          i9.symbol = r3;
          break;
        default:
          i9.symbol = o7;
      }
    });
    const l7 = e3.map(({ sequence: e4 }) => e4).filter((e4) => null != e4), a6 = Math.min(...l7), u7 = Math.max(...l7);
    for (const p8 of e3) p8.sequence !== a6 ? p8.sequence !== u7 ? "ok" === p8.status || "not-located-on-closest" === p8.status ? "waypoint" !== p8.locationType ? "break" !== p8.locationType ? p8.symbol = o7 : p8.symbol = n6 : p8.symbol = s4 : p8.symbol = i8 : p8.symbol = r3 : p8.symbol = t4;
  }
  _toRouteLayerSolution(e3) {
    var _a, _b, _c, _d, _e, _f, _g;
    const t4 = (_a = e3.routeResults[0].stops) == null ? void 0 : _a.map((e4) => w3.fromJSON(e4.toJSON()));
    this._setStopSymbol(t4);
    const r3 = new le(t4), o7 = new se((_b = e3.polygonBarriers) == null ? void 0 : _b.map((e4) => {
      const t5 = T.fromJSON(e4.toJSON());
      return t5.symbol = this.defaultSymbols.polygonBarriers, t5;
    })), i8 = new ne((_c = e3.polylineBarriers) == null ? void 0 : _c.map((e4) => {
      const t5 = j4.fromJSON(e4.toJSON());
      return t5.symbol = this.defaultSymbols.polylineBarriers, t5;
    })), s4 = new ie((_d = e3.pointBarriers) == null ? void 0 : _d.map((e4) => {
      const t5 = C.fromJSON(e4.toJSON());
      return t5.symbol = this.defaultSymbols.pointBarriers, t5;
    })), n6 = (_e = e3.routeResults[0].route) == null ? void 0 : _e.toJSON(), l7 = S4.fromJSON(n6);
    l7.symbol = this.defaultSymbols.routeInfo;
    const a6 = new oe((_f = e3.routeResults[0].directionPoints) == null ? void 0 : _f.features.map((e4) => {
      const t5 = y5.fromJSON(e4.toJSON());
      return t5.symbol = this.defaultSymbols.directionPoints, t5;
    }));
    return { directionLines: new re((_g = e3.routeResults[0].directionLines) == null ? void 0 : _g.features.map((e4) => {
      const t5 = c2.fromJSON(e4.toJSON());
      return t5.symbol = this.defaultSymbols.directionLines, t5;
    })), directionPoints: a6, pointBarriers: s4, polygonBarriers: o7, polylineBarriers: i8, routeInfo: l7, stops: r3 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", c2.fields, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", y5.fields, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e3, t4, r3, o7, i8, s4) {
    if (!(e3 == null ? void 0 : e3.length)) return null;
    const n6 = this.spatialReference.toJSON(), { fullExtent: l7, maxScale: a6, minScale: u7 } = this;
    return { featureSet: { features: e3.toArray().map((e4) => te(e4)), geometryType: r3, spatialReference: n6 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: null != t4 ? t4.toJSON() : H(r3) } }, extent: l7.toJSON(), fields: o7, geometryType: r3, hasM: false, hasZ: false, maxScale: a6, minScale: u7, name: i8, objectIdField: "ObjectID", spatialReference: n6, title: s4, type: "Feature Layer", typeIdField: "" } };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", C.fields, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", T.fields, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", j4.fields, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(null != this.routeInfo ? new V([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", S4.fields, "RouteInfo", "Route Details");
  }
  _writeStops() {
    var _a, _b, _c;
    const e3 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", w3.fields, "Stops", "Stops");
    if (null == e3) return null;
    const { stops: t4 } = this.defaultSymbols, r3 = (_a = t4 == null ? void 0 : t4.first) == null ? void 0 : _a.toJSON(), o7 = (_b = t4 == null ? void 0 : t4.middle) == null ? void 0 : _b.toJSON(), i8 = (_c = t4 == null ? void 0 : t4.last) == null ? void 0 : _c.toJSON();
    return e3.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o7, uniqueValueInfos: [{ value: "1", symbol: r3, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i8, label: "Last Stop" }] }, e3;
  }
};
e([y({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], pe.prototype, "_featureCollection", void 0), e([r(["web-map", "portal-item"], "_featureCollection")], pe.prototype, "writeFeatureCollectionWebmap", null), e([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], pe.prototype, "_type", void 0), e([y({ nonNullable: true, type: d4 })], pe.prototype, "defaultSymbols", void 0), e([y({ readOnly: true })], pe.prototype, "directionLines", void 0), e([o2(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionLines", null), e([y({ readOnly: true })], pe.prototype, "directionPoints", void 0), e([o2(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionPoints", null), e([y({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], pe.prototype, "featureCollectionType", void 0), e([y({ readOnly: true })], pe.prototype, "fullExtent", null), e([y({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], pe.prototype, "legendEnabled", void 0), e([y({ type: ["show", "hide"] })], pe.prototype, "listMode", void 0), e([y({ type: Number, nonNullable: true, json: { write: false } })], pe.prototype, "maxScale", void 0), e([o2(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMaxScale", null), e([y({ type: Number, nonNullable: true, json: { write: false } })], pe.prototype, "minScale", void 0), e([o2(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMinScale", null), e([y({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], pe.prototype, "operationalLayerType", void 0), e([y({ nonNullable: true, type: V.ofType(C) })], pe.prototype, "pointBarriers", void 0), e([o2(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPointBarriers", null), e([y({ nonNullable: true, type: V.ofType(T) })], pe.prototype, "polygonBarriers", void 0), e([o2(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolygonBarriers", null), e([y({ nonNullable: true, type: V.ofType(j4) })], pe.prototype, "polylineBarriers", void 0), e([o2(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolylineBarriers", null), e([y({ readOnly: true })], pe.prototype, "routeInfo", void 0), e([o2(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], pe.prototype, "readRouteInfo", null), e([y({ type: f2 })], pe.prototype, "spatialReference", void 0), e([o2(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], pe.prototype, "readSpatialReference", null), e([y({ nonNullable: true, type: V.ofType(w3) })], pe.prototype, "stops", void 0), e([o2(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], pe.prototype, "readStops", null), e([y()], pe.prototype, "title", null), e([y({ readOnly: true, json: { read: false } })], pe.prototype, "type", void 0), e([y()], pe.prototype, "url", null), pe = e([a(ae)], pe);
var ce = pe;
export {
  ce as default
};
//# sourceMappingURL=RouteLayer-CWJAGOD4.js.map
