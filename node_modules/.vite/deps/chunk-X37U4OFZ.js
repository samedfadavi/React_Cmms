import {
  n as n5
} from "./chunk-RBD4NFLO.js";
import {
  i as i3,
  o as o2
} from "./chunk-NYSNGPJM.js";
import {
  n as n4
} from "./chunk-FYJHK7JQ.js";
import {
  n as n3,
  p as p2
} from "./chunk-FHON4NYJ.js";
import {
  R
} from "./chunk-P3MZKJDB.js";
import {
  f as f3,
  i as i2,
  s as s3
} from "./chunk-3QWMYL5A.js";
import {
  c
} from "./chunk-IGNUVZ34.js";
import {
  d as d2
} from "./chunk-CJJCN7PA.js";
import {
  y as y3
} from "./chunk-IJ42YN7D.js";
import {
  b,
  i as i4
} from "./chunk-CAC7FEOV.js";
import {
  n as n2
} from "./chunk-KK4UI5LV.js";
import {
  n
} from "./chunk-Q4D7WYWB.js";
import {
  i
} from "./chunk-NYWHVRZC.js";
import {
  p,
  y as y2
} from "./chunk-ZH4RVBER.js";
import {
  v
} from "./chunk-7PMYO342.js";
import {
  V
} from "./chunk-3DBICPHD.js";
import {
  w
} from "./chunk-66KCMKB5.js";
import {
  o
} from "./chunk-ZART2Y5J.js";
import {
  f as f2,
  r as r2
} from "./chunk-F4OBDVPS.js";
import {
  W2 as W,
  d2 as d
} from "./chunk-X3IFQMC4.js";
import {
  U
} from "./chunk-WC4SPMPL.js";
import {
  S,
  f2 as f,
  y
} from "./chunk-TJUEGVVG.js";
import {
  a3 as a,
  g,
  r
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  e as e2,
  k,
  s as s2
} from "./chunk-VMWKLHJD.js";
import {
  s2 as s
} from "./chunk-YNL57W4I.js";
import {
  O,
  has
} from "./chunk-2PA5UPTB.js";

// ../node_modules/@arcgis/core/renderers/support/clickToleranceUtils.js
function t(t2, e4) {
  return e4 ? "xoffset" in e4 && e4.xoffset ? Math.max(t2, Math.abs(e4.xoffset)) : "yoffset" in e4 && e4.yoffset ? Math.max(t2, Math.abs(e4.yoffset || 0)) : t2 : t2;
}
function e3(t2) {
  let e4 = 0, n7 = 0;
  for (let r5 = 0; r5 < t2.length; r5++) {
    const o5 = t2[r5].size;
    "number" == typeof o5 && (e4 += o5, n7++);
  }
  return e4 / n7;
}
function n6(t2, n7) {
  var _a;
  return "number" == typeof t2 ? t2 : ((_a = t2 == null ? void 0 : t2.stops) == null ? void 0 : _a.length) ? e3(t2.stops) : n7;
}
function r3(t2, e4) {
  if (!e4) return t2;
  const r5 = e4.filter((t3) => "size" === t3.type).map((e5) => {
    const { maxSize: r6, minSize: o6 } = e5;
    return (n6(r6, t2) + n6(o6, t2)) / 2;
  });
  let o5 = 0;
  const s4 = r5.length;
  if (0 === s4) return t2;
  for (let n7 = 0; n7 < s4; n7++) o5 += r5[n7];
  const f5 = Math.floor(o5 / s4);
  return Math.max(f5, t2);
}
function o3(e4) {
  var _a;
  const n7 = e4 == null ? void 0 : e4.renderer, o5 = e4 == null ? void 0 : e4.pointerType, s4 = "touch" === o5 ? 9 : 6;
  if (!n7) return s4;
  const f5 = "visualVariables" in n7 ? r3(s4, n7.visualVariables) : s4;
  if ("simple" === n7.type) return t(f5, n7.symbol);
  if ("unique-value" === n7.type) {
    let e5 = f5;
    return (_a = n7.uniqueValueInfos) == null ? void 0 : _a.forEach((n8) => {
      e5 = t(e5, n8.symbol);
    }), e5;
  }
  if ("class-breaks" === n7.type) {
    let e5 = f5;
    return n7.classBreakInfos.forEach((n8) => {
      e5 = t(e5, n8.symbol);
    }), e5;
  }
  return "dot-density" === n7.type || n7.type, f5;
}

// ../node_modules/@arcgis/core/rest/operations/identify.js
function o4(e4, r5) {
  const { dpi: n7, gdbVersion: s4, geometry: o5, geometryPrecision: a6, height: m3, historicMoment: p4, layerOption: f5, mapExtent: y4, maxAllowableOffset: u3, returnFieldName: c2, returnGeometry: d4, returnUnformattedValues: g2, returnZ: x, spatialReference: h, timeExtent: b2, tolerance: E, width: O2 } = e4.toJSON(), { dynamicLayers: S3, layerDefs: j, layerIds: N } = l(e4), $ = null != (r5 == null ? void 0 : r5.geometry) ? r5.geometry : null, I = { historicMoment: p4, geometryPrecision: a6, maxAllowableOffset: u3, returnFieldName: c2, returnGeometry: d4, returnUnformattedValues: g2, returnZ: x, tolerance: E }, R3 = ($ == null ? void 0 : $.toJSON()) || o5;
  I.imageDisplay = `${O2},${m3},${n7}`, s4 && (I.gdbVersion = s4), R3 && (delete R3.spatialReference, I.geometry = JSON.stringify(R3), I.geometryType = p(R3));
  const U3 = h ?? (R3 == null ? void 0 : R3.spatialReference) ?? (y4 == null ? void 0 : y4.spatialReference);
  if (U3 && (I.sr = d(U3)), I.time = b2 ? [b2.start, b2.end].join(",") : null, y4) {
    const { xmin: e5, ymin: t2, xmax: r6, ymax: i5 } = y4;
    I.mapExtent = `${e5},${t2},${r6},${i5}`;
  }
  return j && (I.layerDefs = j), S3 && !j && (I.dynamicLayers = S3), I.layers = "popup" === f5 ? "visible" : f5, N && !S3 && (I.layers += `:${N.join(",")}`), I;
}
function l(e4) {
  var _a, _b;
  const { mapExtent: t2, floors: i5, width: o5, sublayers: l2, layerIds: m3, layerOption: p4, gdbVersion: f5 } = e4, y4 = (_b = (_a = l2 == null ? void 0 : l2.find((e5) => null != e5.layer)) == null ? void 0 : _a.layer) == null ? void 0 : _b.serviceSublayers, u3 = "popup" === p4, c2 = {}, d4 = i3({ extent: t2, width: o5, spatialReference: t2 == null ? void 0 : t2.spatialReference }), g2 = [], x = (e5) => {
    const t3 = 0 === d4, r5 = 0 === e5.minScale || d4 <= e5.minScale, i6 = 0 === e5.maxScale || d4 >= e5.maxScale;
    if (e5.visible && (t3 || r5 && i6)) if (e5.sublayers) e5.sublayers.forEach(x);
    else {
      if (false === (m3 == null ? void 0 : m3.includes(e5.id)) || u3 && (!e5.popupTemplate || !e5.popupEnabled)) return;
      g2.unshift(e5);
    }
  };
  if (l2 == null ? void 0 : l2.forEach(x), l2 && !g2.length) c2.layerIds = [];
  else {
    const e5 = n4(g2, y4, f5), t3 = g2.map((e6) => {
      const t4 = n5(i5, e6);
      return e6.toExportImageJSON(t4);
    });
    if (e5) c2.dynamicLayers = JSON.stringify(t3);
    else {
      if (l2) {
        let e7 = g2.map(({ id: e8 }) => e8);
        m3 && (e7 = e7.filter((e8) => m3.includes(e8))), c2.layerIds = e7;
      } else (m3 == null ? void 0 : m3.length) && (c2.layerIds = m3);
      const e6 = a2(i5, g2);
      if (null != e6 && e6.length) {
        const t4 = {};
        for (const r5 of e6) r5.definitionExpression && (t4[r5.id] = r5.definitionExpression);
        Object.keys(t4).length && (c2.layerDefs = JSON.stringify(t4));
      }
    }
  }
  return c2;
}
function a2(t2, r5) {
  const i5 = !!(t2 == null ? void 0 : t2.length), s4 = r5.filter((e4) => null != e4.definitionExpression || i5 && null != e4.floorInfo);
  return s4.length ? s4.map((r6) => {
    const i6 = n5(t2, r6), s5 = n2(i6, r6.definitionExpression);
    return { id: r6.id, definitionExpression: s5 ?? void 0 };
  }) : null;
}

// ../node_modules/@arcgis/core/rest/support/IdentifyParameters.js
var a3;
var u = a3 = class extends f {
  static from(t2) {
    return g(a3, t2);
  }
  constructor(t2) {
    super(t2), this.dpi = 96, this.floors = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = null, this.height = 400, this.historicMoment = null, this.layerIds = null, this.layerOption = "top", this.mapExtent = null, this.maxAllowableOffset = null, this.returnFieldName = true, this.returnGeometry = false, this.returnM = false, this.returnUnformattedValues = true, this.returnZ = false, this.spatialReference = null, this.sublayers = null, this.timeExtent = null, this.tolerance = null, this.width = 400;
  }
  writeHistoricMoment(t2, e4) {
    e4.historicMoment = t2 && t2.getTime();
  }
};
e([y({ type: Number, json: { write: true } })], u.prototype, "dpi", void 0), e([y()], u.prototype, "floors", void 0), e([y({ type: String, json: { write: true } })], u.prototype, "gdbVersion", void 0), e([y({ types: n, json: { read: y2, write: true } })], u.prototype, "geometry", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "geometryPrecision", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "height", void 0), e([y({ type: Date })], u.prototype, "historicMoment", void 0), e([r2("historicMoment")], u.prototype, "writeHistoricMoment", null), e([y({ type: [Number], json: { write: true } })], u.prototype, "layerIds", void 0), e([y({ type: ["top", "visible", "all", "popup"], json: { write: true } })], u.prototype, "layerOption", void 0), e([y({ type: w, json: { write: true } })], u.prototype, "mapExtent", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "maxAllowableOffset", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnFieldName", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnGeometry", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnM", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnUnformattedValues", void 0), e([y({ type: Boolean, json: { write: true } })], u.prototype, "returnZ", void 0), e([y({ type: f2, json: { write: true } })], u.prototype, "spatialReference", void 0), e([y()], u.prototype, "sublayers", void 0), e([y({ type: c, json: { write: true } })], u.prototype, "timeExtent", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "tolerance", void 0), e([y({ type: Number, json: { write: true } })], u.prototype, "width", void 0), u = a3 = e([a("esri.rest.support.IdentifyParameters")], u);
var d3 = u;

// ../node_modules/@arcgis/core/rest/support/IdentifyResult.js
var u2 = class extends f {
  constructor(r5) {
    super(r5), this.displayFieldName = null, this.feature = null, this.layerId = null, this.layerName = null;
  }
  readFeature(r5, t2) {
    return d2.fromJSON({ attributes: { ...t2.attributes }, geometry: { ...t2.geometry } });
  }
  writeFeature(r5, e4) {
    if (!r5) return;
    const { attributes: t2, geometry: o5 } = r5;
    t2 && (e4.attributes = { ...t2 }), null != o5 && (e4.geometry = o5.toJSON(), e4.geometryType = i.toJSON(o5.type));
  }
};
e([y({ type: String, json: { write: true } })], u2.prototype, "displayFieldName", void 0), e([y({ type: d2 })], u2.prototype, "feature", void 0), e([o("feature", ["attributes", "geometry"])], u2.prototype, "readFeature", null), e([r2("feature")], u2.prototype, "writeFeature", null), e([y({ type: Number, json: { write: true } })], u2.prototype, "layerId", void 0), e([y({ type: String, json: { write: true } })], u2.prototype, "layerName", void 0), u2 = e([a("esri.rest.support.IdentifyResult")], u2);
var m = u2;

// ../node_modules/@arcgis/core/rest/identify.js
async function f4(u3, i5, f5) {
  const c2 = (i5 = a4(i5)).geometry ? [i5.geometry] : [], l2 = f3(u3);
  return l2.path += "/identify", R(c2).then((e4) => {
    const t2 = o4(i5, { geometry: e4 == null ? void 0 : e4[0] }), u4 = s3({ ...l2.query, f: "json", ...t2 }), a6 = i2(u4, f5);
    return U(l2.path, a6).then(m2).then((r5) => p3(r5, i5.sublayers));
  });
}
function m2(r5) {
  const e4 = r5.data;
  return e4.results = e4.results || [], e4.exceededTransferLimit = Boolean(e4.exceededTransferLimit), e4.results = e4.results.map((r6) => m.fromJSON(r6)), e4;
}
function a4(r5) {
  return r5 = d3.from(r5);
}
function p3(r5, e4) {
  if (!(e4 == null ? void 0 : e4.length)) return r5;
  const t2 = /* @__PURE__ */ new Map();
  function o5(r6) {
    t2.set(r6.id, r6), r6.sublayers && r6.sublayers.forEach(o5);
  }
  e4.forEach(o5);
  for (const s4 of r5.results) s4.feature.sourceLayer = t2.get(s4.layerId);
  return r5;
}

// ../node_modules/@arcgis/core/views/layers/support/MapServiceLayerViewHelper.js
var S2 = null;
function U2(e4, t2) {
  return "tile" === t2.type || "map-image" === t2.type;
}
var _ = class extends S {
  constructor(e4) {
    super(e4), this._featuresResolutions = /* @__PURE__ */ new WeakMap(), this.highlightGraphics = null, this.highlightGraphicUpdated = null, this.updateHighlightedFeatures = k(async (e5) => {
      this.destroyed || this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(e5).catch(() => {
      }));
    });
  }
  initialize() {
    const e4 = (e5) => {
      this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(e5).catch(() => {
      })), this.updateHighlightedFeatures(this._highlightGeometriesResolution);
    };
    this.addHandles([v(() => this.highlightGraphics, "change", (t2) => e4(t2.added), { onListenerAdd: (t2) => e4(t2) })]);
  }
  async fetchPopupFeaturesAtLocation(e4, t2) {
    var _a, _b;
    const { layerView: { layer: r5, view: { scale: s4 } } } = this;
    if (!e4) throw new s("fetchPopupFeatures:invalid-area", "Nothing to fetch without area", { layer: r5 });
    const i5 = R2(r5.sublayers, s4, t2);
    if (!i5.length) return [];
    const a6 = await T(r5, i5);
    if (!((((_b = (_a = r5.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsIdentify) ?? true) && r5.version >= 10.5) && !a6) throw new s("fetchPopupFeatures:not-supported", "query operation is disabled for this service", { layer: r5 });
    return a6 ? this._fetchPopupFeaturesUsingQueries(e4, i5, t2) : this._fetchPopupFeaturesUsingIdentify(e4, i5, t2);
  }
  clearHighlights() {
    var _a;
    (_a = this.highlightGraphics) == null ? void 0 : _a.removeAll();
  }
  highlight(e4) {
    const r5 = this.highlightGraphics;
    if (!r5) return e2();
    let o5 = null;
    if (e4 instanceof d2 ? o5 = [e4] : V.isCollection(e4) && e4.length > 0 ? o5 = e4.toArray() : Array.isArray(e4) && e4.length > 0 && (o5 = e4), o5 = o5 == null ? void 0 : o5.filter(O), !(o5 == null ? void 0 : o5.length)) return e2();
    for (const t2 of o5) {
      const e5 = t2.sourceLayer;
      null != e5 && "geometryType" in e5 && "point" === e5.geometryType && (t2.visible = false);
    }
    return r5.addMany(o5), e2(() => r5.removeMany(o5 ?? []));
  }
  async _updateHighlightedFeaturesSymbols(e4) {
    const { layerView: { view: t2 }, highlightGraphics: r5, highlightGraphicUpdated: s4 } = this;
    if (r5 && s4) for (const i5 of e4) {
      const e5 = i5.sourceLayer && "renderer" in i5.sourceLayer && i5.sourceLayer.renderer;
      i5.sourceLayer && "geometryType" in i5.sourceLayer && "point" === i5.sourceLayer.geometryType && e5 && "getSymbolAsync" in e5 && e5.getSymbolAsync(i5).then(async (o5) => {
        var _a;
        o5 || (o5 = new y3());
        let a6 = null;
        const n7 = "visualVariables" in e5 ? (_a = e5.visualVariables) == null ? void 0 : _a.find((e6) => "size" === e6.type) : void 0;
        n7 && (S2 || (S2 = (await import("./visualVariableUtils-UXXQJZUU.js")).getSize), a6 = S2(n7, i5, { view: t2.type, scale: t2.scale, shape: "simple-marker" === o5.type ? o5.style : null })), a6 || (a6 = "width" in o5 && "height" in o5 && null != o5.width && null != o5.height ? Math.max(o5.width, o5.height) : "size" in o5 ? o5.size : 16), r5.includes(i5) && (i5.symbol = new y3({ style: "square", size: a6, xoffset: "xoffset" in o5 ? o5.xoffset : 0, yoffset: "yoffset" in o5 ? o5.yoffset : 0 }), s4(i5, "symbol"), i5.visible = true);
      });
    }
  }
  async _updateHighlightedFeaturesGeometries(e4) {
    const { layerView: { layer: t2, view: r5 }, highlightGraphics: s4, highlightGraphicUpdated: i5 } = this;
    if (this._highlightGeometriesResolution = e4, !i5 || !(s4 == null ? void 0 : s4.length) || !t2.capabilities.operations.supportsQuery) return;
    const o5 = this._getTargetResolution(e4), a6 = /* @__PURE__ */ new Map();
    for (const c2 of s4) if (!this._featuresResolutions.has(c2) || this._featuresResolutions.get(c2) > o5) {
      const e5 = c2.sourceLayer;
      r(a6, e5, () => /* @__PURE__ */ new Map()).set(c2.getObjectId(), c2);
    }
    const l2 = Array.from(a6, ([e5, t3]) => {
      const s5 = e5.createQuery();
      return s5.objectIds = [...t3.keys()], s5.outFields = [e5.objectIdField], s5.returnGeometry = true, s5.maxAllowableOffset = o5, s5.outSpatialReference = r5.spatialReference, e5.queryFeatures(s5);
    }), p4 = await Promise.all(l2);
    if (!this.destroyed) for (const { features: n7 } of p4) for (const e5 of n7) {
      const t3 = e5.sourceLayer, r6 = a6.get(t3).get(e5.getObjectId());
      r6 && s4.includes(r6) && (r6.geometry = e5.geometry, i5(r6, "geometry"), this._featuresResolutions.set(r6, o5));
    }
  }
  _getTargetResolution(e4) {
    const t2 = e4 * W(this.layerView.view.spatialReference), r5 = t2 / 16;
    return r5 <= 10 ? 0 : e4 / t2 * r5;
  }
  async _fetchPopupFeaturesUsingIdentify(e4, t2, r5) {
    const s4 = await this._createIdentifyParameters(e4, t2, r5);
    if (null == s4) return [];
    const { results: i5 } = await f4(this.layerView.layer.parsedUrl, s4, r5);
    return i5.map((e5) => e5.feature);
  }
  async _createIdentifyParameters(e4, t2, r5) {
    const { floors: s4, layer: i5, timeExtent: o5, view: { spatialReference: a6, scale: n7 } } = this.layerView;
    if (!t2.length) return null;
    await Promise.all(t2.map(({ sublayer: e5 }) => e5.load(r5).catch(() => {
    })));
    const l2 = Math.min(has("mapservice-popup-identify-max-tolerance"), i5.allSublayers.reduce((e5, t3) => t3.renderer ? o3({ renderer: t3.renderer, pointerType: r5 == null ? void 0 : r5.pointerType }) : e5, 2)), p4 = this.createFetchPopupFeaturesQueryGeometry(e4, l2), c2 = o2(n7, a6), u3 = Math.round(p4.width / c2), h = new w({ xmin: p4.center.x - c2 * u3, ymin: p4.center.y - c2 * u3, xmax: p4.center.x + c2 * u3, ymax: p4.center.y + c2 * u3, spatialReference: p4.spatialReference });
    return new d3({ floors: s4, gdbVersion: "gdbVersion" in i5 ? i5.gdbVersion : void 0, geometry: e4, height: u3, layerOption: "popup", mapExtent: h, returnGeometry: true, spatialReference: a6, sublayers: i5.sublayers, timeExtent: o5, tolerance: l2, width: u3 });
  }
  async _fetchPopupFeaturesUsingQueries(e4, t2, r5) {
    const { layerView: { floors: i5, timeExtent: o5 } } = this, a6 = t2.map(async ({ sublayer: t3, popupTemplate: s4 }) => {
      var _a;
      if (await t3.load(r5).catch(() => {
      }), t3.capabilities && !t3.capabilities.operations.supportsQuery) return [];
      const a7 = t3.createQuery(), n7 = o3({ renderer: t3.renderer, pointerType: r5 == null ? void 0 : r5.pointerType }), l2 = this.createFetchPopupFeaturesQueryGeometry(e4, n7), c2 = /* @__PURE__ */ new Set(), [h] = await Promise.all([n3(t3, s4), (_a = t3.renderer) == null ? void 0 : _a.collectRequiredFields(c2, t3.fieldsIndex)]);
      s2(r5), b(c2, t3.fieldsIndex, h);
      const y4 = Array.from(c2).sort();
      a7.geometry = l2, a7.outFields = y4, a7.timeExtent = o5;
      const m3 = n5(i5, t3);
      a7.where = n2(a7.where, m3);
      const f5 = this._getTargetResolution(l2.width / n7), d4 = await A(s4);
      s2(r5);
      const v2 = "point" === t3.geometryType || d4 && d4.arcadeUtils.hasGeometryOperations(s4);
      v2 || (a7.maxAllowableOffset = f5);
      let { features: j } = await t3.queryFeatures(a7, r5);
      const x = v2 ? 0 : f5;
      j = await V2(t3, j, r5);
      for (const e5 of j) this._featuresResolutions.set(e5, x);
      return j;
    });
    return (await Promise.allSettled(a6)).reduce((e5, t3) => "fulfilled" === t3.status ? [...e5, ...t3.value] : e5, []).filter(O);
  }
};
function R2(e4, t2, r5) {
  const s4 = [];
  if (!e4) return s4;
  const i5 = (e5) => {
    const o5 = 0 === e5.minScale || t2 <= e5.minScale, a6 = 0 === e5.maxScale || t2 >= e5.maxScale;
    if (e5.visible && o5 && a6) {
      if (e5.sublayers) e5.sublayers.forEach(i5);
      else if (e5.popupEnabled) {
        const t3 = p2(e5, { ...r5, defaultPopupTemplateEnabled: false });
        null != t3 && s4.unshift({ sublayer: e5, popupTemplate: t3 });
      }
    }
  };
  return e4.map(i5), s4;
}
function A(e4) {
  var _a;
  return ((_a = e4.expressionInfos) == null ? void 0 : _a.length) || Array.isArray(e4.content) && e4.content.some((e5) => "expression" === e5.type) ? i4() : Promise.resolve();
}
async function T(e4, t2) {
  var _a, _b;
  if ((_b = (_a = e4.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQuery) return true;
  try {
    return await Promise.any(t2.map(({ sublayer: e5 }) => e5.load().then(() => e5.capabilities.operations.supportsQuery)));
  } catch {
    return false;
  }
}
async function V2(e4, t2, r5) {
  const s4 = e4.renderer;
  return s4 && "defaultSymbol" in s4 && !s4.defaultSymbol && (t2 = s4.valueExpression ? await Promise.all(t2.map((e5) => s4.getSymbolAsync(e5, r5).then((t3) => t3 ? e5 : null))).then((e5) => e5.filter((e6) => null != e6)) : t2.filter((e5) => null != s4.getSymbol(e5))), t2;
}
e([y({ constructOnly: true })], _.prototype, "createFetchPopupFeaturesQueryGeometry", void 0), e([y({ constructOnly: true })], _.prototype, "layerView", void 0), e([y({ constructOnly: true })], _.prototype, "highlightGraphics", void 0), e([y({ constructOnly: true })], _.prototype, "highlightGraphicUpdated", void 0), e([y({ constructOnly: true })], _.prototype, "updatingHandles", void 0), _ = e([a("esri.views.layers.support.MapServiceLayerViewHelper")], _);

// ../node_modules/@arcgis/core/views/support/drapedUtils.js
function r4(t2, r5, i5, a6 = new w()) {
  let o5 = 0;
  if ("2d" === i5.type) o5 = r5 * (i5.resolution ?? 0);
  else if ("3d" === i5.type) {
    const n7 = i5.overlayPixelSizeInMapUnits(t2), a7 = i5.basemapSpatialReference;
    o5 = null == a7 || a7.equals(i5.spatialReference) ? r5 * n7 : W(a7) / W(i5.spatialReference);
  }
  const s4 = t2.x - o5, l2 = t2.y - o5, m3 = t2.x + o5, p4 = t2.y + o5, { spatialReference: c2 } = i5;
  return a6.xmin = Math.min(s4, m3), a6.ymin = Math.min(l2, p4), a6.xmax = Math.max(s4, m3), a6.ymax = Math.max(l2, p4), a6.spatialReference = c2, a6;
}
var a5 = new w();

export {
  U2 as U,
  _,
  r4 as r
};
//# sourceMappingURL=chunk-X37U4OFZ.js.map
