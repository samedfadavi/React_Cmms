import {
  p
} from "./chunk-OXBW45CN.js";
import {
  i as i3
} from "./chunk-UPDXKN2W.js";
import {
  i as i2
} from "./chunk-LAB5SETU.js";
import "./chunk-7W2VQZZM.js";
import {
  r,
  t
} from "./chunk-XPEOBWSB.js";
import "./chunk-PYM2YVDF.js";
import {
  n,
  p as p2
} from "./chunk-6DUA2ISU.js";
import {
  o
} from "./chunk-JSJ34DFQ.js";
import {
  m
} from "./chunk-E7HFITKU.js";
import {
  a,
  f as f2,
  i,
  s as s2
} from "./chunk-7TO4QD67.js";
import "./chunk-URNMKNS6.js";
import "./chunk-3QWMYL5A.js";
import {
  U,
  j,
  w as w3
} from "./chunk-MB5H6D2S.js";
import "./chunk-LVH66MEH.js";
import "./chunk-4FW6GTBF.js";
import "./chunk-E5ZJCKHO.js";
import "./chunk-YUQFVZCH.js";
import "./chunk-T4EIRKFE.js";
import {
  I as I2
} from "./chunk-OHUWK5XV.js";
import {
  L,
  w as w2
} from "./chunk-PHVKM5OH.js";
import {
  S
} from "./chunk-KQ5GHUVQ.js";
import "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-ZK2DM5OJ.js";
import "./chunk-TW7VY7XV.js";
import "./chunk-BL2UGYYZ.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import {
  C
} from "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import {
  w
} from "./chunk-7PMYO342.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import {
  R
} from "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import {
  f
} from "./chunk-F4OBDVPS.js";
import {
  G
} from "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import {
  I,
  W
} from "./chunk-WC4SPMPL.js";
import "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import "./chunk-GEH2VXFC.js";
import "./chunk-BJY5ADVY.js";
import "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  s2 as s
} from "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/webdoc/support/webdocSaveUtils.js
var A = ["NatGeo_World_Map", "Ocean_Basemap", "USA_Topo_Maps", "World_Imagery", "World_Street_Map", "World_Terrain_Base", "World_Topo_Map", "World_Hillshade", "Canvas/World_Light_Gray_Base", "Canvas/World_Light_Gray_Reference", "Canvas/World_Dark_Gray_Base", "Canvas/World_Dark_Gray_Reference", "Ocean/World_Ocean_Base", "Ocean/World_Ocean_Reference", "Reference/World_Boundaries_and_Places", "Reference/World_Reference_Overlay", "Reference/World_Transportation"].map((e) => e.toLowerCase());
async function U2(e, t2, r2) {
  r2 ?? (r2 = {}), C2(e, t2), await w(() => !t2.updatingFromView), await t2.load(), await V(t2), await r(t2), await D(e, t2);
  const a2 = t2.portalItem, { json: i4, jsonContext: n2 } = await O(t2, a2);
  return t(n2, { errorName: `${e.name}:save` }, r2), await x(t2, a2), await we(e, t2, a2, i4, n2), await Promise.all([t2.updateItemThumbnail(), p(t2.resourceReferences, n2)]), a2;
}
async function O(e, t2) {
  const o2 = o(t2, "web-map", true), r2 = e.write({}, o2);
  return await Promise.all(o2.resources.pendingOperations), { json: r2, jsonContext: o2 };
}
async function T(e, t2, r2, a2) {
  a2 ?? (a2 = {});
  const i4 = E(e, r2);
  await w(() => !t2.updatingFromView), await t2.load(), await V(t2), await r(t2), await D(e, t2);
  const { json: n2, jsonContext: s3 } = await O(t2, i4);
  t(s3, { errorName: `${e.name}:save` }, a2), await Y(t2, i4);
  const l = t2.getThumbnailState();
  return await ye(e, t2, i4, n2, s3, a2) && (t2.resourceReferences.portalItem = i4), t2.restoreThumbnailFromState(l), await Promise.all([t2.updateItemThumbnail(), p(t2.resourceReferences, s3)]), i4;
}
function C2(t2, o2) {
  if (!o2.portalItem) throw new s(`${t2.name}:portal-item-not-set`, "Portal item to save to has not been set on the WebMap");
  i3(o2.portalItem), M(t2, o2.portalItem);
}
function M(t2, o2) {
  if (o2.type !== t2.itemType) throw new s(`${t2.name}:portal-item-wrong-type`, `Portal item needs to have type "${t2.itemType}"`);
}
async function D(t2, r2) {
  var _a;
  if (!((_a = r2.basemap) == null ? void 0 : _a.baseLayers.length)) throw new s(`${t2.name}:save`, "Map does not have a valid basemap with a base layer.");
  let a2 = null;
  if (await w(() => {
    const e = U(r2.initialViewProperties, r2.basemap);
    return a2 = e.spatialReference, !e.updating;
  }), !G(a2, r2.initialViewProperties.spatialReference)) throw new s(`${t2.name}:save`, "The spatial reference of the basemap is not compatible with the one from the map.", { expected: r2.initialViewProperties.spatialReference, actual: a2 });
}
function E(e, t2) {
  let o2 = S.from(t2);
  return o2.id && (o2 = o2.clone(), o2.id = null), o2.type || (o2.type = e.itemType), o2.portal || (o2.portal = C.getDefault()), i3(o2), M(e, o2), o2;
}
function V(e) {
  const t2 = [];
  return e.basemap && t2.push(e.basemap.load()), e.ground && t2.push(e.ground.load()), Promise.allSettled(t2).then(() => {
  });
}
async function x(e, t2) {
  t2.extent = await ce(e.portalItem, e.initialViewProperties.viewpoint.targetGeometry), await Z(e, t2);
}
var G2 = f2.JSAPI;
var L2 = "CollectorDisabled";
var k = "Collector";
var $ = "Data Editing";
var B = "OfflineDisabled";
var N = "Offline";
var K = "Workforce Project";
var F = "Workforce Worker";
var H = "Workforce Dispatcher";
var J = "Offline Map Areas";
var q = "FieldMapsDisabled";
var z = f2.DEVELOPER_BASEMAP;
var Q = "UtilityNetwork";
var X = "IPS";
async function Y(e, t2) {
  a(t2, L2), a(t2, q), a(t2, f2.METADATA), a(t2, B), a(t2, J), a(t2, H), a(t2, K), a(t2, F), await x(e, t2);
}
async function Z(e, t2) {
  i(t2, G2), await ee(e), ae(e, t2), ie(e, t2), ne(e, t2), se(e, t2), le(e, t2), pe(e, t2), t2.typeKeywords && (t2.typeKeywords = t2.typeKeywords.filter((e2, t3, o2) => o2.indexOf(e2) === t3));
}
function ee(e) {
  const t2 = te(e).map((e2) => e2.load()).toArray();
  return Promise.allSettled(t2).then(() => {
  });
}
function te(e) {
  return e.allLayers.concat(e.allTables);
}
function oe(e) {
  return te(e).some((e2) => e2.loaded && L(e2) && e2.capabilities.operations.supportsEditing && e2.editingEnabled && ("subtype-group" !== e2.type || e2.sublayers.some((e3) => e3.editingEnabled)));
}
function re(e) {
  return te(e).filter((e2) => "group" !== e2.type).every((t2) => t2.loaded && fe(e, t2));
}
function ae(e, t2) {
  s2(t2, L2) || s2(t2, K) || s2(t2, F) || s2(t2, H) || !oe(e) ? a(t2, k) : i(t2, k);
}
function ie(e, t2) {
  oe(e) ? i(t2, $) : a(t2, $);
}
function ne(e, t2) {
  !s2(t2, B) && re(e) ? i(t2, N) : a(t2, N);
}
function se(e, t2) {
  w3(e.basemap) ? i(t2, z) : a(t2, z);
}
function le(e, t2) {
  var _a;
  ((_a = e.utilityNetworks) == null ? void 0 : _a.length) ? i(t2, Q) : a(t2, Q);
}
function pe(e, t2) {
  e.ipsInfo ? i(t2, X) : a(t2, X);
}
async function ce(e, t2) {
  const o2 = t2.clone().normalize();
  let r2;
  if (o2.length > 1) for (const a2 of o2) r2 ? a2.width > r2.width && (r2 = a2) : r2 = a2;
  else r2 = o2[0];
  return me(e, r2);
}
async function me(e, t2) {
  const o2 = t2.spatialReference;
  if (o2.isWGS84) return t2.clone();
  if (o2.isWebMercator) return R(t2);
  const { getGeometryServiceURL: r2 } = await import("./geometryServiceUtils-63NYHJCH.js"), a2 = await r2(e), i4 = new p2({ geometries: [t2], outSpatialReference: f.WGS84 });
  return (await n(a2, i4))[0];
}
function ue(e) {
  return w2(e) || "map-notes" === e.type || "route" === e.type;
}
function fe(e, t2) {
  return L(t2) && t2.capabilities.operations.supportsSync || ue(t2) && !t2.portalItem || ("tile" === t2.type || "vector-tile" === t2.type) && (t2.capabilities.operations.supportsExportTiles || de(t2) || j(t2)) && t2.spatialReference.equals(e.initialViewProperties.spatialReference);
}
function de(e) {
  return "tile" === e.type && (I2(e.url) && A.some((t2) => {
    var _a;
    return (_a = e.url) == null ? void 0 : _a.toLowerCase().includes("/" + t2 + "/");
  }));
}
async function we(e, t2, o2, r2, a2) {
  await o2.update({ data: r2 }), _e(e, t2, o2, r2, a2);
}
async function ye(t2, o2, r2, a2, i4, n2) {
  const s3 = o2.portalItem, l = { item: s3, authenticated: !(!(s3 == null ? void 0 : s3.id) || !s3.portal.user) }, p3 = r2.portal;
  await p3.signIn();
  const { copyAllowed: c, itemReloaded: m2 } = await he(l, p3);
  if (l.authenticated || (l.authenticated = m2), !c) throw new s(`${t2.name}:save-as-copy-not-allowed`, "Owner of this map does not allow others to save a copy");
  const u = await ge(r2, l, a2, n2);
  return o2.portalItem = r2, _e(t2, o2, r2, a2, i4), u;
}
async function he(e, t2) {
  var _a;
  const { item: o2, authenticated: r2 } = e;
  return (o2 == null ? void 0 : o2.id) && ((_a = o2.typeKeywords) == null ? void 0 : _a.includes("useOnly")) ? o2.portal.portalHostname !== t2.portalHostname ? { copyAllowed: false, itemReloaded: false } : (r2 || await o2.reload(), { copyAllowed: "admin" === o2.itemControl || "update" === o2.itemControl, itemReloaded: true }) : { copyAllowed: true, itemReloaded: false };
}
async function ge(e, t2, o2, a2) {
  var _a;
  const i4 = e.portal, { item: n2 } = t2, { folder: s3, copyAllResources: l } = a2;
  let p3 = false;
  if (l && (n2 == null ? void 0 : n2.id) && W(n2.portal.url, i4.url) && parseInt(n2.portal.currentVersion, 10) >= 2023) {
    const { total: e2 } = await n2.fetchResources();
    p3 = !!e2;
  }
  if (p3) {
    const t3 = await n2.copy({ copyResources: "all", folder: s3 });
    e.id = t3.id, e.portal = t3.portal;
    const r2 = e.toJSON();
    await e.load(), e.read(r2), await e.update({ data: o2 });
  } else await ((_a = i4.user) == null ? void 0 : _a.addItem({ item: e, folder: s3, data: o2 }));
  return p3;
}
function _e(e, o2, r2, n2, s3) {
  m.prototype.read.call(o2, { version: n2.version, authoringApp: n2.authoringApp, authoringAppVersion: n2.authoringAppVersion }, { origin: e.origin, ignoreDefaults: true, url: r2.itemUrl ? I(r2.itemUrl) : void 0 }), i2(s3), o2.resourceInfo = n2;
}
export {
  O as createJSON,
  U2 as save,
  T as saveAs
};
//# sourceMappingURL=webdocSaveUtils-762WSUFM.js.map
