import {
  createSelectorCreator,
  lruMemoize,
  require_shim
} from "./chunk-A4T5QUT7.js";
import {
  useEnhancedEffect_default
} from "./chunk-MRR25XVD.js";
import {
  _extends
} from "./chunk-EQCCHGRT.js";
import {
  require_jsx_runtime
} from "./chunk-LYX35WRP.js";
import {
  require_react
} from "./chunk-4JXTDHVJ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-XZXEUADC.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React5 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef = React5.useRef, useEffect2 = React5.useEffect, useMemo2 = React5.useMemo, useDebugValue = React5.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo2(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect2(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewProvider.js
var React3 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewContext.js
var React = __toESM(require_react(), 1);
var TreeViewContext = React.createContext(null);
if (true) TreeViewContext.displayName = "TreeViewContext";
var useTreeViewContext = () => {
  const context = React.useContext(TreeViewContext);
  if (context == null) {
    throw new Error(["MUI X: Could not find the Tree View context.", "It looks like you rendered your component outside of a SimpleTreeView or RichTreeView parent component.", "This can also happen if you are bundling multiple versions of the Tree View."].join("\n"));
  }
  return context;
};

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewStyleContext.js
var React2 = __toESM(require_react(), 1);
var TreeViewStyleContext = React2.createContext({
  classes: {},
  slots: {},
  slotProps: {}
});
if (true) TreeViewStyleContext.displayName = "TreeViewStyleContext";
var useTreeViewStyleContext = () => {
  return React2.useContext(TreeViewStyleContext);
};

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var EMPTY_OBJECT = {};
function TreeViewProvider(props) {
  const {
    contextValue,
    classes = EMPTY_OBJECT,
    slots = EMPTY_OBJECT,
    slotProps = EMPTY_OBJECT,
    children
  } = props;
  const styleContextValue = React3.useMemo(() => ({
    classes,
    slots: {
      collapseIcon: slots.collapseIcon,
      expandIcon: slots.expandIcon,
      endIcon: slots.endIcon
    },
    slotProps: {
      collapseIcon: slotProps.collapseIcon,
      expandIcon: slotProps.expandIcon,
      endIcon: slotProps.endIcon
    }
  }), [classes, slots.collapseIcon, slots.expandIcon, slots.endIcon, slotProps.collapseIcon, slotProps.expandIcon, slotProps.endIcon]);
  return (0, import_jsx_runtime.jsx)(TreeViewContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime.jsx)(TreeViewStyleContext.Provider, {
      value: styleContextValue,
      children: contextValue.wrapRoot({
        children
      })
    })
  });
}

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.itemPlugin.js
var React4 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/hooks/useSelector.js
var import_with_selector = __toESM(require_with_selector(), 1);
var defaultCompare = Object.is;
var useSelector = (store, selector, args = void 0, equals = defaultCompare) => {
  const selectorWithArgs = (state) => selector(state, args);
  return (0, import_with_selector.useSyncExternalStoreWithSelector)(store.subscribe, store.getSnapshot, store.getSnapshot, selectorWithArgs, equals);
};

// node_modules/@mui/x-tree-view/esm/internals/utils/selectors.js
var reselectCreateSelector = createSelectorCreator({
  memoize: lruMemoize,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is
  }
});
var cache = /* @__PURE__ */ new WeakMap();
var createSelector = (...createSelectorArgs) => {
  const selector = (state, selectorArgs) => {
    const cacheKey = state.cacheKey;
    let cacheForCurrentTreeViewInstance = cache.get(cacheKey);
    if (!cacheForCurrentTreeViewInstance) {
      cacheForCurrentTreeViewInstance = /* @__PURE__ */ new Map();
      cache.set(cacheKey, cacheForCurrentTreeViewInstance);
    }
    const cachedSelector = cacheForCurrentTreeViewInstance.get(createSelectorArgs);
    if (cachedSelector) {
      return cachedSelector(state, selectorArgs);
    }
    const fn = reselectCreateSelector(...createSelectorArgs);
    cacheForCurrentTreeViewInstance.set(createSelectorArgs, fn);
    return fn(state, selectorArgs);
  };
  return selector;
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.utils.js
var TREE_VIEW_ROOT_PARENT_ID = "__TREE_VIEW_ROOT_PARENT_ID__";
var buildSiblingIndexes = (siblings) => {
  const siblingsIndexLookup = {};
  siblings.forEach((childId, index) => {
    siblingsIndexLookup[childId] = index;
  });
  return siblingsIndexLookup;
};
var isItemDisabled = (itemMetaLookup, itemId) => {
  if (itemId == null) {
    return false;
  }
  let itemMeta = itemMetaLookup[itemId];
  if (!itemMeta) {
    return false;
  }
  if (itemMeta.disabled) {
    return true;
  }
  while (itemMeta.parentId != null) {
    itemMeta = itemMetaLookup[itemMeta.parentId];
    if (!itemMeta) {
      return false;
    }
    if (itemMeta.disabled) {
      return true;
    }
  }
  return false;
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.selectors.js
var selectorTreeViewItemsState = (state) => state.items;
var selectorIsTreeViewLoading = createSelector(selectorTreeViewItemsState, (items) => items.loading);
var selectorGetTreeViewError = createSelector(selectorTreeViewItemsState, (items) => items.error);
var selectorItemMetaLookup = createSelector(selectorTreeViewItemsState, (items) => items.itemMetaLookup);
var EMPTY_CHILDREN = [];
var selectorItemOrderedChildrenIds = createSelector([selectorTreeViewItemsState, (_, itemId) => itemId], (itemsState, itemId) => itemsState.itemOrderedChildrenIdsLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? EMPTY_CHILDREN);
var selectorItemModel = createSelector([selectorTreeViewItemsState, (_, itemId) => itemId], (itemsState, itemId) => itemsState.itemModelLookup[itemId]);
var selectorItemMeta = createSelector([selectorItemMetaLookup, (_, itemId) => itemId], (itemMetaLookup, itemId) => itemMetaLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? null);
var selectorIsItemDisabled = createSelector([selectorItemMetaLookup, (_, itemId) => itemId], isItemDisabled);
var selectorItemIndex = createSelector([selectorTreeViewItemsState, selectorItemMeta], (itemsState, itemMeta) => {
  if (itemMeta == null) {
    return -1;
  }
  const parentIndexes = itemsState.itemChildrenIndexesLookup[itemMeta.parentId ?? TREE_VIEW_ROOT_PARENT_ID];
  return parentIndexes[itemMeta.id];
});
var selectorItemParentId = createSelector([selectorItemMeta], (itemMeta) => (itemMeta == null ? void 0 : itemMeta.parentId) ?? null);
var selectorItemDepth = createSelector([selectorItemMeta], (itemMeta) => (itemMeta == null ? void 0 : itemMeta.depth) ?? 0);
var selectorDisabledItemFocusable = createSelector([selectorTreeViewItemsState], (itemsState) => itemsState.disabledItemsFocusable);
var selectorCanItemBeFocused = createSelector([selectorDisabledItemFocusable, selectorIsItemDisabled], (disabledItemsFocusable, isDisabled) => {
  if (disabledItemsFocusable) {
    return true;
  }
  return !isDisabled;
});

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.selectors.js
var selectorTreeViewLabelState = (state) => state.label;
var selectorIsItemEditable = createSelector([selectorTreeViewLabelState, (state, itemId) => selectorItemModel(state, itemId)], (labelState, itemModel) => {
  if (!itemModel || !labelState) {
    return false;
  }
  if (typeof labelState.isItemEditable === "boolean") {
    return labelState.isItemEditable;
  }
  return labelState.isItemEditable(itemModel);
});
var selectorIsItemBeingEdited = createSelector([selectorTreeViewLabelState, (_, itemId) => itemId], (labelState, itemId) => itemId ? (labelState == null ? void 0 : labelState.editedItemId) === itemId : false);
var selectorIsAnyItemBeingEdited = createSelector(selectorTreeViewLabelState, (labelState) => !!(labelState == null ? void 0 : labelState.editedItemId));

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.itemPlugin.js
var useTreeViewLabelItemPlugin = ({
  props
}) => {
  const {
    store
  } = useTreeViewContext();
  const {
    label,
    itemId
  } = props;
  const [labelInputValue, setLabelInputValue] = React4.useState(label);
  const isItemEditable = useSelector(store, selectorIsItemEditable, itemId);
  const isItemBeingEdited = useSelector(store, selectorIsItemBeingEdited, itemId);
  React4.useEffect(() => {
    if (!isItemBeingEdited) {
      setLabelInputValue(label);
    }
  }, [isItemBeingEdited, label]);
  return {
    propsEnhancers: {
      label: () => ({
        editable: isItemEditable
      }),
      labelInput: ({
        externalEventHandlers,
        interactions
      }) => {
        if (!isItemEditable) {
          return {};
        }
        const handleKeydown = (event) => {
          var _a;
          (_a = externalEventHandlers.onKeyDown) == null ? void 0 : _a.call(externalEventHandlers, event);
          if (event.defaultMuiPrevented) {
            return;
          }
          const target = event.target;
          if (event.key === "Enter" && target.value) {
            interactions.handleSaveItemLabel(event, target.value);
          } else if (event.key === "Escape") {
            interactions.handleCancelItemLabelEditing(event);
          }
        };
        const handleBlur = (event) => {
          var _a;
          (_a = externalEventHandlers.onBlur) == null ? void 0 : _a.call(externalEventHandlers, event);
          if (event.defaultMuiPrevented) {
            return;
          }
          if (event.target.value) {
            interactions.handleSaveItemLabel(event, event.target.value);
          }
        };
        const handleInputChange = (event) => {
          var _a;
          (_a = externalEventHandlers.onChange) == null ? void 0 : _a.call(externalEventHandlers, event);
          setLabelInputValue(event.target.value);
        };
        return {
          value: labelInputValue ?? "",
          "data-element": "labelInput",
          onChange: handleInputChange,
          onKeyDown: handleKeydown,
          onBlur: handleBlur,
          autoFocus: true,
          type: "text"
        };
      }
    }
  };
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.js
var useTreeViewLabel = ({
  store,
  params
}) => {
  const setEditedItem = (editedItemId) => {
    if (editedItemId !== null) {
      const isEditable = selectorIsItemEditable(store.value, editedItemId);
      if (!isEditable) {
        return;
      }
    }
    store.update((prevState) => _extends({}, prevState, {
      label: _extends({}, prevState.label, {
        editedItemId
      })
    }));
  };
  const updateItemLabel = (itemId, label) => {
    if (!label) {
      throw new Error(["MUI X: The Tree View component requires all items to have a `label` property.", "The label of an item cannot be empty.", itemId].join("\n"));
    }
    store.update((prevState) => {
      const item = prevState.items.itemMetaLookup[itemId];
      if (item.label !== label) {
        return _extends({}, prevState, {
          items: _extends({}, prevState.items, {
            itemMetaLookup: _extends({}, prevState.items.itemMetaLookup, {
              [itemId]: _extends({}, item, {
                label
              })
            })
          })
        });
      }
      return prevState;
    });
    if (params.onItemLabelChange) {
      params.onItemLabelChange(itemId, label);
    }
  };
  useEnhancedEffect_default(() => {
    store.update((prevState) => _extends({}, prevState, {
      label: _extends({}, prevState.label, {
        isItemEditable: params.isItemEditable
      })
    }));
  }, [store, params.isItemEditable]);
  return {
    instance: {
      setEditedItem,
      updateItemLabel
    },
    publicAPI: {
      setEditedItem,
      updateItemLabel
    }
  };
};
useTreeViewLabel.itemPlugin = useTreeViewLabelItemPlugin;
useTreeViewLabel.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  isItemEditable: params.isItemEditable ?? false
});
useTreeViewLabel.getInitialState = (params) => ({
  label: {
    isItemEditable: params.isItemEditable,
    editedItemId: null
  }
});
useTreeViewLabel.params = {
  onItemLabelChange: true,
  isItemEditable: true
};

// node_modules/@mui/x-tree-view/esm/internals/utils/plugins.js
var hasPlugin = (instance, plugin) => {
  const plugins = instance.getAvailablePlugins();
  return plugins.has(plugin);
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewExpansion/useTreeViewExpansion.selectors.js
var selectorExpansion = (state) => state.expansion;
var selectorExpandedItems = createSelector([selectorExpansion], (expansionState) => expansionState.expandedItems);
var selectorExpandedItemsMap = createSelector([selectorExpandedItems], (expandedItems) => {
  const expandedItemsMap = /* @__PURE__ */ new Map();
  expandedItems.forEach((id) => {
    expandedItemsMap.set(id, true);
  });
  return expandedItemsMap;
});
var selectorIsItemExpanded = createSelector([selectorExpandedItemsMap, (_, itemId) => itemId], (expandedItemsMap, itemId) => expandedItemsMap.has(itemId));
var selectorIsItemExpandable = createSelector([selectorItemMeta], (itemMeta) => (itemMeta == null ? void 0 : itemMeta.expandable) ?? false);
var selectorItemExpansionTrigger = createSelector([selectorExpansion], (expansionState) => expansionState.expansionTrigger);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.selectors.js
var selectorTreeViewSelectionState = (state) => state.selection;
var selectorSelectionModel = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.selectedItems);
var selectorSelectionModelArray = createSelector([selectorSelectionModel], (selectedItems) => {
  if (Array.isArray(selectedItems)) {
    return selectedItems;
  }
  if (selectedItems != null) {
    return [selectedItems];
  }
  return [];
});
var selectorSelectionModelMap = createSelector([selectorSelectionModelArray], (selectedItems) => {
  const selectedItemsMap = /* @__PURE__ */ new Map();
  selectedItems.forEach((id) => {
    selectedItemsMap.set(id, true);
  });
  return selectedItemsMap;
});
var selectorIsItemSelected = createSelector([selectorSelectionModelMap, (_, itemId) => itemId], (selectedItemsMap, itemId) => selectedItemsMap.has(itemId));
var selectorIsMultiSelectEnabled = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.isEnabled && selectionState.isMultiSelectEnabled);
var selectorIsSelectionEnabled = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.isEnabled);
var selectorIsCheckboxSelectionEnabled = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.isCheckboxSelectionEnabled);
var selectorIsItemSelectionEnabled = createSelector([selectorIsItemDisabled, selectorIsSelectionEnabled], (isItemDisabled2, isSelectionEnabled) => isSelectionEnabled && !isItemDisabled2);
var selectorSelectionPropagationRules = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.selectionPropagation);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewFocus/useTreeViewFocus.selectors.js
var selectorTreeViewFocusState = (state) => state.focus;
var selectorDefaultFocusableItemId = createSelector([selectorSelectionModelArray, selectorExpandedItemsMap, selectorItemMetaLookup, selectorDisabledItemFocusable, (state) => selectorItemOrderedChildrenIds(state, null)], (selectedItems, expandedItemsMap, itemMetaLookup, disabledItemsFocusable, orderedRootItemIds) => {
  const firstSelectedItem = selectedItems.find((itemId) => {
    if (!disabledItemsFocusable && isItemDisabled(itemMetaLookup, itemId)) {
      return false;
    }
    const itemMeta = itemMetaLookup[itemId];
    return itemMeta && (itemMeta.parentId == null || expandedItemsMap.has(itemMeta.parentId));
  });
  if (firstSelectedItem != null) {
    return firstSelectedItem;
  }
  const firstNavigableItem = orderedRootItemIds.find((itemId) => disabledItemsFocusable || !isItemDisabled(itemMetaLookup, itemId));
  if (firstNavigableItem != null) {
    return firstNavigableItem;
  }
  return null;
});
var selectorIsItemTheDefaultFocusableItem = createSelector([selectorDefaultFocusableItemId, (_, itemId) => itemId], (defaultFocusableItemId, itemId) => defaultFocusableItemId === itemId);
var selectorFocusedItemId = createSelector(selectorTreeViewFocusState, (focus) => focus.focusedItemId);
var selectorIsItemFocused = createSelector([selectorFocusedItemId, (_, itemId) => itemId], (focusedItemId, itemId) => focusedItemId === itemId);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLazyLoading/useTreeViewLazyLoading.selectors.js
var selectorLazyLoading = (state) => state.lazyLoading;
var selectorLazyLoadingOptional = (state) => state.lazyLoading;
var selectorDataSourceState = createSelector([selectorLazyLoading], (lazyLoading) => lazyLoading.dataSource);
var selectorIsLazyLoadingEnabled = createSelector([selectorLazyLoadingOptional], (lazyLoading) => !!(lazyLoading == null ? void 0 : lazyLoading.enabled));
var selectorIsItemLoading = createSelector([selectorDataSourceState, (_, itemId) => itemId], (dataSourceState, itemId) => dataSourceState.loading[itemId] || false);
var selectorGetTreeItemError = createSelector([selectorDataSourceState, (_, itemId) => itemId], (dataSourceState, itemId) => dataSourceState.errors[itemId] || null);

// node_modules/@mui/x-tree-view/esm/hooks/useTreeItemUtils/useTreeItemUtils.js
var itemHasChildren = (reactChildren) => {
  if (Array.isArray(reactChildren)) {
    return reactChildren.length > 0 && reactChildren.some(itemHasChildren);
  }
  return Boolean(reactChildren);
};
var useTreeItemUtils = ({
  itemId,
  children
}) => {
  const {
    instance,
    store,
    publicAPI
  } = useTreeViewContext();
  const isItemExpandable = useSelector(store, selectorIsItemExpandable, itemId);
  const isLazyLoadingEnabled = useSelector(store, selectorIsLazyLoadingEnabled);
  const isMultiSelectEnabled = useSelector(store, selectorIsMultiSelectEnabled);
  const loading = useSelector(store, (state) => isLazyLoadingEnabled ? selectorIsItemLoading(state, itemId) : false);
  const error = useSelector(store, (state) => isLazyLoadingEnabled ? Boolean(selectorGetTreeItemError(state, itemId)) : false);
  const isExpandable = itemHasChildren(children) || isItemExpandable;
  const isExpanded = useSelector(store, selectorIsItemExpanded, itemId);
  const isFocused = useSelector(store, selectorIsItemFocused, itemId);
  const isSelected = useSelector(store, selectorIsItemSelected, itemId);
  const isDisabled = useSelector(store, selectorIsItemDisabled, itemId);
  const isEditing = useSelector(store, selectorIsItemBeingEdited, itemId);
  const isEditable = useSelector(store, selectorIsItemEditable, itemId);
  const status = {
    expandable: isExpandable,
    expanded: isExpanded,
    focused: isFocused,
    selected: isSelected,
    disabled: isDisabled,
    editing: isEditing,
    editable: isEditable,
    loading,
    error
  };
  const handleExpansion = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused) {
      instance.focusItem(event, itemId);
    }
    const multiple = isMultiSelectEnabled && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (status.expandable && !(multiple && selectorIsItemExpanded(store.value, itemId))) {
      instance.setItemExpansion({
        event,
        itemId
      });
    }
  };
  const handleSelection = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused && !status.editing) {
      instance.focusItem(event, itemId);
    }
    const multiple = isMultiSelectEnabled && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (multiple) {
      if (event.shiftKey) {
        instance.expandSelectionRange(event, itemId);
      } else {
        instance.setItemSelection({
          event,
          itemId,
          keepExistingSelection: true
        });
      }
    } else {
      instance.setItemSelection({
        event,
        itemId,
        shouldBeSelected: true
      });
    }
  };
  const handleCheckboxSelection = (event) => {
    const hasShift = event.nativeEvent.shiftKey;
    if (isMultiSelectEnabled && hasShift) {
      instance.expandSelectionRange(event, itemId);
    } else {
      instance.setItemSelection({
        event,
        itemId,
        keepExistingSelection: isMultiSelectEnabled,
        shouldBeSelected: event.target.checked
      });
    }
  };
  const toggleItemEditing = () => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (isEditing) {
      instance.setEditedItem(null);
    } else {
      instance.setEditedItem(itemId);
    }
  };
  const handleSaveItemLabel = (event, newLabel) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (selectorIsItemBeingEdited(store.value, itemId)) {
      instance.updateItemLabel(itemId, newLabel);
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const handleCancelItemLabelEditing = (event) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (selectorIsItemBeingEdited(store.value, itemId)) {
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const interactions = {
    handleExpansion,
    handleSelection,
    handleCheckboxSelection,
    toggleItemEditing,
    handleSaveItemLabel,
    handleCancelItemLabelEditing
  };
  return {
    interactions,
    status,
    publicAPI
  };
};

export {
  useSelector,
  createSelector,
  useTreeViewContext,
  useTreeViewStyleContext,
  TreeViewProvider,
  TREE_VIEW_ROOT_PARENT_ID,
  buildSiblingIndexes,
  selectorIsTreeViewLoading,
  selectorGetTreeViewError,
  selectorItemMetaLookup,
  selectorItemOrderedChildrenIds,
  selectorItemModel,
  selectorItemMeta,
  selectorIsItemDisabled,
  selectorItemIndex,
  selectorItemParentId,
  selectorItemDepth,
  selectorCanItemBeFocused,
  selectorExpandedItems,
  selectorIsItemExpanded,
  selectorIsItemExpandable,
  selectorItemExpansionTrigger,
  selectorSelectionModel,
  selectorSelectionModelArray,
  selectorIsItemSelected,
  selectorIsMultiSelectEnabled,
  selectorIsSelectionEnabled,
  selectorIsCheckboxSelectionEnabled,
  selectorIsItemSelectionEnabled,
  selectorSelectionPropagationRules,
  selectorDefaultFocusableItemId,
  selectorIsItemTheDefaultFocusableItem,
  selectorFocusedItemId,
  hasPlugin,
  selectorIsItemEditable,
  selectorIsItemBeingEdited,
  useTreeViewLabel,
  useTreeItemUtils
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-RNO7ZPBG.js.map
