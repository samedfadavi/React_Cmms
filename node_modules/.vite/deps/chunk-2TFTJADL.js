import {
  l as l2,
  n2 as n4,
  t as t2
} from "./chunk-RSPPQPTD.js";
import {
  l
} from "./chunk-Z2KLKC47.js";
import {
  b as b3,
  m as m2,
  y as y2
} from "./chunk-MB5H6D2S.js";
import {
  F
} from "./chunk-LVH66MEH.js";
import {
  t
} from "./chunk-E5ZJCKHO.js";
import {
  o as o3
} from "./chunk-LTSQHA4C.js";
import {
  B,
  O
} from "./chunk-PHVKM5OH.js";
import {
  u as u3
} from "./chunk-4AGGGL2W.js";
import {
  n as n3,
  r as r2
} from "./chunk-E5KBRIJQ.js";
import {
  o as o2
} from "./chunk-Z32PAECZ.js";
import {
  n as n2
} from "./chunk-TW7VY7XV.js";
import {
  m
} from "./chunk-YTTIKQNA.js";
import {
  A,
  d
} from "./chunk-7PMYO342.js";
import {
  V
} from "./chunk-3DBICPHD.js";
import {
  o
} from "./chunk-ZK4LSXOH.js";
import {
  r
} from "./chunk-F4OBDVPS.js";
import {
  s as s3
} from "./chunk-4ZEH5SNV.js";
import {
  S,
  f2 as f,
  u3 as u2,
  y
} from "./chunk-TJUEGVVG.js";
import {
  N,
  a3 as a2,
  b
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  b as b2,
  e as e2,
  s as s2
} from "./chunk-VMWKLHJD.js";
import {
  u
} from "./chunk-5AEITAWU.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-YNL57W4I.js";

// ../node_modules/@arcgis/core/ground/NavigationConstraint.js
var s4;
var p = s4 = class extends f {
  constructor(o4) {
    super(o4), this.type = "none";
  }
  clone() {
    return new s4({ type: this.type });
  }
};
e([o2({ none: "none", stayAbove: "stay-above" })], p.prototype, "type", void 0), p = s4 = e([a2("esri.ground.NavigationConstraint")], p);

// ../node_modules/@arcgis/core/Ground.js
var S2;
var C = S2 = class extends u2(m) {
  constructor(r4) {
    super(r4), this.opacity = 1, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new V();
    const e4 = (r5) => {
      r5.parent && r5.parent !== this && "remove" in r5.parent && r5.parent.remove(r5), r5.parent = this, "elevation" !== r5.type && "base-elevation" !== r5.type && n.getLogger(this).error(`Layer '${r5.title}, id:${r5.id}' of type '${r5.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, t4 = (r5) => {
      r5.parent = null;
    };
    this.addHandles([this.layers.on("after-add", (r5) => e4(r5.item)), this.layers.on("after-remove", (r5) => t4(r5.item))]);
  }
  initialize() {
    this.when().catch((r4) => {
      b2(r4) || n.getLogger(this).error("#load()", "Failed to load ground", r4);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const r4 = this.layers.removeAll();
    for (const e4 of r4) u(e4);
    this.layers.destroy();
  }
  normalizeCtorArgs(r4) {
    return r4 && "resourceInfo" in r4 && (this._set("resourceInfo", r4.resourceInfo), delete (r4 = { ...r4 }).resourceInfo), r4;
  }
  set layers(r4) {
    this._set("layers", n2(r4, this._get("layers")));
  }
  writeLayers(r4, e4, o4, t4) {
    const i2 = [];
    r4 ? (t4 = { ...t4, layerContainerType: "ground" }, r4.forEach((r5) => {
      if ("write" in r5) {
        const e5 = {};
        o3(r5)().write(e5, t4) && i2.push(e5);
      } else (t4 == null ? void 0 : t4.messages) && t4.messages.push(new s("layer:unsupported", `Layers (${r5.title}, ${r5.id}) of type '${r5.declaredClass}' cannot be persisted in the ground`, { layer: r5 }));
    }), e4.layers = i2) : e4.layers = i2;
  }
  load(r4) {
    return this.addResolvingPromise(this._loadFromSource(r4)), Promise.resolve(this);
  }
  loadAll() {
    return t(this, (r4) => {
      r4(this.layers);
    });
  }
  async queryElevation(r4, e4) {
    await this.load({ signal: e4 == null ? void 0 : e4.signal });
    const { ElevationQuery: o4 } = await import("./ElevationQuery-2JLHE3OU.js");
    s2(e4);
    const t4 = new o4(), s5 = this.layers.filter(L).toArray();
    return t4.queryAll(s5, r4, e4);
  }
  async createElevationSampler(r4, e4) {
    await this.load({ signal: e4 == null ? void 0 : e4.signal });
    const { ElevationQuery: o4 } = await import("./ElevationQuery-2JLHE3OU.js");
    s2(e4);
    const t4 = new o4(), s5 = this.layers.filter(L).toArray();
    return t4.createSamplerAll(s5, r4, e4);
  }
  clone() {
    const r4 = { opacity: this.opacity, surfaceColor: a(this.surfaceColor), navigationConstraint: a(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (r4.loadStatus = "loaded"), new S2({ resourceInfo: this.resourceInfo }).set(r4);
  }
  read(r4, e4) {
    this.resourceInfo || this._set("resourceInfo", { data: r4, context: e4 }), super.read(r4, e4);
  }
  _loadFromSource(r4) {
    const e4 = this.resourceInfo;
    return e4 ? this._loadLayersFromJSON(e4.data, e4.context, r4) : Promise.resolve();
  }
  async _loadLayersFromJSON(r4, e4, o4) {
    const t4 = (e4 == null ? void 0 : e4.origin) || "web-scene", s5 = (e4 == null ? void 0 : e4.portal) || null, a5 = (e4 == null ? void 0 : e4.url) || null, { populateOperationalLayers: i2 } = await import("./layersCreator-YSCMKCBR.js");
    s2(o4);
    const n6 = [];
    if (r4.layers && Array.isArray(r4.layers)) {
      const e5 = { context: { origin: t4, url: a5, portal: s5, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
      n6.push(i2(this.layers, r4.layers, e5));
    }
    await Promise.allSettled(n6);
  }
};
function I(r4) {
  return r4 && "createElevationSampler" in r4;
}
function L(r4) {
  return "elevation" === r4.type || I(r4);
}
e([y({ json: { read: false } })], C.prototype, "layers", null), e([r("layers")], C.prototype, "writeLayers", null), e([y({ readOnly: true })], C.prototype, "resourceInfo", void 0), e([y({ type: Number, nonNullable: true, range: { min: 0, max: 1 }, json: { type: N, read: { reader: r2, source: "transparency" }, write: { writer: (r4, e4) => {
  e4.transparency = n3(r4);
}, target: "transparency" } } })], C.prototype, "opacity", void 0), e([y({ type: u3, json: { type: [N], write: (r4, e4) => {
  e4.surfaceColor = r4.toJSON().slice(0, 3);
} } })], C.prototype, "surfaceColor", void 0), e([y({ type: p, json: { write: true } })], C.prototype, "navigationConstraint", void 0), C = S2 = e([a2("esri.Ground")], C);
var b4 = C;

// ../node_modules/@arcgis/core/layers/catalog/catalogUtils.js
var r3 = /* @__PURE__ */ new WeakMap();
function a3(o4) {
  return !o4.destroyed && (r3.has(o4) || o4.addHandles([d(() => {
    const e4 = o4.parent;
    return !(!e4 || !("type" in e4)) && ("catalog-dynamic-group" === e4.type || a3(e4));
  }, (e4) => r3.set(o4, e4), A), e2(() => r3.delete(o4))]), r3.get(o4));
}

// ../node_modules/@arcgis/core/layers/support/editableLayers.js
function n5(t4) {
  return "object" == typeof t4 && null != t4 && "loaded" in t4 && true === t4.loaded && "type" in t4;
}
function e3(e4) {
  var _a, _b;
  return !(!n5(e4) || !((_b = (_a = O(e4)) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsEditing) || "editingEnabled" in e4 && !B(e4) || a3(e4));
}

// ../node_modules/@arcgis/core/support/groundUtils.js
var i = { "world-elevation": { id: "worldElevation", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" }, "world-topobathymetry": { id: "worldTopoBathymetry", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/TopoBathy3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" } };
function t3(t4) {
  let a5 = null;
  if ("string" == typeof t4) if (t4 in i) {
    const r4 = i[t4];
    a5 = new b4({ resourceInfo: { data: { layers: [r4] } } });
  } else n.getLogger("esri.support.groundUtils").warn(`Unable to find ground definition for: ${t4}. Try "world-elevation"`);
  else a5 = b(b4, t4);
  return a5;
}

// ../node_modules/@arcgis/core/Map.js
var j = class extends n4(l2(o.EventedMixin(S))) {
  constructor(e4) {
    super(e4), this.allLayers = new l({ getCollections: () => {
      var _a, _b, _c;
      return [(_a = this.basemap) == null ? void 0 : _a.baseLayers, (_b = this.ground) == null ? void 0 : _b.layers, this.layers, (_c = this.basemap) == null ? void 0 : _c.referenceLayers];
    }, getChildrenFunction: (e5) => "layers" in e5 ? e5.layers : null }), this.allTables = t2(this), this.basemap = null, this.editableLayers = new l({ getCollections: () => [this.allLayers], itemFilterFunction: e3 }), this.ground = new b4(), this._basemapCache = y2();
  }
  destroy() {
    m2(this._basemapCache), this._basemapCache = null, this.allLayers.destroy(), this.allTables.destroy(), this.editableLayers.destroy(), this.basemap = u(this.basemap), u(this.ground), this._set("ground", null);
  }
  castBasemap(e4) {
    return b3(e4, this._basemapCache);
  }
  castGround(e4) {
    const s5 = t3(e4);
    return s5 ?? this._get("ground");
  }
  findLayerById(e4) {
    return this.allLayers.find((s5) => s5.id === e4);
  }
  findTableById(e4) {
    return this.allTables.find((s5) => s5.id === e4);
  }
};
e([y({ readOnly: true, dependsOn: [] })], j.prototype, "allLayers", void 0), e([y({ readOnly: true })], j.prototype, "allTables", void 0), e([y({ type: F, json: { read: { source: "baseMap" }, write: { target: "baseMap" } } })], j.prototype, "basemap", void 0), e([s3("basemap")], j.prototype, "castBasemap", null), e([y({ readOnly: true })], j.prototype, "editableLayers", void 0), e([y({ type: b4, nonNullable: true })], j.prototype, "ground", void 0), e([s3("ground")], j.prototype, "castGround", null), e([y()], j.prototype, "undoRedo", void 0), j = e([a2("esri.Map")], j);
var L2 = j;

// ../node_modules/@arcgis/core/webmap/background/ColorBackground.js
var p2;
var a4 = p2 = class extends f {
  constructor(o4) {
    super(o4), this.color = new u3([0, 0, 0, 1]);
  }
  clone() {
    return new p2(a({ color: this.color }));
  }
};
e([y({ type: u3, json: { write: true } })], a4.prototype, "color", void 0), a4 = p2 = e([a2("esri.webmap.background.ColorBackground")], a4);
var m3 = a4;

export {
  L2 as L,
  m3 as m
};
//# sourceMappingURL=chunk-2TFTJADL.js.map
