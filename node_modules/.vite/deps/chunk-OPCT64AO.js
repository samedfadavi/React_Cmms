import {
  l
} from "./chunk-G36SOMYZ.js";

// ../node_modules/@arcgis/core/core/MemCache.js
var e = -3;
var s = e - 1;
var i;
!function(t) {
  t[t.ALL = 0] = "ALL", t[t.SOME = 1] = "SOME";
}(i || (i = {}));
var r = class {
  constructor(t, e3, s2) {
    this.name = t, this._storage = e3, this.id = o++ + ":", this.size = 0, this.maxSize = -1, this._removeFunc = false, this._hit = 0, this._miss = 0, this._storage.register(this), s2 && (this._storage.registerRemoveFunc(this.id, s2), this._removeFunc = true);
  }
  destroy() {
    this._storage.clear(this), this._removeFunc && this._storage.deregisterRemoveFunc(this.id), this._storage.deregister(this), this._storage = null;
  }
  get hitRate() {
    return this._hit / (this._hit + this._miss);
  }
  get storageSize() {
    return this._storage.size;
  }
  getSize(t) {
    return this._storage.getSize(this, t);
  }
  resetHitRate() {
    this._hit = this._miss = 0;
  }
  put(t, e3, s2, i2 = 0) {
    this._storage.put(this, t, e3, s2, i2);
  }
  pop(t) {
    const e3 = this._storage.pop(this, t);
    return void 0 === e3 ? ++this._miss : ++this._hit, e3;
  }
  get(t) {
    const e3 = this._storage.get(this, t);
    return void 0 === e3 ? ++this._miss : ++this._hit, e3;
  }
  peek(t) {
    return this._storage.peek(this, t);
  }
  updateSize(t, e3, s2) {
    this._storage.updateSize(this, t, e3, s2);
  }
  clear() {
    this._storage.clear(this);
  }
  clearAll() {
    this._storage.clearAll();
  }
  get performanceInfo() {
    return this._storage.performanceInfo;
  }
  resetStats() {
    this._storage.resetStats();
  }
};
var h = class {
  get size() {
    return this._size;
  }
  constructor(e3 = 10485760) {
    this._maxSize = e3, this._db = /* @__PURE__ */ new Map(), this._size = 0, this._hit = 0, this._miss = 0, this._removeFuncs = new l(), this._users = new l();
  }
  destroy() {
    this.clearAll(), this._removeFuncs.clear(), this._users.clear(), this._db = null;
  }
  register(t) {
    this._users.push(t);
  }
  deregister(t) {
    this._users.removeUnordered(t);
  }
  registerRemoveFunc(t, e3) {
    this._removeFuncs.push([t, e3]);
  }
  deregisterRemoveFunc(t) {
    this._removeFuncs.filterInPlace((e3) => e3[0] !== t);
  }
  get maxSize() {
    return this._maxSize;
  }
  set maxSize(t) {
    this._maxSize = Math.max(t, -1), this._checkSize();
  }
  getSize(t, e3) {
    const s2 = this._db.get(t.id + e3);
    return (s2 == null ? void 0 : s2.size) ?? 0;
  }
  put(t, r2, h2, o2, _) {
    r2 = t.id + r2;
    const a = this._db.get(r2);
    if (a && (this._size -= a.size, t.size -= a.size, this._db.delete(r2), a.entry !== h2 && this._notifyRemove(r2, a.entry, a.size, i.ALL)), o2 > this._maxSize) return void this._notifyRemove(r2, h2, o2, i.ALL);
    if (void 0 === h2) return void console.warn("Refusing to cache undefined entry ");
    if (!o2 || o2 < 0) return console.warn(`Refusing to cache entry with size ${o2} for key ${r2}`), void this._notifyRemove(r2, h2, 0, i.ALL);
    const c = 1 + Math.max(_, s) - e;
    this._db.set(r2, new n(h2, o2, c)), this._size += o2, t.size += o2, this._checkSize();
  }
  updateSize(t, e3, s2, r2) {
    e3 = t.id + e3;
    const h2 = this._db.get(e3);
    if (h2 && h2.entry === s2) {
      for (this._size -= h2.size, t.size -= h2.size; r2 > this._maxSize; ) {
        const t2 = this._notifyRemove(e3, s2, r2, i.SOME);
        if (!(null != t2 && t2 > 0)) return void this._db.delete(e3);
        r2 = t2;
      }
      h2.size = r2, this._size += r2, t.size += r2, this._checkSize();
    }
  }
  pop(t, e3) {
    e3 = t.id + e3;
    const s2 = this._db.get(e3);
    if (s2) return this._size -= s2.size, t.size -= s2.size, this._db.delete(e3), ++this._hit, s2.entry;
    ++this._miss;
  }
  get(t, e3) {
    e3 = t.id + e3;
    const s2 = this._db.get(e3);
    if (void 0 !== s2) return this._db.delete(e3), s2.lives = s2.lifetime, this._db.set(e3, s2), ++this._hit, s2.entry;
    ++this._miss;
  }
  peek(t, e3) {
    const s2 = this._db.get(t.id + e3);
    return s2 ? ++this._hit : ++this._miss, s2 == null ? void 0 : s2.entry;
  }
  get performanceInfo() {
    const t = { Size: Math.round(this._size / 1048576) + "/" + Math.round(this._maxSize / 1048576) + "MB", "Hit rate": Math.round(100 * this._getHitRate()) + "%", Entries: this._db.size.toString() }, s2 = {}, i2 = new Array();
    this._db.forEach((t2, e3) => {
      const r3 = t2.lifetime;
      i2[r3] = (i2[r3] || 0) + t2.size, this._users.forAll((i3) => {
        const { id: r4, name: h3 } = i3;
        if (e3.startsWith(r4)) {
          const e4 = s2[h3] || 0;
          s2[h3] = e4 + t2.size;
        }
      });
    });
    const r2 = {};
    this._users.forAll((t2) => {
      const e3 = t2.name;
      if ("hitRate" in t2 && "number" == typeof t2.hitRate && !isNaN(t2.hitRate) && t2.hitRate > 0) {
        const i3 = s2[e3] || 0;
        s2[e3] = i3, r2[e3] = Math.round(100 * t2.hitRate) + "%";
      } else r2[e3] = "0%";
    });
    const h2 = Object.keys(s2);
    h2.sort((t2, e3) => s2[e3] - s2[t2]), h2.forEach((e3) => t[e3] = Math.round(s2[e3] / 2 ** 20) + "MB / " + r2[e3]);
    for (let o2 = i2.length - 1; o2 >= 0; --o2) {
      const s3 = i2[o2];
      s3 && (t["Priority " + (o2 + e - 1)] = Math.round(s3 / this._size * 100) + "%");
    }
    return t;
  }
  resetStats() {
    this._hit = this._miss = 0, this._users.forAll((t) => t.resetHitRate());
  }
  clear(t) {
    const e3 = t.id;
    this._db.forEach((t2, s2) => {
      s2.startsWith(e3) && (this._size -= t2.size, this._db.delete(s2), this._notifyRemove(s2, t2.entry, t2.size, i.ALL));
    }), t.size = 0;
  }
  clearAll() {
    this._db.forEach((t, e3) => this._notifyRemove(e3, t.entry, t.size, i.ALL)), this._users.forAll((t) => t.size = 0), this._size = 0, this._db.clear();
  }
  _getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  _notifyRemove(t, e3, s2, i2) {
    let r2;
    return this._removeFuncs.some((h2) => {
      if (t.startsWith(h2[0])) {
        const t2 = h2[1](e3, i2, s2);
        return "number" == typeof t2 && (r2 = t2), true;
      }
      return false;
    }), r2;
  }
  _checkSize() {
    this._users.forAll((t) => this._checkSizeLimits(t)), this._checkSizeLimits();
  }
  _checkSizeLimits(t) {
    const e3 = t ?? this;
    if (e3.maxSize < 0 || e3.size <= e3.maxSize) return;
    const s2 = t == null ? void 0 : t.id;
    let i2 = true;
    for (; i2; ) {
      i2 = false;
      for (const [r2, h2] of this._db) if (0 === h2.lifetime && (!s2 || r2.startsWith(s2))) {
        if (this._purgeItem(r2, h2, t), e3.size <= 0.9 * e3.maxSize) return;
        i2 || (i2 = this._db.has(r2));
      }
    }
    for (const [r2, h2] of this._db) if ((!s2 || r2.startsWith(s2)) && (this._purgeItem(r2, h2, t), e3.size <= 0.9 * e3.maxSize)) return;
  }
  _purgeItem(t, e3, s2 = this._users.find((e4) => t.startsWith(e4.id))) {
    if (this._db.delete(t), e3.lives <= 1) {
      this._size -= e3.size, s2 && (s2.size -= e3.size);
      const r2 = this._notifyRemove(t, e3.entry, e3.size, i.SOME);
      null != r2 && r2 > 0 && (this._size += r2, s2 && (s2.size += r2), e3.lives = e3.lifetime, e3.size = r2, this._db.set(t, e3));
    } else --e3.lives, this._db.set(t, e3);
  }
};
var o = 0;
var n = class {
  constructor(t, e3, s2) {
    this.entry = t, this.size = e3, this.lifetime = s2, this.lives = s2;
  }
};

// ../node_modules/@arcgis/core/core/LRUCache.js
var e2 = class {
  constructor(e3, s2) {
    this._storage = new h(), this.id = "", this.name = "", this.size = 0, this._storage.maxSize = e3, this._storage.register(this), s2 && this._storage.registerRemoveFunc("", s2);
  }
  destroy() {
    this._storage.deregister(this), this._storage.destroy();
  }
  put(t, e3, s2 = 1) {
    this._storage.put(this, t, e3, s2, 1);
  }
  pop(t) {
    return this._storage.pop(this, t);
  }
  get(t) {
    return this._storage.get(this, t);
  }
  clear() {
    this._storage.clearAll();
  }
  get maxSize() {
    return this._storage.maxSize;
  }
  set maxSize(t) {
    this._storage.maxSize = t;
  }
  resetHitRate() {
  }
};

export {
  r,
  h,
  e2 as e
};
//# sourceMappingURL=chunk-OPCT64AO.js.map
