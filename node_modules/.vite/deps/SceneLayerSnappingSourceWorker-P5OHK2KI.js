import {
  M,
  h,
  v
} from "./chunk-5SIVFK3W.js";
import {
  H,
  N,
  T,
  V,
  _,
  l as l2,
  m as m2,
  s as s2,
  st
} from "./chunk-2PUGZZAH.js";
import "./chunk-4K57JS64.js";
import "./chunk-DOINOMWZ.js";
import {
  m
} from "./chunk-3A2DSA53.js";
import "./chunk-U23SDH2H.js";
import "./chunk-HCN6M4ZV.js";
import "./chunk-NSJBY6SI.js";
import "./chunk-KWTQCB43.js";
import {
  i
} from "./chunk-UNI34X2Q.js";
import "./chunk-LXZ5X57H.js";
import "./chunk-POOHJZAR.js";
import "./chunk-RRSX64BO.js";
import "./chunk-WX4IZMIC.js";
import "./chunk-T5CIHLIU.js";
import "./chunk-XXTMACWZ.js";
import "./chunk-TNRF7MOE.js";
import "./chunk-CYGO6TZX.js";
import {
  r as r3
} from "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import "./chunk-T4EIRKFE.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-6N5YXCNN.js";
import {
  A,
  g,
  n,
  p,
  q,
  r,
  r2,
  t,
  u,
  x
} from "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import {
  a3 as a,
  e2
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  s
} from "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import {
  l
} from "./chunk-G36SOMYZ.js";
import "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/geometry/support/clipRay.js
function a2(r5) {
  return r5 ? { ray: m2(r5.ray), c0: r5.c0, c1: r5.c1 } : { ray: m2(), c0: 0, c1: Number.MAX_VALUE };
}
var A2 = new s2(() => a2());

// ../node_modules/@arcgis/core/geometry/support/frustum.js
function I() {
  return [n(), n(), n(), n(), n(), n(), n(), n()];
}
function s4(T3, _3) {
  for (let O2 = 0; O2 < b3; O2++) {
    const R2 = T3[O2];
    if (R2[0] * _3[0] + R2[1] * _3[1] + R2[2] * _3[2] + R2[3] >= _3[3]) return false;
  }
  return true;
}
var j;
var g2;
!function(T3) {
  T3[T3.LEFT = 0] = "LEFT", T3[T3.RIGHT = 1] = "RIGHT", T3[T3.BOTTOM = 2] = "BOTTOM", T3[T3.TOP = 3] = "TOP", T3[T3.NEAR = 4] = "NEAR", T3[T3.FAR = 5] = "FAR";
}(j || (j = {})), function(T3) {
  T3[T3.NEAR_BOTTOM_LEFT = 0] = "NEAR_BOTTOM_LEFT", T3[T3.NEAR_BOTTOM_RIGHT = 1] = "NEAR_BOTTOM_RIGHT", T3[T3.NEAR_TOP_RIGHT = 2] = "NEAR_TOP_RIGHT", T3[T3.NEAR_TOP_LEFT = 3] = "NEAR_TOP_LEFT", T3[T3.FAR_BOTTOM_LEFT = 4] = "FAR_BOTTOM_LEFT", T3[T3.FAR_BOTTOM_RIGHT = 5] = "FAR_BOTTOM_RIGHT", T3[T3.FAR_TOP_RIGHT = 6] = "FAR_TOP_RIGHT", T3[T3.FAR_TOP_LEFT = 7] = "FAR_TOP_LEFT";
}(g2 || (g2 = {}));
var v3 = { bottom: [g2.FAR_BOTTOM_RIGHT, g2.NEAR_BOTTOM_RIGHT, g2.NEAR_BOTTOM_LEFT, g2.FAR_BOTTOM_LEFT], near: [g2.NEAR_BOTTOM_LEFT, g2.NEAR_BOTTOM_RIGHT, g2.NEAR_TOP_RIGHT, g2.NEAR_TOP_LEFT], far: [g2.FAR_BOTTOM_RIGHT, g2.FAR_BOTTOM_LEFT, g2.FAR_TOP_LEFT, g2.FAR_TOP_RIGHT], right: [g2.NEAR_BOTTOM_RIGHT, g2.FAR_BOTTOM_RIGHT, g2.FAR_TOP_RIGHT, g2.NEAR_TOP_RIGHT], left: [g2.FAR_BOTTOM_LEFT, g2.NEAR_BOTTOM_LEFT, g2.NEAR_TOP_LEFT, g2.FAR_TOP_LEFT], top: [g2.FAR_TOP_LEFT, g2.NEAR_TOP_LEFT, g2.NEAR_TOP_RIGHT, g2.FAR_TOP_RIGHT] };
var b3 = 6;
var k = [r3(-1, -1, -1, 1), r3(1, -1, -1, 1), r3(1, 1, -1, 1), r3(-1, 1, -1, 1), r3(-1, -1, 1, 1), r3(1, -1, 1, 1), r3(1, 1, 1, 1), r3(-1, 1, 1, 1)];
var x2 = new s2(a2);
var y2 = I();

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/Octree.js
var b4 = class _b {
  get bounds() {
    return this._root.bounds;
  }
  get halfSize() {
    return this._root.halfSize;
  }
  get root() {
    return this._root.node;
  }
  get maximumObjectsPerNode() {
    return this._maximumObjectsPerNode;
  }
  get maximumDepth() {
    return this._maximumDepth;
  }
  get objectCount() {
    return this._objectCount;
  }
  constructor(t3, e4) {
    this.objectToBoundingSphere = t3, this._maximumObjectsPerNode = 10, this._maximumDepth = 20, this._degenerateObjects = /* @__PURE__ */ new Set(), this._root = new g3(), this._objectCount = 0, e4 && (void 0 !== e4.maximumObjectsPerNode && (this._maximumObjectsPerNode = e4.maximumObjectsPerNode), void 0 !== e4.maximumDepth && (this._maximumDepth = e4.maximumDepth));
  }
  destroy() {
    this._degenerateObjects.clear(), g3.clearPool(), q2[0] = null, K.prune(), Q.prune();
  }
  add(t3, e4 = t3.length) {
    this._objectCount += e4, this._grow(t3, e4);
    const n2 = g3.acquire();
    for (let o2 = 0; o2 < e4; o2++) {
      const e5 = t3[o2];
      this._isDegenerate(e5) ? this._degenerateObjects.add(e5) : (n2.init(this._root), this._add(e5, n2));
    }
    g3.release(n2);
  }
  remove(t3, e4 = null) {
    this._objectCount -= t3.length;
    const n2 = g3.acquire();
    for (const o2 of t3) {
      const t4 = e4 ?? T(this.objectToBoundingSphere(o2), J);
      C(t4[3]) ? (n2.init(this._root), O(o2, t4, n2)) : this._degenerateObjects.delete(o2);
    }
    g3.release(n2), this._shrink();
  }
  update(t3, e4) {
    if (!C(e4[3]) && this._isDegenerate(t3)) return;
    const n2 = y3(t3);
    this.remove(n2, e4), this.add(n2);
  }
  forEachAlongRay(t3, e4, n2) {
    const o2 = l2(t3, e4);
    S(this._root, (t4) => {
      if (!T2(o2, t4)) return false;
      const e5 = t4.node;
      return e5.terminals.forAll((t5) => {
        this._intersectsObject(o2, t5) && n2(t5);
      }), null !== e5.residents && e5.residents.forAll((t5) => {
        this._intersectsObject(o2, t5) && n2(t5);
      }), true;
    });
  }
  forEachAlongRayWithVerticalOffset(t3, e4, n2, o2) {
    const i2 = l2(t3, e4);
    S(this._root, (t4) => {
      if (!z2(i2, t4, o2)) return false;
      const e5 = t4.node;
      return e5.terminals.forAll((t5) => {
        this._intersectsObjectWithOffset(i2, t5, o2) && n2(t5);
      }), null !== e5.residents && e5.residents.forAll((t5) => {
        this._intersectsObjectWithOffset(i2, t5, o2) && n2(t5);
      }), true;
    });
  }
  forEach(t3) {
    S(this._root, (e4) => {
      const n2 = e4.node;
      return n2.terminals.forAll(t3), null !== n2.residents && n2.residents.forAll(t3), true;
    }), this._degenerateObjects.forEach(t3);
  }
  forEachDegenerateObject(t3) {
    this._degenerateObjects.forEach(t3);
  }
  findClosest(t3, e4, n2, o2 = () => true, s5 = 1 / 0) {
    let h3 = 1 / 0, a3 = 1 / 0, d = null;
    const u2 = F(t3, e4), c2 = (i2) => {
      if (--s5, !o2(i2)) return;
      const r5 = this.objectToBoundingSphere(i2);
      if (!s4(n2, r5)) return;
      const u3 = v4(t3, e4, V(r5)), c3 = u3 - r5[3], f3 = u3 + r5[3];
      c3 < h3 && (h3 = c3, a3 = f3, d = i2);
    };
    return j2(this._root, (o3) => {
      if (s5 <= 0 || !s4(n2, o3.bounds)) return false;
      g(I2, u2, o3.halfSize), u(I2, I2, V(o3.bounds));
      if (v4(t3, e4, I2) > a3) return false;
      const h4 = o3.node;
      return h4.terminals.forAll((t4) => c2(t4)), null !== h4.residents && h4.residents.forAll((t4) => c2(t4)), true;
    }, t3, e4), d;
  }
  forEachInDepthRange(t3, e4, n2, o2, s5, h3, a3) {
    let d = -1 / 0, u2 = 1 / 0;
    const c2 = { setRange: (t4) => {
      n2 === _b.DepthOrder.FRONT_TO_BACK ? (d = Math.max(d, t4.near), u2 = Math.min(u2, t4.far)) : (d = Math.max(d, -t4.far), u2 = Math.min(u2, -t4.near));
    } };
    c2.setRange(o2);
    const f3 = v4(e4, n2, t3), _3 = F(e4, n2), p2 = F(e4, -n2), g4 = (t4) => {
      if (!a3(t4)) return;
      const o3 = this.objectToBoundingSphere(t4), i2 = V(o3), r5 = v4(e4, n2, i2) - f3, _4 = r5 - o3[3], p3 = r5 + o3[3];
      _4 > u2 || p3 < d || !s4(h3, o3) || s5(t4, c2);
    };
    j2(this._root, (t4) => {
      if (!s4(h3, t4.bounds)) return false;
      g(I2, _3, t4.halfSize), u(I2, I2, V(t4.bounds));
      if (v4(e4, n2, I2) - f3 > u2) return false;
      g(I2, p2, t4.halfSize), u(I2, I2, V(t4.bounds));
      if (v4(e4, n2, I2) - f3 < d) return false;
      const o3 = t4.node;
      return o3.terminals.forAll((t5) => g4(t5)), null !== o3.residents && o3.residents.forAll((t5) => g4(t5)), true;
    }, e4, n2);
  }
  forEachNode(t3) {
    S(this._root, (e4) => t3(e4.node, e4.bounds, e4.halfSize, e4.depth));
  }
  forEachNeighbor(t3, e4) {
    const n2 = N(e4), o2 = V(e4), i2 = (e5) => {
      const i3 = this.objectToBoundingSphere(e5), r6 = N(i3), h4 = n2 + r6;
      return !(p(V(i3), o2) - h4 * h4 <= 0) || t3(e5);
    };
    let r5 = true;
    const h3 = (t4) => {
      r5 && (r5 = i2(t4));
    };
    S(this._root, (t4) => {
      const e5 = N(t4.bounds), i3 = n2 + e5;
      if (p(V(t4.bounds), o2) - i3 * i3 > 0) return false;
      const a3 = t4.node;
      return a3.terminals.forAll(h3), r5 && null !== a3.residents && a3.residents.forAll(h3), r5;
    }), r5 && this.forEachDegenerateObject(h3);
  }
  _intersectsObject(t3, e4) {
    const n2 = this.objectToBoundingSphere(e4);
    return !(n2[3] > 0) || H(n2, t3);
  }
  _intersectsObjectWithOffset(t3, e4, n2) {
    const o2 = this.objectToBoundingSphere(e4);
    return !(o2[3] > 0) || H(n2.applyToBoundingSphere(o2), t3);
  }
  _add(t3, e4) {
    e4.advanceTo(this.objectToBoundingSphere(t3)) ? e4.node.terminals.push(t3) : (e4.node.residents.push(t3), e4.node.residents.length > this._maximumObjectsPerNode && e4.depth < this._maximumDepth && this._split(e4));
  }
  _split(t3) {
    const e4 = t3.node.residents;
    t3.node.residents = null;
    for (let n2 = 0; n2 < e4.length; n2++) {
      const o2 = g3.acquire().init(t3);
      this._add(e4.at(n2), o2), g3.release(o2);
    }
  }
  _grow(t3, e4) {
    if (0 !== e4 && (D(t3, e4, (t4) => this.objectToBoundingSphere(t4), W), C(W[3]) && !this._fitsInsideTree(W))) if (N2(this._root.node)) T(W, this._root.bounds), this._root.halfSize = 1.25 * this._root.bounds[3], this._root.updateBoundsRadiusFromHalfSize();
    else {
      const t4 = this._rootBoundsForRootAsSubNode(W);
      this._placingRootViolatesMaxDepth(t4) ? this._rebuildTree(W, t4) : this._growRootAsSubNode(t4), g3.release(t4);
    }
  }
  _rebuildTree(t3, e4) {
    r2(V(V3), V(e4.bounds)), V3[3] = e4.halfSize, D([t3, V3], 2, (t4) => t4, G2);
    const o2 = g3.acquire().init(this._root);
    this._root.initFrom(null, G2, G2[3]), this._root.increaseHalfSize(1.25), S(o2, (t4) => (this.add(t4.node.terminals.data, t4.node.terminals.length), null !== t4.node.residents && this.add(t4.node.residents.data, t4.node.residents.length), true)), g3.release(o2);
  }
  _placingRootViolatesMaxDepth(t3) {
    const e4 = Math.log(t3.halfSize / this._root.halfSize) * Math.LOG2E;
    let n2 = 0;
    return S(this._root, (t4) => (n2 = Math.max(n2, t4.depth), n2 + e4 <= this._maximumDepth)), n2 + e4 > this._maximumDepth;
  }
  _rootBoundsForRootAsSubNode(t3) {
    const e4 = t3[3], n2 = t3;
    let o2 = -1 / 0;
    const i2 = this._root.bounds, r5 = this._root.halfSize;
    for (let h3 = 0; h3 < 3; h3++) {
      const t4 = i2[h3] - r5 - (n2[h3] - e4), s6 = n2[h3] + e4 - (i2[h3] + r5), a3 = Math.max(0, Math.ceil(t4 / (2 * r5))), l3 = Math.max(0, Math.ceil(s6 / (2 * r5))) + 1, d = 2 ** Math.ceil(Math.log(a3 + l3) * Math.LOG2E);
      o2 = Math.max(o2, d), U[h3].min = a3, U[h3].max = l3;
    }
    for (let h3 = 0; h3 < 3; h3++) {
      let t4 = U[h3].min, e5 = U[h3].max;
      const n3 = (o2 - (t4 + e5)) / 2;
      t4 += Math.ceil(n3), e5 += Math.floor(n3);
      const s6 = i2[h3] - r5 - t4 * r5 * 2;
      k2[h3] = s6 + (e5 + t4) * r5;
    }
    const s5 = o2 * r5;
    return k2[3] = s5 * w, g3.acquire().initFrom(null, k2, s5, 0);
  }
  _growRootAsSubNode(t3) {
    const e4 = this._root.node;
    r2(V(W), V(this._root.bounds)), W[3] = this._root.halfSize, this._root.init(t3), t3.advanceTo(W, null, true), t3.node.children = e4.children, t3.node.residents = e4.residents, t3.node.terminals = e4.terminals;
  }
  _shrink() {
    for (; ; ) {
      const t3 = this._findShrinkIndex();
      if (-1 === t3) break;
      this._root.advance(t3), this._root.depth = 0;
    }
  }
  _findShrinkIndex() {
    if (0 !== this._root.node.terminals.length || this._root.isLeaf()) return -1;
    let t3 = null;
    const e4 = this._root.node.children;
    let n2 = 0, o2 = 0;
    for (; o2 < e4.length && null == t3; ) n2 = o2++, t3 = e4[n2];
    for (; o2 < e4.length; ) if (e4[o2++]) return -1;
    return n2;
  }
  _isDegenerate(t3) {
    return !C(this.objectToBoundingSphere(t3)[3]);
  }
  _fitsInsideTree(t3) {
    const e4 = this._root.bounds, n2 = this._root.halfSize;
    return t3[3] <= n2 && t3[0] >= e4[0] - n2 && t3[0] <= e4[0] + n2 && t3[1] >= e4[1] - n2 && t3[1] <= e4[1] + n2 && t3[2] >= e4[2] - n2 && t3[2] <= e4[2] + n2;
  }
  toJSON() {
    const { maximumDepth: t3, maximumObjectsPerNode: e4, _objectCount: n2 } = this, o2 = this._nodeToJSON(this._root.node);
    return { maximumDepth: t3, maximumObjectsPerNode: e4, objectCount: n2, root: { bounds: this._root.bounds, halfSize: this._root.halfSize, depth: this._root.depth, node: o2 } };
  }
  _nodeToJSON(t3) {
    var _a, _b2;
    const e4 = t3.children.map((t4) => t4 ? this._nodeToJSON(t4) : null), n2 = (_a = t3.residents) == null ? void 0 : _a.map((t4) => this.objectToBoundingSphere(t4)), o2 = (_b2 = t3.terminals) == null ? void 0 : _b2.map((t4) => this.objectToBoundingSphere(t4));
    return { children: e4, residents: n2, terminals: o2 };
  }
  static fromJSON(t3) {
    const e4 = new _b((t4) => t4, { maximumDepth: t3.maximumDepth, maximumObjectsPerNode: t3.maximumObjectsPerNode });
    return e4._objectCount = t3.objectCount, e4._root.initFrom(t3.root.node, t3.root.bounds, t3.root.halfSize, t3.root.depth), e4;
  }
};
var g3 = class _g {
  constructor() {
    this.bounds = _(), this.halfSize = 0, this.initFrom(null, null, 0, 0);
  }
  init(t3) {
    return this.initFrom(t3.node, t3.bounds, t3.halfSize, t3.depth);
  }
  initFrom(t3, e4, n2, o2 = this.depth) {
    return this.node = null != t3 ? t3 : _g.createEmptyNode(), e4 && T(e4, this.bounds), this.halfSize = n2, this.depth = o2, this;
  }
  increaseHalfSize(t3) {
    this.halfSize *= t3, this.updateBoundsRadiusFromHalfSize();
  }
  updateBoundsRadiusFromHalfSize() {
    this.bounds[3] = this.halfSize * w;
  }
  advance(t3) {
    let e4 = this.node.children[t3];
    e4 || (e4 = _g.createEmptyNode(), this.node.children[t3] = e4), this.node = e4, this.halfSize /= 2, this.depth++;
    const n2 = E2[t3];
    return this.bounds[0] += n2[0] * this.halfSize, this.bounds[1] += n2[1] * this.halfSize, this.bounds[2] += n2[2] * this.halfSize, this.updateBoundsRadiusFromHalfSize(), this;
  }
  advanceTo(t3, e4, n2 = false) {
    for (; ; ) {
      if (this.isTerminalFor(t3)) return e4 && e4(this, -1), true;
      if (this.isLeaf()) {
        if (!n2) return e4 && e4(this, -1), false;
        this.node.residents = null;
      }
      const o2 = this._childIndex(t3);
      e4 && e4(this, o2), this.advance(o2);
    }
  }
  isLeaf() {
    return null != this.node.residents;
  }
  isTerminalFor(t3) {
    return t3[3] > this.halfSize / 2;
  }
  _childIndex(t3) {
    const e4 = this.bounds;
    return (e4[0] < t3[0] ? 1 : 0) + (e4[1] < t3[1] ? 2 : 0) + (e4[2] < t3[2] ? 4 : 0);
  }
  static createEmptyNode() {
    return { children: [null, null, null, null, null, null, null, null], terminals: new l({ shrink: true }), residents: new l({ shrink: true }) };
  }
  static acquire() {
    return _g._pool.acquire();
  }
  static release(t3) {
    _g._pool.release(t3);
  }
  static clearPool() {
    _g._pool.prune();
  }
};
function S(t3, e4) {
  let n2 = g3.acquire().init(t3);
  const o2 = [n2];
  for (; 0 !== o2.length; ) {
    if (n2 = o2.pop(), e4(n2) && !n2.isLeaf()) for (let t4 = 0; t4 < n2.node.children.length; t4++) {
      n2.node.children[t4] && o2.push(g3.acquire().init(n2).advance(t4));
    }
    g3.release(n2);
  }
}
function j2(t3, e4, n2, o2 = b4.DepthOrder.FRONT_TO_BACK) {
  let i2 = g3.acquire().init(t3);
  const r5 = [i2];
  for (R(n2, o2, X); 0 !== r5.length; ) {
    if (i2 = r5.pop(), e4(i2) && !i2.isLeaf()) for (let t4 = 7; t4 >= 0; --t4) {
      const e5 = X[t4];
      i2.node.children[e5] && r5.push(g3.acquire().init(i2).advance(e5));
    }
    g3.release(i2);
  }
}
function O(t3, e4, n2) {
  K.clear();
  const o2 = n2.advanceTo(e4, (t4, e5) => {
    K.push(t4.node), K.push(e5);
  }) ? n2.node.terminals : n2.node.residents;
  if (o2.removeUnordered(t3), 0 === o2.length) for (let i2 = K.length - 2; i2 >= 0; i2 -= 2) {
    if (!x3(K.data[i2], K.data[i2 + 1])) break;
  }
}
function x3(t3, n2) {
  return n2 >= 0 && (t3.children[n2] = null), !!N2(t3) && (null === t3.residents && (t3.residents = new l({ shrink: true })), true);
}
function T2(t3, e4) {
  return B(V(e4.bounds), 2 * -e4.halfSize, L), B(V(e4.bounds), 2 * e4.halfSize, H3), i(t3.origin, t3.direction, L, H3);
}
function z2(t3, e4, n2) {
  return B(V(e4.bounds), 2 * -e4.halfSize, L), B(V(e4.bounds), 2 * e4.halfSize, H3), n2.applyToMinMax(L, H3), i(t3.origin, t3.direction, L, H3);
}
function N2(t3) {
  if (0 !== t3.terminals.length) return false;
  if (null !== t3.residents) return 0 === t3.residents.length;
  for (let e4 = 0; e4 < t3.children.length; e4++) if (t3.children[e4]) return false;
  return true;
}
function M2(t3, e4) {
  t3[0] = Math.min(t3[0], e4[0] - e4[3]), t3[1] = Math.min(t3[1], e4[1] - e4[3]), t3[2] = Math.min(t3[2], e4[2] - e4[3]);
}
function A4(t3, e4) {
  t3[0] = Math.max(t3[0], e4[0] + e4[3]), t3[1] = Math.max(t3[1], e4[1] + e4[3]), t3[2] = Math.max(t3[2], e4[2] + e4[3]);
}
function B(t3, e4, n2) {
  n2[0] = t3[0] + e4, n2[1] = t3[1] + e4, n2[2] = t3[2] + e4;
}
function D(t3, e4, n2, i2) {
  if (1 === e4) {
    const e5 = n2(t3[0]);
    T(e5, i2);
  } else {
    L[0] = 1 / 0, L[1] = 1 / 0, L[2] = 1 / 0, H3[0] = -1 / 0, H3[1] = -1 / 0, H3[2] = -1 / 0;
    for (let o2 = 0; o2 < e4; o2++) {
      const e5 = n2(t3[o2]);
      C(e5[3]) && (M2(L, e5), A4(H3, e5));
    }
    A(V(i2), L, H3, 0.5), i2[3] = Math.max(H3[0] - L[0], H3[1] - L[1], H3[2] - L[2]) / 2;
  }
}
function R(t3, e4, n2) {
  if (!Q.length) for (let o2 = 0; o2 < 8; ++o2) Q.push({ index: 0, distance: 0 });
  for (let o2 = 0; o2 < 8; ++o2) {
    const n3 = E2[o2];
    Q.data[o2].index = o2, Q.data[o2].distance = v4(t3, e4, n3);
  }
  Q.sort((t4, e5) => t4.distance - e5.distance);
  for (let o2 = 0; o2 < 8; ++o2) n2[o2] = Q.data[o2].index;
}
function F(t3, e4) {
  let n2, o2 = 1 / 0;
  for (let i2 = 0; i2 < 8; ++i2) {
    const r5 = v4(t3, e4, P[i2]);
    r5 < o2 && (o2 = r5, n2 = P[i2]);
  }
  return n2;
}
function v4(t3, e4, n2) {
  return e4 * (t3[0] * n2[0] + t3[1] * n2[1] + t3[2] * n2[2]);
}
function C(t3) {
  return !isNaN(t3) && t3 !== -1 / 0 && t3 !== 1 / 0 && t3 > 0;
}
g3._pool = new e2(g3), function(t3) {
  var e4;
  (e4 = t3.DepthOrder || (t3.DepthOrder = {}))[e4.FRONT_TO_BACK = 1] = "FRONT_TO_BACK", e4[e4.BACK_TO_FRONT = -1] = "BACK_TO_FRONT";
}(b4 || (b4 = {}));
var E2 = [r(-1, -1, -1), r(1, -1, -1), r(-1, 1, -1), r(1, 1, -1), r(-1, -1, 1), r(1, -1, 1), r(-1, 1, 1), r(1, 1, 1)];
var P = [r(-1, -1, -1), r(-1, -1, 1), r(-1, 1, -1), r(-1, 1, 1), r(1, -1, -1), r(1, -1, 1), r(1, 1, -1), r(1, 1, 1)];
var w = Math.sqrt(3);
var q2 = [null];
function y3(t3) {
  return q2[0] = t3, q2;
}
var k2 = _();
var I2 = n();
var L = n();
var H3 = n();
var K = new l();
var J = _();
var W = _();
var V3 = _();
var G2 = _();
var U = [{ min: 0, max: 0 }, { min: 0, max: 0 }, { min: 0, max: 0 }];
var Q = new l();
var X = [0, 0, 0, 0, 0, 0, 0, 0];
var Y = b4;

// ../node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/sceneLayerSnappingUtils.js
var t2 = 1e3;
function e3(t3, e4, a3) {
  const p2 = _(), m4 = V(p2);
  return q(m4, m4, t3, 0.5), q(m4, m4, e4, 0.5), p2[3] = x(m4, t3), u(m4, m4, a3), p2;
}

// ../node_modules/@arcgis/core/views/interactive/snapping/featureSources/sceneLayerSource/SceneLayerSnappingSourceWorker.js
var f2 = class {
  constructor() {
    this._idToComponent = /* @__PURE__ */ new Map(), this._components = new Y((e4) => e4.bounds), this._edges = new Y((e4) => e4.bounds), this._tmpLineSegment = v(), this._tmpP1 = n(), this._tmpP2 = n(), this._tmpP3 = n(), this.remoteClient = null;
  }
  async fetchCandidates(e4, o2) {
    await Promise.resolve(), s(o2), await this._ensureEdgeLocations(e4, o2);
    const s5 = [];
    return this._edges.forEachNeighbor((t3) => (this._addCandidates(e4, t3, s5), s5.length < t2), e4.bounds), { result: { candidates: s5 } };
  }
  async _ensureEdgeLocations(e4, t3) {
    const o2 = [];
    if (this._components.forEachNeighbor((e5) => {
      if (null == e5.info) {
        const { id: t4, uid: s6 } = e5;
        o2.push({ id: t4, uid: s6 });
      }
      return true;
    }, e4.bounds), !o2.length) return;
    const s5 = { components: o2 }, n2 = await this.remoteClient.invoke("fetchAllEdgeLocations", s5, t3 ?? {});
    for (const i2 of n2.components) this._setFetchEdgeLocations(i2);
  }
  async add(e4) {
    const t3 = new j3(e4.id, e4.bounds);
    return this._idToComponent.set(t3.id, t3), this._components.add([t3]), { result: {} };
  }
  async remove(e4) {
    const t3 = this._idToComponent.get(e4.id);
    if (t3) {
      const e5 = [];
      this._edges.forEachNeighbor((o2) => (o2.component === t3 && e5.push(o2), true), t3.bounds), this._edges.remove(e5), this._components.remove([t3]), this._idToComponent.delete(t3.id);
    }
    return { result: {} };
  }
  _setFetchEdgeLocations(e4) {
    const t3 = this._idToComponent.get(e4.id);
    if (null == t3 || e4.uid !== t3.uid) return;
    const o2 = m.createView(e4.locations), s5 = new Array(o2.count), n2 = n(), r5 = n();
    for (let i2 = 0; i2 < o2.count; i2++) {
      o2.position0.getVec(i2, n2), o2.position1.getVec(i2, r5);
      const c3 = e3(n2, r5, e4.origin), d2 = new w2(t3, i2, c3);
      s5[i2] = d2;
    }
    this._edges.add(s5);
    const { objectIds: c2, origin: d } = e4;
    t3.info = { locations: o2, objectIds: c2, origin: d };
  }
  _addCandidates(e4, t3, o2) {
    const { info: n2 } = t3.component, { origin: i2, objectIds: r5 } = n2, c2 = n2.locations, d = c2.position0.getVec(t3.index, this._tmpP1), a3 = c2.position1.getVec(t3.index, this._tmpP2);
    u(d, d, i2), u(a3, a3, i2);
    const p2 = r5[c2.componentIndex.get(t3.index)];
    this._addEdgeCandidate(e4, p2, d, a3, o2), b5(e4, p2, d, o2), b5(e4, p2, a3, o2);
  }
  _addEdgeCandidate(e4, t3, o2, s5, i2) {
    if (!e4.returnEdge) return;
    const c2 = V(e4.bounds), u2 = h(o2, s5, this._tmpLineSegment), h3 = M(u2, c2, this._tmpP3);
    st(e4.bounds, h3) && i2.push({ type: "edge", objectId: t3, target: t(h3), distance: x(c2, h3), start: t(o2), end: t(s5) });
  }
};
f2 = e([a("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")], f2);
var _2 = f2;
function b5(e4, t3, o2, s5) {
  if (!e4.returnVertex || !st(e4.bounds, o2)) return;
  const i2 = V(e4.bounds);
  s5.push({ type: "vertex", objectId: t3, target: t(o2), distance: x(i2, o2) });
}
var j3 = class _j {
  constructor(e4, t3) {
    this.id = e4, this.bounds = t3, this.info = null, this.uid = ++_j.uid;
  }
};
j3.uid = 0;
var w2 = class {
  constructor(e4, t3, o2) {
    this.component = e4, this.index = t3, this.bounds = o2;
  }
};
export {
  _2 as default
};
//# sourceMappingURL=SceneLayerSnappingSourceWorker-P5OHK2KI.js.map
