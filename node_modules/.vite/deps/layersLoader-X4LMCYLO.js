import {
  w
} from "./chunk-R2DPWIJF.js";
import {
  a,
  c,
  e,
  i,
  n,
  o,
  s as s2,
  t as t3,
  u
} from "./chunk-CYYHPZKH.js";
import "./chunk-7SBYPGB2.js";
import {
  t as t2
} from "./chunk-BCRDWA3W.js";
import {
  t
} from "./chunk-72F4IYHA.js";
import {
  a as a2
} from "./chunk-KJQQHZYX.js";
import {
  e as e2
} from "./chunk-JSJ34DFQ.js";
import {
  t as t4
} from "./chunk-CZ3DCLKN.js";
import {
  s as s3
} from "./chunk-7TO4QD67.js";
import {
  d
} from "./chunk-OHUWK5XV.js";
import "./chunk-PHVKM5OH.js";
import "./chunk-KQ5GHUVQ.js";
import "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import {
  C
} from "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import "./chunk-WC4SPMPL.js";
import "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import "./chunk-GEH2VXFC.js";
import "./chunk-BJY5ADVY.js";
import "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  s2 as s
} from "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/portal/support/layersLoader.js
async function g(e3, t5) {
  const r = e3.instance.portalItem;
  if (r == null ? void 0 : r.id) return await r.load(t5), b(e3), e3.validateItem && e3.validateItem(r), L(e3, t5);
}
function b(t5) {
  const r = t5.instance.portalItem;
  if (!(r == null ? void 0 : r.type) || !t5.supportedTypes.includes(r.type)) throw new s("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}'", { type: r == null ? void 0 : r.type, expectedType: t5.supportedTypes.join(", ") });
}
async function L(e3, t5) {
  const r = e3.instance, o2 = r.portalItem;
  if (!o2) return;
  const { url: n2, title: s4 } = o2, l = e2(o2, "portal-item");
  if ("group" === r.type) return S(r, l, e3);
  n2 && "media" !== r.type && r.read({ url: n2 }, l);
  const c2 = new e(), u2 = await M(e3, c2, t5);
  return u2 && r.read(u2, l), r.resourceReferences = { portalItem: o2, paths: l.readResourcePaths ?? [] }, "subtype-group" !== r.type && r.read({ title: s4 }, l), t4(r, l);
}
async function S(t5, r, a3) {
  const o2 = t5.portalItem;
  if (!t5.sourceIsPortalItem) return;
  const { title: n2, type: s4 } = o2;
  if ("Group Layer" === s4) {
    if (!s3(o2, "Map")) throw new s("portal:invalid-layer-item-typekeyword", "'Group Layer' item without 'Map' type keyword is not supported");
    return T(t5);
  }
  return t5.read({ title: n2 }, r), v(t5, a3);
}
async function T(e3) {
  const t5 = e3.portalItem, r = await t5.fetchData("json");
  if (!r) return;
  const a3 = e2(t5, "web-map");
  e3.read(r, a3), await w(e3, r, { context: a3 }), e3.resourceReferences = { portalItem: t5, paths: a3.readResourcePaths ?? [] };
}
async function v(t5, r) {
  var _a;
  let o2;
  const { portalItem: n2 } = t5;
  if (!n2) return;
  const s4 = n2.type, i2 = r.layerModuleTypeMap;
  switch (s4) {
    case "Feature Service":
    case "Feature Collection":
      o2 = i2.FeatureLayer;
      break;
    case "Stream Service":
      o2 = i2.StreamLayer;
      break;
    case "Scene Service":
      o2 = i2.SceneLayer;
      break;
    default:
      throw new s("portal:unsupported-item-type-as-group", `The item type '${s4}' is not supported as a 'IGroupLayer'`);
  }
  const y = new e();
  let [f, m] = await Promise.all([o2(), M(r, y)]), d2 = () => f;
  if ("Feature Service" === s4) {
    const e3 = (_a = s2(m)) == null ? void 0 : _a.customParameters;
    m = n2.url ? await a(m, n2.url, y) : {}, d2 = await E(m, i2) || d2;
    const r2 = await k(n2.url, { customParameters: e3, loadContext: y });
    return await F(t5, d2, m, r2);
  }
  return "Scene Service" === s4 && n2.url && (m = await o(n2, m, y)), u(m) > 0 ? await F(t5, d2, m) : await j(t5, d2);
}
async function j(e3, t5) {
  var _a, _b;
  const { portalItem: r } = e3;
  if (!(r == null ? void 0 : r.url)) return;
  const a3 = await t(r.url);
  a3 && F(e3, t5, { layers: (_a = a3.layers) == null ? void 0 : _a.map(t3), tables: (_b = a3.tables) == null ? void 0 : _b.map(t3) });
}
async function F(e3, t5, r, a3) {
  var _a;
  let o2 = r.layers || [];
  const s4 = r.tables || [];
  if ("Feature Collection" === ((_a = e3.portalItem) == null ? void 0 : _a.type) ? (o2.forEach((e4, t6) => {
    var _a2;
    e4.id = t6, "Table" === ((_a2 = e4 == null ? void 0 : e4.layerDefinition) == null ? void 0 : _a2.type) && s4.push(e4);
  }), o2 = o2.filter((e4) => {
    var _a2;
    return "Table" !== ((_a2 = e4 == null ? void 0 : e4.layerDefinition) == null ? void 0 : _a2.type);
  })) : (o2.reverse(), s4.reverse()), o2.forEach((o3) => {
    const n2 = a3 == null ? void 0 : a3(o3);
    if (n2 || !a3) {
      const a4 = P(e3, t5(o3), r, o3, n2);
      e3.add(a4);
    }
  }), s4.length) {
    const t6 = await a2.FeatureLayer();
    s4.forEach((o3) => {
      const n2 = a3 == null ? void 0 : a3(o3);
      if (n2 || !a3) {
        const a4 = P(e3, t6, r, o3, n2);
        e3.tables.add(a4);
      }
    });
  }
}
function P(e3, t5, r, a3, o2) {
  const n2 = e3.portalItem, i2 = { portalItem: n2.clone(), layerId: a3.id };
  null != a3.url && (i2.url = a3.url);
  const l = new t5(i2);
  if ("sourceJSON" in l && (l.sourceJSON = o2), "subtype-group" !== l.type && "catalog" !== l.type && (l.sublayerTitleMode = "service-name"), "Feature Collection" === n2.type) {
    const e4 = { origin: "portal-item", portal: n2.portal || C.getDefault() };
    l.read(a3, e4);
    const t6 = r.showLegend;
    null != t6 && l.read({ showLegend: t6 }, e4);
  }
  return l;
}
async function M(e3, t5, r) {
  if (false === e3.supportsData) return;
  const a3 = e3.instance, o2 = a3.portalItem;
  if (!o2) return;
  let n2 = null;
  try {
    n2 = await o2.fetchData("json", r);
  } catch (s4) {
  }
  if (D(a3)) {
    let e4 = null;
    const r2 = await x(o2, n2, t5);
    if (((n2 == null ? void 0 : n2.layers) || (n2 == null ? void 0 : n2.tables)) && r2 > 0) {
      if (null == a3.layerId) {
        const e5 = c(a3.type), t6 = e5 ? n(n2, e5)[0] : s2(n2);
        t6 && (a3.layerId = t6.id);
      }
      e4 = C2(n2, a3), "OrientedImageryLayer" === (e4 == null ? void 0 : e4.layerType) && "oriented-imagery" === a3.type && a3.supportedSourceTypes.add("Feature Layer"), e4 && null != n2.showLegend && (e4.showLegend = n2.showLegend);
    }
    return r2 > 1 && "sublayerTitleMode" in a3 && "service-name" !== a3.sublayerTitleMode && (a3.sublayerTitleMode = "item-title-and-service-name"), e4;
  }
  return n2;
}
async function x(e3, r, a3) {
  var _a, _b, _c, _d, _e;
  if ((r == null ? void 0 : r.layers) && (r == null ? void 0 : r.tables)) return u(r);
  const o2 = d(e3.url);
  if (!o2) return 1;
  const n2 = await a3.fetchServiceMetadata(o2.url.path, { customParameters: (_a = s2(r)) == null ? void 0 : _a.customParameters }).catch(() => null);
  return (((_b = r == null ? void 0 : r.layers) == null ? void 0 : _b.length) ?? ((_c = n2 == null ? void 0 : n2.layers) == null ? void 0 : _c.length) ?? 0) + (((_d = r == null ? void 0 : r.tables) == null ? void 0 : _d.length) ?? ((_e = n2 == null ? void 0 : n2.tables) == null ? void 0 : _e.length) ?? 0);
}
function C2(e3, t5) {
  var _a, _b;
  const { layerId: r } = t5, a3 = ((_a = e3.layers) == null ? void 0 : _a.find((e4) => e4.id === r)) || ((_b = e3.tables) == null ? void 0 : _b.find((e4) => e4.id === r));
  return a3 && G(a3, t5) ? a3 : null;
}
function D(e3) {
  return "stream" !== e3.type && "layerId" in e3;
}
function G(e3, t5) {
  const r = "layerType" in e3 && e3.layerType, { type: a3 } = t5;
  return !("feature" === a3 && r && "ArcGISFeatureLayer" !== e3.layerType || "catalog" === a3 && !r || "oriented-imagery" === a3 && !r || "subtype-group" === a3 && !r);
}
async function k(e3, t5) {
  const { layersJSON: a3 } = await t2(e3, t5);
  if (!a3) return null;
  const o2 = [...a3.layers, ...a3.tables];
  return (e4) => o2.find((t6) => t6.id === e4.id);
}
async function E(e3, t5) {
  const { layers: r } = e3;
  if (!(r == null ? void 0 : r.length)) return;
  const a3 = /* @__PURE__ */ new Set(), o2 = [];
  for (const { layerType: i2 } of r) {
    const e4 = i2 ?? "ArcGISFeatureLayer";
    if (a3.has(e4)) continue;
    a3.add(e4);
    const r2 = t5[i(e4)];
    o2.push(r2());
  }
  const n2 = await Promise.all(o2), s4 = /* @__PURE__ */ new Map();
  return Array.from(a3).forEach((e4, t6) => {
    s4.set(e4, n2[t6]);
  }), ({ layerType: e4 }) => {
    const t6 = e4 ?? "ArcGISFeatureLayer";
    return s4.get(t6);
  };
}
export {
  g as load
};
//# sourceMappingURL=layersLoader-X4LMCYLO.js.map
