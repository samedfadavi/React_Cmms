import {
  D,
  I,
  M,
  T2 as T,
  ae,
  b,
  h,
  w as w2
} from "./chunk-B5LY3L7P.js";
import "./chunk-5QK3TRYR.js";
import {
  R
} from "./chunk-WDAANELG.js";
import "./chunk-SOAAYVHP.js";
import "./chunk-6RHMAIR4.js";
import "./chunk-UOIKTJMB.js";
import "./chunk-DO3EYTSJ.js";
import "./chunk-VR7WVNO3.js";
import "./chunk-5T4GYCDT.js";
import "./chunk-P6AJLPW7.js";
import {
  ot
} from "./chunk-F54TE5DA.js";
import "./chunk-ZPZCSP4J.js";
import "./chunk-5YPRHJQA.js";
import {
  e as e2
} from "./chunk-ZVC7ZICV.js";
import "./chunk-V3JQJNA6.js";
import "./chunk-VBYAAZGS.js";
import "./chunk-C5TCSNRO.js";
import "./chunk-MGJTYDNO.js";
import "./chunk-PFCHMQMS.js";
import "./chunk-QSCURXVW.js";
import "./chunk-DDQ2RCGU.js";
import "./chunk-OBN3TJ5S.js";
import "./chunk-YJXOPMOL.js";
import "./chunk-P3MZKJDB.js";
import "./chunk-JWA73VK6.js";
import "./chunk-UFNQVX5G.js";
import "./chunk-KW3Q5OC2.js";
import "./chunk-XNYIPE5U.js";
import "./chunk-YHUE64L3.js";
import "./chunk-MUYRQ7CH.js";
import "./chunk-GPH64EJR.js";
import "./chunk-U6JPKU6C.js";
import "./chunk-FY5GOH3U.js";
import "./chunk-AMKKU676.js";
import "./chunk-QBW6ZJYD.js";
import "./chunk-S7J6OTBX.js";
import "./chunk-GMJ4G37M.js";
import "./chunk-CSCLMZ7J.js";
import "./chunk-BIJ6AA2G.js";
import "./chunk-FTURJXD3.js";
import "./chunk-LNOEFEG3.js";
import "./chunk-4SCOCLA2.js";
import "./chunk-WF67GKPJ.js";
import "./chunk-PVGZCS2Z.js";
import "./chunk-4HOM27T6.js";
import "./chunk-FO4JQZA5.js";
import "./chunk-XEELLOJE.js";
import "./chunk-647CGSDX.js";
import "./chunk-JVNKXKH7.js";
import "./chunk-2FW7ECQ2.js";
import "./chunk-LGQJAMGK.js";
import "./chunk-PVAXLXWO.js";
import "./chunk-D6KE2FST.js";
import "./chunk-W3XB5XWO.js";
import "./chunk-6QBE4YDH.js";
import "./chunk-LXDJBJSP.js";
import "./chunk-OPCT64AO.js";
import "./chunk-CFIKP7ET.js";
import {
  l
} from "./chunk-VEAHCP5W.js";
import "./chunk-WO4V65CJ.js";
import "./chunk-QUNQAVSE.js";
import {
  t
} from "./chunk-HNXXFTFZ.js";
import "./chunk-NSXZC33R.js";
import "./chunk-E7HFITKU.js";
import "./chunk-ZFQCSBZ4.js";
import "./chunk-4PAHN45R.js";
import "./chunk-CRUGTXEH.js";
import "./chunk-CPGVDDHW.js";
import "./chunk-VEOZVJAT.js";
import "./chunk-3D32E2TW.js";
import "./chunk-ACWF4COQ.js";
import "./chunk-P35RWHDU.js";
import "./chunk-G5U2OA3R.js";
import "./chunk-OIFKYPGO.js";
import "./chunk-JNGB7HKP.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import "./chunk-DZNQTDMC.js";
import "./chunk-URNMKNS6.js";
import "./chunk-3QWMYL5A.js";
import "./chunk-MB5H6D2S.js";
import "./chunk-LVH66MEH.js";
import "./chunk-4FW6GTBF.js";
import "./chunk-E5ZJCKHO.js";
import "./chunk-ZRA2NDCA.js";
import "./chunk-JJIIUFER.js";
import "./chunk-ITGBXG45.js";
import "./chunk-LLJZCFHW.js";
import "./chunk-VIUFBDIY.js";
import "./chunk-TXIL3QUC.js";
import "./chunk-2ASAB4KA.js";
import {
  f
} from "./chunk-EA74CF7B.js";
import "./chunk-IGNUVZ34.js";
import "./chunk-LTSQHA4C.js";
import "./chunk-YUQFVZCH.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-T4EIRKFE.js";
import "./chunk-PHVKM5OH.js";
import "./chunk-KQ5GHUVQ.js";
import "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-JQIB7GFW.js";
import "./chunk-CJJCN7PA.js";
import "./chunk-IJUFAIOF.js";
import "./chunk-MNMU4ARP.js";
import "./chunk-7OW2VNCC.js";
import "./chunk-AFBYZF6Q.js";
import "./chunk-IJ42YN7D.js";
import "./chunk-4AGGGL2W.js";
import "./chunk-FJPG3YI6.js";
import "./chunk-BJHLU2MM.js";
import "./chunk-E5KBRIJQ.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-TW7VY7XV.js";
import "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import "./chunk-BL2UGYYZ.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import {
  V
} from "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import {
  m
} from "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import {
  _,
  w
} from "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import {
  n as n2
} from "./chunk-K4UOG562.js";
import "./chunk-WC4SPMPL.js";
import {
  y
} from "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import {
  a3 as a,
  r
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  s as s2
} from "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/layers/knowledgeGraph/IdealEdgeLengthTypeOptions.js
var e3;
!function(e5) {
  e5.MULTIPLIER = "multiplier", e5.ABSOLUTE = "absoluteValue";
}(e3 || (e3 = {}));

// ../node_modules/@arcgis/core/libs/linkchartlayout/LinkChartLayout.js
var e4;
var r2 = null;
function n3() {
  return e4 || (e4 = import("./lclayout-V24RFAWQ.js").then((t2) => t2.l).then(({ default: e5 }) => e5({ locateFile: (e6) => n2(`esri/libs/linkchartlayout/${e6}`) })).then((t2) => {
    s3(t2);
  }), e4);
}
function s3(t2) {
  r2 = t2;
}
var u;
var o;
function l2(t2, e5, a2, n4, s4, u2) {
  const o2 = a2.length, l3 = s4.length, y3 = Float64Array.BYTES_PER_ELEMENT, i2 = Uint32Array.BYTES_PER_ELEMENT, c2 = Uint8Array.BYTES_PER_ELEMENT, E2 = 16, f3 = E2 + o2 * (c2 + 2 * y3) + l3 * (2 * i2), p2 = r2._malloc(f3);
  try {
    const c3 = p2 + E2 - p2 % E2, f4 = c3 + o2 * y3, A2 = f4 + o2 * y3, _3 = A2 + l3 * i2, P3 = _3 + l3 * i2, b3 = () => [r2.HEAPF64.subarray(c3 >> 3, (c3 >> 3) + o2), r2.HEAPF64.subarray(f4 >> 3, (f4 >> 3) + o2), r2.HEAPU32.subarray(A2 >> 2, (A2 >> 2) + l3), r2.HEAPU32.subarray(_3 >> 2, (_3 >> 2) + l3), r2.HEAPU8.subarray(P3, P3 + o2)], [g2, H2, L, h2, d] = b3();
    g2.set(a2), H2.set(n4), L.set(s4), h2.set(u2), d.set(e5);
    let C = t2(o2, P3, c3, f4, l3, A2, _3), F = null, m2 = null;
    if (C) {
      const t3 = r2.getLayoutLinksTypes(), e6 = r2.getLayoutLinksVerticesEndIndices(), a3 = r2.getLayoutLinksVertices(), n5 = r2.countLayoutLinksVertices();
      !l3 || t3 && e6 ? n5 && !a3 ? C = false : (F = { types: new Uint8Array(r2.HEAPU8.subarray(t3, t3 + l3)), vertexEndIndex: new Uint32Array(r2.HEAPU32.subarray(e6 >> 2, (e6 >> 2) + l3)), vertices: new Float64Array(r2.HEAPF64.subarray(a3 >> 3, (a3 >> 3) + 2 * n5)) }, m2 = r2.getAuxiliaryGraphicElements()) : C = false;
    }
    const [R2, T2, U, B, v] = b3();
    return a2.set(R2), n4.set(T2), s4.set(U), u2.set(B), e5.set(v), { success: C, links: F, graphics: m2 };
  } finally {
    r2._free(p2), r2.cleanupLayout();
  }
}
!function(t2) {
  t2[t2.None = 0] = "None", t2[t2.IsMovable = 1] = "IsMovable", t2[t2.IsGeographic = 2] = "IsGeographic", t2[t2.IsRoot = 4] = "IsRoot";
}(u || (u = {})), function(t2) {
  t2[t2.Regular = 0] = "Regular", t2[t2.Orthogonal = 1] = "Orthogonal", t2[t2.Curved = 2] = "Curved", t2[t2.Recursive = 3] = "Recursive";
}(o || (o = {}));
var y2 = 2;
var i = 1;
var c = -1;
var E;
var f2;
var p;
var A;
var _2;
var P;
var b2;
var g;
var H;
!function(t2) {
  function e5() {
    return r2.getMinIdealEdgeLength();
  }
  function a2(t3, e6, a3, n4, s4, u2 = y2, o2 = i, E2 = c) {
    return l2((t4, e7, a4, n5, s5, l3, y3) => r2.applyForceDirectedLayout(t4, e7, a4, n5, s5, l3, y3, u2, o2, E2), t3, e6, a3, n4, s4);
  }
  t2.getMinIdealEdgeLength = e5, t2.apply = a2;
}(E || (E = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4, u2 = y2, o2 = i, E2 = c) {
    return l2((t4, e7, a3, n5, s5, l3, y3) => r2.applyCommunityLayout(t4, e7, a3, n5, s5, l3, y3, u2, o2, E2), t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(f2 || (f2 = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applySimpleLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(p || (p = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applyHierarchicalLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(A || (A = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applyRadialTreeLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(_2 || (_2 = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4) {
    return l2(r2.applySmartTreeLayout, t3, e6, a2, n4, s4);
  }
  t2.apply = e5;
}(P || (P = {})), function(t2) {
  function e5(t3, e6, a2, n4, s4, u2, o2, y3, i2) {
    return l2((t4, e7, a3, u3, o3, l3, c2) => {
      if (n4.length !== t4) return false;
      if (s4.length !== t4) return false;
      if (y3.length !== o3) return false;
      if (i2.length !== o3) return false;
      const E2 = Float64Array.BYTES_PER_ELEMENT, f3 = 16, p2 = r2._malloc(f3 + t4 * E2), A2 = r2._malloc(f3 + t4 * E2), _3 = r2._malloc(f3 + o3 * E2), P3 = r2._malloc(f3 + o3 * E2), b3 = p2 + f3 - p2 % f3, g2 = A2 + f3 - A2 % f3, H2 = _3 + f3 - _3 % f3, L = P3 + f3 - P3 % f3;
      try {
        return r2.HEAPF64.subarray(b3 >> 3, (b3 >> 3) + t4).set(n4), r2.HEAPF64.subarray(g2 >> 3, (g2 >> 3) + t4).set(s4), r2.HEAPF64.subarray(H2 >> 3, (H2 >> 3) + o3).set(y3), r2.HEAPF64.subarray(L >> 3, (L >> 3) + o3).set(i2), r2.applyChronologicalLayout(t4, e7, a3, u3, b3, g2, o3, l3, c2, H2, L);
      } finally {
        r2._free(p2), r2._free(A2), r2._free(_3), r2._free(P3);
      }
    }, t3, e6, a2, u2, o2);
  }
  t2.apply = e5;
}(b2 || (b2 = {})), function(t2) {
  t2[t2.Undirected = 0] = "Undirected", t2[t2.Directed = 1] = "Directed", t2[t2.Reversed = 2] = "Reversed";
}(g || (g = {})), function(t2) {
  t2[t2.ByCC_Raw = 0] = "ByCC_Raw", t2[t2.ByCC_NormalizeGlobally = 1] = "ByCC_NormalizeGlobally", t2[t2.ByCC_NormalizeByCC = 2] = "ByCC_NormalizeByCC";
}(H || (H = {}));

// ../node_modules/@arcgis/core/layers/LinkChartLayer.js
var j = class extends l(t(f)) {
  constructor(e5) {
    if (super(e5), this.dataPreloadedInLocalCache = false, this.defaultLinkChartConfig = null, this._currentLinkChartConfig = { layoutMode: "RADIAL_TREE" }, this._graphTypeLookup = /* @__PURE__ */ new Map(), this.dataManager = null, this.knowledgeGraph = null, this.layers = new V(), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.linkChartExtent = new w({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 }), this.memberEntityTypes = null, this.memberRelationshipTypes = null, this.sublayerIdsCache = /* @__PURE__ */ new Map(), this.tables = new V(), this.type = "link-chart", this._originalInclusionList = e5.inclusionModeDefinition, e5.dataPreloadedInLocalCache && !e5.inclusionModeDefinition) throw new s("knowledge-graph:linkchart-layer-constructor", "If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");
  }
  normalizeCtorArgs(e5) {
    return { url: e5.url, title: e5.title, dataPreloadedInLocalCache: e5.dataPreloadedInLocalCache, defaultLinkChartConfig: e5.defaultLinkChartConfig };
  }
  _initializeLayerProperties(e5) {
    var _a, _b, _c, _d, _e, _f;
    if (!this.title && this.url) {
      const e6 = this.url.split("/");
      this.title = e6[e6.length - 2];
    }
    const t2 = /* @__PURE__ */ new Set();
    let n4 = [], s4 = [];
    if (e5.inclusionModeDefinition && (!e5.inclusionModeDefinition.namedTypeDefinitions || e5.inclusionModeDefinition.namedTypeDefinitions.size < 1)) throw new s("knowledge-graph:composite-layer-constructor", "If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");
    (_a = e5.knowledgeGraph.dataModel.entityTypes) == null ? void 0 : _a.forEach((e6) => {
      e6.name && this._graphTypeLookup.set(e6.name, e6);
    }), (_b = e5.knowledgeGraph.dataModel.relationshipTypes) == null ? void 0 : _b.forEach((e6) => {
      e6.name && this._graphTypeLookup.set(e6.name, e6);
    }), ((_c = e5.inclusionModeDefinition) == null ? void 0 : _c.generateAllSublayers) ? (n4 = e5.knowledgeGraph.dataModel.entityTypes ?? [], s4 = e5.knowledgeGraph.dataModel.relationshipTypes ?? []) : ((_d = e5.inclusionModeDefinition) == null ? void 0 : _d.namedTypeDefinitions) && ((_e = e5.inclusionModeDefinition) == null ? void 0 : _e.namedTypeDefinitions.size) > 0 ? (_f = e5.inclusionModeDefinition) == null ? void 0 : _f.namedTypeDefinitions.forEach((a2, o3) => {
      var _a2, _b2;
      const r3 = this._graphTypeLookup.get(o3);
      if (!r3) return n.getLogger(this).warn(`A named type, ${o3}, was in the inclusion list that wasn't in the data model and will be removed`), void ((_a2 = e5.inclusionModeDefinition) == null ? void 0 : _a2.namedTypeDefinitions.delete(o3));
      "relationship" === r3.type ? t2.has(o3) || (t2.add(o3), s4.push(r3)) : "entity" === r3.type ? t2.has(o3) || (t2.add(o3), n4.push(r3)) : (n.getLogger(this).warn(`A named type, ${o3}, was in the inclusion list that wasn't properly modeled and will be removed`), (_b2 = e5.inclusionModeDefinition) == null ? void 0 : _b2.namedTypeDefinitions.delete(o3));
    }) : (n4 = e5.knowledgeGraph.dataModel.entityTypes ?? [], s4 = e5.knowledgeGraph.dataModel.relationshipTypes ?? []);
    const o2 = new M({ knowledgeGraph: e5.knowledgeGraph, inclusionModeDefinition: e5.inclusionModeDefinition });
    this.knowledgeGraph = e5.knowledgeGraph, this.memberEntityTypes = n4, this.memberRelationshipTypes = s4, this.dataManager = o2;
  }
  load(e5) {
    return this.addResolvingPromise(new Promise((t2) => {
      R(this.url).then((a2) => {
        var _a, _b, _c, _d, _e, _f;
        if (this._initializeLayerProperties({ knowledgeGraph: a2, inclusionModeDefinition: this._originalInclusionList }), ((_b = (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) == null ? void 0 : _b.size) || (this.dataManager.inclusionModeDefinition = { generateAllSublayers: false, namedTypeDefinitions: /* @__PURE__ */ new Map() }, (_c = this.dataManager.knowledgeGraph.dataModel.entityTypes) == null ? void 0 : _c.forEach((e6) => {
          var _a2;
          e6.name && ((_a2 = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a2.namedTypeDefinitions.set(e6.name, { useAllData: true }));
        }), (_d = this.dataManager.knowledgeGraph.dataModel.relationshipTypes) == null ? void 0 : _d.forEach((e6) => {
          var _a2;
          e6.name && ((_a2 = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a2.namedTypeDefinitions.set(e6.name, { useAllData: true }));
        })), this.dataPreloadedInLocalCache) this.loadLayerAssumingLocalCache(), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false), (_e = this.dataManager.inclusionModeDefinition) == null ? void 0 : _e.namedTypeDefinitions.forEach((e6) => {
          var _a2;
          e6.useAllData = false, (_a2 = e6.members) == null ? void 0 : _a2.forEach((e7) => {
            let t3;
            t3 = e7.linkChartLocation instanceof e2 ? e7.linkChartLocation : e7.linkChartLocation ? ot(e7.linkChartLocation) : null, t3 && 2 === t3.coords.length && 0 === t3.lengths.length ? this.entityLinkChartDiagramLookup.set(e7.id, t3) : this.relationshipLinkChartDiagramLookup.set(e7.id, t3);
          }), this.addResolvingPromise(this._initializeDiagram().then(async () => {
            this.layers.forEach(async (e7) => {
              await e7.refreshCachedQueryEngine();
            }), this.tables.forEach(async (e7) => {
              await e7.refreshCachedQueryEngine();
            });
          }));
        });
        else {
          const t3 = "GEOGRAPHIC" === ((_f = this.defaultLinkChartConfig) == null ? void 0 : _f.layoutMode);
          this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0, false, t3, true).then(async () => {
            s2(e5);
            const t4 = [], a3 = [];
            this.loadLayerAssumingLocalCache(), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false, this.dataManager.inclusionModeDefinition.namedTypeDefinitions.forEach((e6) => {
              e6.useAllData = false;
            })), await this._initializeDiagram(), this.layers.forEach((e6) => {
              a3.push(e6.refreshCachedQueryEngine()), t4.push(new Promise((t5) => {
                e6.on("layerview-create", () => {
                  t5(null);
                });
              }));
            }), this.tables.forEach((e6) => {
              a3.push(e6.refreshCachedQueryEngine());
            }), await Promise.all(a3);
          }));
        }
        t2(null);
      });
    })), Promise.resolve(this);
  }
  async addRecords(e5, t2) {
    let a2 = [];
    (t2 == null ? void 0 : t2.cascadeAddRelationshipEndNodes) && this.dataManager.knowledgeGraph.dataModel && (a2 = await h(e5, this.dataManager.knowledgeGraph));
    const i2 = e5.concat(a2).filter((e6) => {
      var _a;
      return !((_a = this.sublayerIdsCache.get(e6.typeName)) == null ? void 0 : _a.has(e6.id));
    });
    await this._handleNewRecords(i2);
  }
  async removeRecords(e5, { cascadeRemoveRelationships: t2 = true, recalculateLayout: a2 = false } = { cascadeRemoveRelationships: true, recalculateLayout: false }) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let i2 = [];
    for (const s4 of e5) false === ((_c = (_b = (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) == null ? void 0 : _b.get(s4.typeName)) == null ? void 0 : _c.useAllData) && ((_g = (_f = (_e = (_d = this.dataManager.inclusionModeDefinition) == null ? void 0 : _d.namedTypeDefinitions) == null ? void 0 : _e.get(s4.typeName)) == null ? void 0 : _f.members) == null ? void 0 : _g.has(s4.id)) && i2.push(s4);
    if (t2) {
      const e6 = /* @__PURE__ */ new Set(), t3 = [];
      for (const a3 of i2) if (this.dataManager.nodeConnectionsLookup.has(a3.id)) for (const t4 of this.dataManager.nodeConnectionsLookup.get(a3.id)) e6.add(t4);
      for (const a3 of e6) if (this.dataManager.memberIdTypeLookup.has(a3)) for (const e7 of this.dataManager.memberIdTypeLookup.get(a3)) this.dataManager.relationshipTypeNames.has(e7) && t3.push({ id: a3, typeName: e7 });
      i2 = i2.concat(t3);
    }
    this.dataManager.removeFromLayer(i2);
    for (const s4 of i2) (_h = this.sublayerIdsCache.get(s4.typeName)) == null ? void 0 : _h.delete(s4.id), this.dataManager.relationshipTypeNames.has(s4.typeName) ? this.relationshipLinkChartDiagramLookup.delete(s4.id) : this.entityLinkChartDiagramLookup.delete(s4.id);
    a2 && await this.calculateLinkChartLayout(this._currentLinkChartConfig.layoutMode, this._currentLinkChartConfig.layoutOptions);
    const n4 = [];
    return this.layers.forEach((e6) => {
      n4.push(e6.refreshCachedQueryEngine());
    }), await Promise.all(n4), this._refreshNamedTypes(), i2;
  }
  async expand(e5, t2) {
    const a2 = await this.dataManager.getConnectedRecordIds(e5, t2), i2 = a2.filter((e6) => {
      var _a;
      return !((_a = this.sublayerIdsCache.get(e6.typeName)) == null ? void 0 : _a.has(e6.id));
    });
    return await this._handleNewRecords(a2), { records: i2 };
  }
  loadLayerAssumingLocalCache() {
    var _a, _b;
    this.memberRelationshipTypes.forEach((e5) => {
      const t2 = new ae({ objectType: e5, parentCompositeLayer: this, graphType: "relationship", title: e5.name });
      t2.geometryType ? this.layers.push(t2) : this.tables.push(t2), this.dataManager.sublayerCaches.has(e5.name) || this.dataManager.sublayerCaches.set(e5.name, /* @__PURE__ */ new Map());
    }), this.memberEntityTypes.forEach((e5) => {
      const t2 = new ae({ objectType: e5, parentCompositeLayer: this, graphType: "entity", title: e5.name });
      t2.geometryType ? this.layers.push(t2) : this.tables.push(t2), this.dataManager.sublayerCaches.has(e5.name) || this.dataManager.sublayerCaches.set(e5.name, /* @__PURE__ */ new Map());
    }), ((_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) && ((_b = this.dataManager.inclusionModeDefinition) == null ? void 0 : _b.namedTypeDefinitions.forEach((e5, t2) => {
      var _a2;
      const a2 = r(this.sublayerIdsCache, t2, () => /* @__PURE__ */ new Set());
      (_a2 = e5.members) == null ? void 0 : _a2.forEach((e6) => {
        if (a2.add(e6.id), e6.linkChartLocation) if (e6.linkChartLocation instanceof e2) this.dataManager.relationshipTypeNames.has(t2) ? this.relationshipLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation) : this.entityLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation);
        else {
          const a3 = ot(e6.linkChartLocation);
          this.dataManager.relationshipTypeNames.has(t2) ? this.relationshipLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation ? a3 : null) : this.entityLinkChartDiagramLookup.set(e6.id, e6.linkChartLocation ? a3 : null);
        }
      });
    }));
  }
  async calculateLinkChartLayout(e5 = "RADIAL_TREE", t2) {
    var _a, _b, _c;
    const n4 = [], s4 = [], o2 = [];
    this.dataManager.sublayerCaches.forEach((e6, t3) => {
      this.dataManager.entityTypeNames.has(t3) ? e6.forEach((e7) => {
        n4.push({ typeName: t3, feature: e7 });
      }) : this.dataManager.relationshipTypeNames.has(t3) && e6.forEach((e7) => {
        s4.push({ typeName: t3, feature: e7 });
      });
    }), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map();
    const r3 = /* @__PURE__ */ new Map(), h2 = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map(), p2 = /* @__PURE__ */ new Map(), u2 = new Uint8Array(n4.length), L = new Float64Array(n4.length), C = new Float64Array(n4.length), k = new Uint32Array(s4.length), M2 = new Uint32Array(s4.length), I2 = [], j2 = "FORCE_DIRECTED", P3 = new w({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 });
    let S, O = "FORCE_DIRECTED", z = 0, U = 0;
    switch (O = "GEOGRAPHIC" === e5 ? j2 : e5, O) {
      case "FORCE_DIRECTED":
        S = E.apply;
        break;
      case "COMMUNITY":
        S = f2.apply;
        break;
      case "HIERARCHICAL":
        S = A.apply;
        break;
      case "RADIAL_TREE":
        S = _2.apply;
        break;
      case "SMART_TREE":
        S = P.apply;
        break;
      default:
        S = p.apply;
    }
    n4.forEach(({ typeName: a2, feature: i2 }) => {
      var _a2, _b2, _c2;
      if ((_a2 = t2 == null ? void 0 : t2.lockedNodeLocations) == null ? void 0 : _a2.has(i2.attributes[w2])) {
        "GEOGRAPHIC" === e5 && this.dataManager.geographicLookup.has(a2) ? u2[z] = u.IsGeographic : u2[z] = u.None;
        const n5 = t2.lockedNodeLocations.get(i2.attributes[w2]);
        L[z] = n5.x, C[z] = n5.y;
      } else if ("GEOGRAPHIC" === e5 && this.dataManager.geographicLookup.has(a2)) {
        u2[z] = u.IsGeographic;
        let e6 = null;
        const t3 = i2.attributes[this.dataManager.geographicLookup.get(a2).name], n5 = (_b2 = this.dataManager.geographicLookup.get(a2)) == null ? void 0 : _b2.geometryType;
        switch (n5) {
          case "esriGeometryPoint":
            L[z] = t3 == null ? void 0 : t3.x, C[z] = t3 == null ? void 0 : t3.y;
            break;
          case "esriGeometryPolygon":
            e6 = t3 == null ? void 0 : t3.centroid, null != (e6 == null ? void 0 : e6.x) && null != (e6 == null ? void 0 : e6.y) ? (L[z] = e6.x, C[z] = e6.y) : u2[z] = u.IsMovable;
            break;
          case "esriGeometryPolyline":
          case "esriGeometryMultipoint":
            e6 = (_c2 = t3 == null ? void 0 : t3.extent) == null ? void 0 : _c2.center, null != (e6 == null ? void 0 : e6.x) && null != (e6 == null ? void 0 : e6.y) ? (L[z] = e6.x, C[z] = e6.y) : u2[z] = u.IsMovable;
            break;
          default:
            u2[z] = u.IsMovable;
        }
        (null == L[z] || null == C[z] || Number.isNaN(L[z]) || Number.isNaN(C[z])) && (u2[z] = u.IsMovable, L[z] = 0, C[z] = 0);
      } else u2[z] = u.IsMovable, L[z] = 0, C[z] = 0;
      p2.set(i2.attributes[w2], z), I2[z] = { feature: i2, typeName: a2 }, z++;
    });
    let H2 = false;
    const B = /* @__PURE__ */ new Map();
    s4.forEach((e6) => {
      const t3 = e6.feature.attributes[b], a2 = e6.feature.attributes[T], i2 = p2.get(t3), n5 = p2.get(a2);
      if (void 0 !== i2 && void 0 !== n5) {
        const s5 = t3 + "-" + a2, r4 = B.get(s5), h3 = r4 == null ? void 0 : r4.has(e6.typeName);
        h3 || (k[U] = i2, M2[U] = n5, void 0 === r4 ? B.set(s5, /* @__PURE__ */ new Map([[e6.typeName, U]])) : r4.set(e6.typeName, U), U++), o2.push(e6);
      } else H2 = true, this.relationshipLinkChartDiagramLookup.set(t3, null);
    }), H2 && n.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");
    const F = this._validateLayoutSettings(e5, t2), Q = this._convertLayoutSettingsToCalculationSettings(F);
    await n3();
    const { success: K, links: Y } = S(u2, L, C, k.subarray(0, U), M2.subarray(0, U), Q.computationBudgetTime, Q.idealEdgeLengthMultiplier, Q.repulsionRadiusMultiplier);
    if (!K) throw new s("knowledge-graph:layout-failed", "Attempting to arrange the records in the specified layout failed");
    for (let a2 = 0; a2 < I2.length; a2++) {
      if (C[a2] > 84.9999 ? C[a2] = 84.9999 : C[a2] < -84.9999 && (C[a2] = -84.9999), L[a2] > 179.9999 ? L[a2] = 179.9999 : L[a2] < -179.9999 && (L[a2] = -179.9999), I2[a2].feature.attributes[D] = new _(L[a2], C[a2]), r3.has(I2[a2].typeName)) {
        const e7 = r3.get(I2[a2].typeName);
        e7 == null ? void 0 : e7.set(I2[a2].feature.attributes[w2], I2[a2].feature);
      } else {
        const e7 = /* @__PURE__ */ new Map();
        e7.set(I2[a2].feature.attributes[w2], I2[a2].feature), r3.set(I2[a2].typeName, e7);
      }
      d.set(I2[a2].feature.attributes[w2], I2[a2].feature);
      const e6 = ot(I2[a2].feature.attributes[D]);
      this.entityLinkChartDiagramLookup.set(I2[a2].feature.attributes[w2], I2[a2].feature.attributes[D] ? e6 : null), I2[a2].feature.attributes[D].x < P3.xmin && (P3.xmin = I2[a2].feature.attributes[D].x), I2[a2].feature.attributes[D].x > P3.xmax && (P3.xmax = I2[a2].feature.attributes[D].x), I2[a2].feature.attributes[D].y < P3.ymin && (P3.ymin = I2[a2].feature.attributes[D].y), I2[a2].feature.attributes[D].y > P3.ymax && (P3.ymax = I2[a2].feature.attributes[D].y);
    }
    if (this.linkChartExtent.xmin = P3.xmin, this.linkChartExtent.xmax = P3.xmax, this.linkChartExtent.ymin = P3.ymin, this.linkChartExtent.ymax = P3.ymax, !Y) throw new s("knowledge-graph:layout-failed", "Attempting to retrieve link geometry from diagram engine failed");
    const $ = /* @__PURE__ */ new Map(), W = /* @__PURE__ */ new Map(), q = /* @__PURE__ */ new Map(), J = /* @__PURE__ */ new Set();
    for (let a2 = 0; a2 < o2.length; a2++) {
      const e6 = [], t3 = o2[a2], n5 = t3.feature.attributes[b], s5 = t3.feature.attributes[T], r4 = n5 + "-" + s5, u3 = B.get(r4).get(t3.typeName), f3 = 0 === u3 ? 0 : Y == null ? void 0 : Y.vertexEndIndex[u3 - 1];
      if (!J.has(u3)) {
        if (J.add(u3), Y.types[u3] === o.Recursive) {
          const t5 = [Y.vertices[2 * f3], Y.vertices[2 * f3 + 1]], a4 = [Y.vertices[2 * (f3 + 1)], Y.vertices[2 * (f3 + 1) + 1]], i2 = [0.5 * (t5[0] + a4[0]), 0.5 * (t5[1] + a4[1])], n6 = [i2[0] - t5[0], i2[1] - t5[1]], s6 = [i2[0] + n6[1], i2[1] - n6[0]], o3 = [i2[0] - n6[1], i2[1] + n6[0]];
          e6.push(t5), e6.push(s6), e6.push(a4), e6.push(o3), e6.push(t5);
        } else {
          if (Y.types[u3] !== o.Regular) {
            n.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");
            continue;
          }
          for (let t5 = f3; t5 < Y.vertexEndIndex[u3]; t5++) e6.push([Y.vertices[2 * t5], Y.vertices[2 * t5 + 1]]);
        }
        const t4 = (_a = I2[p2.get(n5)]) == null ? void 0 : _a.feature.attributes[D], a3 = (_b = I2[p2.get(s5)]) == null ? void 0 : _b.feature.attributes[D];
        e6[0][0] === t4.x && e6[0][1] === t4.y || (e6[0] = [t4.x, t4.y]), e6[e6.length - 1][0] === a3.x && e6[e6.length - 1][1] === a3.y || (e6[e6.length - 1] = [a3.x, a3.y]);
        for (let i2 = 1; i2 < e6.length - 1; i2++) e6[i2][1] > 85.5 ? e6[i2][1] = 85.5 : e6[i2][1] < -85.5 && (e6[i2][1] = -85.5), e6[i2][0] > 179.9999 ? e6[i2][0] = 179.9999 : e6[i2][0] < -179.9999 && (e6[i2][0] = -179.9999);
        $.has(r4) ? $.get(r4).push(e6) : $.set(r4, [e6]);
      }
      const L2 = $.get(r4);
      W.has(r4) || (W.set(r4, /* @__PURE__ */ new Map()), q.set(r4, /* @__PURE__ */ new Map()));
      const C2 = W.get(r4), k2 = q.get(r4);
      C2.has(t3.typeName) || (C2.set(t3.typeName, L2.shift()), k2.set(t3.typeName, 0));
      const M3 = C2.get(t3.typeName);
      k2.set(t3.typeName, k2.get(t3.typeName) + 1);
      const w3 = new m({ paths: M3 });
      if (t3.feature.attributes[D] = w3, h2.has(t3.typeName)) {
        const e7 = h2.get(t3.typeName);
        e7 == null ? void 0 : e7.set(t3.feature.attributes[w2], t3.feature);
      } else {
        const e7 = /* @__PURE__ */ new Map();
        e7.set(t3.feature.attributes[w2], t3.feature), h2.set(t3.typeName, e7);
      }
      d.set(t3.feature.attributes[w2], t3.feature);
      const b3 = ot(t3.feature.attributes[D]);
      this.relationshipLinkChartDiagramLookup.set(t3.feature.attributes[w2], t3.feature.attributes[D] ? b3 : null);
    }
    for (const a2 of o2) a2.feature.attributes[I] = ((_c = q.get(a2.feature.attributes[b] + "-" + a2.feature.attributes[T])) == null ? void 0 : _c.get(a2.typeName)) ?? null;
    return this._currentLinkChartConfig = { layoutMode: e5, layoutOptions: F }, { nodes: r3, links: h2, idMap: d };
  }
  async applyNewLinkChartLayout(e5 = "RADIAL_TREE", t2) {
    const a2 = [];
    await this.calculateLinkChartLayout(e5, t2), this.layers.forEach((e6) => {
      a2.push(e6.refreshCachedQueryEngine());
    }), await Promise.all(a2), this._refreshNamedTypes();
  }
  getCurrentNodeLocations() {
    var _a, _b;
    const e5 = /* @__PURE__ */ new Map();
    return (_b = (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) == null ? void 0 : _b.forEach((t2) => {
      var _a2;
      (_a2 = t2 == null ? void 0 : t2.members) == null ? void 0 : _a2.forEach((t3) => {
        const a2 = t3.linkChartLocation;
        let i2;
        const n4 = t3.id;
        a2 && (i2 = "x" in a2 ? { x: a2.x, y: a2.y } : { x: a2.coords[0], y: a2.coords[1] }, e5.set(n4, new _({ x: i2.x, y: i2.y })));
      });
    }), e5;
  }
  async synchronizeInclusionListWithCache() {
    return new Promise((e5) => {
      var _a;
      (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions.forEach((e6, t2) => {
        if (e6.useAllData = false, e6.members && e6.members.size > 0) {
          if (!this.dataManager.sublayerCaches.get(t2)) return;
          const a2 = new Set(Array.from(this.dataManager.sublayerCaches.get(t2).keys()));
          Array.from(e6.members.keys()).filter((e7) => !a2.has(e7)).forEach((t3) => {
            var _a2;
            (_a2 = e6.members) == null ? void 0 : _a2.delete(t3);
          });
        }
      }), e5();
    });
  }
  async refreshLinkChartCache(e5) {
    await this.dataManager.refreshCacheContent(e5);
    const t2 = [];
    this.layers.forEach((e6) => {
      t2.push(e6.refreshCachedQueryEngine());
    }), await Promise.all(t2), this._refreshNamedTypes();
  }
  async connectEntities(e5) {
    let t2 = [];
    for (const i2 of this.dataManager.relationshipTypeNames) {
      const e6 = this.sublayerIdsCache.get(i2);
      e6 && (t2 = t2.concat(Array.from(e6.keys())));
    }
    const a2 = await this.dataManager.getAttachedRelationships(e5, t2);
    return await this._handleNewRecords(a2), { records: a2 };
  }
  async _handleNewRecords(e5) {
    const t2 = [];
    this.dataManager.addToLayer(e5);
    for (const i2 of e5) this.sublayerIdsCache.has(i2.typeName) || (this.sublayerIdsCache.set(i2.typeName, /* @__PURE__ */ new Set()), t2.push(i2.typeName)), this.sublayerIdsCache.get(i2.typeName).add(i2.id);
    for (const i2 of t2) {
      const e6 = this._graphTypeLookup.get(i2);
      if (e6) {
        const t3 = new ae({ objectType: e6, parentCompositeLayer: this, graphType: e6.type, title: i2 });
        "entity" === e6.type ? this.dataManager.entityTypeNames.add(i2) : this.dataManager.relationshipTypeNames.add(i2), t3.geometryType ? this.layers.push(t3) : this.tables.push(t3), this.dataManager.sublayerCaches.set(i2, /* @__PURE__ */ new Map());
      }
    }
    await this.dataManager.refreshCacheContent(e5.map((e6) => e6.id));
    const a2 = Object.assign({}, this._currentLinkChartConfig.layoutOptions);
    a2.lockedNodeLocations = this.getCurrentNodeLocations(), await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode, a2);
  }
  async _initializeDiagram() {
    var _a, _b;
    this.defaultLinkChartConfig ? this.defaultLinkChartConfig.doNotRecalculateLayout ? ((_b = (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) == null ? void 0 : _b.forEach((e5, t2) => {
      var _a2;
      (_a2 = e5 == null ? void 0 : e5.members) == null ? void 0 : _a2.forEach((e6) => {
        const a2 = e6.linkChartLocation;
        let i2;
        const n4 = e6.id;
        if (!a2) return;
        i2 = "x" in a2 ? { x: a2.x, y: a2.y } : { x: a2.coords[0], y: a2.coords[1] };
        const s4 = ot(i2);
        this.dataManager.relationshipTypeNames.has(t2) ? this.relationshipLinkChartDiagramLookup.set(n4, s4) : this.entityLinkChartDiagramLookup.set(n4, s4), this.linkChartExtent.xmin > i2.x && (this.linkChartExtent.xmin = i2.x), this.linkChartExtent.xmax < i2.x && (this.linkChartExtent.xmax = i2.x), this.linkChartExtent.ymin > i2.y && (this.linkChartExtent.ymin = i2.y), this.linkChartExtent.ymax < i2.y && (this.linkChartExtent.ymax = i2.y);
      });
    }), this.memberRelationshipTypes.forEach((e5) => {
      var _a2;
      e5.name && ((_a2 = this.dataManager.sublayerCaches.get(e5.name)) == null ? void 0 : _a2.forEach((e6) => {
        const t2 = this.relationshipLinkChartDiagramLookup.get(e6.attributes[b]), a2 = this.relationshipLinkChartDiagramLookup.get(e6.attributes[T]);
        if (t2 && a2) {
          const i2 = ot(new m({ paths: [[t2.coords[0], t2.coords[1]], [a2.coords[0], a2.coords[1]]] }));
          this.relationshipLinkChartDiagramLookup.set(e6.attributes[w2], i2);
        } else this.relationshipLinkChartDiagramLookup.set(e6.attributes[w2], null);
      }));
    })) : await this.calculateLinkChartLayout(this.defaultLinkChartConfig.layoutMode, { lockedNodeLocations: this.getCurrentNodeLocations(), ...this.defaultLinkChartConfig.layoutOptions || {} }) : await this.calculateLinkChartLayout("RADIAL_TREE", { lockedNodeLocations: this.getCurrentNodeLocations() });
  }
  _refreshNamedTypes() {
    for (const e5 of this.layers) e5.emit("refresh", { dataChanged: true });
    for (const e5 of this.tables) e5.emit("refresh", { dataChanged: true });
  }
  _validateLayoutSettings(e5, t2) {
    const a2 = (e6) => "number" == typeof e6 && !isNaN(e6), n4 = (e6) => a2(e6) && e6 >= 1, s4 = (e6) => a2(e6) && e6 >= 1, o2 = (e6) => Object.values(e3).includes(e6), r3 = (e6) => a2(e6) && e6 >= 0, h2 = /* @__PURE__ */ new Set(["FORCE_DIRECTED", "COMMUNITY", "GEOGRAPHIC"]), l3 = {};
    if (!h2.has(e5) || !t2) return !h2.has(e5) && t2 && n.getLogger(this).warn("Layout mode options were given for a layout mode that does not utilize them, settings will be ignored"), l3;
    const { computationBudgetTime: d, repulsionRadiusMultiplier: u2, idealEdgeLength: c2, idealEdgeLengthType: y3 } = t2;
    s4(d) ? l3.computationBudgetTime = d : void 0 !== d && n.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"), n4(u2) ? l3.repulsionRadiusMultiplier = u2 : void 0 !== u2 && n.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting");
    const g2 = void 0 !== c2 || void 0 !== y3;
    return "GEOGRAPHIC" !== e5 && g2 ? n.getLogger(this).warn("Ideal edge length settings were specified for an incompatible layout mode, and will be ignored") : "GEOGRAPHIC" === e5 && g2 && (o2(y3) ? l3.idealEdgeLengthType = y3 : void 0 !== y3 && n.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'), r3(c2) ? l3.idealEdgeLength = c2 : void 0 !== c2 && n.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")), l3;
  }
  _convertLayoutSettingsToCalculationSettings(e5) {
    let t2 = e5.idealEdgeLength;
    return e5.idealEdgeLengthType === e3.ABSOLUTE && (void 0 === t2 ? t2 = -1 : t2 *= -1), { computationBudgetTime: e5.computationBudgetTime, repulsionRadiusMultiplier: e5.repulsionRadiusMultiplier, idealEdgeLengthMultiplier: t2 };
  }
};
e([y()], j.prototype, "dataPreloadedInLocalCache", void 0), e([y()], j.prototype, "defaultLinkChartConfig", void 0), e([y()], j.prototype, "dataManager", void 0), e([y()], j.prototype, "knowledgeGraph", void 0), e([y()], j.prototype, "layers", void 0), e([y()], j.prototype, "entityLinkChartDiagramLookup", void 0), e([y()], j.prototype, "relationshipLinkChartDiagramLookup", void 0), e([y()], j.prototype, "linkChartExtent", void 0), e([y()], j.prototype, "memberEntityTypes", void 0), e([y()], j.prototype, "memberRelationshipTypes", void 0), e([y()], j.prototype, "sublayerIdsCache", void 0), e([y()], j.prototype, "tables", void 0), e([y({ json: { read: false } })], j.prototype, "type", void 0), j = e([a("esri.layers.LinkChartLayer")], j);
var P2 = j;
export {
  P2 as default
};
//# sourceMappingURL=LinkChartLayer-3PNRM3ML.js.map
