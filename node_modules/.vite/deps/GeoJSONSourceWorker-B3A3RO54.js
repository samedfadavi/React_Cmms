import {
  E,
  I,
  N
} from "./chunk-BGYJXU44.js";
import {
  d as d2,
  f,
  j as j2,
  p as p2,
  y
} from "./chunk-KENYLMTJ.js";
import {
  c,
  i as i3,
  o
} from "./chunk-6RHMAIR4.js";
import "./chunk-DYYENG3B.js";
import {
  m
} from "./chunk-UOIKTJMB.js";
import "./chunk-DO3EYTSJ.js";
import {
  $
} from "./chunk-VR7WVNO3.js";
import {
  j,
  x
} from "./chunk-5T4GYCDT.js";
import "./chunk-P6AJLPW7.js";
import {
  et,
  nt,
  ot,
  rt,
  tt
} from "./chunk-F54TE5DA.js";
import "./chunk-ZPZCSP4J.js";
import "./chunk-5YPRHJQA.js";
import "./chunk-ZVC7ZICV.js";
import "./chunk-V3JQJNA6.js";
import "./chunk-VBYAAZGS.js";
import "./chunk-C5TCSNRO.js";
import "./chunk-MGJTYDNO.js";
import "./chunk-PFCHMQMS.js";
import "./chunk-QSCURXVW.js";
import "./chunk-DDQ2RCGU.js";
import "./chunk-OBN3TJ5S.js";
import "./chunk-YJXOPMOL.js";
import "./chunk-P3MZKJDB.js";
import "./chunk-JWA73VK6.js";
import "./chunk-UFNQVX5G.js";
import {
  Z
} from "./chunk-LXDJBJSP.js";
import "./chunk-OPCT64AO.js";
import "./chunk-3D32E2TW.js";
import "./chunk-OIFKYPGO.js";
import "./chunk-JNGB7HKP.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import "./chunk-DZNQTDMC.js";
import "./chunk-URNMKNS6.js";
import "./chunk-3QWMYL5A.js";
import "./chunk-MB5H6D2S.js";
import "./chunk-LVH66MEH.js";
import "./chunk-4FW6GTBF.js";
import "./chunk-E5ZJCKHO.js";
import {
  i as i2
} from "./chunk-2ASAB4KA.js";
import "./chunk-YUQFVZCH.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-T4EIRKFE.js";
import "./chunk-PHVKM5OH.js";
import "./chunk-KQ5GHUVQ.js";
import "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-JQIB7GFW.js";
import "./chunk-BJHLU2MM.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-TW7VY7XV.js";
import {
  H,
  K
} from "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import "./chunk-BL2UGYYZ.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import {
  p
} from "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import {
  i
} from "./chunk-AZ7WOCBW.js";
import "./chunk-3DBICPHD.js";
import {
  d
} from "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import "./chunk-F4OBDVPS.js";
import {
  G,
  g
} from "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import {
  U
} from "./chunk-WC4SPMPL.js";
import "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import "./chunk-GEH2VXFC.js";
import "./chunk-BJY5ADVY.js";
import {
  b
} from "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/layers/graphics/sources/geojson/GeoJSONSourceWorker.js
var D = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: false, supportsSqlExpression: true, supportsDisjointSpatialRel: true } };
var Q = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e) => {
      const t = await this._fetch(e);
      return this._createFeatures(t);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = this._createDefaultAttributes = null;
  }
  async load(e, t = {}) {
    this._loadOptions = { url: e.url, customParameters: e.customParameters };
    const i4 = [], [r] = await Promise.all([e.url ? this._fetch(t == null ? void 0 : t.signal) : null, this._checkProjection(e.spatialReference)]), n2 = I(r, { geometryType: e.geometryType }), o2 = e.fields || n2.fields || [], l = null != e.hasZ ? e.hasZ : n2.hasZ, u = n2.geometryType;
    let d3 = e.objectIdField || n2.objectIdFieldName || "__OBJECTID";
    const p3 = e.spatialReference || g;
    let c2 = e.timeInfo;
    o2 === n2.fields && n2.unknownFields.length > 0 && i4.push({ name: "geojson-layer:unknown-field-types", message: "Some fields types couldn't be inferred from the features and were dropped", details: { unknownFields: n2.unknownFields } });
    const y2 = new Z(o2);
    let h = y2.get(d3);
    h ? ("esriFieldTypeString" !== h.type && (h.type = "esriFieldTypeOID"), h.editable = false, h.nullable = false, d3 = h.name) : (h = { alias: d3, name: d3, type: "string" === n2.objectIdFieldType ? "esriFieldTypeString" : "esriFieldTypeOID", editable: false, nullable: false }, o2.unshift(h));
    const _ = {};
    for (const a of o2) {
      if (null == a.name && (a.name = a.alias), null == a.alias && (a.alias = a.name), !a.name) throw new s("geojson-layer:invalid-field-name", "field name is missing", { field: a });
      if (!i2.jsonValues.includes(a.type)) throw new s("geojson-layer:invalid-field-type", `invalid type for field "${a.name}"`, { field: a });
      if (a.name !== h.name) {
        const e2 = H(a);
        void 0 !== e2 && (_[a.name] = e2);
      }
      null == a.length && (a.length = K(a));
    }
    if (c2) {
      if (c2.startTimeField) {
        const e2 = y2.get(c2.startTimeField);
        e2 ? (c2.startTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.startTimeField = null;
      }
      if (c2.endTimeField) {
        const e2 = y2.get(c2.endTimeField);
        e2 ? (c2.endTimeField = e2.name, e2.type = "esriFieldTypeDate") : c2.endTimeField = null;
      }
      if (c2.trackIdField) {
        const e2 = y2.get(c2.trackIdField);
        e2 ? c2.trackIdField = e2.name : (c2.trackIdField = null, i4.push({ name: "geojson-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: c2 } }));
      }
      c2.startTimeField || c2.endTimeField || (i4.push({ name: "geojson-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing", details: { timeInfo: c2 } }), c2 = null);
    }
    const F = u ? o(u) : void 0, b2 = y2.dateFields.length ? { timeZoneIANA: i } : null, T = { warnings: i4, featureErrors: [], layerDefinition: { ...D, drawingInfo: F ?? void 0, templates: c(_), extent: void 0, geometryType: u, objectIdField: d3, fields: o2, hasZ: !!l, timeInfo: c2, dateFieldsTimeReference: b2 } };
    this._queryEngine = new $({ fieldsIndex: Z.fromLayerJSON({ fields: o2, timeInfo: c2, dateFieldsTimeReference: b2 }), geometryType: u, hasM: false, hasZ: l, objectIdField: d3, spatialReference: p3, timeInfo: c2, featureStore: new m({ geometryType: u, hasM: false, hasZ: l }), cacheSpatialQueries: true });
    const w = this._queryEngine.fieldsIndex.requiredFields.indexOf(h);
    w > -1 && this._queryEngine.fieldsIndex.requiredFields.splice(w, 1), this._createDefaultAttributes = i3(_, d3);
    const q = await this._createFeatures(r);
    this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, q);
    const x2 = this._normalizeFeatures(q, T.featureErrors);
    this._queryEngine.featureStore.addMany(x2);
    const { fullExtent: Q2, timeExtent: v } = await this._queryEngine.fetchRecomputedExtents();
    if (T.layerDefinition.extent = Q2, v) {
      const { start: e2, end: t2 } = v;
      T.layerDefinition.timeInfo.timeExtent = [e2, t2];
    }
    return T;
  }
  async applyEdits(e) {
    const { spatialReference: t, geometryType: s2 } = this._queryEngine;
    return await Promise.all([j2(t, s2), x(e.adds, t), x(e.updates, t)]), await this._waitSnapshotComplete(), this._applyEdits(e);
  }
  async queryFeatures(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e, t.signal);
  }
  async queryFeatureCount(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e, t.signal);
  }
  async queryObjectIds(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e, t.signal);
  }
  async queryExtent(e = {}, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e, t.signal);
  }
  async querySnapping(e, t = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e, t.signal);
  }
  async refresh(e) {
    var _a;
    this._loadOptions.customParameters = e, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d(this._snapshotFeatures), this._snapshotTask.promise.then((e2) => {
      this._queryEngine.featureStore.clear(), this._objectIdGenerator = this._createObjectIdGenerator(this._queryEngine, e2);
      const t = this._normalizeFeatures(e2);
      t && this._queryEngine.featureStore.addMany(t);
    }, (e2) => {
      this._queryEngine.featureStore.clear(), b(e2) || n.getLogger("esri.layers.GeoJSONLayer").error(new s("geojson-layer:refresh", "An error occurred during refresh", { error: e2 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: n2, timeExtent: a } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n2, timeExtent: a };
  }
  async _createFeatures(e) {
    if (null == e) return [];
    const { geometryType: t, hasZ: s2, objectIdField: i4 } = this._queryEngine, r = N(e, { geometryType: t, hasZ: s2, objectIdField: i4 });
    if (!G(this._queryEngine.spatialReference, g)) for (const n2 of r) null != n2.geometry && (n2.geometry = ot(j(rt(n2.geometry, this._queryEngine.geometryType, this._queryEngine.hasZ, false), g, this._queryEngine.spatialReference)));
    return r;
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t) {
    const { url: s2, customParameters: i4 } = this._loadOptions, r = (await U(s2 ?? "", { responseType: "json", query: { ...i4 }, signal: t })).data;
    return E(r), r;
  }
  _normalizeFeatures(e, t) {
    const { objectIdField: s2, fieldsIndex: i4 } = this._queryEngine, r = [];
    for (const n2 of e) {
      const e2 = this._createDefaultAttributes(), a = p2(i4, e2, n2.attributes, true);
      a ? t == null ? void 0 : t.push(a) : (this._assignObjectId(e2, n2.attributes, true), n2.attributes = e2, n2.objectId = e2[s2], r.push(n2));
    }
    return r;
  }
  async _applyEdits(e) {
    const { adds: t, updates: s2, deletes: i4 } = e, r = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if ((t == null ? void 0 : t.length) && this._applyAddEdits(r, t), (s2 == null ? void 0 : s2.length) && this._applyUpdateEdits(r, s2), i4 == null ? void 0 : i4.length) {
      for (const e2 of i4) r.deleteResults.push(d2(e2));
      this._queryEngine.featureStore.removeManyById(i4);
    }
    const { fullExtent: n2, timeExtent: a } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: n2, timeExtent: a, featureEditResults: r };
  }
  _applyAddEdits(e, t) {
    const { addResults: s2 } = e, { geometryType: i4, hasM: r, hasZ: a, objectIdField: o2, spatialReference: l, featureStore: u, fieldsIndex: p3 } = this._queryEngine, c2 = [];
    for (const d3 of t) {
      if (d3.geometry && i4 !== p(d3.geometry)) {
        s2.push(f("Incorrect geometry type."));
        continue;
      }
      const t2 = this._createDefaultAttributes(), r2 = p2(p3, t2, d3.attributes);
      if (r2) s2.push(r2);
      else {
        if (this._assignObjectId(t2, d3.attributes), d3.attributes = t2, null != d3.uid) {
          const t3 = d3.attributes[o2];
          e.uidToObjectId[d3.uid] = t3;
        }
        if (null != d3.geometry) {
          const e2 = d3.geometry.spatialReference ?? l;
          d3.geometry = j(y(d3.geometry, e2), e2, l);
        }
        c2.push(d3), s2.push(d2(d3.attributes[o2]));
      }
    }
    u.addMany(et([], c2, i4, a, r, o2));
  }
  _applyUpdateEdits({ updateResults: e }, t) {
    const { geometryType: s2, hasM: i4, hasZ: r, objectIdField: a, spatialReference: o2, featureStore: l, fieldsIndex: u } = this._queryEngine;
    for (const d3 of t) {
      const { attributes: t2, geometry: m2 } = d3, y2 = t2 == null ? void 0 : t2[a];
      if (null == y2) {
        e.push(f(`Identifier field ${a} missing`));
        continue;
      }
      if (!l.has(y2)) {
        e.push(f(`Feature with object id ${y2} missing`));
        continue;
      }
      const f2 = nt(l.getFeature(y2), s2, r, i4);
      if (null != m2) {
        if (s2 !== p(m2)) {
          e.push(f("Incorrect geometry type."));
          continue;
        }
        const t3 = m2.spatialReference ?? o2;
        f2.geometry = j(y(m2, t3), t3, o2);
      }
      if (t2) {
        const s3 = p2(u, f2.attributes, t2);
        if (s3) {
          e.push(s3);
          continue;
        }
      }
      l.add(tt(f2, s2, r, i4, a)), e.push(d2(y2));
    }
  }
  _createObjectIdGenerator(e, t) {
    const s2 = e.fieldsIndex.get(e.objectIdField);
    if ("esriFieldTypeString" === s2.type) return () => s2.name + "-" + Date.now().toString(16);
    let i4 = Number.NEGATIVE_INFINITY;
    for (const r of t) r.objectId && (i4 = Math.max(i4, r.objectId));
    return i4 = Math.max(0, i4) + 1, () => i4++;
  }
  _assignObjectId(e, t, s2 = false) {
    const i4 = this._queryEngine.objectIdField;
    e[i4] = s2 && i4 in t ? t[i4] : this._objectIdGenerator();
  }
  async _checkProjection(e) {
    try {
      await x(g, e);
    } catch {
      throw new s("geojson-layer", "Projection not supported");
    }
  }
};
export {
  Q as default
};
//# sourceMappingURL=GeoJSONSourceWorker-B3A3RO54.js.map
