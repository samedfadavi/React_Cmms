import {
  e as e5
} from "./chunk-ESM5T6DL.js";
import {
  i as i7
} from "./chunk-EZCD2BEA.js";
import {
  l as l2
} from "./chunk-DWRS6H6A.js";
import {
  i as i5,
  r,
  r2
} from "./chunk-IDGJX6LV.js";
import {
  M as M2,
  a as a6,
  c,
  h as h3,
  h2 as h4,
  i as i4,
  m as m2,
  n as n5,
  t as t4,
  t3 as t5,
  t4 as t6,
  x as x2
} from "./chunk-RYYZIVJQ.js";
import {
  i as i6
} from "./chunk-SQ4YHPTM.js";
import {
  f as f4,
  y as y3
} from "./chunk-ZCZQCHTP.js";
import {
  b as b4
} from "./chunk-ZGAEGZY4.js";
import {
  E,
  N,
  R,
  a as a5,
  h as h2,
  s2 as s4
} from "./chunk-55VZQ2O4.js";
import {
  o as o6
} from "./chunk-RBD4NFLO.js";
import {
  n as n4,
  p as p2
} from "./chunk-FHON4NYJ.js";
import {
  o as o3
} from "./chunk-TNYUXGW7.js";
import {
  t as t2
} from "./chunk-HGR37N5M.js";
import {
  t
} from "./chunk-TLURKUXV.js";
import {
  ee,
  me,
  o as o5,
  re
} from "./chunk-CWKNMWWX.js";
import {
  G
} from "./chunk-TCGVPS3X.js";
import {
  i as i2,
  o as o4
} from "./chunk-A2WMIQD6.js";
import {
  tt
} from "./chunk-F54TE5DA.js";
import {
  t as t3
} from "./chunk-OELB7RPX.js";
import {
  e as e4
} from "./chunk-2U77OHLU.js";
import {
  s as s3
} from "./chunk-H6PZORTK.js";
import {
  h
} from "./chunk-6V4RA3W6.js";
import {
  a as a3
} from "./chunk-GPH64EJR.js";
import {
  d as d5,
  w as w2
} from "./chunk-FY5GOH3U.js";
import {
  a as a4
} from "./chunk-QBW6ZJYD.js";
import {
  d as d4
} from "./chunk-647CGSDX.js";
import {
  i
} from "./chunk-P35RWHDU.js";
import {
  m
} from "./chunk-G5U2OA3R.js";
import {
  f as f3
} from "./chunk-OIFKYPGO.js";
import {
  p
} from "./chunk-ZRA2NDCA.js";
import {
  b as b2
} from "./chunk-LLJZCFHW.js";
import {
  n as n3
} from "./chunk-LTSQHA4C.js";
import {
  g
} from "./chunk-OHUWK5XV.js";
import {
  O as O2
} from "./chunk-PHVKM5OH.js";
import {
  d as d6
} from "./chunk-CJJCN7PA.js";
import {
  S as S2,
  d as d3,
  y as y2
} from "./chunk-IJ42YN7D.js";
import {
  I,
  J,
  L as L2,
  M,
  O as O3,
  T,
  b as b3,
  i as i3,
  je,
  v as v2,
  w as w3,
  x
} from "./chunk-CAC7FEOV.js";
import {
  n as n2
} from "./chunk-KK4UI5LV.js";
import {
  u as u5
} from "./chunk-BL2UGYYZ.js";
import {
  A,
  P,
  d as d2,
  v
} from "./chunk-7PMYO342.js";
import {
  V
} from "./chunk-3DBICPHD.js";
import {
  o as o2
} from "./chunk-ZK4LSXOH.js";
import {
  u as u4
} from "./chunk-AL3F322A.js";
import {
  F,
  e as e3
} from "./chunk-6N5YXCNN.js";
import {
  w
} from "./chunk-66KCMKB5.js";
import {
  o
} from "./chunk-ZART2Y5J.js";
import {
  f as f2
} from "./chunk-F4OBDVPS.js";
import {
  S,
  y
} from "./chunk-TJUEGVVG.js";
import {
  a3 as a2
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  L,
  b,
  d,
  e as e2,
  f,
  s as s2,
  u as u3
} from "./chunk-VMWKLHJD.js";
import {
  u as u2
} from "./chunk-5AEITAWU.js";
import {
  a,
  l2 as l,
  n2 as n,
  s2 as s,
  u
} from "./chunk-YNL57W4I.js";
import {
  O,
  has
} from "./chunk-2PA5UPTB.js";

// ../node_modules/@arcgis/core/AggregateGraphic.js
var p3 = class extends d6 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e8 = false) {
    var _a;
    if (this.popupTemplate) return this.popupTemplate;
    const t12 = (_a = this.sourceLayer) == null ? void 0 : _a.featureReduction;
    return t12 && "popupTemplate" in t12 && t12.popupEnabled ? t12.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
e([y({ type: Boolean })], p3.prototype, "isAggregate", void 0), p3 = e([a2("esri.AggregateGraphic")], p3);
var s5 = p3;

// ../node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var c2 = class extends S {
  constructor(e8) {
    super(e8), this._filter = null, this.duration = has("mapview-transitions-duration"), this._excludedEffectView = new h2(e8), this._includedEffectView = new h2(e8);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e8) {
    this._get("featureEffect") !== e8 && this._transitionTo(e8);
  }
  get filter() {
    var _a;
    return this._filter || ((_a = this.featureEffect) == null ? void 0 : _a.filter) || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e8) {
    this._set("scale", e8), this._excludedEffectView.scale = e8, this._includedEffectView.scale = e8;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  transitionStep(e8, t12) {
    this._set("scale", t12), this.transitioning ? (this._includedEffectView.transitionStep(e8, t12), this._excludedEffectView.transitionStep(e8, t12), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t12, this._includedEffectView.scale = t12);
  }
  endTransitions() {
    this._includedEffectView.endTransitions(), this._excludedEffectView.endTransitions(), this._filter = null;
  }
  _transitionTo(e8) {
    const t12 = this._get("featureEffect"), i11 = e8, s9 = i11 == null ? void 0 : i11.includedEffect, f7 = i11 == null ? void 0 : i11.excludedEffect, c9 = this._includedEffectView.canTransitionTo(s9) && this._excludedEffectView.canTransitionTo(f7);
    this._includedEffectView.effect = s9, this._excludedEffectView.effect = f7, this._set("featureEffect", i11), this._filter = (i11 == null ? void 0 : i11.filter) || (t12 == null ? void 0 : t12.filter) || null, c9 || this.endTransitions();
  }
};
e([y()], c2.prototype, "_filter", void 0), e([y()], c2.prototype, "_excludedEffectView", void 0), e([y()], c2.prototype, "_includedEffectView", void 0), e([y()], c2.prototype, "duration", void 0), e([y()], c2.prototype, "excludedEffects", null), e([y()], c2.prototype, "featureEffect", null), e([y()], c2.prototype, "filter", null), e([y()], c2.prototype, "hasEffects", null), e([y()], c2.prototype, "includedEffects", null), e([y({ value: 0 })], c2.prototype, "scale", null), e([y()], c2.prototype, "transitioning", null), c2 = e([a2("esri.layers.effects.FeatureEffectView")], c2);
var r3 = c2;

// ../node_modules/@arcgis/core/rest/support/AggregateFeatureSet.js
var c3 = class extends d4 {
  constructor() {
    super(...arguments), this.features = [];
  }
  readFeatures(e8, t12) {
    var _a;
    const o15 = f2.fromJSON(t12.spatialReference), s9 = [];
    for (let a10 = 0; a10 < e8.length; a10++) {
      const t13 = e8[a10], p7 = s5.fromJSON(t13), c9 = (_a = t13.geometry) == null ? void 0 : _a.spatialReference;
      null == p7.geometry || c9 || (p7.geometry.spatialReference = o15);
      const m9 = t13.aggregateGeometries, i11 = p7.aggregateGeometries;
      if (m9 && null != i11) for (const e9 in i11) {
        const r8 = i11[e9], t14 = m9[e9], s10 = t14 == null ? void 0 : t14.spatialReference;
        null == r8 || s10 || (r8.spatialReference = o15);
      }
      s9.push(p7);
    }
    return s9;
  }
};
e([y({ type: [s5], json: { write: true } })], c3.prototype, "features", void 0), e([o("features")], c3.prototype, "readFeatures", null), c3 = e([a2("esri.rest.support.AggregateFeatureSet")], c3);
var m3 = c3;

// ../node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/FeatureInstanceStore.js
var s6 = class {
  constructor() {
    this._instanceById = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._instanceById.clear();
  }
  get size() {
    return this._instanceById.size;
  }
  entries() {
    return this._instanceById.entries();
  }
  updateStart() {
    this._instanceByIdNext = /* @__PURE__ */ new Map();
  }
  updateEnd() {
    if (!this._instanceByIdNext) throw new Error("InternalError: Found updateEnd call without corresponding updateStart");
    for (const t12 of this._instanceById.keys()) this._instanceByIdNext.has(t12) || this._instanceById.delete(t12);
    for (const [t12, n11] of this._instanceByIdNext.entries()) {
      const e8 = this._instanceById.get(t12);
      e8 ? e8.setInput(n11.getInput()) : this._instanceById.set(t12, n11);
    }
    this._instanceByIdNext = null;
  }
  values() {
    return this._instanceById.values();
  }
  ensureInstance(s9, i11) {
    let r8;
    if ("object" == typeof i11 && "optionalAttributes" in i11 && "uniforms" in i11) {
      r8 = `${s9.type}${JSON.stringify(i11.optionalAttributes)}`;
      const t12 = i11.uniforms;
      if ("object" == typeof t12) for (const n11 in t12) r8 += `${n11}.${null != t12[n11]}`;
    } else r8 = `${s9.type}.${JSON.stringify(i11)}`;
    const a10 = l(r8);
    if (this._instanceByIdNext) {
      const t12 = new i5(r2(a10), s9, i11);
      return this._instanceByIdNext.set(a10, t12), t12;
    }
    if (!this._instanceById.has(a10)) {
      const t12 = new i5(r2(a10), s9, i11);
      this._instanceById.set(a10, t12);
    }
    return this._instanceById.get(a10);
  }
  getInstance(t12) {
    return this._instanceById.get(t12);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/RenderState.js
var l3 = 1e3;
var d7 = class {
  constructor(t12, i11, s9) {
    this.getStage = t12, this.version = i11, this._tileInfoView = s9, this._pendingUpdates = new t2(l3), this._locked = false, this._tiles = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const e8 of this.tiles()) e8.destroy();
    this._pendingUpdates.clear(), this._tiles.clear();
  }
  tiles() {
    return this._tiles.values();
  }
  size() {
    return this._tiles.size;
  }
  setTiles(e8) {
    this._tiles.clear();
    for (const t12 of e8) this._tiles.set(t12.key.id, t12);
  }
  lockUploads() {
    this._locked = true;
  }
  unlockUploads() {
    this._locked = false, this.flush();
  }
  enqueueUpdate(e8) {
    this._pendingUpdates.enqueue(e8);
  }
  update(e8) {
    if (!this._locked) for (; this._pendingUpdates.size; ) {
      const t12 = this._pendingUpdates.peek();
      if (null == t12 || t12.attributeEpoch > e8) break;
      this._updateTile(t12), this._pendingUpdates.dequeue();
    }
  }
  removeTile(e8) {
    const t12 = this._tiles.get(e8);
    has("esri-2d-update-debug") && console.debug(`Tile[${e8}] RenderState.removeTile`), t12 == null ? void 0 : t12.destroy(), this._tiles.delete(e8);
  }
  isTileDone(e8) {
    const t12 = this._tiles.get(e8.id);
    return !!t12 && t12.isReady;
  }
  flush() {
    for (; this._pendingUpdates.size; ) {
      const e8 = this._pendingUpdates.dequeue();
      null != e8 && this._updateTile(e8);
    }
    for (const e8 of this._tiles.values()) e8.upload();
  }
  _updateTile(e8) {
    var _a;
    if (has("esri-2d-update-debug")) {
      const t13 = ((_a = e8.debugInfo) == null ? void 0 : _a.chunkId) ?? "<EnsureEnd>";
      console.debug(`Version[${e8.version}] Tile[${e8.id}] Chunk[${t13}] RenderState.updateTile [${e8.type}]`, e8);
    }
    const t12 = this._ensureTile(e8.id);
    if ("update" === e8.type) {
      const [i12, ...s10] = e8.modify;
      t12.onMessage({ type: "update", modify: i12, remove: e8.remove, end: e8.end, attributeEpoch: e8.attributeEpoch });
      for (const t13 of s10) {
        const i13 = this._tiles.get(t13.tileId);
        i13 && i13.onMessage({ type: "update", modify: t13, remove: e8.remove, end: false, isPixelBuffer: true, attributeEpoch: null });
      }
      return;
    }
    if (null == e8.append) return void t12.onMessage({ type: "append", clear: e8.clear, debugInfo: e8.debugInfo, end: e8.end, attributeEpoch: e8.attributeEpoch });
    const [i11, ...s9] = e8.append;
    t12.onMessage({ type: "append", clear: e8.clear, append: i11, debugInfo: e8.debugInfo, end: e8.end, attributeEpoch: e8.attributeEpoch });
    for (const o15 of s9) {
      const e9 = this._tiles.get(o15.tileId);
      e9 && e9.onMessage({ type: "update", modify: o15, remove: [], sort: false, end: false, isPixelBuffer: true, attributeEpoch: null });
    }
  }
  _ensureTile(e8) {
    if (!this._tiles.has(e8)) {
      const t12 = this._createTile(e8);
      this._copyPixelBufferedEntitiesInto(t12), this._tiles.set(e8, t12);
    }
    return this._tiles.get(e8);
  }
  _createTile(e8) {
    has("esri-2d-update-debug") && console.debug(`Version[${this.version}] Tile[${e8}] RenderState.createTile`);
    const r8 = new e4(e8), l12 = this._tileInfoView.getTileBounds(u4(), r8), d10 = this._tileInfoView.getTileResolution(r8.level), a10 = new b4(r8, d10, l12[0], l12[3], true);
    if (a10.stage = this.getStage(), !a10.stage) {
      const e9 = new s("featurelayerview:webgl", "Cannot create tile with empty stage");
      n.getLogger("esri.views.2d.layers.features.RenderState").error(e9);
    }
    return a10;
  }
  _copyPixelBufferedEntitiesInto(e8) {
    let t12 = 7;
    for (let i11 = -1; i11 <= 1; i11++) for (let s9 = -1; s9 <= 1; s9++) {
      if (0 === i11 && 0 === s9) continue;
      const o15 = this._tileInfoView.tileInfo.isWrappable, n11 = o3(e8.key, s9, i11, o15).id, l12 = this._tiles.get(n11);
      if (null != l12) {
        const o16 = 1 << t12;
        e8.copyPixelBufferedEntitesFrom(l12, o16, s9, i11);
      }
      t12--;
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/FeatureContainer.js
var l4 = class {
  constructor(e8, s9) {
    this.id = e8, this.version = s9, this._resolver = L(), this._done = false;
  }
  get done() {
    return this._done;
  }
  get promise() {
    return this._resolver.promise;
  }
  end() {
    this._resolver.resolve(), this._done = true;
  }
  destroy() {
    this._resolver.reject();
  }
};
var u6 = class extends r {
  constructor(e8) {
    super(e8.view.featuresTilingScheme), this.updatingHandles = new h(), this._hitTestsRequests = [], this._store = new s6(), this._visibleTiles = /* @__PURE__ */ new Set(), this._subscriptions = /* @__PURE__ */ new Map(), this._updateStatisticsRequests = [], this._lockStatisticUpdates = false, this._layerView = e8;
  }
  renderChildren(e8) {
    var _a, _b;
    if (this.attributeView.update(), (_a = this._renderState) == null ? void 0 : _a.update(this.attributeView.currentEpoch), this._renderState) {
      const e9 = Array.from(this._renderState.tiles()).filter((e10) => e10.needsUpload);
      if (e9.length) {
        e9[Math.floor(Math.random() * e9.length)].upload(), e9.length >= 2 && this.requestRender();
      }
      for (const t12 of this._renderState.tiles()) t12.tryReady(this.attributeView.currentEpoch) && ((_b = this._subscriptions.get(t12.key.id)) == null ? void 0 : _b.end(), this._layerView.requestUpdate(), this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this.requestRender());
    }
    for (const t12 of this.children) t12.setTransform(e8.state);
    if (this.hasAnimation) {
      e8.painter.effects.integrate.draw(e8, e8.attributeView);
    }
    switch (super.renderChildren(e8), e8.drawPhase) {
      case E.MAP:
        return this._renderMapPhase(e8);
      case E.HIGHLIGHT:
        return this._renderHighlightPhase(e8);
      case E.LABEL:
        return this._renderLabelPhase(e8);
    }
  }
  subscriptions() {
    return this._subscriptions.values();
  }
  get _instanceStore() {
    return this._store;
  }
  get instanceStore() {
    return this._store;
  }
  get layerView() {
    return this._layerView;
  }
  get hasLabels() {
    return this._layerView.labelingCollisionInfos.length > 0;
  }
  get hasHighlight() {
    return this._layerView.hasHighlight();
  }
  get _layer() {
    return this._layerView.layer;
  }
  _getExclusivePostprocessingInstance({ drawPhase: e8 }) {
    if (null == this._instanceStore) return null;
    let t12 = 0, s9 = null;
    for (const i11 of this._instanceStore.values()) i11.techniqueRef.drawPhase & e8 && (t12++, i11.techniqueRef.postProcessingEnabled && (s9 = i11));
    return t12 > 1 ? null : s9;
  }
  _getOverrideStencilRef({ drawPhase: e8 }) {
    if (null == this._instanceStore) return null;
    let t12 = null;
    for (const s9 of this._instanceStore.values()) {
      if (!(s9.techniqueRef.drawPhase & e8)) continue;
      const { overrideStencilRef: i11 } = s9.techniqueRef;
      if (null == t12) t12 = i11;
      else if (t12 !== i11) {
        t12 = null;
        break;
      }
    }
    return t12;
  }
  get children() {
    return this._renderState ? Array.from(this._renderState.tiles()).filter((e8) => this._visibleTiles.has(e8.key.id)) : [];
  }
  updateAttributeView(e8) {
    this.requestRender(), this.attributeView.requestUpdate(e8), this.hasLabels && this._layerView.view.labelManager.requestUpdate();
  }
  updateSubscriptions(e8) {
    for (const { tileId: t12, version: s9 } of e8.subscribe) if (this._subscriptions.has(t12)) this._subscriptions.get(t12).version = s9;
    else {
      const e9 = new l4(t12, s9);
      this._subscriptions.set(t12, e9), this.updatingHandles.addPromise(e9.promise);
    }
    for (const t12 of e8.unsubscribe) {
      const e9 = this._subscriptions.get(t12);
      e9 == null ? void 0 : e9.destroy(), this._subscriptions.delete(t12), this.removeTile(t12);
    }
  }
  isDone(e8) {
    return !!this._renderState && this._renderState.isTileDone(e8);
  }
  async updateRenderState(e8) {
    has("esri-2d-update-debug") && console.debug(`Version[${e8}] FeatureContainer.updateRenderState`), this._renderStateNext = new d7(() => this._stage, e8, this._tileInfoView);
  }
  getDisplayStatistics(e8, t12) {
    const s9 = this._statisticsByLevel.get(e8);
    return s9 ? s9.get(t12) : null;
  }
  updateStatistics(e8, t12) {
    if (this._lockStatisticUpdates) return void this._updateStatisticsRequests.push({ level: e8, statistics: t12 });
    let s9 = this._statisticsByLevel.get(e8);
    s9 || (s9 = /* @__PURE__ */ new Map(), this._statisticsByLevel.set(e8, s9));
    for (const i11 of t12) s9.set(i11.fieldName, { minValue: i11.minValue, maxValue: i11.maxValue });
  }
  editStart() {
    var _a;
    (_a = this._renderState) == null ? void 0 : _a.lockUploads(), this.attributeView.lockTextureUploads(), this._lockStatisticUpdates = true;
  }
  editEnd() {
    var _a;
    (_a = this._renderState) == null ? void 0 : _a.unlockUploads(), this.attributeView.unlockTextureUploads(), this._lockStatisticUpdates = false;
    for (const e8 of this._updateStatisticsRequests) this.updateStatistics(e8.level, e8.statistics);
    this._updateStatisticsRequests = [], this.requestRender();
  }
  swapRenderState() {
    var _a;
    this._renderStateNext && (has("esri-2d-update-debug") && console.debug(`Version[${this._renderStateNext.version}] FeatureContainer.update.swapRenderState`), (_a = this._renderState) == null ? void 0 : _a.destroy(), this._renderState = this._renderStateNext, this._renderStateNext = null), this._renderState && this._renderState.flush(), this.requestRender();
  }
  setVisibleTiles(e8) {
    this._visibleTiles = e8;
  }
  async onMessage(t12, s9) {
    s2(s9);
    const i11 = t12.inner;
    if (!this._subscriptions.has(i11.id)) return;
    const r8 = this._subscriptions.get(i11.id);
    if (r8.version !== i11.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e8 = `${i11.subscriptionVesrion} != ${r8.version}`;
        console.debug(`Version[${e8}] Tile[${i11.id}] FeatureContainer - Dropping message, outdated version]`, i11);
      }
      return;
    }
    const n11 = this._renderStateNext ?? this._renderState;
    if (!n11) throw new Error("InternalError: No renderState defined");
    n11.version !== i11.version && console.error(`InternalError: Version mismatch. [renderState: ${n11.version}, message: ${i11.version}]`), n11.enqueueUpdate(i11), this.requestRender(), this._layerView.view.labelManager.requestUpdate(), this._layerView.requestUpdate();
  }
  removeTile(e8) {
    (this._renderState || this._renderStateNext) && (this._renderState && this._renderState.removeTile(e8), this._renderStateNext && this._renderStateNext.removeTile(e8));
  }
  hitTest(e8) {
    let s9 = this._hitTestsRequests.find(({ x: t12, y: s10 }) => t12 === e8.x && s10 === e8.y);
    const i11 = L();
    return s9 ? s9.resolvers.push(i11) : (s9 = { x: e8.x, y: e8.y, resolvers: [i11] }, this._hitTestsRequests.push(s9)), this.requestRender(), i11.promise;
  }
  getSortKeys(e8) {
    const t12 = new Set(e8), s9 = /* @__PURE__ */ new Map();
    for (const i11 of this.children) if (i11.getSortKeys(t12).forEach((e9, t13) => s9.set(t13, e9)), s9.size === t12.size) break;
    return s9;
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  updateTransitionProperties(e8, t12) {
    super.updateTransitionProperties(e8, t12), this._layerView.featureEffectView.transitionStep(e8, t12), this._layerView.featureEffectView.transitioning && this.requestRender();
  }
  doRender(e8) {
    const { minScale: t12, maxScale: s9 } = this._layer.effectiveScaleRange, i11 = e8.state.scale;
    i11 <= (t12 || 1 / 0) && i11 >= s9 && super.doRender(e8);
  }
  afterRender(e8) {
    super.afterRender(e8), this._hitTestsRequests.length && this.requestRender();
  }
  setStencilReference(e8) {
    const t12 = this._getOverrideStencilRef(e8);
    if (null == t12) super.setStencilReference(e8);
    else for (const s9 of this.children) s9.stencilRef = t12(s9);
  }
  _renderMapPhase(e8) {
    this._layerView.featureEffectView.hasEffects ? (this._renderOutsideEffect(e8), this._renderInsideEffect(e8)) : this._renderFeatures(e8, R.All), this._hitTestsRequests.length > 0 && this._renderHittest(e8);
  }
  _renderHighlightPhase(e8) {
    this.hasHighlight && a5(e8, false, (e9) => {
      this._renderFeatures(e9, R.Highlight);
    });
  }
  _renderLabelPhase(e8) {
    this._renderFeatures(e8, R.All);
  }
  _renderInsideEffect(e8) {
    const t12 = e8.painter.effects.insideEffect;
    t12.bind(e8), this._renderFeatures(e8, R.InsideEffect), t12.draw(e8, this._layerView.featureEffectView.includedEffects), t12.unbind();
  }
  _renderOutsideEffect(e8) {
    const t12 = e8.painter.effects.outsideEffect;
    t12.bind(e8), this._renderFeatures(e8, R.OutsideEffect), t12.draw(e8, this._layerView.featureEffectView.excludedEffects), t12.unbind();
  }
  _renderHittest(e8) {
    const { context: t12 } = e8, s9 = e8.painter.effects.hittest, i11 = t12.getBoundFramebufferObject(), a10 = t12.getViewport(), o15 = e8.passOptions, h5 = e8.drawPhase;
    s9.bind(e8), e8.passOptions = s9.createOptions(e8, this._hitTestsRequests), e8.drawPhase = E.HITTEST;
    const { distance: d10, smallSymbolDistance: l12 } = e8.passOptions, u14 = Math.max(d10, l12);
    for (const r8 of this.children) r8.visible && r8.containsScreenPoint(e8.state, e8.passOptions.position, 2 * u14) && this._renderTile(r8, e8, R.All);
    s9.draw(e8), s9.unbind(), t12.bindFramebuffer(i11), t12.restoreViewport(a10), e8.passOptions = o15, e8.drawPhase = h5;
  }
  _renderFeatures(e8, t12) {
    for (const i11 of this.children) i11.visible && this._renderTile(i11, e8, t12);
    const s9 = this._getExclusivePostprocessingInstance(e8);
    null != s9 && s9.techniqueRef.postProcess(e8, s9);
  }
  _renderTile(e8, t12, s9) {
    const i11 = has("featurelayer-force-marker-text-draw-order") ? N.STRICT_MARKERS_AND_TEXT : N.BATCHING, r8 = e8.getDisplayList(this._instanceStore, i11);
    t12.selection = s9, r8 == null ? void 0 : r8.render(t12);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorkerProxy.js
async function t7(t12) {
  const o15 = await p("FeaturePipelineWorker", { client: t12, strategy: "dedicated" });
  return new n6(o15);
}
var n6 = class {
  constructor(e8) {
    this._connection = e8, this.pipeline = this._connection.createInvokeProxy(), this.features = this._connection.createInvokeProxy("features"), this.aggregates = this._connection.createInvokeProxy("aggregates"), this.streamMessenger = this._connection.createInvokeProxy("streamMessenger");
  }
  destroy() {
    this._connection.destroy();
  }
  get closed() {
    return this._connection.closed;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/FeatureSourceEventLog.js
var n7 = 10;
var l5 = class extends S {
  constructor() {
    super(...arguments), this.events = new o2(), this._updatingStrategy = true, this._tileToEvent = new s3(), this._fetchStatus = { outstanding: 0, done: 0 };
  }
  get hasAllFeatures() {
    var _a;
    return this._hasAllData() && (((_a = this._strategyInfo) == null ? void 0 : _a.willQueryAllFeatures) ?? false);
  }
  get hasAllFeaturesInView() {
    return this._hasAllData();
  }
  get hasFullGeometries() {
    var _a;
    return this._hasAllData() && (((_a = this._strategyInfo) == null ? void 0 : _a.willQueryFullResolutionGeometry) ?? false);
  }
  onEvent(t12) {
    switch (t12.type) {
      case "subscribe":
      case "unsubscribe":
      case "loaded":
      case "error":
        this._handleTileEvent(t12);
        break;
      case "updateStrategyStart":
        this._updatingStrategy = true, this._fetchStatus = { done: 0, outstanding: 0 }, this._strategyInfo = t12.about;
        break;
      case "updateStrategyEnd":
        this._updatingStrategy = false;
        break;
      case "updateFieldsStart":
        this._fetchStatus = { done: 0, outstanding: 0 };
        break;
      case "updateFieldsEnd":
        break;
      case "updateFieldsError":
        this.events.emit("error", t12);
        break;
      case "fetchStart":
        this._fetchStatus.outstanding += 1, this.events.emit("status", this._fetchStatus);
        break;
      case "fetchEnd":
        this._fetchStatus.done += 1, this.events.emit("status", this._fetchStatus), t12.done && (this._fetchStatus = { done: 0, outstanding: 0 });
    }
  }
  _hasAllData() {
    return !this._updatingStrategy && this._hasAllTileData();
  }
  _hasAllTileData() {
    for (const t12 of this._tileToEvent.values()) {
      const e8 = t12.peekLast();
      if ("loaded" !== (e8 == null ? void 0 : e8.type)) return false;
    }
    return true;
  }
  _handleTileEvent(t12) {
    switch (t12.type) {
      case "subscribe": {
        const e8 = new t2(n7);
        e8.enqueue(t12), this._tileToEvent.set(t12.tile, e8);
        break;
      }
      case "unsubscribe":
        this._tileToEvent.delete(t12.tile);
        break;
      case "loaded": {
        const e8 = this._tileToEvent.get(t12.tile);
        if (!e8) return;
        e8.enqueue(t12), this._tileToEvent.set(t12.tile, e8);
        break;
      }
      case "error": {
        const e8 = this._tileToEvent.get(t12.tile);
        if (!e8) return;
        e8.enqueue(t12), this._tileToEvent.set(t12.tile, e8), this.events.emit("error", t12);
        break;
      }
    }
  }
};
e([y({ readOnly: true })], l5.prototype, "hasAllFeatures", null), e([y({ readOnly: true })], l5.prototype, "hasAllFeaturesInView", null), e([y({ readOnly: true })], l5.prototype, "hasFullGeometries", null), e([y()], l5.prototype, "_updatingStrategy", void 0), e([y()], l5.prototype, "_strategyInfo", void 0), e([y()], l5.prototype, "_tileToEvent", void 0), l5 = e([a2("esri.views.2d.layers.features.FeatureSourceEventLog")], l5);

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/geometryUtils.js
function e6(e8) {
  switch (e8.geometryType) {
    case "point":
      return "esriGeometryPoint";
    case "polyline":
      return "esriGeometryPolyline";
    case "polygon":
    case "multipatch":
      return "esriGeometryPolygon";
    case "multipoint":
      return "esriGeometryMultipoint";
    default:
      return null;
  }
}

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureReductionUtils.js
function e7(e8, a10) {
  const c9 = e8.featureReduction;
  return c9 && "selection" !== c9.type && (!("maxScale" in c9) || !c9.maxScale || c9.maxScale < a10.scale) ? c9 : null;
}

// ../node_modules/@arcgis/core/views/2d/layers/support/visualVariableSimpleUtils.js
var r4 = Math.PI;
function i8(e8, t12) {
  switch (t12.transformationType) {
    case i.Additive:
      return s7(e8, t12);
    case i.Constant:
      return o7(t12, e8);
    case i.ClampedLinear:
      return u7(e8, t12);
    case i.Proportional:
      return l6(e8, t12);
    case i.Stops:
      return c4(e8, t12);
    case i.RealWorldSize:
      return m4(e8, t12);
    case i.Identity:
      return e8;
    case i.Unknown:
      return null;
  }
}
function a7(e8, t12) {
  return "number" == typeof e8 ? e8 : i8(t12, e8);
}
function s7(e8, t12) {
  return e8 + (a7(t12.minSize, e8) || t12.minDataValue);
}
function o7(e8, t12) {
  const n11 = e8.stops;
  let r8 = (n11 == null ? void 0 : n11.length) && n11[0].size;
  return null == r8 && (r8 = e8.minSize), a7(r8, t12);
}
function u7(e8, t12) {
  const n11 = t12.minDataValue, r8 = t12.maxDataValue, i11 = (e8 - n11) / (r8 - n11), s9 = a7(t12.minSize, e8), o15 = a7(t12.maxSize, e8);
  return e8 <= n11 ? s9 : e8 >= r8 ? o15 : s9 + i11 * (o15 - s9);
}
function l6(t12, n11) {
  const r8 = t12 / n11.minDataValue, i11 = a7(n11.minSize, t12), s9 = a7(n11.maxSize, t12);
  let o15 = null;
  return o15 = r8 * i11, e3(o15, i11, s9);
}
function c4(e8, t12) {
  const [n11, r8, i11] = p4(e8, t12.cache.ipData);
  if (n11 === r8) return a7(t12.stops[n11].size, e8);
  {
    const s9 = a7(t12.stops[n11].size, e8);
    return s9 + (a7(t12.stops[r8].size, e8) - s9) * i11;
  }
}
function m4(n11, i11) {
  const s9 = m[i11.valueUnit], o15 = a7(i11.minSize, n11), u14 = a7(i11.maxSize, n11), { valueRepresentation: l12 } = i11;
  let c9 = null;
  return c9 = "area" === l12 ? 2 * Math.sqrt(n11 / r4) / s9 : "radius" === l12 || "distance" === l12 ? 2 * n11 / s9 : n11 / s9, e3(c9, o15, u14);
}
function p4(e8, t12) {
  if (!t12) return;
  let n11 = 0, r8 = t12.length - 1;
  return t12.some((t13, i11) => e8 < t13 ? (r8 = i11, true) : (n11 = i11, false)), [n11, r8, (e8 - t12[n11]) / (t12[r8] - t12[n11])];
}

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/labelingUtils.js
function l7(n11) {
  var _a;
  return (n11.labelsVisible && ((_a = n11.labelingInfo) == null ? void 0 : _a.every((n12) => "none" !== n12.deconflictionStrategy))) ?? false;
}
function r5(n11, i11) {
  var _a;
  const l12 = e7(n11, i11);
  if ((l12 == null ? void 0 : l12.labelsVisible) && ((_a = l12.labelingInfo) == null ? void 0 : _a.length)) return l12.labelingInfo.every((n12) => "none" !== n12.deconflictionStrategy);
}
function t8(e8) {
  return (l12) => u5(i8(l12, e8));
}
function o8(n11) {
  const e8 = null != n11 && "visualVariables" in n11 && n11.visualVariables;
  if (!e8) return null;
  for (const i11 of e8) if ("size" === i11.type) return t8(i11);
  return null;
}

// ../node_modules/@arcgis/core/views/2d/layers/features/schema/SourceSchema.js
function t9(t12, i11, s9, o15) {
  var _a, _b;
  const r8 = null != t12.subtypeCode ? `${t12.subtypeField} = ${t12.subtypeCode}` : null, n11 = n2(t12.definitionExpression, r8), a10 = t12.customParameters ?? {};
  return o15 && (a10.token = o15), { type: "feature", mutable: { sourceRefreshVersion: s9, availableFields: i11.availableFields, dataFilter: { queryScaleRanges: t12.queryScaleRanges ?? [], definitionExpression: n11, gdbVersion: t12.gdbVersion, historicMoment: (_a = t12.historicMoment) == null ? void 0 : _a.getTime(), timeExtent: (_b = t12.timeExtent) == null ? void 0 : _b.toJSON(), customParameters: a10 } } };
}

// ../node_modules/@arcgis/core/views/2d/engine/webgl/color.js
function u8(n11, r8, t12 = 0) {
  if (null == r8) return n11[t12] = 0, n11[t12 + 1] = 0, n11[t12 + 2] = 0, void (n11[t12 + 3] = 0);
  const { r: o15, g: u14, b: i11, a: c9 } = r8;
  n11[t12] = o15 * c9 / 255, n11[t12 + 1] = u14 * c9 / 255, n11[t12 + 2] = i11 * c9 / 255, n11[t12 + 3] = c9;
}

// ../node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/SymbolSchema.js
async function M3(i11, a10) {
  if (!i11) return [];
  switch (i11.type) {
    case "simple-fill":
      return P2(i11, a10);
    case "picture-fill":
      return U(i11, a10);
    case "simple-marker":
      return w4(i11, a10);
    case "picture-marker":
      return A2(i11, a10);
    case "simple-line":
      return B(i11, a10, false);
    case "text":
      return R2(i11, a10);
    case "label":
      return k(i11, a10);
    case "cim":
      return n5(i11.data, a10);
    case "web-style": {
      const e8 = await i11.fetchCIMSymbol();
      return n5(e8.data, a10);
    }
    case "line-3d":
      return n.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i11.type}" unsupported in MapView. Defaulting to simple-line`), B(new d3(), a10, false);
    case "point-3d":
      return n.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i11.type}" unsupported in MapView. Defaulting to simple-marker`), w4(new y2(), a10);
    case "polygon-3d":
      return n.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i11.type}" unsupported in MapView. Defaulting to simple-fill`), P2(new S2(), a10);
    case "mesh-3d":
    case "label-3d":
      return n.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i11.type}" unsupported in MapView. Ignoring`), [];
    case "CIMSymbolReference":
      throw new Error("InternalError: CIMSymbolReference should already be resolved");
  }
}
async function x3(e8, i11) {
  const { schemaOptions: a10 } = i11, { store: l12 } = a10, r8 = new Array(G), t12 = new Array(G / 4);
  for (let u14 = 0; u14 < G; u14++) {
    const i12 = u14 < e8.attributes.length ? e8.attributes[u14].color : null;
    r8[u14] = [0, 0, 0, 0], u8(r8[u14], i12);
  }
  for (let u14 = 0; u14 < G / 4; u14++) t12[u14] = [0, 0, 0, 0], t12[u14][0] = 4 * u14 < e8.attributes.length ? 1 : 0, t12[u14][1] = 4 * u14 + 1 < e8.attributes.length ? 1 : 0, t12[u14][2] = 4 * u14 + 2 < e8.attributes.length ? 1 : 0, t12[u14][3] = 4 * u14 + 3 < e8.attributes.length ? 1 : 0;
  const o15 = { uniforms: { isActive: t12, colors: r8, dotValue: e8.dotValue, dotScale: e8.referenceScale, blending: e8.dotBlendingEnabled, dotSize: e8.dotSize, seed: e8.seed }, optionalAttributes: {} }, s9 = l12.ensureInstance(h3.dotDensity, o15).createMeshInfo({ effects: null }), n11 = [];
  if (e8.backgroundColor) {
    const a11 = new S2({ color: e8.backgroundColor, outline: null }), l13 = await M3(a11, i11);
    n11.push(...l13);
  }
  if (n11.push(s9), e8.outline) {
    const a11 = B(e8.outline, i11, true);
    n11.push(...a11);
  }
  return n11;
}
async function C(e8, l12) {
  const { store: r8 } = l12, { radius: t12, minDensity: o15, maxDensity: s9, referenceScale: n11, field: u14, valueExpression: c9, colorStops: p7 } = e8, b5 = f3(p7);
  return [r8.ensureInstance(h3.heatmap, { uniforms: { radius: u5(t12), minDensity: o15, maxDensity: s9, referenceScale: n11, isFieldActive: !(!u14 && !c9), gradient: b5, gradientHash: b5.join(",") }, optionalAttributes: {} }).createMeshInfo({ effects: null })];
}
function I2(e8, a10) {
  var _a, _b, _c, _d;
  const { store: l12 } = a10, r8 = ((_a = e8.outline) == null ? void 0 : _a.width) || 0, t12 = M2(e8), o15 = l12.ensureInstance(h3.pieChart, { uniforms: { shader: { outlineWidth: Math.round(u5(r8)), defaultColor: t4(e8.defaultColor), outlineColor: t4((_b = e8.outline) == null ? void 0 : _b.color), othersColor: t4((_c = e8.othersCategory) == null ? void 0 : _c.color), donutRatio: e8.holePercentage, sectorThreshold: ((_d = e8.othersCategory) == null ? void 0 : _d.threshold) || 0, colors: e8.attributes.map((e9) => t4(e9.color)), visualVariableOpacity: t12.visualVariableOpacity, visualVariableSizeMinMaxValue: t12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: t12.visualVariableSizeScaleStops, visualVariableSizeStops: t12.visualVariableSizeStops, visualVariableSizeUnitValue: t12.visualVariableSizeUnitValue, hittestUniforms: null }, numberOfFields: e8.attributes.length }, optionalAttributes: {} }).createMeshInfo({ size: e8.size, outlineWidth: r8, effects: null, scaleInfo: null, minPixelBuffer: h4(t12) });
  return [...e8.backgroundFillSymbol ? P2(e8.backgroundFillSymbol, { schemaOptions: a10, path: "", uniforms: x2 }) : [], o15];
}
function O4(e8) {
  if ("path" === e8.style) {
    if (null == e8.path) throw new Error("Symbol with a style of type path must define a path");
    return { type: "sprite-rasterization-param", overrides: [], resource: { type: "path", path: e8.path, asFill: true } };
  }
  const i11 = ee.fromSimpleMarker(e8);
  if ("outline" in e8 && e8.outline && "none" !== e8.outline.style) {
    if ("solid" !== e8.outline.style) {
      if (!i11 || !i11.symbolLayers) throw new Error("Error handling marker! ");
      return { type: "sprite-rasterization-param", resource: i11.symbolLayers[0], overrides: [] };
    }
  }
  return { type: "sprite-rasterization-param", resource: l2(i11), overrides: [] };
}
async function w4(e8, i11) {
  var _a, _b, _c, _d, _e;
  const { uniforms: a10, schemaOptions: r8 } = i11, { store: t12 } = r8;
  if ("path" === e8.style || e8.outline && "solid" !== e8.outline.style && "none" !== e8.outline.style) {
    const r9 = ee.fromSimpleMarker(e8);
    if (!r9 || !r9.symbolLayers) throw new Error("Error handling marker! ");
    if (a10.visualVariableRotation && (r9.angleAlignment = "Map"), "path" !== e8.style) {
      const e9 = r9.symbolLayers[0];
      if (a6(i11.uniforms)) {
        const a11 = h4(i11.uniforms, 0, 1);
        if (a11 > e9.size) {
          const i12 = a11 / e9.size;
          e9.size = a11;
          const l12 = (_a = e9.markerGraphics) == null ? void 0 : _a[0].symbol;
          (l12.symbolLayers && l12.symbolLayers[0]).width *= i12;
        }
      }
    }
    return n5({ type: "CIMSymbolReference", symbol: r9 }, i11);
  }
  const s9 = t12.ensureInstance(h3.marker, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableSizeMinMaxValue: a10.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a10.visualVariableSizeScaleStops, visualVariableSizeStops: a10.visualVariableSizeStops, visualVariableSizeUnitValue: a10.visualVariableSizeUnitValue, visualVariableRotation: a10.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), n11 = O4(e8);
  let u14 = ((_b = e8.color) == null ? void 0 : _b.toArray()) ?? [0, 0, 0, 0];
  "CIMVectorMarker" === n11.resource.type && (u14 = [255, 255, 255, 255]);
  const c9 = "triangle" === e8.style ? 124 / 116 : 1, p7 = e8.size, b5 = p7 * c9, m9 = null != a10.visualVariableColor && ("cross" === e8.style || "x" === e8.style);
  return [s9.createMeshInfo({ type: "simple", color: u14, height: p7, width: b5, offsetX: e8.xoffset, offsetY: e8.yoffset, angle: e8.angle, alignment: i4(a10) ? i2.MAP : i2.SCREEN, outlineColor: ((_d = (_c = e8.outline) == null ? void 0 : _c.color) == null ? void 0 : _d.toArray()) ?? [0, 0, 0, 0], outlineSize: ((_e = e8.outline) == null ? void 0 : _e.width) ?? 1, referenceSize: p7, sprite: n11, overrideOutlineColor: m9, hasSizeVV: a6(a10), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: h4(a10) })];
}
function A2(e8, i11) {
  const { uniforms: a10, schemaOptions: r8 } = i11, { store: t12 } = r8, s9 = t12.ensureInstance(h3.marker, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableSizeMinMaxValue: a10.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a10.visualVariableSizeScaleStops, visualVariableSizeStops: a10.visualVariableSizeStops, visualVariableSizeUnitValue: a10.visualVariableSizeUnitValue, visualVariableRotation: a10.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), n11 = ee.createPictureMarkerRasterizationParam(e8);
  if (!n11) return [];
  return [s9.createMeshInfo({ type: "picture", color: [255, 255, 255, 255], height: e8.height, width: e8.width, offsetX: e8.xoffset, offsetY: e8.yoffset, angle: e8.angle, alignment: i4(a10) ? i2.MAP : i2.SCREEN, outlineColor: null, outlineSize: 0, referenceSize: e8.height, sprite: n11, overrideOutlineColor: false, hasSizeVV: a6(a10), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: h4(a10) })];
}
function L3(e8, i11, a10) {
  var _a, _b;
  const { uniforms: l12, schemaOptions: r8 } = a10, { store: t12 } = r8, n11 = t12.ensureInstance(h3.marker, { uniforms: { visualVariableColor: l12.visualVariableColor, visualVariableOpacity: l12.visualVariableOpacity, visualVariableSizeMinMaxValue: l12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: l12.visualVariableSizeScaleStops, visualVariableSizeStops: l12.visualVariableSizeStops, visualVariableSizeUnitValue: l12.visualVariableSizeUnitValue, visualVariableRotation: l12.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), u14 = O4(e8), c9 = 6, p7 = c9 * i11.width, b5 = p7, m9 = ((_a = e8.color) == null ? void 0 : _a.toArray()) ?? ((_b = i11.color) == null ? void 0 : _b.toArray()) ?? [0, 0, 0, 0], V2 = "cross" === e8.style || "x" === e8.style;
  let y5;
  switch (e8.placement) {
    case "begin-end":
      y5 = o4.Both;
      break;
    case "begin":
      y5 = o4.JustBegin;
      break;
    case "end":
      y5 = o4.JustEnd;
      break;
    default:
      y5 = o4.None;
  }
  const z = { type: "cim-marker-placement-param", placement: { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: y5, offsetAlongLine: 0 }, overrides: [] };
  return [n11.createMeshInfo({ type: "simple", color: m9, height: b5, width: p7, offsetX: 0, offsetY: 0, angle: 0, alignment: i4(l12) ? i2.MAP : i2.SCREEN, outlineColor: m9, outlineSize: V2 ? i11.width : 0, referenceSize: b5 / c9, sprite: u14, overrideOutlineColor: V2 && null != l12.visualVariableColor, hasSizeVV: a6(l12), placement: z, transforms: null, effects: null, scaleInfo: null, minPixelBuffer: h4(l12) })];
}
function R2(e8, i11) {
  var _a, _b, _c, _d;
  const { uniforms: a10, schemaOptions: r8 } = i11, { store: t12 } = r8;
  return [t12.ensureInstance(h3.text, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableRotation: a10.visualVariableRotation, visualVariableSizeMinMaxValue: a10.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a10.visualVariableSizeScaleStops, visualVariableSizeStops: a10.visualVariableSizeStops, visualVariableSizeUnitValue: a10.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false, clipAngle: false, referenceSymbol: false } }).createMeshInfo({ boxBackgroundColor: (_a = e8.backgroundColor) == null ? void 0 : _a.toArray(), boxBorderLineColor: (_b = e8.borderLineColor) == null ? void 0 : _b.toArray(), boxBorderLineSize: e8.borderLineSize ?? 0, color: ((_c = e8.color) == null ? void 0 : _c.toArray()) ?? [0, 0, 0, 0], offsetX: e8.xoffset, offsetY: e8.yoffset, postAngle: e8.angle, fontSize: e8.font.size, decoration: e8.font.decoration, haloColor: ((_d = e8.haloColor) == null ? void 0 : _d.toArray()) ?? [0, 0, 0, 0], haloFontSize: e8.haloSize ?? 0, lineWidth: e8.lineWidth, lineHeightRatio: e8.lineHeight, horizontalAlignment: e8.horizontalAlignment, verticalAlignment: e8.verticalAlignment, useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: e8.font.toJSON(), textString: e8.text, symbol: ee.createCIMTextSymbolfromTextSymbol(e8) }, overrides: [] }, referenceSize: null, effects: null, placement: null, scaleInfo: null, transforms: null, scaleFactor: 1, minPixelBuffer: h4(a10), repeatLabel: null, repeatLabelDistance: null, allowOverrun: null, labelPosition: null, isLineLabel: false })];
}
function k(e8, a10) {
  var _a, _b, _c, _d, _e, _f;
  const { schemaOptions: r8, uniforms: t12 } = a10, { store: o15 } = r8, s9 = e8.symbol, { allowOverrun: n11, repeatLabel: c9, repeatLabelDistance: p7 } = e8, b5 = { maxScale: e8.maxScale ?? 0, minScale: e8.minScale ?? 0 }, m9 = o15.ensureInstance(h3.label, { uniforms: { visualVariableColor: null, visualVariableOpacity: null, visualVariableRotation: t12.visualVariableRotation, visualVariableSizeMinMaxValue: t12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: t12.visualVariableSizeScaleStops, visualVariableSizeStops: t12.visualVariableSizeStops, visualVariableSizeUnitValue: t12.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: true, clipAngle: true, referenceSymbol: true } }), V2 = e8.labelPlacement, [y5, v3] = o5(V2);
  return [m9.createMeshInfo({ boxBackgroundColor: (_a = s9.backgroundColor) == null ? void 0 : _a.toArray(), boxBorderLineColor: (_b = s9.borderLineColor) == null ? void 0 : _b.toArray(), boxBorderLineSize: s9.borderLineSize ?? 0, color: ((_c = s9.color) == null ? void 0 : _c.toArray()) ?? [0, 0, 0, 0], offsetX: s9.xoffset, offsetY: s9.yoffset, postAngle: s9.angle, fontSize: s9.font.size, decoration: s9.font.decoration, haloColor: ((_d = s9.haloColor) == null ? void 0 : _d.toArray()) ?? [0, 0, 0, 0], haloFontSize: s9.haloSize ?? 0, lineWidth: s9.lineWidth, lineHeightRatio: s9.lineHeight, horizontalAlignment: y5, verticalAlignment: v3, repeatLabel: c9, repeatLabelDistance: u5(p7), allowOverrun: n11, labelPosition: e8.labelPosition, scaleInfo: b5, minPixelBuffer: h4(t12), useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: s9.font.toJSON(), textString: s9.text, symbol: ee.createCIMTextSymbolfromTextSymbol(s9), primitiveName: "label-override" }, useLegacyLabelEvaluationRules: null == ((_e = e8.labelExpressionInfo) == null ? void 0 : _e.expression), overrides: [{ type: "CIMPrimitiveOverride", valueExpressionInfo: { type: "CIMExpressionInfo", expression: ((_f = e8.labelExpressionInfo) == null ? void 0 : _f.expression) ?? e8.labelExpression, returnType: "String" }, primitiveName: "label-override", propertyName: "textString", defaultValue: "" }] }, referenceSize: null, effects: null, placement: null, transforms: null, scaleFactor: 1, isLineLabel: false })];
}
function j(e8, i11) {
  var _a;
  const a10 = e8.width;
  return { outlineColor: ((_a = e8.color) == null ? void 0 : _a.toArray()) || [0, 0, 0, 1], width: a10, referenceWidth: a10, capType: e8.cap ?? "round", joinType: e8.join ?? "round", miterLimit: e8.miterLimit, hasSizeVV: i11 };
}
function E2(e8, i11) {
  var _a, _b, _c;
  const { uniforms: a10, schemaOptions: l12 } = i11, { store: r8 } = l12, t12 = ((_a = e8.color) == null ? void 0 : _a.toArray()) ?? [0, 0, 0, 0], o15 = { type: "sprite-rasterization-param", resource: { type: "fill-style", style: e8.style }, overrides: [] };
  if ("solid" === ((_b = e8.outline) == null ? void 0 : _b.style)) {
    return [r8.ensureInstance(h3.patternOutlineFill, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableSizeScaleStops: a10.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t12, ...j(e8.outline, !!a10.visualVariableSizeOutlineScaleStops), sprite: o15, scaleInfo: null, effects: null })];
  }
  const s9 = [], n11 = r8.ensureInstance(h3.patternFill, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: ((_c = e8.color) == null ? void 0 : _c.toArray()) ?? [0, 0, 0, 0], sprite: o15, scaleInfo: null, effects: null });
  return s9.push(n11), e8.outline && s9.push(...B(e8.outline, i11, true)), s9;
}
function F2(e8, i11) {
  var _a, _b;
  const { uniforms: a10, schemaOptions: l12 } = i11, { store: r8 } = l12, t12 = ((_a = e8.color) == null ? void 0 : _a.toArray()) ?? [0, 0, 0, 0];
  if ("none" !== e8.style && "solid" === ((_b = e8.outline) == null ? void 0 : _b.style)) {
    return [r8.ensureInstance(h3.outlineFill, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity, visualVariableSizeScaleStops: a10.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t12, ...j(e8.outline, !!a10.visualVariableSizeOutlineScaleStops), scaleInfo: null, effects: null })];
  }
  const o15 = [];
  if ("none" !== e8.style) {
    const e9 = r8.ensureInstance(h3.fill, { uniforms: { visualVariableColor: a10.visualVariableColor, visualVariableOpacity: a10.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t12, scaleInfo: null, effects: null });
    o15.push(e9);
  }
  return e8.outline && o15.push(...B(e8.outline, i11, true)), o15;
}
function P2(e8, i11) {
  const { style: a10 } = e8;
  return a10 && "none" !== a10 && "solid" !== a10 ? E2(e8, i11) : F2(e8, i11);
}
function U(e8, i11) {
  const { outline: a10 } = e8, { uniforms: r8, schemaOptions: t12 } = i11, { store: o15 } = t12, s9 = [], n11 = ee.createPictureFillRasterizationParam(e8);
  if (!n11) return [];
  const { width: u14, height: c9, xoffset: p7, yoffset: b5, xscale: m9, yscale: S3 } = e8, V2 = { color: [255, 255, 255, 255], sprite: n11, height: c9, aspectRatio: u14 / c9, offsetX: p7, offsetY: b5, scaleX: m9, scaleY: S3, angle: 0, applyRandomOffset: false, sampleAlphaOnly: false, scaleProportionally: false, effects: null, scaleInfo: null };
  if ("solid" === (a10 == null ? void 0 : a10.style)) {
    return [o15.ensureInstance(h3.complexOutlineFill, { uniforms: { visualVariableColor: r8.visualVariableColor, visualVariableOpacity: r8.visualVariableOpacity, visualVariableSizeScaleStops: r8.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ ...V2, ...j(a10, !!r8.visualVariableSizeOutlineScaleStops) })];
  }
  const y5 = o15.ensureInstance(h3.complexFill, { uniforms: { visualVariableColor: r8.visualVariableColor, visualVariableOpacity: r8.visualVariableOpacity }, optionalAttributes: { zoomRange: false } });
  return s9.push(y5.createMeshInfo(V2)), a10 && s9.push(...B(a10, i11, true)), s9;
}
function B(e8, i11, a10) {
  const { color: l12, style: o15, width: s9, cap: n11, join: u14 } = e8, { schemaOptions: c9 } = i11, { store: p7 } = c9, b5 = [], m9 = a10 ? { ...x2, visualVariableSizeScaleStops: i11.uniforms.visualVariableSizeOutlineScaleStops } : i11.uniforms, S3 = { uniforms: { visualVariableColor: m9.visualVariableColor, visualVariableOpacity: m9.visualVariableOpacity, visualVariableSizeMinMaxValue: m9.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: m9.visualVariableSizeScaleStops, visualVariableSizeStops: m9.visualVariableSizeStops, visualVariableSizeUnitValue: m9.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false } }, y5 = { color: (l12 == null ? void 0 : l12.toArray()) ?? [0, 0, 0, 0], width: s9, referenceWidth: s9, capType: n11, joinType: u14, miterLimit: e8.miterLimit, hasSizeVV: a6(m9), effects: null, scaleInfo: null };
  if (null == o15 || "solid" === o15) {
    const e9 = p7.ensureInstance(h3.line, S3).createMeshInfo(y5);
    b5.push(e9);
  } else if ("none" !== o15) {
    const e9 = p7.ensureInstance(h3.texturedLine, S3).createMeshInfo({ ...y5, shouldScaleDash: true, shouldSampleAlphaOnly: false, isSDF: true, sprite: { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: me(o15, n11), capStyle: re(n11) }, overrides: [] } });
    b5.push(e9);
  }
  return null != e8.marker && b5.push(...L3(e8.marker, e8, i11)), b5;
}

// ../node_modules/@arcgis/core/views/2d/layers/features/schema/processor/LabelMatcherSchema.js
async function l8(a10, l12, r8) {
  const n11 = l12.labelsVisible && l12.labelingInfo || [], i11 = e6(l12), m9 = a4(n11, i11);
  return { type: "label", classes: await Promise.all(m9.map((e8, s9) => o9(a10, e8, s9, r8))) };
}
async function o9(e8, s9, l12, o15) {
  var _a;
  const r8 = await M3(s9, { path: `${l12}`, schemaOptions: e8, uniforms: o15 });
  return { maxScale: s9.maxScale, minScale: s9.minScale, expression: ((_a = s9.labelExpressionInfo) == null ? void 0 : _a.expression) ?? s9.labelExpression, where: s9.where, meshes: r8 };
}

// ../node_modules/@arcgis/core/views/2d/layers/features/schema/processor/MatcherSchema.js
async function r6(e8, a10) {
  if (!a10) return { type: "simple", meshes: [] };
  switch (a10.type) {
    case "simple":
      return o10(e8, a10);
    case "dot-density":
      return u9(e8, a10);
    case "class-breaks":
      return m6(e8, a10);
    case "unique-value":
      return c5(e8, a10);
    case "dictionary":
      return p5(a10);
    case "heatmap":
      return f5(e8, a10);
    case "pie-chart":
      return y4(e8, a10);
  }
}
async function o10(a10, l12) {
  const n11 = l12.getSymbols(), s9 = n11.length ? n11[0] : null, r8 = M2(l12), t12 = "renderer.symbol";
  return { type: "simple", meshes: await M3(s9, { schemaOptions: a10, uniforms: r8, path: t12 }) };
}
async function u9(a10, i11) {
  const n11 = M2(i11), s9 = "renderer.symbol";
  return { type: "dot-density", meshes: await x3(i11, { schemaOptions: a10, uniforms: n11, path: s9 }) };
}
async function m6(l12, n11) {
  const s9 = M2(n11), r8 = n11.backgroundFillSymbol, t12 = n11.normalizationType, o15 = "log" === t12 ? "esriNormalizeByLog" : "percent-of-total" === t12 ? "esriNormalizeByPercentOfTotal" : "field" === t12 ? "esriNormalizeByField" : null, u14 = n11.classBreakInfos.map(async (e8) => ({ meshes: await M3(e8.symbol, { path: `renderer-stop-${e8.minValue}-${e8.maxValue}`, schemaOptions: l12, uniforms: s9 }), min: e8.minValue, max: e8.maxValue })), m9 = (await Promise.all(u14)).sort((e8, a10) => e8.min - a10.min), c9 = await M3(r8, { schemaOptions: l12, path: "renderer.backgroundFill", uniforms: { ...x2, visualVariableSizeOutlineScaleStops: s9.visualVariableSizeOutlineScaleStops } }), p7 = await M3(n11.defaultSymbol, { schemaOptions: l12, path: "renderer.defaultSymbol", uniforms: s9 });
  return { type: "interval", field: n11.field, expression: n11.valueExpression, backgroundFill: c9, defaultSymbol: p7, intervals: m9, normalizationField: n11.normalizationField, normalizationTotal: n11.normalizationTotal, normalizationType: o15, isMaxInclusive: n11.isMaxInclusive };
}
async function c5(l12, n11) {
  const s9 = [], r8 = M2(n11), t12 = await M3(n11.backgroundFillSymbol, { schemaOptions: l12, path: "renderer.backgroundFill", uniforms: { ...x2, visualVariableSizeOutlineScaleStops: r8.visualVariableSizeOutlineScaleStops } }), o15 = await M3(n11.defaultSymbol, { schemaOptions: l12, path: "renderer.defaultSymbol", uniforms: r8 });
  for (const e8 of n11.uniqueValueInfos ?? []) {
    const a10 = await M3(e8.symbol, { path: `renderer-unique-value-${e8.value}`, schemaOptions: l12, uniforms: r8 });
    s9.push({ value: "" + e8.value, symbol: a10 });
  }
  return { type: "map", field: n11.field, expression: n11.valueExpression, field2: n11.field2, field3: n11.field3, fieldDelimiter: n11.fieldDelimiter, backgroundFill: t12, defaultSymbol: o15, map: s9 };
}
function p5(a10) {
  const i11 = M2(a10), l12 = a10.scaleExpression, n11 = null != l12 && "1" !== l12 ? { valueExpressionInfo: { type: "CIMExpressionInfo", expression: a10.scaleExpression, returnType: "Numeric" }, defaultValue: 1 } : void 0;
  return { type: "dictionary", fieldMap: a10.fieldMap, scaleExpression: n11, visualVariableUniforms: i11 };
}
async function f5(e8, a10) {
  return { type: "heatmap", meshes: await C(a10, e8) };
}
async function y4(e8, a10) {
  return { type: "pie-chart", meshes: I2(a10, e8) };
}

// ../node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SimpleProcessorSchema.js
async function l9(e8, r8) {
  const s9 = r8.renderer, l12 = M2(s9);
  return { symbology: await r6(e8, s9), labels: await l8(e8, r8, l12) };
}
async function a8(e8, r8, t12, i11) {
  const n11 = t12.featureReduction;
  if (n11) switch (n11.type) {
    case "binning":
      return u10(n11, e8, r8, t12, i11);
    case "cluster":
      return f6(n11, e8, r8, t12, i11);
  }
  const a10 = d8(t12.orderBy, t12.renderer, t12.objectIdField), o15 = t5(t12.renderer, r8.filters), c9 = await l9(e8, t12), y5 = false;
  return { storage: o15, mesh: { properties: { sortKey: a10, timeZone: r8.timeZone, returnMeshObjectId: y5, displayRefreshVersion: i11 }, strategy: { type: "feature" }, factory: c9 } };
}
function o11(e8, r8) {
  return e8.fields.map((e9) => ({ ...e9.toJSON(), type: c6(e9, r8) }));
}
function c6(e8, r8) {
  const { onStatisticExpression: t12, onStatisticField: i11, statisticType: s9 } = e8;
  switch (s9) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (t12) {
        const { returnType: e10 } = t12;
        return e10 ? "string" === e10 ? "esriFieldTypeString" : "esriFieldTypeDouble" : "esriFieldTypeString";
      }
      const e9 = r8.find((e10) => e10.name === i11);
      return e9 ? e9.type : "esriFieldTypeString";
    }
  }
}
async function u10(r8, l12, a10, c9, u14) {
  const f7 = o11(r8, c9.fields), d10 = r8.renderer, y5 = await r6(l12, d10), p7 = t5(d10, [null, null]), m9 = M2(d10), g2 = await l8(l12, { geometryType: "polygon", labelingInfo: r8.labelingInfo, labelsVisible: r8.labelsVisible }, m9), b5 = false, h5 = "geohash" === r8.binType ? { type: "geohash", fixBinLevel: r8.fixedBinLevel ?? 3 } : { type: "grid", size: u5(r8.size), fixedBinLevel: r8.fixedBinLevel };
  return { storage: p7, mesh: { properties: { sortKey: null, timeZone: a10.timeZone, returnMeshObjectId: b5, displayRefreshVersion: u14 }, strategy: { type: "binning", fields: f7, index: h5, featureFilter: a10.filters[0] }, factory: { labels: g2, symbology: y5 } } };
}
async function f6(r8, l12, a10, c9, u14) {
  const f7 = o11(r8, c9.fields), d10 = { type: "cluster", feature: await r6(l12, r8.effectiveFeatureRenderer), cluster: await r6(l12, r8.effectiveClusterRenderer) }, y5 = M2(r8.effectiveFeatureRenderer), p7 = { type: "cluster", feature: await l8(l12, c9, y5), cluster: await l8(l12, { geometryType: "point", labelingInfo: r8.labelingInfo, labelsVisible: r8.labelsVisible }, y5) }, m9 = false;
  return { storage: t5(r8.effectiveFeatureRenderer, [null, null]), mesh: { properties: { sortKey: null, timeZone: a10.timeZone, displayRefreshVersion: u14, returnMeshObjectId: m9 }, strategy: { type: "cluster", fields: f7, featureFilter: a10.filters[0], clusterRadius: u5(r8.clusterRadius / 2) }, factory: { labels: p7, symbology: d10 } } };
}
function d8(e8, t12, i11) {
  const s9 = null != t12 && "unique-value" === t12.type && t12.orderByClassesEnabled;
  if ("default" !== e8 || s9 || (e8 = [new a3({ field: i11, order: "descending" })]), "default" !== e8 && e8.length) {
    e8.length;
    const r8 = e8[0], t13 = "ascending" === r8.order ? "asc" : "desc";
    return r8.field ? { field: r8.field, order: t13 } : r8.valueExpression ? { expression: r8.valueExpression, order: t13 } : null;
  }
  if (s9) {
    return { byRenderer: true, order: "asc" };
  }
  return null;
}

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/CatalogFootprintLayerAdapter.js
var l10 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, t12 = l7(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: t12 }];
  }
  async createServiceOptions(o15) {
    var _a, _b;
    const s9 = this.layer, { capabilities: i11, editingInfo: a10, objectIdField: n11, globalIdField: l12, datesInUnknownTimezone: p7, orderBy: u14, parsedUrl: c9 } = s9, d10 = s9.fieldsIndex.toJSON(), m9 = e6(s9), y5 = (_a = s9.timeInfo) == null ? void 0 : _a.toJSON(), f7 = s9.spatialReference.toJSON(), g2 = a(c9);
    let h5 = n11;
    if (u14 == null ? void 0 : u14.length) {
      const e8 = !u14[0].valueExpression && u14[0].field;
      e8 && (h5 = e8);
    }
    return { type: "feature-service", source: g2, isSourceHosted: g(g2.path), orderByFields: h5, outSpatialReference: o15.spatialReference.toJSON(), metadata: { timeReferenceUnknownClient: p7, globalIdField: l12, fieldsIndex: d10, geometryType: m9, objectIdField: n11, timeInfo: y5, spatialReference: f7, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: i11.query.maxRecordCount, supportsCompactGeometry: i11.query.supportsCompactGeometry, supportsDefaultSpatialReference: i11.query.supportsDefaultSpatialReference, supportsFormatPBF: i11.query.supportsFormatPBF, supportsMaxRecordCountFactor: i11.query.supportsMaxRecordCountFactor, supportsQuantization: i11.query.supportsQuantization, lastEditDate: (_b = a10 == null ? void 0 : a10.lastEditDate) == null ? void 0 : _b.getTime(), snapshotInfo: null } };
  }
  createSourceSchema(e8, r8) {
    const { definitionExpression: t12, customParameters: o15, timeExtent: s9, apiKey: a10 } = this.layer;
    return t9({ definitionExpression: t12, customParameters: o15, timeExtent: s9 }, e8, r8, a10);
  }
  createProcessorSchema(e8, r8, t12) {
    const { fields: o15, geometryType: s9, orderBy: i11, objectIdField: n11, renderer: l12, labelingInfo: p7, labelsVisible: u14 } = this.layer, c9 = { featureReduction: null, fields: o15.map((e9) => e9.toJSON()), geometryType: s9, labelingInfo: p7, labelsVisible: u14, objectIdField: n11, orderBy: i11 ?? "default", renderer: l12 == null ? void 0 : l12.clone() };
    return a8(e8, r8, c9, t12);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e8) {
    const r8 = this.layer, { definitionExpression: t12, apiKey: o15, renderer: s9 } = r8, i11 = this.layer.labelsVisible ? this.layer.labelingInfo : null, a10 = JSON.stringify(r8.customParameters), n11 = JSON.stringify(r8.orderBy);
    return { outFields: this.layer.outFields, apiKey: o15, customParameters: a10, definitionExpression: t12, labelingInfo: i11, orderBy: n11, renderer: s9 };
  }
  setGraphicOrigin(e8) {
    e8.origin = { type: "catalog", layer: this.layer };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureServiceUtils.js
function t10(t12, e8) {
  const n11 = t12.extent, o15 = e8 == null ? void 0 : e8.clone().intersection(n11), i11 = null != o15 ? o15.width * o15.height : 0, r8 = e8 ? e8.width * e8.height : 0, h5 = 0 === r8 ? 0 : i11 / r8, s9 = has("featurelayer-snapshot-point-coverage");
  return !isNaN(h5) && h5 >= s9;
}

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/floorFilterUtils.js
function o12(e8, l12) {
  return null != e8.floorInfo && (e8.floorInfo.viewAllLevelIds.length > 0 || l12.floors.length > 0);
}
function r7(e8, o15, r8) {
  const t12 = n8(e8, o15 == null ? void 0 : o15.where, r8);
  return t12 ? (o15 ?? (o15 = new d5()), o15.where = t12, o15) : o15;
}
function n8(l12, o15, r8) {
  var _a;
  if (null == l12.floorInfo || !((_a = r8.floors) == null ? void 0 : _a.length)) return o15;
  let n11 = r8.floors;
  const { floorField: t12, viewAllLevelIds: f7 } = l12.floorInfo;
  f7.length && (n11 = f7);
  const s9 = n11.filter((e8) => "" !== e8).map((e8) => "'" + e8 + "'");
  if (s9.push("''"), o15 == null ? void 0 : o15.includes(t12)) {
    let e8 = new RegExp("AND \\(" + t12 + ".*NULL\\)", "g");
    o15 = o15.replace(e8, ""), e8 = new RegExp("\\(" + t12 + ".*NULL\\)", "g"), o15 = (o15 = o15.replace(e8, "")).replaceAll(/\s+/g, " ").trim();
  }
  let i11 = "(" + t12 + " IN ({ids}) OR " + t12 + " IS NULL)";
  return i11 = i11.replace("{ids}", s9.join(", ")), n2(o15, i11);
}

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/FeatureLayerAdapter.js
var c7 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const t12 = this.layer, r8 = r5(t12, e8) ?? l7(t12);
    return [{ vvEvaluators: { 0: o8(t12.renderer) }, deconflictionEnabled: r8 }];
  }
  async createServiceOptions(r8) {
    var _a, _b, _c2, _d;
    const o15 = this.layer, { capabilities: i11, editingInfo: n11, objectIdField: l12, typeIdField: p7, globalIdField: d10, datesInUnknownTimezone: u14, orderBy: y5, subtypeField: c9, refreshInterval: m9 } = o15, f7 = o15.fieldsIndex.toJSON(), h5 = f7.fields, b5 = e6(o15), g2 = (_a = o15.timeInfo) == null ? void 0 : _a.toJSON(), S3 = o15.spatialReference.toJSON(), F3 = (_b = o15.types) == null ? void 0 : _b.map((e8) => e8.toJSON()), I3 = a(this.layer.parsedUrl);
    this.layer.dynamicDataSource && (I3.query = { layer: JSON.stringify({ source: this.layer.dynamicDataSource }) });
    let x4 = this.layer.objectIdField;
    if (y5 == null ? void 0 : y5.length) {
      const e8 = !y5[0].valueExpression && y5[0].field;
      e8 && (x4 = e8);
    }
    const j2 = !(null != (n11 == null ? void 0 : n11.lastEditDate)) && m9 > 0, R3 = has("featurelayer-snapshot-enabled") && "point" === o15.geometryType && (i11 == null ? void 0 : i11.query.supportsPagination) && !(i11 == null ? void 0 : i11.operations.supportsEditing) && !j2, E3 = R3 && t10(r8, o15.fullExtent);
    return { type: "feature-service", source: I3, isSourceHosted: g(I3.path), orderByFields: x4, outSpatialReference: r8.spatialReference.toJSON(), metadata: { typeIdField: p7 ?? void 0, types: F3, timeReferenceUnknownClient: u14, subtypeField: c9, globalIdField: d10, fields: h5, fieldsIndex: f7, geometryType: b5, objectIdField: l12, timeInfo: g2, spatialReference: S3, subtypes: (_c2 = this.layer.subtypes) == null ? void 0 : _c2.map((e8) => e8.toJSON()) }, queryMetadata: { maxRecordCount: i11.query.maxRecordCount, supportsCompactGeometry: i11.query.supportsCompactGeometry, supportsDefaultSpatialReference: i11.query.supportsDefaultSpatialReference, supportsFormatPBF: i11.query.supportsFormatPBF, supportsMaxRecordCountFactor: i11.query.supportsMaxRecordCountFactor, supportsQuantization: i11.query.supportsQuantization, lastEditDate: (_d = n11 == null ? void 0 : n11.lastEditDate) == null ? void 0 : _d.getTime(), snapshotInfo: { supportsSnapshotMinThreshold: R3, supportsSnapshotMaxThreshold: E3, snapshotCountThresholds: { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") } } } };
  }
  createSourceSchema(e8, t12) {
    const { definitionExpression: r8, customParameters: s9, gdbVersion: o15, historicMoment: i11, subtypeCode: a10, subtypeField: n11, timeExtent: l12, apiKey: p7 } = this.layer;
    return t9({ definitionExpression: r8, customParameters: s9, gdbVersion: o15, historicMoment: i11, subtypeCode: a10, subtypeField: n11, timeExtent: l12 }, e8, t12, p7);
  }
  createProcessorSchema(e8, t12, s9) {
    const { fields: o15, renderer: i11, geometryType: a10, labelingInfo: n11, labelsVisible: l12, orderBy: p7, objectIdField: d10 } = this.layer, y5 = { fields: o15.map((e9) => e9.toJSON()), renderer: i11 == null ? void 0 : i11.clone(), featureReduction: e7(this.layer, t12), geometryType: a10, labelingInfo: n11, labelsVisible: l12, objectIdField: d10, orderBy: p7 ?? "default" };
    return a8(e8, t12, y5, s9);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  hasFilters(e8) {
    return o12(this.layer, e8);
  }
  addFilters(e8, t12) {
    return r7(this.layer, e8, t12);
  }
  getUpdateHashProperties(e8) {
    var _a;
    const t12 = this.layer, { definitionExpression: s9, renderer: i11, gdbVersion: a10, apiKey: n11, subtypeCode: l12 } = t12, p7 = this.layer.labelsVisible ? this.layer.labelingInfo : null, d10 = ((_a = t12.historicMoment) == null ? void 0 : _a.getTime()) ?? void 0, u14 = JSON.stringify(t12.customParameters), y5 = e7(t12, e8), c9 = JSON.stringify(t12.orderBy), m9 = o12(this.layer, e8) ? e8.floors : null;
    return { outFields: this.layer.outFields, apiKey: n11, customParameters: u14, definitionExpression: s9, featureReduction: y5, floors: m9, gdbVersion: a10, historicMoment: d10, labelingInfo: p7, orderBy: c9, renderer: i11, subtypeCode: l12 };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/InMemoryLayerAdapter.js
function u11(r8) {
  if (!("openPorts" in r8)) throw new s("source-not-supported");
}
var p6 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, t12 = r5(r8, e8) ?? l7(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: t12 }];
  }
  async createServiceOptions(e8) {
    var _a;
    const r8 = this.layer, { capabilities: o15, objectIdField: s9 } = r8, i11 = r8.fieldsIndex.toJSON(), n11 = e6(r8), l12 = (_a = r8.timeInfo) == null ? void 0 : _a.toJSON(), a10 = r8.spatialReference.toJSON();
    u11(r8.source);
    return { type: "memory", source: await r8.source.openPorts(), orderByFields: s9, outSpatialReference: e8.spatialReference.toJSON(), metadata: { fieldsIndex: i11, geometryType: n11, objectIdField: s9, timeInfo: l12, spatialReference: a10, subtypes: null, subtypeField: null, globalIdField: null, typeIdField: null, types: null, timeReferenceUnknownClient: null }, queryMetadata: { maxRecordCount: o15.query.maxRecordCount, supportsCompactGeometry: o15.query.supportsCompactGeometry, supportsDefaultSpatialReference: o15.query.supportsDefaultSpatialReference, supportsFormatPBF: o15.query.supportsFormatPBF, supportsMaxRecordCountFactor: o15.query.supportsMaxRecordCountFactor, supportsQuantization: o15.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e8, r8) {
    const { definitionExpression: t12, timeExtent: o15 } = this.layer;
    return t9({ definitionExpression: t12, timeExtent: o15, customParameters: null }, e8, r8, null);
  }
  createProcessorSchema(e8, t12, o15) {
    const { fields: s9, renderer: i11, geometryType: n11, labelingInfo: a10, labelsVisible: u14, orderBy: p7, objectIdField: c9 } = this.layer, d10 = { fields: s9.map((e9) => e9.toJSON()), renderer: i11 == null ? void 0 : i11.clone(), featureReduction: e7(this.layer, t12), geometryType: n11, labelingInfo: a10, labelsVisible: u14, objectIdField: c9, orderBy: p7 ?? "default" };
    return a8(e8, t12, d10, o15);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e8) {
    const t12 = this.layer, { definitionExpression: o15, renderer: s9 } = t12, i11 = this.layer.labelsVisible ? this.layer.labelingInfo : null, n11 = e7(t12, e8);
    return { orderBy: JSON.stringify(t12.orderBy), definitionExpression: o15, renderer: s9, labelingInfo: i11, featureReduction: n11 };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/KnowledgeGraphSublayerAdapter.js
var a9 = class {
  constructor(e8) {
    this.layer = e8, this.timeOptions = null;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, i11 = r5(r8, e8) ?? l7(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: i11 }];
  }
  async createServiceOptions(e8) {
    const t12 = this.layer, { capabilities: o15, objectIdField: s9 } = t12, i11 = t12.fieldsIndex.toJSON(), l12 = e6(t12), n11 = t12.spatialReference.toJSON();
    return { type: "memory", source: await t12.source.openPorts(), orderByFields: s9, outSpatialReference: e8.spatialReference.toJSON(), metadata: { fieldsIndex: i11, geometryType: l12, objectIdField: s9, spatialReference: n11, globalIdField: null, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: o15.query.maxRecordCount, supportsCompactGeometry: o15.query.supportsCompactGeometry, supportsDefaultSpatialReference: o15.query.supportsDefaultSpatialReference, supportsFormatPBF: o15.query.supportsFormatPBF, supportsMaxRecordCountFactor: o15.query.supportsMaxRecordCountFactor, supportsQuantization: o15.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e8, r8) {
    const { definitionExpression: t12 } = this.layer;
    return t9({ definitionExpression: t12, customParameters: null }, e8, r8, null);
  }
  createProcessorSchema(r8, t12, o15) {
    const { fields: s9, renderer: i11, geometryType: n11, labelingInfo: a10, labelsVisible: u14, objectIdField: p7 } = this.layer, c9 = { fields: s9.map((e8) => e8.toJSON()), renderer: i11 == null ? void 0 : i11.clone(), featureReduction: e7(this.layer, t12), geometryType: n11, labelingInfo: a10, labelsVisible: u14, objectIdField: p7, orderBy: "default" };
    return a8(r8, t12, c9, o15);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  getUpdateHashProperties(r8) {
    const t12 = this.layer, { definitionExpression: o15, renderer: s9 } = t12;
    return { definitionExpression: o15, renderer: s9, labelingInfo: this.layer.labelsVisible ? this.layer.labelingInfo : null, featureReduction: e7(t12, r8) };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OGCFeatureLayerAdapter.js
var u12 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, t12 = r5(r8, e8) ?? l7(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: t12 }];
  }
  async createServiceOptions(r8) {
    var _a;
    const o15 = this.layer, { capabilities: s9, objectIdField: a10 } = o15, i11 = o15.fieldsIndex.toJSON(), l12 = e6(o15), n11 = (_a = o15.timeInfo) == null ? void 0 : _a.toJSON(), u14 = o15.spatialReference.toJSON(), c9 = o15.source.getSource(), p7 = this.layer.objectIdField, d10 = a(s9);
    return d10.query.maxRecordCount = c9.maxRecordCount, { type: "ogc", source: c9, orderByFields: p7, outSpatialReference: r8.spatialReference.toJSON(), metadata: { fieldsIndex: i11, geometryType: l12, objectIdField: a10, timeInfo: n11, spatialReference: u14, globalIdField: null, subtypeField: null, subtypes: null, timeReferenceUnknownClient: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: d10.query.maxRecordCount, supportsCompactGeometry: d10.query.supportsCompactGeometry, supportsDefaultSpatialReference: d10.query.supportsDefaultSpatialReference, supportsFormatPBF: d10.query.supportsFormatPBF, supportsMaxRecordCountFactor: d10.query.supportsMaxRecordCountFactor, supportsQuantization: d10.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e8, r8) {
    const { customParameters: t12, timeExtent: o15, apiKey: s9 } = this.layer;
    return t9({ customParameters: t12, timeExtent: o15 }, e8, r8, s9);
  }
  createProcessorSchema(e8, t12, o15) {
    const { fields: s9, renderer: a10, geometryType: i11, labelingInfo: n11, labelsVisible: u14, orderBy: c9, objectIdField: p7 } = this.layer, d10 = { fields: s9.map((e9) => e9.toJSON()), renderer: a10 == null ? void 0 : a10.clone(), featureReduction: e7(this.layer, t12), geometryType: i11, labelingInfo: n11, labelsVisible: u14, objectIdField: p7, orderBy: c9 ?? "default" };
    return a8(e8, t12, d10, o15);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e8) {
    const t12 = this.layer, { renderer: o15, apiKey: s9 } = t12, a10 = this.layer.labelsVisible ? this.layer.labelingInfo : null;
    return { apiKey: s9, customParameters: JSON.stringify(t12.customParameters), featureReduction: e7(t12, e8), labelingInfo: a10, orderBy: JSON.stringify(t12.orderBy), renderer: o15 };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OrientedImageryLayerAdapter.js
var m7 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const r8 = this.layer, t12 = r5(r8, e8) ?? l7(r8);
    return [{ vvEvaluators: { 0: o8(r8.renderer) }, deconflictionEnabled: t12 }];
  }
  async createServiceOptions(t12) {
    var _a;
    const s9 = this.layer, { capabilities: i11, objectIdField: l12, globalIdField: n11, orderBy: p7, refreshInterval: u14 } = s9, d10 = s9.fieldsIndex.toJSON(), c9 = d10.fields, m9 = e6(s9), f7 = (_a = s9.timeInfo) == null ? void 0 : _a.toJSON(), y5 = s9.spatialReference.toJSON(), h5 = a(this.layer.parsedUrl);
    let b5 = this.layer.objectIdField;
    if (p7 == null ? void 0 : p7.length) {
      const e8 = !p7[0].valueExpression && p7[0].field;
      e8 && (b5 = e8);
    }
    const g2 = u14 > 0, S3 = has("featurelayer-snapshot-enabled") && "point" === s9.geometryType && (i11 == null ? void 0 : i11.query.supportsPagination) && !(i11 == null ? void 0 : i11.operations.supportsEditing) && !g2, F3 = S3 && t10(t12, s9.fullExtent);
    return { type: "feature-service", source: h5, isSourceHosted: g(h5.path), orderByFields: b5, outSpatialReference: t12.spatialReference.toJSON(), metadata: { globalIdField: n11, fields: c9, fieldsIndex: d10, geometryType: m9, objectIdField: l12, timeInfo: f7, spatialReference: y5, timeReferenceUnknownClient: false, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: i11.query.maxRecordCount, supportsCompactGeometry: i11.query.supportsCompactGeometry, supportsDefaultSpatialReference: i11.query.supportsDefaultSpatialReference, supportsFormatPBF: i11.query.supportsFormatPBF, supportsMaxRecordCountFactor: i11.query.supportsMaxRecordCountFactor, supportsQuantization: i11.query.supportsQuantization, lastEditDate: null, snapshotInfo: { supportsSnapshotMinThreshold: S3, supportsSnapshotMaxThreshold: F3, snapshotCountThresholds: { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") } } } };
  }
  createSourceSchema(e8, r8) {
    const { definitionExpression: t12, customParameters: o15, timeExtent: s9 } = this.layer;
    return t9({ definitionExpression: t12, customParameters: o15, timeExtent: s9 }, e8, r8, null);
  }
  createProcessorSchema(e8, r8, o15) {
    const { fields: s9, renderer: i11, geometryType: a10, labelingInfo: l12, labelsVisible: n11, orderBy: p7, objectIdField: u14 } = this.layer, c9 = { fields: s9.map((e9) => e9.toJSON()), renderer: i11 == null ? void 0 : i11.clone(), featureReduction: e7(this.layer, r8), geometryType: a10, labelingInfo: l12, labelsVisible: n11, objectIdField: u14, orderBy: p7 ?? "default" };
    return a8(e8, r8, c9, o15);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  hasFilters(e8) {
    return o12(this.layer, e8);
  }
  addFilters(e8, r8) {
    return r7(this.layer, e8, r8);
  }
  getUpdateHashProperties(e8) {
    const r8 = this.layer, { definitionExpression: o15, renderer: i11, outFields: a10 } = r8, l12 = this.layer.labelsVisible ? this.layer.labelingInfo : null, n11 = JSON.stringify(r8.customParameters), p7 = e7(r8, e8);
    return { outFields: a10, orderBy: JSON.stringify(r8.orderBy), definitionExpression: o15, renderer: i11, labelingInfo: l12, featureReduction: p7, customParameters: n11, floors: o12(this.layer, e8) ? e8.floors : null };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/StreamLayerAdapter.js
var l11 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    const t12 = this.layer, o15 = r5(t12, e8) ?? l7(t12);
    return [{ vvEvaluators: { 0: o8(t12.renderer) }, deconflictionEnabled: o15 }];
  }
  async createServiceOptions(e8) {
    var _a;
    const r8 = this.layer, { objectIdField: i11 } = r8, n11 = e6(r8), o15 = ((_a = r8.timeInfo) == null ? void 0 : _a.toJSON()) || null, s9 = r8.spatialReference ? r8.spatialReference.toJSON() : null;
    return { type: "stream", source: this.layer.parsedUrl, outSpatialReference: e8.spatialReference.toJSON(), metadata: { fieldsIndex: this.layer.fieldsIndex.toJSON(), geometryType: n11, objectIdField: i11, timeInfo: o15, timeReferenceUnknownClient: null, spatialReference: s9, subtypeField: null, subtypes: null, globalIdField: null, typeIdField: null, types: null } };
  }
  createSourceSchema(e8, t12) {
    const { definitionExpression: r8, geometryDefinition: i11, customParameters: n11 } = this.layer;
    return { type: "stream", mutable: { sourceRefreshVersion: t12, availableFields: e8.availableFields, dataFilter: { geometryDefinition: i11 == null ? void 0 : i11.toJSON(), definitionExpression: r8, customParameters: n11 ?? null, maxReconnectionAttempts: this.layer.maxReconnectionAttempts, maxReconnectionInterval: this.layer.maxReconnectionInterval, purgeOptions: this.layer.purgeOptions.toJSON() } } };
  }
  createProcessorSchema(t12, r8, i11) {
    const { fields: n11, renderer: s9, geometryType: l12, labelingInfo: a10, labelsVisible: c9, objectIdField: d10 } = this.layer, m9 = { fields: n11.map((e8) => e8.toJSON()), renderer: s9 == null ? void 0 : s9.clone(), featureReduction: e7(this.layer, r8), geometryType: l12, labelingInfo: a10, labelsVisible: c9, objectIdField: d10, orderBy: "default" };
    return a8(t12, r8, m9, i11);
  }
  get hasRequiredSupport() {
    return m2(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(t12) {
    const r8 = this.layer, { definitionExpression: i11, renderer: n11 } = r8, o15 = this.layer.labelsVisible ? this.layer.labelingInfo : null, s9 = JSON.stringify(r8.customParameters);
    return { definitionExpression: i11, renderer: n11, labelingInfo: o15, featureReduction: e7(r8, t12), customParameters: s9, geometryDefinition: r8.geometryDefinition, definitionExpressoin: r8.definitionExpression };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SubtypeProcessorSchema.js
async function i9(e8, { subtypeField: t12, sublayers: s9 }) {
  const a10 = await Promise.all(s9.map(({ renderer: t13 }) => r6(e8, t13)));
  return { type: "subtype", subtypeField: t12, renderers: s9.reduce((e9, { subtypeCode: r8 }, t13) => ({ ...e9, [r8]: a10[t13] }), {}) };
}
function o13(e8, r8) {
  const s9 = t3();
  return { type: "subtype", filters: e8.filters, capabilities: { maxTextureSize: s9.maxTextureSize }, subtypeField: r8.subtypeField, target: "feature", bindings: r8.sublayers.reduce((e9, { renderer: r9, subtypeCode: s10 }) => {
    const a10 = c(r9);
    return { ...e9, [s10]: a10 };
  }, {}) };
}
async function u13(r8, { subtypeField: t12, sublayers: a10 }) {
  const i11 = await Promise.all(a10.map((t13) => {
    const a11 = M2(t13.renderer), i12 = { ...t13, geometryType: t13.geometryType ?? null };
    return l8(r8, i12, a11);
  }));
  return { type: "subtype", subtypeField: t12, renderers: a10.reduce((e8, { subtypeCode: r9 }, t13) => ({ ...e8, [r9]: i11[t13] }), {}) };
}
async function n9(e8, r8, t12, s9) {
  return { storage: o13(r8, t12), mesh: { properties: { timeZone: r8.timeZone, displayRefreshVersion: s9, returnMeshObjectId: false, sortKey: null }, strategy: { type: "feature" }, factory: { symbology: await i9(e8, t12), labels: await u13(e8, t12) } } };
}

// ../node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/SubtypeGroupLayerAdapter.js
var m8 = class {
  constructor(e8) {
    this.layer = e8;
  }
  getLabelingDeconflictionInfo(e8) {
    return [{ vvEvaluators: {}, deconflictionEnabled: this.layer.sublayers.every((e9) => l7(e9)) }];
  }
  async createServiceOptions(t12) {
    var _a, _b, _c;
    const r8 = this.layer, { capabilities: i11, datesInUnknownTimezone: a10, editingInfo: l12, globalIdField: p7, objectIdField: u14, refreshInterval: y5, subtypeField: m9 } = r8, c9 = r8.fieldsIndex.toJSON(), d10 = e6(r8), h5 = (_a = r8.timeInfo) == null ? void 0 : _a.toJSON(), f7 = r8.spatialReference.toJSON(), b5 = a(this.layer.parsedUrl), g2 = u14, S3 = !(null != (l12 == null ? void 0 : l12.lastEditDate)) && y5 > 0, F3 = has("featurelayer-snapshot-enabled") && "point" === r8.geometryType && (i11 == null ? void 0 : i11.query.supportsPagination) && !(i11 == null ? void 0 : i11.operations.supportsEditing) && !S3, x4 = F3 && t10(t12, r8.fullExtent);
    return { type: "feature-service", source: b5, isSourceHosted: g(b5.path), orderByFields: g2, outSpatialReference: t12.spatialReference.toJSON(), metadata: { timeReferenceUnknownClient: a10, subtypeField: m9, globalIdField: p7, fieldsIndex: c9, geometryType: d10, objectIdField: u14, timeInfo: h5, spatialReference: f7, subtypes: (_b = this.layer.subtypes) == null ? void 0 : _b.map((e8) => e8.toJSON()), typeIdField: null, types: null }, queryMetadata: { maxRecordCount: i11.query.maxRecordCount, supportsCompactGeometry: i11.query.supportsCompactGeometry, supportsDefaultSpatialReference: i11.query.supportsDefaultSpatialReference, supportsFormatPBF: i11.query.supportsFormatPBF, supportsMaxRecordCountFactor: i11.query.supportsMaxRecordCountFactor, supportsQuantization: i11.query.supportsQuantization, lastEditDate: (_c = l12 == null ? void 0 : l12.lastEditDate) == null ? void 0 : _c.getTime(), snapshotInfo: { supportsSnapshotMinThreshold: F3, supportsSnapshotMaxThreshold: x4, snapshotCountThresholds: { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") } } } };
  }
  createSourceSchema(e8, t12) {
    const { definitionExpression: r8, customParameters: s9, gdbVersion: i11, historicMoment: o15, subtypeField: a10, timeExtent: l12, apiKey: n11 } = this.layer, p7 = { queryScaleRanges: this.layer.sublayers.items.map((e9) => ({ subtypeCode: e9.subtypeCode, minScale: e9.minScale, maxScale: e9.maxScale })), definitionExpression: r8, customParameters: s9, gdbVersion: i11, historicMoment: o15, subtypeField: a10, timeExtent: l12 };
    return t9(p7, e8, t12, n11);
  }
  createProcessorSchema(e8, t12, r8) {
    const s9 = { subtypeField: this.layer.subtypeField, sublayers: Array.from(this.layer.sublayers, (e9) => ({ featureReduction: null, geometryType: this.layer.geometryType, labelingInfo: e9.labelingInfo, labelsVisible: e9.labelsVisible, renderer: e9.renderer, subtypeCode: e9.subtypeCode, orderBy: null })) };
    return n9(e8, t12, s9, r8);
  }
  hasFilters(e8) {
    return o12(this.layer, e8) || c8(this.layer, e8);
  }
  addFilters(e8, t12) {
    e8 = r7(this.layer, e8, t12);
    const s9 = this.layer.sublayers.filter((e9) => !d9(e9, t12)).map((e9) => e9.subtypeCode);
    if (!s9.length) return e8;
    e8 ?? (e8 = new d5());
    const o15 = `NOT ${this.layer.subtypeField} IN (${s9.join(",")})`;
    return e8.where = n2(e8.where, o15), e8;
  }
  get hasRequiredSupport() {
    return true;
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e8) {
    var _a;
    const t12 = this.layer, { definitionExpression: r8, gdbVersion: s9, apiKey: i11 } = t12, o15 = ((_a = t12.historicMoment) == null ? void 0 : _a.getTime()) ?? void 0, l12 = JSON.stringify(t12.customParameters), n11 = o12(this.layer, e8) ? e8.floors : null, p7 = this.layer.sublayers.map(({ renderer: e9, labelsVisible: t13, labelingInfo: r9, visible: s10 }) => ({ renderer: e9, labelsVisible: t13, labelingInfo: r9, visible: s10 }));
    return { outFields: this.layer.outFields, gdbVersion: s9, definitionExpression: r8, historicMoment: o15, customParameters: l12, apiKey: i11, sublayers: p7, floors: n11 };
  }
  setGraphicOrigin(e8) {
    const t12 = this.layer.fieldsIndex.get(this.layer.subtypeField), r8 = e8.attributes[t12.name], s9 = this.layer.sublayers.find((e9) => e9.subtypeCode === r8);
    e8.layer = e8.sourceLayer = s9;
  }
};
function c8(e8, t12) {
  return e8.sublayers.some((e9) => !d9(e9, t12));
}
function d9(e8, r8) {
  return e8.visible && (0 === e8.minScale || F(r8.scale, e8.minScale) || r8.scale < e8.minScale) && (0 === e8.maxScale || F(r8.scale, e8.maxScale) || r8.scale > e8.maxScale);
}

// ../node_modules/@arcgis/core/views/2d/layers/support/handleNoEngineError.js
async function n10(n11, r8) {
  try {
    return await n11;
  } catch (t12) {
    if ("no-queryEngine" !== t12.name) throw t12;
    return r8;
  }
}

// ../node_modules/@arcgis/core/views/2d/tiling/FeatureTileSubscriptionManager.js
function s8(e8, s9) {
  const t12 = /* @__PURE__ */ new Set();
  for (const i11 of e8 instanceof Set ? e8.values() : e8.keys()) s9.has(i11) || t12.add(i11);
  return t12;
}
var t11 = class {
  constructor(e8, s9, t12) {
    const i11 = t12 ? e8.getTileCoverage(t12, 0, true, "closest") : null, o15 = e8.getTileCoverage(s9, 0, true, "closest");
    if (this._tileKeys = /* @__PURE__ */ new Map(), i11) for (const n11 of i11.keys()) this._tileKeys.set(n11.id, n11);
    if (o15) for (const n11 of o15.keys()) this._tileKeys.set(n11.id, n11);
  }
  get coverageSet() {
    return new Set(this._tileKeys.keys());
  }
  keys() {
    return this._tileKeys.values();
  }
};
var i10 = class {
  constructor(e8) {
    this.version = e8;
  }
};
var o14 = class {
  constructor(e8) {
    this._subscriptions = /* @__PURE__ */ new Map(), this._visible = /* @__PURE__ */ new Set(), this._paused = /* @__PURE__ */ new Set(), this._version = 0, this._config = e8;
  }
  destroy() {
  }
  get _coverageSet() {
    var _a;
    return ((_a = this._coverage) == null ? void 0 : _a.coverageSet) ?? /* @__PURE__ */ new Set();
  }
  suspend() {
    this._suspendedOverage = this._coverage, this._coverage = null, this._updateSubscriptions();
  }
  resume() {
    null == this._coverage && (this._coverage = this._suspendedOverage, this._suspendedOverage = null, this._updateSubscriptions());
  }
  update(e8, s9) {
    return this._version = (this._version + 1) % Number.MAX_SAFE_INTEGER, this._updateCoverage(e8, s9), this._updateSubscriptions(), new Set(this._visible);
  }
  _updateCoverage(e8, s9) {
    this._coverage = new t11(this._config.tileInfoView, e8, s9);
  }
  _updateSubscriptions() {
    const e8 = this._coverageSet, t12 = this._updateVisibility(), o15 = s8(t12, e8), n11 = s8(this._subscriptions, t12), r8 = s8(e8, this._subscriptions), a10 = s8(n11, e8), c9 = s8(o15, a10), u14 = s8(c9, this._paused);
    this._visible = t12;
    for (const s9 of r8.values()) this._subscriptions.set(s9, new i10(this._version));
    for (const s9 of u14.values()) this._paused.add(s9);
    for (const s9 of a10.values()) this._subscriptions.delete(s9), this._paused.delete(s9);
    (r8.size || a10.size || u14.size) && this._sendUpdateSubscriptions(r8, a10, u14);
  }
  _sendUpdateSubscriptions(e8, s9, t12) {
    const i11 = Array.from(e8.values()).map((e9) => ({ tileId: e9, version: this._subscriptions.get(e9).version }));
    this._config.updateSubscriptions({ subscribe: i11, unsubscribe: Array.from(s9.values()), pause: Array.from(t12.values()) });
  }
  _updateVisibility() {
    const s9 = /* @__PURE__ */ new Set(), t12 = /* @__PURE__ */ new Set();
    if (!this._coverage) return s9;
    for (const e8 of this._coverage.keys()) {
      if (this._config.isDone(e8)) {
        s9.add(e8.id);
        continue;
      }
      if (this._addVisibleParent(s9, t12, e8)) continue;
      this._addVisibleChildren(s9, e8) || s9.add(e8.id);
    }
    const i11 = new e4(0, 0, 0, 0), o15 = new e4(0, 0, 0, 0);
    for (const e8 of t12) {
      i11.id = e8;
      for (const e9 of s9) o15.id = e9, i11.containsChild(o15) && s9.delete(e9);
    }
    return s9;
  }
  _addVisibleParent(s9, t12, i11) {
    let o15 = false;
    for (const n11 of this._visible.values()) {
      new e4(n11).containsChild(i11) && (s9.add(n11), t12.add(n11), o15 = true);
    }
    return o15;
  }
  _addVisibleChildren(s9, t12) {
    let i11 = false;
    for (const o15 of this._visible.values()) {
      const n11 = new e4(o15);
      t12.containsChild(n11) && (s9.add(o15), i11 = true);
    }
    return i11;
  }
};

// ../node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var _ = (_2) => {
  let q = class extends _2 {
    constructor(...e8) {
      super(...e8), this._updatingRequiredFieldsPromise = null, this.dataUpdating = false, this.filter = null, this.layer = null, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.addHandles([d2(() => {
        var _a;
        const e8 = this.layer;
        return [e8 && "elevationInfo" in e8 ? (_a = e8.elevationInfo) == null ? void 0 : _a.featureExpressionInfo : null, e8 && "displayField" in e8 ? e8.displayField : null, e8 && "timeInfo" in e8 && e8.timeInfo, e8 && "renderer" in e8 && e8.renderer, e8 && "labelingInfo" in e8 && e8.labelingInfo, e8 && "floorInfo" in e8 && e8.floorInfo, this.filter, this.featureEffect, this.timeExtent];
      }, () => this._handleRequiredFieldsChange(), A), v(() => {
        var _a;
        return (_a = this.view) == null ? void 0 : _a.floors;
      }, "change", () => this._handleRequiredFieldsChange()), v(() => {
        const e8 = this.layer;
        return e8 && "sublayers" in e8 ? e8.sublayers : null;
      }, "change", () => this._handleRequiredFieldsChange())]);
    }
    get availableFields() {
      if (!this.layer) return [];
      const { layer: e8, layer: { fieldsIndex: t12 }, requiredFields: r8 } = this;
      return "outFields" in e8 && e8.outFields ? I(t12, [...x(t12, e8.outFields), ...r8]) : I(t12, r8);
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e8) {
      this._override("featureEffect", e8);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e8) {
      n.getLogger(this).error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    highlight(e8) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e8 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t12 = null != this.filter ? this.filter.createQuery(e8) : new b2(e8);
      if ("floorInfo" in this.layer && this.layer.floorInfo) {
        const e9 = o6(this);
        null != e9 && (t12.where = t12.where ? `(${t12.where}) AND (${e9})` : e9);
      }
      return null != this.timeExtent && (t12.timeExtent = null != t12.timeExtent ? t12.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t12;
    }
    createAggregateQuery() {
      const e8 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new b2(e8);
    }
    queryFeatures(e8, t12) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e8, t12) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e8, t12) {
      throw new Error("missing implementation");
    }
    queryExtent(e8, t12) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeaturesFromGraphics(e8, t12) {
      return this._validateFetchPopupFeatures(e8, t12), this._fetchPopupFeatures(e8, t12);
    }
    _loadArcadeModules(e8) {
      var _a;
      return ((_a = e8.expressionInfos) == null ? void 0 : _a.length) || Array.isArray(e8.content) && e8.content.some((e9) => "expression" === e9.type) ? i3() : Promise.resolve();
    }
    _handleRequiredFieldsChange() {
      const e8 = this._updateRequiredFields();
      this._set("_updatingRequiredFieldsPromise", e8), e8.then(() => {
        this._updatingRequiredFieldsPromise === e8 && this._set("_updatingRequiredFieldsPromise", null);
      });
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view) return;
      const e8 = "3d" === this.view.type, { layer: t12, layer: { fieldsIndex: i11, objectIdField: o15 } } = this, s9 = "renderer" in t12 && t12.renderer, n11 = "orderBy" in t12 && t12.orderBy, l12 = "featureReduction" in t12 ? t12.featureReduction : null, a10 = /* @__PURE__ */ new Set(), u14 = await Promise.allSettled([s9 ? s9.collectRequiredFields(a10, i11) : null, J(a10, t12), e8 && "elevationInfo" in t12 ? v2(a10, t12) : null, null != this.filter ? M(a10, t12, this.filter) : null, e8 || null == this.featureEffect ? null : M(a10, t12, this.featureEffect.filter), !e8 && l12 ? L2(a10, t12, l12) : null, !e8 && n11 ? O3(a10, t12, n11) : null]);
      if ("timeInfo" in t12 && t12.timeInfo && this.timeExtent && b3(a10, t12.fieldsIndex, [t12.timeInfo.startField, t12.timeInfo.endField]), "floorInfo" in t12 && t12.floorInfo && b3(a10, t12.fieldsIndex, [t12.floorInfo.floorField]), "feature" === t12.type && e8 && null != t12.infoFor3D && (null == t12.globalIdField && n.getLogger(this).error("globalIdField missing on 3DObjectFeatureLayer"), b3(a10, t12.fieldsIndex, [t12.globalIdField])), "subtype-group" === t12.type) {
        w3(a10, i11, t12.subtypeField);
        const e9 = t12.sublayers.map((e10) => {
          var _a;
          return Promise.all([(_a = e10.renderer) == null ? void 0 : _a.collectRequiredFields(a10, i11), J(a10, e10)]);
        });
        await Promise.allSettled(e9);
      }
      if ("catalog-footprint" === t12.type && t12.parent) {
        const e9 = t12.parent;
        b3(a10, i11, [e9.itemNameField, e9.itemSourceField, e9.itemTypeField, e9.maxScaleField, e9.minScaleField]);
      }
      for (const d10 of u14) "rejected" === d10.status && n.getLogger(this).error(d10.reason);
      w3(a10, i11, o15), e8 && "displayField" in t12 && t12.displayField && w3(a10, i11, t12.displayField);
      const p7 = Array.from(a10).sort();
      this._set("requiredFields", p7);
    }
    _validateFetchPopupFeatures(e8, r8) {
      if (null != r8) for (const i11 of e8) {
        const e9 = i11.origin && "layer" in i11.origin ? i11.origin.layer : i11.layer;
        if ("popupEnabled" in e9 && !e9.popupEnabled) throw new s("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: e9 });
        if (i11.isAggregate) {
          const r9 = "featureReduction" in e9 ? e9.featureReduction : null;
          if (!(r9 && "popupTemplate" in r9 && r9.popupEnabled && r9.popupTemplate)) throw new s("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: e9 });
        } else if ("popupTemplate" in e9) {
          if (!p2(e9, r8)) throw new s("featurelayerview:fetchPopupFeatures", "Layer does not define a popup template", { layer: e9 });
        }
      }
    }
    _popupFeatureHasRequiredFields(e8, t12) {
      return je(t12, e8);
    }
    async _fetchPopupFeatures(e8, t12) {
      var _a;
      const r8 = new Array(e8.length), o15 = /* @__PURE__ */ new Map(), s9 = await this._createPopupQuery(e8.map((e9) => {
        var _a2;
        return ((_a2 = e9.origin) == null ? void 0 : _a2.layer) ?? e9.layer;
      }), t12);
      for (let n11 = 0; n11 < e8.length; n11++) {
        const l12 = e8[n11];
        if (l12.isAggregate) {
          r8[n11] = l12;
          continue;
        }
        const a10 = ((_a = l12.origin) == null ? void 0 : _a.layer) ?? l12.layer;
        if (!a10 || !("popupEnabled" in a10)) continue;
        const u14 = x(this.layer.fieldsIndex, s9.outFields), p7 = p2(a10, t12);
        if (null == p7) continue;
        const d10 = await this._loadArcadeModules(p7);
        s2(t12);
        d10 && d10.arcadeUtils.hasGeometryOperations(p7) || !this._popupFeatureHasRequiredFields(l12, u14) ? o15.set(l12.getObjectId(), { graphic: l12, index: n11 }) : r8[n11] = l12;
      }
      if ("stream" === this.layer.type || 0 === o15.size) return r8.filter(Boolean);
      s9.objectIds = Array.from(o15.keys());
      try {
        const e9 = await this.layer.queryFeatures(s9, t12);
        for (const t13 of e9.features) {
          const { graphic: { geometry: e10, origin: i11 }, index: s10 } = o15.get(t13.getObjectId());
          t13.geometry || (t13.geometry = e10), t13.origin = i11, r8[s10] = t13;
        }
      } catch {
      }
      return r8.filter(Boolean);
    }
    async _createPopupQuery(e8, t12) {
      const r8 = this.layer.createQuery(), o15 = /* @__PURE__ */ new Set();
      let s9 = false;
      const n11 = e8 ?? [this.layer];
      for (const l12 of n11) {
        if (!("popupEnabled" in l12)) continue;
        const e9 = p2(l12, t12);
        if (null == e9) continue;
        const r9 = await this._loadArcadeModules(e9);
        s2(t12);
        const n12 = r9 && r9.arcadeUtils.hasGeometryOperations(e9);
        s9 = !("point" !== this.layer.geometryType && !n12);
        const a10 = await n4(this.layer, e9);
        s2(t12);
        for (const t13 of a10) o15.add(t13);
      }
      if (r8.returnGeometry = s9, r8.returnZ = s9, r8.returnM = s9, r8.outFields = Array.from(o15), r8.outSpatialReference = this.view.spatialReference, "floorInfo" in this.layer && this.layer.floorInfo) {
        const e9 = o6(this);
        null != e9 && (r8.where = r8.where ? `(${r8.where}) AND (${e9})` : e9);
      }
      return r8;
    }
    canResume() {
      return !!super.canResume() && (null == this.timeExtent || !this.timeExtent.isEmpty);
    }
    getTest() {
    }
    get test() {
    }
  };
  return e([y()], q.prototype, "_updatingRequiredFieldsPromise", void 0), e([y({ readOnly: true })], q.prototype, "availableFields", null), e([y({ readOnly: true })], q.prototype, "dataUpdating", void 0), e([y({ type: w2 })], q.prototype, "featureEffect", null), e([y({ type: d5 })], q.prototype, "filter", void 0), e([y()], q.prototype, "layer", void 0), e([y({ type: Number })], q.prototype, "maximumNumberOfFeatures", null), e([y({ readOnly: true, type: Boolean })], q.prototype, "maximumNumberOfFeaturesExceeded", null), e([y({ readOnly: true })], q.prototype, "requiredFields", void 0), e([y()], q.prototype, "suspended", void 0), e([y()], q.prototype, "view", void 0), q = e([a2("esri.views.layers.FeatureLayerView")], q), q;
};

// ../node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function X(e8, t12) {
  const r8 = /* @__PURE__ */ new Set();
  return e8 && e8.forEach((e9) => r8.add(e9)), t12 && t12.forEach((e9) => r8.add(e9)), r8.has("*") ? ["*"] : Array.from(r8);
}
var Y = 4294967294;
var ee2 = class extends _(i6(f4(y3))) {
  constructor() {
    super(...arguments), this._commandsQueue = new t6({ process: (e8) => {
      switch (e8.type) {
        case "edit-by-feature":
        case "edit-by-id":
          return this._doEdit(e8);
        case "update":
          return this._doUpdate();
        case "highlight":
          return this._updateHighlights();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._highlightCounter = new e5(), this._lastAvailableFields = [], this._lastTargetState = null, this.eventLog = new l5(), this._sourceRefreshVersion = 1, this._displayRefreshVersion = 1, this._pipelineUpdating = false, this._fields = null, this.featureEffectView = new r3();
  }
  destroy() {
    var _a;
    (_a = this._workerProxy) == null ? void 0 : _a.destroy(), this._workerAttached.reject(u3()), this._commandsQueue.destroy();
  }
  initialize() {
    this._workerAttached = L(), d(this._workerAttached.promise), this.addResolvingPromise(this._initProxy()), this.featureEffectView.featureEffect = this.featureEffect, this.featureEffectView.endTransitions();
  }
  async _initProxy() {
    var _a;
    const e8 = this.layer;
    if ("isTable" in e8 && e8.isTable) throw new s("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: e8 });
    if ("mesh" === e8.geometryType) throw new s("featurelayerview:geometry-type-not-supported", `Geometry type of ${e8.geometryType} is not supported`, { layer: e8 });
    if (("feature" === e8.type || "subtype-group" === e8.type) && false === ((_a = O2(e8)) == null ? void 0 : _a.operations.supportsQuery)) throw new s("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e8 });
    this._workerProxy && this._workerProxy.destroy();
    const t12 = this._createClientOptions();
    this._workerProxy = await t7(t12);
  }
  async _attachProxy() {
    const e8 = { service: await this.layerAdapter.createServiceOptions(this.view), tileInfoJSON: this.view.featuresTilingScheme.tileInfo.toJSON() };
    let t12 = [];
    Array.isArray(e8.service.source) && (t12 = e8.service.source);
    try {
      await this._workerProxy.pipeline.onAttach(e8, { transferList: t12 }), this._workerAttached.resolve();
    } catch (r8) {
      this._workerAttached.reject(u3()), f(r8);
    }
  }
  async _detachProxy() {
    return this._workerProxy.pipeline.onDetach();
  }
  async getWorker() {
    return await this._workerAttached.promise, this._workerProxy;
  }
  get hasAllFeatures() {
    return this.layer.visible && this.eventLog.hasAllFeatures;
  }
  get hasAllFeaturesInView() {
    return this.layer.visible && this.eventLog.hasAllFeaturesInView;
  }
  get hasFullGeometries() {
    return this.layer.visible && this.eventLog.hasFullGeometries;
  }
  get labelingCollisionInfos() {
    const e8 = this.layerAdapter.getLabelingDeconflictionInfo(this.view), t12 = this.layer.geometryType, r8 = !this.suspended;
    return e8.map(({ vvEvaluators: e9, deconflictionEnabled: i11 }) => ({ container: this.featureContainer, vvEvaluators: e9, deconflictionEnabled: i11, geometryType: t12, visible: r8 }));
  }
  get layerAdapter() {
    switch (this.layer.type) {
      case "feature":
        return "memory" === this.layer.source.type ? new p6(this.layer) : new c7(this.layer);
      case "geojson":
      case "csv":
      case "wfs":
        return new p6(this.layer);
      case "subtype-group":
        return new m8(this.layer);
      case "ogc-feature":
        return new u12(this.layer);
      case "stream":
        return new l11(this.layer);
      case "oriented-imagery":
        return new m7(this.layer);
      case "knowledge-graph-sublayer":
        return new a9(this.layer);
      case "catalog-footprint":
        return new l10(this.layer);
      default:
        n3(this.layer);
    }
    return null;
  }
  get timeExtent() {
    var _a;
    return i7(this.layerAdapter.timeOptions, (_a = this.view) == null ? void 0 : _a.timeExtent, this._get("timeExtent"));
  }
  getDisplayStatistics(e8, t12) {
    var _a;
    return (_a = this.featureContainer) == null ? void 0 : _a.getDisplayStatistics(e8, t12);
  }
  async queryHeatmapStatistics(e8) {
    return (await this.getWorker()).pipeline.queryHeatmapStatistics(e8);
  }
  highlight(e8, t12 = "highlight") {
    let a10;
    e8 instanceof d6 ? a10 = [e8.getObjectId()] : "number" == typeof e8 || "string" == typeof e8 ? a10 = [e8] : V.isCollection(e8) && e8.length > 0 ? a10 = e8.map((e9) => e9 == null ? void 0 : e9.getObjectId()).toArray() : Array.isArray(e8) && e8.length > 0 && (a10 = "number" == typeof e8[0] || "string" == typeof e8[0] ? e8 : e8.map((e9) => e9 == null ? void 0 : e9.getObjectId()));
    const o15 = a10 == null ? void 0 : a10.filter(O);
    return (o15 == null ? void 0 : o15.length) ? (this._addHighlights(o15, t12), e2(() => this._removeHighlights(o15, t12))) : e2();
  }
  getHighlightIds() {
    return Array.from(this._highlightCounter.ids());
  }
  hasHighlight() {
    return !this._highlightCounter.empty;
  }
  async hitTest(e8, i11) {
    const s9 = await this.featureContainer.hitTest(i11);
    if (0 === s9.length) return null;
    const a10 = await this.getWorker(), { features: o15, aggregates: n11 } = await a10.pipeline.getDisplayFeatures(s9), u14 = this.featureContainer.getSortKeys(s9), l12 = ({ displayId: e9 }, { displayId: t12 }) => u14.has(e9) && u14.has(t12) ? u14.get(e9) - u14.get(t12) : e9 - t12;
    return o15.sort(l12).reverse(), n11.sort(l12).reverse(), [...n11.map((r8) => this._createGraphicHit(e8, s5.fromJSON(r8))), ...o15.map((t12) => this._createGraphicHit(e8, d6.fromJSON(t12)))];
  }
  async queryStatistics() {
    const e8 = await this.getWorker();
    return n10(e8.pipeline.queryStatistics(), { featureCount: 0, ringCount: 0, vertexCount: 0 });
  }
  async querySummaryStatistics(e8, t12, r8) {
    const i11 = await this.getWorker(), s9 = { ...t12, scale: this.view.scale }, a10 = i11.features.executeQueryForSummaryStatistics(this._cleanUpQuery(e8), s9, r8);
    return n10(a10, {});
  }
  async queryAggregateSummaryStatistics(e8, t12, r8) {
    const i11 = { ...t12, scale: this.view.scale }, s9 = (await this.getWorker()).aggregates.executeQueryForSummaryStatistics(this._cleanUpAggregateQuery(e8), i11, r8);
    return n10(s9, {});
  }
  async queryUniqueValues(e8, t12, r8) {
    const i11 = await this.getWorker(), s9 = { ...t12, scale: this.view.scale }, a10 = i11.features.executeQueryForUniqueValues(this._cleanUpQuery(e8), s9, r8);
    return n10(a10, { uniqueValueInfos: [] });
  }
  async queryAggregateUniqueValues(e8, t12, r8) {
    const i11 = await this.getWorker(), s9 = { ...t12, scale: this.view.scale }, a10 = i11.aggregates.executeQueryForUniqueValues(this._cleanUpAggregateQuery(e8), s9, r8);
    return n10(a10, { uniqueValueInfos: [] });
  }
  async queryClassBreaks(e8, t12, r8) {
    const i11 = await this.getWorker(), s9 = { ...t12, scale: this.view.scale }, a10 = i11.features.executeQueryForClassBreaks(this._cleanUpQuery(e8), s9, r8);
    return n10(a10, { classBreakInfos: [] });
  }
  async queryAggregateClassBreaks(e8, t12, r8) {
    const i11 = await this.getWorker(), s9 = { ...t12, scale: this.view.scale }, a10 = i11.aggregates.executeQueryForClassBreaks(this._cleanUpAggregateQuery(e8), s9, r8);
    return n10(a10, { classBreakInfos: [] });
  }
  async queryHistogram(e8, t12, r8) {
    const i11 = await this.getWorker(), s9 = { ...t12, scale: this.view.scale }, a10 = i11.features.executeQueryForHistogram(this._cleanUpQuery(e8), s9, r8);
    return n10(a10, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  async queryAggregateHistogram(e8, t12, r8) {
    const i11 = await this.getWorker(), s9 = { ...t12, scale: this.view.scale }, a10 = i11.aggregates.executeQueryForHistogram(this._cleanUpAggregateQuery(e8), s9, r8);
    return n10(a10, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  queryFeatures(e8, t12) {
    return this.queryFeaturesJSON(e8, t12).then((e9) => {
      const t13 = d4.fromJSON(e9);
      return t13.features.forEach((e10) => this._setLayersForFeature(e10)), t13;
    });
  }
  async queryVisibleFeatures(e8, t12) {
    const r8 = (await this.getWorker()).pipeline.queryVisibleFeatures(this._cleanUpQuery(e8), t12), i11 = await n10(r8, { features: [] }), s9 = d4.fromJSON(i11);
    return s9.features.forEach((e9) => this._setLayersForFeature(e9)), s9;
  }
  async queryAggregates(e8, t12) {
    const r8 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e8), t12), i11 = await n10(r8, { features: [] }), s9 = m3.fromJSON(i11);
    return s9.features.forEach((e9) => this._setLayersForFeature(e9)), s9;
  }
  async queryAggregateIds(e8, t12) {
    const r8 = (await this.getWorker()).aggregates.executeQueryForIds(this._cleanUpAggregateQuery(e8), t12);
    return n10(r8, []);
  }
  async queryAggregateCount(e8, t12) {
    const r8 = (await this.getWorker()).aggregates.executeQueryForCount(this._cleanUpAggregateQuery(e8), t12);
    return n10(r8, 0);
  }
  async queryAggregateJSON(e8, t12) {
    const r8 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e8), t12);
    return n10(r8, { features: [] });
  }
  async queryFeaturesJSON(e8, t12) {
    const r8 = (await this.getWorker()).features.executeQuery(this._cleanUpQuery(e8), t12);
    return n10(r8, { features: [] });
  }
  async queryObjectIds(e8, t12) {
    const r8 = (await this.getWorker()).features.executeQueryForIds(this._cleanUpQuery(e8), t12);
    return n10(r8, []);
  }
  async queryFeatureCount(e8, t12) {
    const r8 = (await this.getWorker()).features.executeQueryForCount(this._cleanUpQuery(e8), t12);
    return n10(r8, 0);
  }
  async queryExtent(e8, t12) {
    const r8 = (await this.getWorker()).features.executeQueryForExtent(this._cleanUpQuery(e8), t12), i11 = await n10(r8, { count: 0, extent: null });
    return { count: i11.count, extent: w.fromJSON(i11.extent) };
  }
  async getSampleFeatures(e8) {
    return (await this.getWorker()).pipeline.getSampleFeatures(e8);
  }
  setVisibility(e8, t12) {
    t12 ? this._visibilityOverrides.delete(e8) : this._visibilityOverrides.add(e8), this._update();
  }
  update(e8) {
    if (!this._subscriptionManager) return;
    this.view.animation && !this._lastTargetState && (this._lastTargetState = e8.state.clone()), !this.view.animation && this._lastTargetState && (this._lastTargetState = null);
    const t12 = this._subscriptionManager.update(e8.targetState, this._lastTargetState);
    this.featureContainer.setVisibleTiles(t12);
  }
  attach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.attach"), d(this._updatingHandles.addPromise(this._workerAttached.promise)), d(this._attachProxy()), this.featureContainer = new u6(this), this.container.addChild(this.featureContainer), this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this._subscriptionManager = new o14({ tileInfoView: this.view.featuresTilingScheme, updateSubscriptions: (e8) => {
      this.featureContainer.updateSubscriptions(e8), d(this._updatingHandles.addPromise(this.getWorker().then((t12) => t12.pipeline.updateSubscriptions(e8))));
    }, isDone: (e8) => this.featureContainer.isDone(e8) }), this.requestUpdate(), this.addAttachHandles([d2(() => JSON.stringify({ displayRefreshVersion: this._displayRefreshVersion, timeExtent: this.timeExtent, clips: this.clips, filter: this.filter, featureEffect: this.featureEffect, sourceRefreshVersion: this._sourceRefreshVersion, timeZone: this.view.timeZone, effect: this.featureEffect, ...this.layerAdapter.getUpdateHashProperties(this.view) }), () => this._update(), P), d2(() => this.updateSuspended, (e8) => {
      e8 || (this._subscriptionManager.resume(), this.view.labelManager.requestUpdate());
    })]), "stream" !== this.layer.type && "catalog-footprint" !== this.layer.type && this.addAttachHandles(this.layer.on("edits", (e8) => this._edit(e8)));
  }
  detach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.detach"), this._detachProxy(), this._fields = null, this.featureContainer.destroy(), this.featureContainer = null, this._commandsQueue.clear(), this.container.removeAllChildren(), this._subscriptionManager = u2(this._subscriptionManager), this._workerProxy.pipeline.onDetach(), this._workerAttached = L(), d(this._workerAttached.promise), this._lastAvailableFields = [], this._lastSchema = null;
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  isUpdating() {
    const e8 = "renderer" in this.layer && null != this.layer.renderer, t12 = this._commandsQueue.updateTracking.updating, r8 = null != this._updatingRequiredFieldsPromise, i11 = this.featureContainer.updatingHandles.updating, s9 = this.updateRequested || e8 && (t12 || r8) || i11 || this._pipelineUpdating || this.dataUpdating;
    if (has("esri-2d-log-updating")) {
      console.log(`Updating FLV2D (${this.layer.id}): ${s9}
  -> updateRequested ${this.updateRequested}
  -> hasRenderer ${e8}
  -> updatingRequiredFields ${r8}
  -> hasPendingCommand ${t12}
  -> dataUpdating ${this.dataUpdating}
  -> processing ${this._pipelineUpdating}
  -> updatingContainer ${i11}
`);
      for (const e9 of this.featureContainer.subscriptions()) console.log(`    -> Tile[${e9.id}] Done: ${e9.done}`);
    }
    return s9;
  }
  _createClientOptions() {
    const e8 = this;
    return { get container() {
      return e8.featureContainer;
    }, setUpdating: (e9) => {
      this._set("_pipelineUpdating", e9.pipeline), this._set("dataUpdating", e9.data);
    }, emitEvent: (e9) => {
      this.emit(e9.name, e9.event);
    }, get eventLog() {
      return e8.eventLog;
    }, fetch: (t12) => Promise.all(t12.map((t13) => e8.view.stage.painter.textureManager.rasterizeItem(t13))), fetchDictionary: (e9) => Promise.all(e9.map((e10) => this._fetchDictionaryRequest(e10))) };
  }
  async _fetchDictionaryRequest(e8) {
    try {
      if ("subtype-group" === this.layer.type) throw new Error("InternalError: SubtypeGroupLayer does not support dictionary renderer");
      const t12 = this.layer.renderer;
      if (!t12 || "dictionary" !== t12.type) throw new Error("InternalError: Expected layer to have a DictionaryRenderer");
      const r8 = this._lastSchema.processor.mesh.factory.symbology;
      if ("dictionary" !== r8.type) throw new Error("InternalError: Expected schema to be of type 'dictionary'");
      const i11 = { cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, store: this.featureContainer.instanceStore, scaleExpression: r8.scaleExpression };
      this._fields || (this._fields = this.layer.fields.map((e9) => e9.toJSON()));
      const s9 = r8.visualVariableUniforms, a10 = await t12.getSymbolAsync(e8.feature, { fields: this._fields });
      if (!a10 || !a10.data) return { type: "dictionary-response", meshes: [] };
      return { type: "dictionary-response", meshes: await n5(a10.data, { uniforms: s9, path: "renderer", schemaOptions: i11 }) };
    } catch (t12) {
      return { type: "dictionary-response", meshes: [] };
    }
  }
  _cleanUpQuery(e8) {
    const t12 = b2.from(e8) || this.createQuery();
    return t12.outSpatialReference || (t12.outSpatialReference = this.view.spatialReference), t12.toJSON();
  }
  _cleanUpAggregateQuery(e8) {
    const t12 = b2.from(e8) || this.createAggregateQuery();
    t12.outSpatialReference || (t12.outSpatialReference = this.view.spatialReference);
    const r8 = t12.objectIds ?? [];
    for (const i11 of t12.aggregateIds ?? []) r8.push(i11);
    return t12.objectIds = r8, t12.aggregateIds = [], t12.toJSON();
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  async _edit(e8) {
    if (this.updateSuspended) return void this._subscriptionManager.suspend();
    const t12 = this._getEffectiveEdit(e8);
    return t12 ? this._commandsQueue.push(t12).catch(f) : void 0;
  }
  async doRefresh(e8) {
    this.attached && (this.updateSuspended && e8 || (e8 ? this.incrementSourceRefreshVersion() : this.incrementDisplayRefreshVersion()));
  }
  incrementSourceRefreshVersion() {
    this._sourceRefreshVersion = (this._sourceRefreshVersion + 1) % Y + 1;
  }
  incrementDisplayRefreshVersion() {
    this._displayRefreshVersion = (this._displayRefreshVersion + 1) % Y + 1;
  }
  _getEffectiveEdit(e8) {
    var _a, _b;
    const t12 = "globalIdField" in this.layer && this.layer.globalIdField, r8 = e8.deletedFeatures.some((e9) => -1 === e9.objectId || !e9.objectId), i11 = t12 && this.availableFields.includes(t12);
    if (r8 && !i11) return n.getLogger(this).error(new s("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${t12} to be included the layer's outFields for updates to be reflected on the map`)), null;
    const s9 = this.layer, a10 = ((_a = e8.historicMoment) == null ? void 0 : _a.getTime()) ?? null, n11 = "layerId" in s9 && ((_b = e8.editedFeatures) == null ? void 0 : _b.find((e9) => e9.layerId === s9.layerId));
    if (n11 && this._canEditByFeature(n11)) {
      const e9 = false, r9 = false, i12 = s4(this.layer.geometryType), { adds: s10, deletes: o15, updates: u14 } = n11.editedFeatures, l12 = this.layer.objectIdField, h5 = s10.map((t13) => tt(t13, i12, e9, r9)), c9 = u14.map((t13) => tt(t13.current, i12, e9, r9));
      return { type: "edit-by-feature", added: h5, removed: o15.map((e10) => "attributes" in e10 ? { globalId: t12 ? e10.attributes[t12] : null, objectId: l12 ? e10.attributes[l12] : null } : e10), updated: c9, historicMoment: a10 };
    }
    return { type: "edit-by-id", added: e8.addedFeatures, updated: e8.updatedFeatures, removed: e8.deletedFeatures, historicMoment: a10 };
  }
  _canEditByFeature(e8) {
    const { adds: t12, updates: r8 } = e8.editedFeatures;
    return t12.every((e9) => {
      var _a;
      return this.view.spatialReference.equals((_a = e9.geometry) == null ? void 0 : _a.spatialReference);
    }) && r8.every((e9) => {
      var _a;
      return this.view.spatialReference.equals((_a = e9.current.geometry) == null ? void 0 : _a.spatialReference);
    });
  }
  async _doUpdate() {
    var _a, _b, _c, _d;
    "featureReduction" in this.layer && this.layer.featureReduction && this.layer.featureReduction !== this._lastFeatureReduction && (this.layer.featureReduction = (_a = this.layer.featureReduction) == null ? void 0 : _a.clone(), this._lastFeatureReduction = this.layer.featureReduction);
    try {
      if (await this._updateRequiredFields(), this.destroyed || !((_b = this.layerAdapter) == null ? void 0 : _b.hasRequiredSupport) || !this._subscriptionManager) return;
      const e8 = this.featureContainer.instanceStore;
      this.featureContainer.attributeView.lockTextureUploads(), e8.updateStart();
      const t12 = this.featureEffect, r8 = { store: e8, cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, scaleExpression: void 0 }, i11 = this._createViewSchemaConfig(), s9 = { source: this.layerAdapter.createSourceSchema(i11, this._sourceRefreshVersion), processor: await this.layerAdapter.createProcessorSchema(r8, i11, this._displayRefreshVersion) }, a10 = u((_c = this._lastSchema) == null ? void 0 : _c.source.mutable, s9.source.mutable) || u((_d = this._lastSchema) == null ? void 0 : _d.processor, s9.processor);
      if (!a10) return this.featureContainer.requestRender(), this.featureContainer.attributeView.unlockTextureUploads(), e8.updateEnd(), void (this.featureEffectView.featureEffect = t12);
      this._lastSchema = s9, this._fields = null;
      const o15 = Math.round(performance.now());
      has("esri-2d-update-debug") && console.debug(`Id[${this.layer.uid}] Version[${o15}] FeatureLayerView2D._doUpdate`, { changes: a10 });
      const n11 = await this.getWorker();
      await n11.pipeline.updateSchema(s9, o15), e8.updateEnd(), this.featureEffectView.featureEffect = t12, this.featureEffectView.endTransitions(), this.featureContainer.attributeView.unlockTextureUploads(), this.featureContainer.swapRenderState(), this.featureContainer.requestRender(), has("esri-2d-update-debug") && console.debug(`Version[${o15}] FeatureLayerView2D.updateEnd`), this.requestUpdate();
    } catch (e8) {
      has("esri-2d-update-debug") && console.error("Encountered an error during update", e8);
    }
  }
  async _doEdit(e8) {
    const t12 = await this.getWorker();
    try {
      this.featureContainer.editStart(), await t12.pipeline.onEdits(e8), this.featureContainer.editEnd();
    } catch (r8) {
      b(r8), 0;
    }
  }
  get hasFilter() {
    var _a, _b;
    const e8 = ((_b = (_a = this.layerAdapter).hasFilters) == null ? void 0 : _b.call(_a, this.view)) ?? false;
    return null != this.filter || null != this.timeExtent || this._visibilityOverrides.size > 0 || e8;
  }
  _getEffectiveAvailableFields(e8) {
    const t12 = X(this._lastAvailableFields, e8);
    return this._lastAvailableFields = t12, T(this.layer.fieldsIndex, t12);
  }
  _createViewSchemaConfig() {
    var _a, _b;
    const e8 = [te(this.view, this.layerAdapter, this.timeExtent, this._visibilityOverrides, this.filter), ((_b = (_a = this.featureEffect) == null ? void 0 : _a.filter) == null ? void 0 : _b.toJSON()) ?? null];
    return { availableFields: this._getEffectiveAvailableFields(this.availableFields), filters: e8, scale: this.view.scale, timeZone: this.view.timeZone };
  }
  _addHighlights(e8, t12) {
    this._highlightCounter.addReason(e8, t12), this._commandsQueue.push({ type: "highlight" });
  }
  _removeHighlights(e8, t12) {
    this._highlightCounter.deleteReason(e8, t12), this._commandsQueue.push({ type: "highlight" });
  }
  async _updateHighlights() {
    const e8 = [];
    for (const i11 of this._highlightCounter.ids()) {
      const t13 = this._highlightCounter.getHighlightReason(i11), r9 = t(t13);
      e8.push({ objectId: i11, highlightFlags: r9 });
    }
    const t12 = await this.getWorker();
    if (this.destroyed) return;
    const r8 = t12.pipeline.updateHighlight({ highlights: e8 }).catch((e9) => {
      b(e9) || n.getLogger(this).error(e9);
    });
    this._updatingHandles.addPromise(r8);
  }
  _setLayersForFeature(e8) {
    e8.layer = e8.sourceLayer = this.layer, this.layerAdapter.setGraphicOrigin && this.layerAdapter.setGraphicOrigin(e8);
  }
  _createGraphicHit(e8, t12) {
    return this._setLayersForFeature(t12), null != t12.geometry && (t12.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t12, layer: this.layer, mapPoint: e8 };
  }
};
function te(e8, t12, r8, i11, s9) {
  var _a;
  s9 && (s9 = s9.clone());
  const a10 = null != s9 ? s9.timeExtent : null, o15 = null != r8 && null != a10 ? r8.intersection(a10) : r8 || a10;
  o15 && (s9 ?? (s9 = new d5()), s9.timeExtent = o15), s9 = ((_a = t12.addFilters) == null ? void 0 : _a.call(t12, s9, e8)) ?? s9;
  let n11 = (s9 == null ? void 0 : s9.toJSON()) ?? null;
  return i11.size && (n11 ?? (n11 = new d5().toJSON()), n11.hiddenIds = Array.from(i11)), n11;
}
e([y()], ee2.prototype, "_commandsQueue", void 0), e([y()], ee2.prototype, "_sourceRefreshVersion", void 0), e([y()], ee2.prototype, "_displayRefreshVersion", void 0), e([y({ readOnly: true })], ee2.prototype, "_pipelineUpdating", void 0), e([y({ readOnly: true })], ee2.prototype, "hasAllFeatures", null), e([y({ readOnly: true })], ee2.prototype, "hasAllFeaturesInView", null), e([y({ readOnly: true })], ee2.prototype, "hasFullGeometries", null), e([y()], ee2.prototype, "featureEffectView", void 0), e([y()], ee2.prototype, "labelingCollisionInfos", null), e([y()], ee2.prototype, "layerAdapter", null), e([y({ readOnly: true })], ee2.prototype, "timeExtent", null), e([y()], ee2.prototype, "updating", void 0), ee2 = e([a2("esri.views.2d.layers.FeatureLayerView2D")], ee2);
var re2 = ee2;

export {
  n10 as n,
  re2 as re
};
//# sourceMappingURL=chunk-2URKZEBZ.js.map
