{
  "version": 3,
  "sources": ["../../../../node_modules/@esri/calcite-components/dist/components/src/utils/form.tsx"],
  "sourcesContent": ["import { FunctionalComponent, h } from \"@stencil/core\";\nimport { Writable } from \"type-fest\";\nimport { IconNameOrString, Status } from \"../components\";\nimport { closestElementCrossShadowBoundary, queryElementRoots } from \"./dom\";\n\n/**\n * Any form <Component> with a `calcite<Component>Input` event needs to be included in this array.\n */\nexport const componentsWithInputEvent = [\n  \"calcite-input\",\n  \"calcite-input-number\",\n  \"calcite-input-text\",\n  \"calcite-text-area\",\n];\n\n/**\n * Get the event name to listen for that, when emitted, will clear the\n * validation message that displays after form submission. Only validation\n * messages that are set by the browser will be cleared. If a user sets\n * validationMessage to a custom value, they are responsible for clearing it.\n *\n * Exported for testing purposes.\n *\n * @param componentTag the tag of the component, e.g. \"calcite-input\"\n * @returns the event name\n */\nexport function getClearValidationEventName(componentTag: string): string {\n  const componentTagCamelCase = componentTag\n    .split(\"-\")\n    .map((part: string, index: number) =>\n      index === 0 ? part : `${part[0].toUpperCase()}${part.slice(1)}`,\n    )\n    .join(\"\");\n\n  const clearValidationEvent = `${componentTagCamelCase}${\n    componentsWithInputEvent.includes(componentTag) ? \"Input\" : \"Change\"\n  }`;\n\n  return clearValidationEvent;\n}\n\nexport type MutableValidityState = Writable<ValidityState>;\n\n/**\n * Exported for testing purposes.\n */\nexport const hiddenFormInputSlotName = \"hidden-form-input\";\n\n/**\n * Defines interface for form owning components.\n *\n * Allows calling submit/reset methods on the form.\n */\nexport interface FormOwner {\n  /**\n   * The host element.\n   */\n  readonly el: HTMLElement;\n\n  /**\n   * The ID of the form to associate with the component.\n   *\n   * When not set, the component will be associated with its ancestor form element, if any.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  form: string;\n\n  /**\n   * The form this component is associated with.\n   *\n   * @internal\n   */\n  formEl: HTMLFormElement;\n}\n\n/**\n * Defines interface for form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface FormComponent<T = any> extends FormOwner {\n  /**\n   * When true, this component's value will not be submitted in the form.\n   */\n  disabled: boolean;\n\n  /**\n   * When true, form submit requests will enforce field requirement.\n   *\n   * @todo remove optional in follow-up PR\n   */\n  required?: boolean;\n\n  /**\n   * The name used to submit the value to the associated form.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  name: string;\n\n  /**\n   * This form component's value.\n   *\n   * Note that this prop should use the @Prop decorator.\n   */\n  value: T;\n\n  /**\n   * The initial value for this form component.\n   *\n   * When the form is reset, the value will be set to this property.\n   */\n  defaultValue: T;\n\n  /** The validation icon to display. */\n  validationIcon?: string | boolean;\n\n  /** The validation message to display. */\n  validationMessage?: string;\n\n  /** The validity state of the form component. */\n  validity?: MutableValidityState;\n\n  /**\n   * Hook for components to provide custom form reset behavior.\n   */\n  onFormReset?: () => void;\n\n  /**\n   * Hook for components to sync _extra_ props on the hidden input form element used for form-submitting.\n   *\n   * Note: The following props are set by default: disabled, hidden, name, required, value.\n   */\n  syncHiddenFormInput?: (input: HTMLInputElement) => void;\n}\n\n/**\n * Defines interface for checkable form-associated components.\n *\n * Along with the interface, use the matching form utils to help set up the component behavior.\n */\nexport interface CheckableFormComponent<T = any> extends FormComponent<T> {\n  /**\n   * For boolean-valued components, this property defines whether the associated value is submitted to the form or not.\n   */\n  checked: boolean;\n\n  /**\n   * The initial checked value for this form component.\n   *\n   * When the form is reset, the checked property will be set to this value.\n   */\n  defaultChecked: boolean;\n}\n\nfunction isCheckable(component: FormComponent): component is CheckableFormComponent {\n  return \"checked\" in component;\n}\n\nconst onFormResetMap = new WeakMap<HTMLElement, FormComponent[\"onFormReset\"]>();\nconst formComponentSet = new WeakSet<HTMLElement>();\n\n/**\n * This helps determine if our form component is part of a composite form-associated component.\n *\n * @param form\n * @param formComponentEl\n */\nfunction hasRegisteredFormComponentParent(\n  form: HTMLFormElement,\n  formComponentEl: HTMLElement,\n): boolean {\n  // if we have a parent component using the form ID attribute, we assume it is form-associated\n  const hasParentComponentWithFormIdSet = closestElementCrossShadowBoundary(\n    formComponentEl.parentElement,\n    \"[form]\",\n  );\n\n  if (hasParentComponentWithFormIdSet) {\n    return true;\n  }\n\n  // we use events as a way to test for nested form-associated components across shadow bounds\n  const formComponentRegisterEventName = \"calciteInternalFormComponentRegister\";\n\n  let hasRegisteredFormComponentParent = false;\n\n  form.addEventListener(\n    formComponentRegisterEventName,\n    (event) => {\n      hasRegisteredFormComponentParent = event\n        .composedPath()\n        .some((element) => formComponentSet.has(element as HTMLElement));\n      event.stopPropagation();\n    },\n    { once: true },\n  );\n\n  formComponentEl.dispatchEvent(\n    new CustomEvent(formComponentRegisterEventName, {\n      bubbles: true,\n      composed: true,\n    }),\n  );\n\n  return hasRegisteredFormComponentParent;\n}\n\n// exported for test purposes only\nexport interface ValidationProps {\n  status: Status;\n  message: string;\n  icon: IconNameOrString | boolean | \"\";\n}\n\nfunction displayValidationMessage(\n  component: HTMLCalciteInputElement | FormComponent,\n  { status, message, icon }: ValidationProps,\n): void {\n  if (\"status\" in component) {\n    component.status = status;\n  }\n\n  if (\"validationIcon\" in component && typeof component.validationIcon !== \"string\") {\n    component.validationIcon = icon;\n  }\n\n  if (\"validationMessage\" in component && !component.validationMessage) {\n    component.validationMessage = message;\n  }\n}\n\nfunction getValidationComponent(\n  el: HTMLCalciteInputElement,\n  // TODO: create an HTMLCalciteFormAssociatedElement base type\n): HTMLCalciteInputElement | HTMLCalciteRadioButtonGroupElement {\n  // radio-button is formAssociated, but the validation props are on the parent group\n  if (el.nodeName === \"CALCITE-RADIO-BUTTON\") {\n    return closestElementCrossShadowBoundary<HTMLCalciteRadioButtonGroupElement>(\n      el,\n      \"calcite-radio-button-group\",\n    );\n  }\n  return el;\n}\n\nconst invalidEvent = new CustomEvent(\"calciteInvalid\", { bubbles: true, composed: true });\n\nfunction invalidHandler(event: Event) {\n  // target is the hidden input, which is slotted in the actual form component\n  const hiddenInput = event?.target as HTMLInputElement;\n  const hiddenInputMessage = hiddenInput?.validationMessage;\n\n  // not necessarily a calcite-input, but we don't have an HTMLCalciteFormAssociatedElement type\n  const formComponent = getValidationComponent(\n    hiddenInput?.parentElement as HTMLCalciteInputElement,\n  ) as HTMLCalciteInputElement;\n\n  if (!formComponent) {\n    return;\n  }\n\n  const componentTag = formComponent?.nodeName?.toLowerCase();\n  const componentTagParts = componentTag?.split(\"-\");\n\n  if (componentTagParts.length < 2 || componentTagParts[0] !== \"calcite\") {\n    return;\n  }\n\n  // prevent the browser from showing the native validation popover\n  event?.preventDefault();\n\n  if (\"validity\" in formComponent) {\n    formComponent.validity = hiddenInput?.validity;\n  }\n\n  // dispatch a \"calciteInvalid\" so users can set custom validation messages\n  formComponent.dispatchEvent(invalidEvent);\n\n  displayValidationMessage(formComponent, {\n    message: hiddenInputMessage,\n    icon: true,\n    status: \"invalid\",\n  });\n\n  const clearValidationEvent = getClearValidationEventName(componentTag);\n  formComponent.addEventListener(\n    clearValidationEvent,\n    () => {\n      if (\"status\" in formComponent) {\n        formComponent.status = \"idle\";\n      }\n\n      if (\"validationIcon\" in formComponent && !formComponent.validationIcon) {\n        formComponent.validationIcon = false;\n      }\n\n      if (\n        \"validationMessage\" in formComponent &&\n        formComponent.validationMessage === hiddenInputMessage\n      ) {\n        formComponent.validationMessage = \"\";\n      }\n\n      if (\"validity\" in formComponent) {\n        formComponent.validity = hiddenInput?.validity;\n      }\n    },\n    { once: true },\n  );\n}\n\n/**\n * Helper to submit a form.\n *\n * @param component\n * @returns true if its associated form was submitted, false otherwise.\n */\nexport function submitForm(component: FormOwner): boolean {\n  const { formEl } = component;\n\n  if (!formEl) {\n    return false;\n  }\n\n  formEl.addEventListener(\"invalid\", invalidHandler, true);\n  formEl.requestSubmit();\n  formEl.removeEventListener(\"invalid\", invalidHandler, true);\n\n  requestAnimationFrame(() => {\n    const invalidEls = formEl.querySelectorAll(\"[status=invalid]\");\n\n    // focus the first invalid element that has a validation message\n    for (const el of invalidEls) {\n      if ((el as HTMLCalciteInputElement)?.validationMessage) {\n        (el as HTMLCalciteInputElement)?.setFocus();\n        break;\n      }\n    }\n  });\n\n  return true;\n}\n\n/**\n * Helper to reset a form.\n *\n * @param component\n */\nexport function resetForm(component: FormOwner): void {\n  component.formEl?.reset();\n}\n\n/**\n * Helper to set up form interactions on connectedCallback.\n *\n * @param component\n */\nexport function connectForm<T>(component: FormComponent<T>): void {\n  const { el, value } = component;\n  const associatedForm = findAssociatedForm(component);\n\n  if (!associatedForm || hasRegisteredFormComponentParent(associatedForm, el)) {\n    return;\n  }\n\n  component.formEl = associatedForm;\n  component.defaultValue = value;\n\n  if (isCheckable(component)) {\n    component.defaultChecked = component.checked;\n  }\n\n  const boundOnFormReset = (component.onFormReset || onFormReset).bind(component);\n  associatedForm.addEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.set(component.el, boundOnFormReset);\n  formComponentSet.add(el);\n}\n\n/**\n * Utility method to find a form-component's associated form element.\n *\n * @param component\n */\nexport function findAssociatedForm(component: FormOwner): HTMLFormElement | null {\n  const { el, form } = component;\n\n  return form\n    ? queryElementRoots<HTMLFormElement>(el, { id: form })\n    : closestElementCrossShadowBoundary<HTMLFormElement>(el, \"form\");\n}\n\nfunction onFormReset<T>(this: FormComponent<T>): void {\n  if (\"status\" in this) {\n    this.status = \"idle\";\n  }\n\n  if (\"validationIcon\" in this) {\n    this.validationIcon = false;\n  }\n\n  if (\"validationMessage\" in this) {\n    this.validationMessage = \"\";\n  }\n\n  if (isCheckable(this)) {\n    this.checked = this.defaultChecked;\n    return;\n  }\n\n  this.value = this.defaultValue;\n}\n\n/**\n * Helper to tear down form interactions on disconnectedCallback.\n *\n * @param component\n */\nexport function disconnectForm<T>(component: FormComponent<T>): void {\n  const { el, formEl } = component;\n\n  if (!formEl) {\n    return;\n  }\n\n  const boundOnFormReset = onFormResetMap.get(el);\n  formEl.removeEventListener(\"reset\", boundOnFormReset);\n  onFormResetMap.delete(el);\n  component.formEl = null;\n  formComponentSet.delete(el);\n}\n\n/**\n * Helper for setting the default value on initialization after connectedCallback.\n *\n * Note that this is only needed if the default value cannot be determined on connectedCallback.\n *\n * @param component\n * @param value\n */\nexport function afterConnectDefaultValueSet<T>(component: FormComponent<T>, value: any): void {\n  component.defaultValue = value;\n}\n\nexport const internalHiddenInputInputEvent = \"calciteInternalHiddenInputInput\";\n\nconst hiddenInputInputHandler = (event: Event) => {\n  event.target.dispatchEvent(new CustomEvent(internalHiddenInputInputEvent, { bubbles: true }));\n};\n\nconst removeHiddenInputChangeEventListener = (input: HTMLInputElement) =>\n  input.removeEventListener(\"input\", hiddenInputInputHandler);\n\n/**\n * Helper for maintaining a form-associated's hidden input in sync with the component.\n *\n * Based on Ionic's approach: https://github.com/ionic-team/ionic-framework/blob/e4bf052794af9aac07f887013b9250d2a045eba3/core/src/utils/helpers.ts#L198\n *\n * @param component\n */\nfunction syncHiddenFormInput(component: FormComponent): void {\n  const { el, formEl, name, value } = component;\n  const { ownerDocument } = el;\n\n  const inputs = el.querySelectorAll<HTMLInputElement>(`input[slot=\"${hiddenFormInputSlotName}\"]`);\n\n  if (!formEl || !name) {\n    inputs.forEach((input) => {\n      removeHiddenInputChangeEventListener(input);\n      input.remove();\n    });\n    return;\n  }\n\n  const values = Array.isArray(value) ? value : [value];\n  const extra: any[] = [];\n  const seen = new Set<any>();\n\n  inputs.forEach((input) => {\n    const valueMatch = values.find(\n      (val) =>\n        /* intentional non-strict equality check */\n        val == input.value,\n    );\n\n    if (valueMatch != null) {\n      seen.add(valueMatch);\n      defaultSyncHiddenFormInput(component, input, valueMatch);\n    } else {\n      extra.push(input);\n    }\n  });\n\n  let docFrag: DocumentFragment;\n\n  values.forEach((value) => {\n    if (seen.has(value)) {\n      return;\n    }\n\n    let input = extra.pop();\n\n    if (!input) {\n      input = ownerDocument!.createElement(\"input\");\n      input.slot = hiddenFormInputSlotName;\n    }\n\n    if (!docFrag) {\n      docFrag = ownerDocument!.createDocumentFragment();\n    }\n\n    docFrag.append(input);\n\n    // emits when hidden input is autofilled\n    input.addEventListener(\"input\", hiddenInputInputHandler);\n\n    defaultSyncHiddenFormInput(component, input, value);\n  });\n\n  if (docFrag) {\n    el.append(docFrag);\n  }\n  extra.forEach((input) => {\n    removeHiddenInputChangeEventListener(input);\n    input.remove();\n  });\n}\n\nfunction defaultSyncHiddenFormInput(\n  component: FormComponent,\n  input: HTMLInputElement,\n  value: string,\n): void {\n  const { defaultValue, disabled, form, name, required } = component;\n\n  // keep in sync to prevent losing reset value\n  input.defaultValue = defaultValue;\n  input.disabled = disabled;\n  input.name = name;\n  input.required = required;\n  input.tabIndex = -1;\n\n  // we set the attr as the prop is read-only\n  if (form) {\n    input.setAttribute(\"form\", form);\n  } else {\n    input.removeAttribute(\"form\");\n  }\n\n  if (isCheckable(component)) {\n    input.checked = component.checked;\n\n    // keep in sync to prevent losing reset value\n    input.defaultChecked = component.defaultChecked;\n    // heuristic to support default/on mode from https://html.spec.whatwg.org/multipage/input.html#dom-input-value-default-on\n    input.value = component.checked ? value || \"on\" : \"\";\n  } else {\n    input.value = value || \"\";\n  }\n\n  component.syncHiddenFormInput?.(input);\n\n  const validationComponent = getValidationComponent(component.el as HTMLCalciteInputElement);\n\n  if (validationComponent && \"validity\" in validationComponent) {\n    // mutate the component's validity object to prevent a rerender\n    // https://stenciljs.com/docs/properties#mutable-arrays-and-objects\n    for (const key in { ...input?.validity }) {\n      validationComponent.validity[key] = input.validity[key];\n    }\n  }\n}\n\ninterface HiddenFormInputSlotProps {\n  component: FormComponent;\n}\n\n/**\n * Helper to render the slot for form-associated component's hidden input.\n *\n * If the component has a default slot, this must be placed at the bottom of the component's root container to ensure it is the last child.\n *\n * render(): VNode {\n *   <Host>\n *     <div class={CSS.container}>\n *     // ...\n *     <HiddenFormInputSlot component={this} />\n *     </div>\n *   </Host>\n * }\n *\n * Note that the hidden-form-input Sass mixin must be added to the component's style to apply specific styles.\n *\n * @param root0\n * @param root0.component\n */\nexport const HiddenFormInputSlot: FunctionalComponent<HiddenFormInputSlotProps> = ({\n  component,\n}) => {\n  syncHiddenFormInput(component);\n\n  return <slot name={hiddenFormInputSlotName} />;\n};\n"],
  "mappings": "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",
  "names": ["hasRegisteredFormComponentParent", "value"]
}
