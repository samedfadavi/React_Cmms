import {
  a as a3,
  c,
  i
} from "./chunk-OVORXUCO.js";
import {
  v
} from "./chunk-BTSZKQPH.js";
import {
  _,
  f2,
  g,
  n,
  p,
  w
} from "./chunk-66KCMKB5.js";
import {
  f,
  r
} from "./chunk-F4OBDVPS.js";
import {
  y
} from "./chunk-TJUEGVVG.js";
import {
  a3 as a2
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  a
} from "./chunk-YNL57W4I.js";
import {
  h
} from "./chunk-2PA5UPTB.js";

// ../node_modules/@arcgis/core/geometry/geometryCursorCollectUtils.js
function t(t2) {
  const n3 = [];
  for (t2.reset(); t2.nextPath(); ) {
    const e2 = [];
    for (; t2.nextPoint(); ) e2.push([t2.x, t2.y]);
    n3.push(e2);
  }
  return t2.reset(), n3;
}
function n2(t2) {
  const n3 = [];
  for (; t2.nextPoint(); ) n3.push([t2.x, t2.y]);
  return t2.seekPathStart(), n3;
}

// ../node_modules/@arcgis/core/geometry/support/centroid.js
function r2(t2) {
  return t2 ? t2.hasZ ? [t2.xmax - t2.xmin / 2, t2.ymax - t2.ymin / 2, t2.zmax - t2.zmin / 2] : [t2.xmax - t2.xmin / 2, t2.ymax - t2.ymin / 2] : null;
}
function l(t2) {
  return t2 ? o(t2.rings, t2.hasZ ?? false) : null;
}
function o(t2, n3) {
  if (!(t2 == null ? void 0 : t2.length)) return null;
  const e2 = [], r3 = [], l2 = n3 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o2 = 0, i3 = t2.length; o2 < i3; o2++) {
    const e3 = u(t2[o2], n3, l2);
    e3 && r3.push(e3);
  }
  if (r3.sort((t3, e3) => {
    let r4 = t3[2] - e3[2];
    return 0 === r4 && n3 && (r4 = t3[4] - e3[4]), r4;
  }), r3.length && (e2[0] = r3[0][0], e2[1] = r3[0][1], n3 && (e2[2] = r3[0][3]), (e2[0] < l2[0] || e2[0] > l2[1] || e2[1] < l2[2] || e2[1] > l2[3] || n3 && (e2[2] < l2[4] || e2[2] > l2[5])) && (e2.length = 0)), !e2.length) {
    const r4 = t2[0] && t2[0].length ? s(t2[0], n3) : null;
    if (!r4) return null;
    e2[0] = r4[0], e2[1] = r4[1], n3 && r4.length > 2 && (e2[2] = r4[2]);
  }
  return e2;
}
function u(t2, n3, e2) {
  let r3 = 0, l2 = 0, o2 = 0, u2 = 0, i3 = 0;
  const s2 = t2.length ? t2[0][0] : 0, I2 = t2.length ? t2[0][1] : 0, h4 = t2.length && n3 ? t2[0][2] : 0;
  for (let f4 = 0; f4 < t2.length; f4++) {
    const c4 = t2[f4], N2 = t2[(f4 + 1) % t2.length], [x3, g2, a4] = c4, m = x3 - s2, P = g2 - I2, [T, y2, E] = N2, S = T - s2, p2 = y2 - I2, z = m * p2 - S * P;
    if (u2 += z, r3 += (m + S) * z, l2 += (P + p2) * z, n3 && c4.length > 2 && N2.length > 2) {
      const t3 = a4 - h4, n4 = E - h4, e3 = m * n4 - S * t3;
      o2 += (t3 + n4) * e3, i3 += e3;
    }
    x3 < e2[0] && (e2[0] = x3), x3 > e2[1] && (e2[1] = x3), g2 < e2[2] && (e2[2] = g2), g2 > e2[3] && (e2[3] = g2), n3 && (a4 < e2[4] && (e2[4] = a4), a4 > e2[5] && (e2[5] = a4));
  }
  if (u2 > 0 && (u2 *= -1), i3 > 0 && (i3 *= -1), !u2) return null;
  u2 *= 0.5, i3 *= 0.5;
  const c3 = [r3 / (6 * u2) + s2, l2 / (6 * u2) + I2, u2];
  return n3 && (e2[4] === e2[5] || 0 === i3 ? (c3[3] = (e2[4] + e2[5]) / 2, c3[4] = 0) : (c3[3] = o2 / (6 * i3) + h4, c3[4] = i3)), c3;
}
function i2(t2, n3) {
  let e2 = 0, r3 = 0, l2 = 0;
  t2.nextPoint();
  const o2 = t2.pathSize ? t2.x : 0, u2 = t2.pathSize ? t2.y : 0;
  for (let i3 = 0; i3 < t2.pathSize; i3++) {
    t2.seekInPath(i3);
    const s2 = [t2.x, t2.y];
    t2.seekInPath((i3 + 1) % t2.pathSize);
    const I2 = [t2.x, t2.y], [h4, c3] = s2, f4 = h4 - o2, N2 = c3 - u2, [x3, g2] = I2, a4 = x3 - o2, m = g2 - u2, P = f4 * m - a4 * N2;
    l2 += P, e2 += (f4 + a4) * P, r3 += (N2 + m) * P, h4 < n3[0] && (n3[0] = h4), h4 > n3[1] && (n3[1] = h4), c3 < n3[2] && (n3[2] = c3), c3 > n3[3] && (n3[3] = c3);
  }
  if (l2 > 0 && (l2 *= -1), !l2) return null;
  l2 *= 0.5;
  return [e2 / (6 * l2) + o2, r3 / (6 * l2) + u2, l2];
}
function s(t2, r3) {
  const l2 = r3 ? [0, 0, 0] : [0, 0], o2 = r3 ? [0, 0, 0] : [0, 0];
  let u2 = 0, i3 = 0, s2 = 0, I2 = 0;
  for (let h4 = 0, c3 = t2.length; h4 < c3 - 1; h4++) {
    const c4 = t2[h4], f4 = t2[h4 + 1];
    if (c4 && f4) {
      l2[0] = c4[0], l2[1] = c4[1], o2[0] = f4[0], o2[1] = f4[1], r3 && c4.length > 2 && f4.length > 2 && (l2[2] = c4[2], o2[2] = f4[2]);
      const t3 = i(l2, o2);
      if (t3) {
        u2 += t3;
        const n3 = c(c4, f4);
        i3 += t3 * n3[0], s2 += t3 * n3[1], r3 && n3.length > 2 && (I2 += t3 * n3[2]);
      }
    }
  }
  return u2 > 0 ? r3 ? [i3 / u2, s2 / u2, I2 / u2] : [i3 / u2, s2 / u2] : t2.length ? t2[0] : null;
}
function I(n3) {
  const { hasZ: e2, totalSize: r3 } = n3;
  if (0 === r3) return null;
  const l2 = [], o2 = [], i3 = e2 ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  for (n3.reset(); n3.nextPath(); ) {
    const e3 = u(n2(n3), n3.hasZ, i3);
    e3 && o2.push(e3);
  }
  if (o2.sort((t2, n4) => {
    let r4 = t2[2] - n4[2];
    return 0 === r4 && e2 && (r4 = t2[4] - n4[4]), r4;
  }), o2.length && (l2[0] = o2[0][0], l2[1] = o2[0][1], e2 && (l2[2] = o2[0][3]), (l2[0] < i3[0] || l2[0] > i3[1] || l2[1] < i3[2] || l2[1] > i3[3] || e2 && (l2[2] < i3[4] || l2[2] > i3[5])) && (l2.length = 0)), !l2.length) {
    n3.reset(), n3.nextPath();
    const t2 = n3.pathSize ? h2(n3) : null;
    if (!t2) return null;
    l2[0] = t2[0], l2[1] = t2[1], e2 && t2.length > 2 && (l2[2] = t2[2]);
  }
  return l2;
}
function h2(t2) {
  const { hasZ: r3 } = t2, l2 = r3 ? [0, 0, 0] : [0, 0], o2 = r3 ? [0, 0, 0] : [0, 0];
  let u2 = 0, i3 = 0, s2 = 0, I2 = 0;
  if (t2.nextPoint()) {
    let h4 = t2.x, c3 = t2.y, f4 = t2.z;
    for (; t2.nextPoint(); ) {
      const N2 = t2.x, x3 = t2.y, g2 = t2.z;
      l2[0] = h4, l2[1] = c3, o2[0] = N2, o2[1] = x3, r3 && (l2[2] = f4, o2[2] = g2);
      const a4 = i(l2, o2);
      if (a4) {
        u2 += a4;
        const t3 = c(l2, o2);
        i3 += a4 * t3[0], s2 += a4 * t3[1], r3 && t3.length > 2 && (I2 += a4 * t3[2]);
      }
      h4 = N2, c3 = x3, f4 = g2;
    }
  }
  return u2 > 0 ? r3 ? [i3 / u2, s2 / u2, I2 / u2] : [i3 / u2, s2 / u2] : t2.pathSize ? (t2.seekPathStart(), t2.nextPoint(), [t2.x, t2.y]) : null;
}
var c2 = 1e-6;
function f3(t2) {
  let n3 = 0;
  for (t2.reset(); t2.nextPath(); ) n3 += t2.getCurrentRingArea();
  if (n3 < c2) {
    const n4 = I(t2);
    return n4 ? [n4[0], n4[1]] : null;
  }
  const e2 = [0, 0];
  if (t2.reset(), !t2.nextPath() || !t2.nextPoint()) return null;
  const r3 = [t2.x, t2.y];
  for (t2.reset(); t2.nextPath(); ) x(e2, r3, t2);
  return e2[0] *= 1 / n3, e2[1] *= 1 / n3, e2[0] += r3[0], e2[1] += r3[1], e2;
}
var N = 1 / 3;
function x(t2, n3, e2) {
  if (!t2 || !e2 || e2.pathSize < 3) return null;
  e2.nextPoint();
  const r3 = e2.x, l2 = e2.y;
  e2.nextPoint();
  let o2, u2 = e2.x - r3, i3 = e2.y - l2, s2 = 0, I2 = 0;
  for (; e2.nextPoint(); ) s2 = e2.x - r3, I2 = e2.y - l2, o2 = 0.5 * N * (s2 * i3 - I2 * u2), t2[0] += o2 * (u2 + s2), t2[1] += o2 * (i3 + I2), u2 = s2, i3 = I2;
  const h4 = e2.getCurrentRingArea(), c3 = [r3, l2];
  return c3[0] -= n3[0], c3[1] -= n3[1], c3[0] *= h4, c3[1] *= h4, t2[0] += c3[0], t2[1] += c3[1], t2;
}

// ../node_modules/@arcgis/core/geometry/support/zmUtils.js
function h3(h4, a4, s2 = false) {
  let { hasM: t2, hasZ: e2 } = h4;
  Array.isArray(a4) ? 4 !== a4.length || t2 || e2 ? 3 === a4.length && s2 && !t2 ? (e2 = true, t2 = false) : 3 === a4.length && t2 && e2 && (t2 = false, e2 = false) : (t2 = true, e2 = true) : (e2 = !e2 && a4.hasZ && (!t2 || a4.hasM), t2 = !t2 && a4.hasM && (!e2 || a4.hasZ)), h4.hasZ = e2, h4.hasM = t2;
}

// ../node_modules/@arcgis/core/geometry/Polygon.js
var d;
function R(t2) {
  return !Array.isArray(t2[0]);
}
var x2 = d = class extends n {
  static fromExtent(t2) {
    const r3 = t2.clone().normalize(), e2 = t2.spatialReference;
    let s2 = false, n3 = false;
    for (const o2 of r3) o2.hasZ && (s2 = true), o2.hasM && (n3 = true);
    const i3 = { rings: r3.map((t3) => {
      const r4 = [[t3.xmin, t3.ymin], [t3.xmin, t3.ymax], [t3.xmax, t3.ymax], [t3.xmax, t3.ymin], [t3.xmin, t3.ymin]];
      if (s2 && t3.hasZ) {
        const e3 = t3.zmin + 0.5 * (t3.zmax - t3.zmin);
        for (let t4 = 0; t4 < r4.length; t4++) r4[t4].push(e3);
      }
      if (n3 && t3.hasM) {
        const e3 = t3.mmin + 0.5 * (t3.mmax - t3.mmin);
        for (let t4 = 0; t4 < r4.length; t4++) r4[t4].push(e3);
      }
      return r4;
    }), spatialReference: e2 };
    return s2 && (i3.hasZ = true), n3 && (i3.hasM = true), new d(i3);
  }
  constructor(...t2) {
    super(...t2), this.rings = [], this.type = "polygon";
  }
  normalizeCtorArgs(t2, r3) {
    var _a, _b;
    let e2, s2, n3 = null, i3 = null;
    return t2 && !Array.isArray(t2) ? (n3 = t2.rings ?? null, r3 || (t2.spatialReference ? r3 = t2.spatialReference : t2.rings || (r3 = t2)), e2 = t2.hasZ, s2 = t2.hasM) : n3 = t2, n3 = n3 || [], r3 = r3 || f.WGS84, n3.length && null != ((_a = n3[0]) == null ? void 0 : _a[0]) && "number" == typeof n3[0][0] && (n3 = [n3]), i3 = (_b = n3[0]) == null ? void 0 : _b[0], i3 && (void 0 === e2 && void 0 === s2 ? (e2 = i3.length > 2, s2 = i3.length > 3) : void 0 === e2 ? e2 = s2 ? i3.length > 3 : i3.length > 2 : void 0 === s2 && (s2 = e2 ? i3.length > 3 : i3.length > 2)), { rings: n3, spatialReference: r3, hasZ: e2, hasM: s2 };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t2 = l(this);
    if (!t2 || isNaN(t2[0]) || isNaN(t2[1]) || this.hasZ && isNaN(t2[2])) return null;
    const r3 = new _();
    return r3.x = t2[0], r3.y = t2[1], r3.spatialReference = this.spatialReference, this.hasZ && (r3.z = t2[2]), r3;
  }
  get extent() {
    const { spatialReference: t2 } = this, r3 = v(this);
    if (!r3) return null;
    const e2 = new w(r3);
    return e2.spatialReference = t2, e2;
  }
  get isSelfIntersecting() {
    return p(this.rings);
  }
  writeRings(t2, r3) {
    r3.rings = a(this.rings);
  }
  addRing(t2) {
    if (!t2) return;
    const r3 = this.rings, e2 = r3.length;
    if (R(t2)) {
      const s2 = [];
      for (let r4 = 0, e3 = t2.length; r4 < e3; r4++) s2[r4] = t2[r4].toArray();
      r3[e2] = s2;
    } else r3[e2] = t2.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t2 = new d();
    return t2.spatialReference = this.spatialReference, t2.rings = a(this.rings), t2.hasZ = this.hasZ, t2.hasM = this.hasM, t2;
  }
  equals(t2) {
    if (this === t2) return true;
    if (null == t2) return false;
    const e2 = this.spatialReference, s2 = t2.spatialReference;
    if (null != e2 != (null != s2)) return false;
    if (null != e2 && null != s2 && !e2.equals(s2)) return false;
    if (this.rings.length !== t2.rings.length) return false;
    const n3 = ([t3, r3, e3, s3], [n4, i3, o2, a4]) => t3 === n4 && r3 === i3 && (null == e3 && null == o2 || e3 === o2) && (null == s3 && null == a4 || s3 === a4);
    for (let i3 = 0; i3 < this.rings.length; i3++) {
      const e3 = this.rings[i3], s3 = t2.rings[i3];
      if (!h(e3, s3, n3)) return false;
    }
    return true;
  }
  contains(t2) {
    if (!t2) return false;
    const r3 = g(t2, this.spatialReference);
    return f2(this, null != r3 ? r3 : t2);
  }
  isClockwise(t2) {
    const r3 = R(t2) ? t2.map((t3) => this.hasZ ? this.hasM ? [t3.x, t3.y, t3.z, t3.m] : [t3.x, t3.y, t3.z] : [t3.x, t3.y]) : t2;
    return a3(r3);
  }
  getPoint(t2, r3) {
    if (!this._validateInputs(t2, r3)) return null;
    const e2 = this.rings[t2][r3], s2 = this.hasZ, n3 = this.hasM;
    return s2 && !n3 ? new _(e2[0], e2[1], e2[2], void 0, this.spatialReference) : n3 && !s2 ? new _(e2[0], e2[1], void 0, e2[2], this.spatialReference) : s2 && n3 ? new _(e2[0], e2[1], e2[2], e2[3], this.spatialReference) : new _(e2[0], e2[1], this.spatialReference);
  }
  insertPoint(t2, r3, e2) {
    return this._validateInputs(t2, r3, true) ? (h3(this, e2), Array.isArray(e2) || (e2 = e2.toArray()), this.rings[t2].splice(r3, 0, e2), this.notifyChange("rings"), this) : this;
  }
  removePoint(t2, r3) {
    if (!this._validateInputs(t2, r3)) return null;
    const e2 = new _(this.rings[t2].splice(r3, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), e2;
  }
  removeRing(t2) {
    if (!this._validateInputs(t2, null)) return null;
    const r3 = this.rings.splice(t2, 1)[0], e2 = this.spatialReference, s2 = r3.map((t3) => new _(t3, e2));
    return this.notifyChange("rings"), s2;
  }
  setPoint(t2, r3, e2) {
    return this._validateInputs(t2, r3) ? (h3(this, e2), Array.isArray(e2) || (e2 = e2.toArray()), this.rings[t2][r3] = e2, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t2, r3, e2 = false) {
    if (null == t2 || t2 < 0 || t2 >= this.rings.length) return false;
    if (null != r3) {
      const s2 = this.rings[t2];
      if (e2 && (r3 < 0 || r3 > s2.length)) return false;
      if (!e2 && (r3 < 0 || r3 >= s2.length)) return false;
    }
    return true;
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
};
e([y({ readOnly: true })], x2.prototype, "cache", null), e([y({ readOnly: true })], x2.prototype, "centroid", null), e([y({ readOnly: true })], x2.prototype, "extent", null), e([y({ readOnly: true })], x2.prototype, "isSelfIntersecting", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], x2.prototype, "rings", void 0), e([r("rings")], x2.prototype, "writeRings", null), x2 = d = e([a2("esri.geometry.Polygon")], x2), x2.prototype.toJSON.isDefaultToJSON = true;
var j = x2;

export {
  h3 as h,
  t,
  n2 as n,
  r2 as r,
  l,
  o,
  i2 as i,
  f3 as f,
  j
};
//# sourceMappingURL=chunk-VRHSV3YE.js.map
