import {
  C,
  N,
  O,
  P,
  R,
  k,
  q,
  v,
  x
} from "./chunk-XDQZOUPG.js";
import "./chunk-BGYJXU44.js";
import "./chunk-KENYLMTJ.js";
import "./chunk-6RHMAIR4.js";
import "./chunk-DYYENG3B.js";
import "./chunk-P6AJLPW7.js";
import "./chunk-F54TE5DA.js";
import "./chunk-ZPZCSP4J.js";
import "./chunk-5YPRHJQA.js";
import "./chunk-ZVC7ZICV.js";
import {
  c as c2
} from "./chunk-KW3Q5OC2.js";
import "./chunk-XNYIPE5U.js";
import "./chunk-YHUE64L3.js";
import {
  n
} from "./chunk-IFLXRJZP.js";
import {
  i as i2
} from "./chunk-NGPLQQSE.js";
import "./chunk-IEANCNX6.js";
import {
  p as p2
} from "./chunk-MUYRQ7CH.js";
import "./chunk-GPH64EJR.js";
import {
  c
} from "./chunk-U6JPKU6C.js";
import "./chunk-FY5GOH3U.js";
import {
  s as s3
} from "./chunk-AMKKU676.js";
import {
  C as C2,
  l as l4
} from "./chunk-QBW6ZJYD.js";
import {
  m as m2,
  u
} from "./chunk-S7J6OTBX.js";
import "./chunk-GMJ4G37M.js";
import {
  l as l3
} from "./chunk-CSCLMZ7J.js";
import "./chunk-BIJ6AA2G.js";
import {
  p as p3
} from "./chunk-FTURJXD3.js";
import "./chunk-LNOEFEG3.js";
import {
  e as e2
} from "./chunk-TJWXOPWU.js";
import "./chunk-4SCOCLA2.js";
import "./chunk-WF67GKPJ.js";
import "./chunk-PVGZCS2Z.js";
import "./chunk-4HOM27T6.js";
import "./chunk-FO4JQZA5.js";
import "./chunk-XEELLOJE.js";
import {
  d as d2
} from "./chunk-647CGSDX.js";
import "./chunk-JVNKXKH7.js";
import "./chunk-2FW7ECQ2.js";
import "./chunk-LGQJAMGK.js";
import "./chunk-PVAXLXWO.js";
import "./chunk-D6KE2FST.js";
import "./chunk-W3XB5XWO.js";
import "./chunk-6QBE4YDH.js";
import "./chunk-LXDJBJSP.js";
import "./chunk-OPCT64AO.js";
import {
  j
} from "./chunk-5LNCGIUN.js";
import {
  f as f3
} from "./chunk-CFIKP7ET.js";
import {
  l
} from "./chunk-VEAHCP5W.js";
import "./chunk-WO4V65CJ.js";
import "./chunk-QUNQAVSE.js";
import {
  t as t2
} from "./chunk-HNXXFTFZ.js";
import {
  b
} from "./chunk-KVPS4KFB.js";
import {
  d,
  l as l2,
  p,
  s as s2,
  t,
  y as y3
} from "./chunk-NSXZC33R.js";
import {
  S
} from "./chunk-E7HFITKU.js";
import "./chunk-ZFQCSBZ4.js";
import "./chunk-4PAHN45R.js";
import "./chunk-CRUGTXEH.js";
import "./chunk-CPGVDDHW.js";
import "./chunk-VEOZVJAT.js";
import "./chunk-3D32E2TW.js";
import "./chunk-ACWF4COQ.js";
import "./chunk-P35RWHDU.js";
import "./chunk-G5U2OA3R.js";
import "./chunk-OIFKYPGO.js";
import "./chunk-JNGB7HKP.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import "./chunk-7TO4QD67.js";
import "./chunk-DZNQTDMC.js";
import {
  b as b2
} from "./chunk-LLJZCFHW.js";
import "./chunk-VIUFBDIY.js";
import {
  y as y2
} from "./chunk-TXIL3QUC.js";
import "./chunk-2ASAB4KA.js";
import {
  f as f2
} from "./chunk-EA74CF7B.js";
import "./chunk-IGNUVZ34.js";
import "./chunk-LTSQHA4C.js";
import "./chunk-YUQFVZCH.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-T4EIRKFE.js";
import "./chunk-PHVKM5OH.js";
import "./chunk-KQ5GHUVQ.js";
import "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-JQIB7GFW.js";
import "./chunk-CJJCN7PA.js";
import {
  k as k2
} from "./chunk-IJUFAIOF.js";
import "./chunk-MNMU4ARP.js";
import "./chunk-7OW2VNCC.js";
import "./chunk-AFBYZF6Q.js";
import "./chunk-IJ42YN7D.js";
import "./chunk-4AGGGL2W.js";
import "./chunk-FJPG3YI6.js";
import "./chunk-BJHLU2MM.js";
import "./chunk-E5KBRIJQ.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-TW7VY7XV.js";
import {
  g,
  p as p4
} from "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import "./chunk-BL2UGYYZ.js";
import "./chunk-Q4D7WYWB.js";
import {
  i,
  o as o2
} from "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import "./chunk-FADA7L64.js";
import {
  m
} from "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import {
  w
} from "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import {
  f
} from "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import "./chunk-WC4SPMPL.js";
import {
  y
} from "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import {
  a3 as a
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  o,
  s2 as s
} from "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/layers/graphics/sources/OGCFeatureSource.js
var S2 = class extends m {
  constructor() {
    super(...arguments), this.featureDefinition = null, this.type = "ogc-feature";
  }
  load(t3) {
    return this.addResolvingPromise(this._loadOGCServices(this.layer, t3)), this.when();
  }
  getSource() {
    const { featureDefinition: { collection: t3, layerDefinition: e3, spatialReference: s4, supportedCrs: r }, layer: { apiKey: o3, customParameters: p5, effectiveMaxRecordCount: i3 } } = this;
    return { type: "ogc-source", collection: t3, layerDefinition: e3, maxRecordCount: i3, queryParameters: { apiKey: o3, customParameters: p5 }, spatialReference: s4, supportedCrs: r };
  }
  queryExtent(t3, e3 = {}) {
    return null;
  }
  queryFeatureCount(t3, e3 = {}) {
    return null;
  }
  queryFeatures(t3, e3 = {}) {
    return this.queryFeaturesJSON(t3, e3).then((t4) => d2.fromJSON(t4));
  }
  queryFeaturesJSON(t3, e3 = {}) {
    const s4 = this.getSource();
    return this.load(e3).then(() => R(s4, t3, e3));
  }
  queryObjectIds(t3, e3 = {}) {
    return null;
  }
  serviceSupportsSpatialReference(t3) {
    return !(!t3.isWGS84 && !t3.isWebMercator) || !!this.featureDefinition.supportedCrs[t3.wkid];
  }
  _conformsToType(t3, e3) {
    const s4 = new RegExp(`^${o(e3)}$`, "i");
    return t3.conformsTo.some((t4) => s4.test(t4)) ?? false;
  }
  _getCapabilities(t3, e3) {
    return { analytics: { supportsCacheHint: false }, attachment: null, data: { isVersioned: false, supportsAttachment: false, supportsM: false, supportsZ: t3 }, metadata: { supportsAdvancedFieldProperties: false }, operations: { supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsAdd: false, supportsDelete: false, supportsEditing: false, supportsChangeTracking: false, supportsQuery: false, supportsQueryAnalytics: false, supportsQueryAttachments: false, supportsQueryTopFeatures: false, supportsResizeAttachments: false, supportsSync: false, supportsUpdate: false, supportsExceedsLimitStatistics: false, supportsAsyncConvert3D: false }, query: { maxRecordCount: e3, maxRecordCountFactor: void 0, standardMaxRecordCount: void 0, supportsCacheHint: false, supportsCentroid: false, supportsDisjointSpatialRelationship: false, supportsDistance: false, supportsDistinct: false, supportsExtent: false, supportsFormatPBF: false, supportsGeometryProperties: false, supportsHavingClause: false, supportsHistoricMoment: false, supportsMaxRecordCountFactor: false, supportsOrderBy: false, supportsPagination: false, supportsPercentileStatistics: false, supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryByAnonymous: false, supportsQueryByOthers: false, supportsQueryGeometry: false, supportsResultType: false, supportsStandardizedQueriesOnly: false, supportsTopFeaturesQuery: false, supportsStatistics: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: false, supportsFullTextSearch: false, supportsCompactGeometry: false, supportsSqlExpression: false, tileMaxRecordCount: void 0 }, queryRelated: { supportsCount: false, supportsOrderBy: false, supportsPagination: false, supportsCacheHint: false }, queryTopFeatures: { supportsCacheHint: false }, editing: { supportsDeleteByAnonymous: false, supportsDeleteByOthers: false, supportsGeometryUpdate: false, supportsGlobalId: false, supportsReturnServiceEditsInSourceSpatialReference: false, supportsRollbackOnFailure: false, supportsUpdateByAnonymous: false, supportsUpdateByOthers: false, supportsUploadWithItemId: false, supportsUpdateWithoutM: false, supportsAsyncApplyEdits: false, zDefault: void 0 } };
  }
  _getMaxRecordCount(t3) {
    var _a, _b, _c, _d, _e;
    const e3 = (_a = t3 == null ? void 0 : t3.components) == null ? void 0 : _a.parameters;
    return ((_c = (_b = e3 == null ? void 0 : e3.limit) == null ? void 0 : _b.schema) == null ? void 0 : _c.maximum) ?? ((_e = (_d = e3 == null ? void 0 : e3.limitFeatures) == null ? void 0 : _d.schema) == null ? void 0 : _e.maximum);
  }
  _getStorageSpatialReference(t3) {
    const e3 = t3.storageCrs ?? x, s4 = C(e3);
    return null == s4 ? f.WGS84 : new f({ wkid: s4 });
  }
  _getSupportedSpatialReferences(t3, e3) {
    const s4 = "#/crs", r = t3.crs ?? [x], o3 = r.includes(s4) ? r.filter((t4) => t4 !== s4).concat(e3.crs ?? []) : r, p5 = /^http:\/\/www\.opengis.net\/def\/crs\/epsg\/.*\/3785$/i;
    return o3.filter((t4) => !p5.test(t4));
  }
  async _loadOGCServices(t3, s4) {
    const o3 = null != s4 ? s4.signal : null, { apiKey: p5, collectionId: i3, customParameters: a2, fields: f4, geometryType: g2, hasZ: S3, objectIdField: C3, timeInfo: R2, url: w2 } = t3, j2 = { fields: f4 == null ? void 0 : f4.map((t4) => t4.toJSON()), geometryType: i.toJSON(g2), hasZ: S3 ?? false, objectIdField: C3, timeInfo: R2 == null ? void 0 : R2.toJSON() }, x2 = { apiKey: p5, customParameters: a2, signal: o3 }, v2 = await P(w2, x2), [F, O2] = await Promise.all([O(v2, x2), N(v2, x2)]);
    if (!this._conformsToType(F, "http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/geojson")) throw new s("ogc-feature-layer:no-geojson-support", "Server does not support geojson");
    const D = O2.collections.find(({ id: t4 }) => t4 === i3);
    if (!D) throw new s("ogc-feature-layer:collection-not-found", "Server does not contain the named collection");
    const T = this._conformsToType(F, "http://www.opengis.net/spec/ogcapi-features-1/1.0/conf/oas30") ? await q(v2, x2) : null, A = await v(D, j2, x2), _ = this._getMaxRecordCount(T), P2 = this._getCapabilities(A.hasZ, _), b3 = this._getStorageSpatialReference(D).toJSON(), q2 = this._getSupportedSpatialReferences(D, O2), E = new RegExp(`^${o(k)}`, "i"), G = {};
    for (const e3 of q2) {
      const t4 = C(e3);
      null != t4 && (G[t4] || (G[t4] = e3.replace(E, "")));
    }
    this.featureDefinition = { capabilities: P2, collection: D, layerDefinition: A, spatialReference: b3, supportedCrs: G };
  }
};
e([y()], S2.prototype, "featureDefinition", void 0), e([y({ constructOnly: true })], S2.prototype, "layer", void 0), e([y()], S2.prototype, "type", void 0), S2 = e([a("esri.layers.graphics.sources.OGCFeatureSource")], S2);

// ../node_modules/@arcgis/core/layers/OGCFeatureLayer.js
var U = s3();
var B = class extends i2(e2(c2(c(l(p2(l3(t2(b(j(f3(S(f2)))))))))))) {
  constructor(e3) {
    super(e3), this.capabilities = null, this.collectionId = null, this.copyright = null, this.description = null, this.displayField = null, this.elevationInfo = null, this.fields = null, this.fieldsIndex = null, this.fullExtent = null, this.geometryType = null, this.hasZ = void 0, this.labelingInfo = null, this.labelsVisible = true, this.legendEnabled = true, this.maxRecordCount = null, this.objectIdField = null, this.operationalLayerType = "OGCFeatureLayer", this.popupEnabled = true, this.popupTemplate = null, this.screenSizePerspectiveEnabled = true, this.source = new S2({ layer: this }), this.spatialReference = null, this.title = null, this.type = "ogc-feature", this.typeIdField = null, this.types = null, this.url = null;
  }
  destroy() {
    var _a;
    (_a = this.source) == null ? void 0 : _a.destroy();
  }
  load(e3) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["OGCFeatureServer"] }, e3).then(() => this._fetchService(e3))), this.when();
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get effectiveMaxRecordCount() {
    var _a;
    return this.maxRecordCount ?? ((_a = this.capabilities) == null ? void 0 : _a.query.maxRecordCount) ?? 5e3;
  }
  get isTable() {
    return this.loaded && null == this.geometryType;
  }
  set renderer(e3) {
    p4(e3, this.fieldsIndex), this._set("renderer", e3);
  }
  on(e3, r) {
    return super.on(e3, r);
  }
  createPopupTemplate(e3) {
    return p3(this, e3);
  }
  createQuery() {
    return new b2();
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFieldDomain(e3, r) {
    var _a;
    let t3, i3 = false;
    const o3 = (_a = r == null ? void 0 : r.feature) == null ? void 0 : _a.attributes, s4 = this.typeIdField && (o3 == null ? void 0 : o3[this.typeIdField]);
    return null != s4 && this.types && (i3 = this.types.some((r2) => {
      var _a2;
      return r2.id == s4 && (t3 = (_a2 = r2.domains) == null ? void 0 : _a2[e3], "inherited" === (t3 == null ? void 0 : t3.type) && (t3 = this._getLayerDomain(e3)), true);
    })), i3 || t3 || (t3 = this._getLayerDomain(e3)), t3;
  }
  queryFeatures(e3, r) {
    return this.load().then(() => this.source.queryFeatures(b2.from(e3) || this.createQuery(), r)).then((e4) => {
      var _a;
      return (_a = e4 == null ? void 0 : e4.features) == null ? void 0 : _a.forEach((e5) => {
        e5.layer = e5.sourceLayer = this;
      }), e4;
    });
  }
  serviceSupportsSpatialReference(e3) {
    var _a;
    return ((_a = this.source) == null ? void 0 : _a.serviceSupportsSpatialReference(e3)) ?? false;
  }
  async _fetchService(e3) {
    await this.source.load(e3), this.read(this.source.featureDefinition, { origin: "service" }), p4(this.renderer, this.fieldsIndex), g(this.timeInfo, this.fieldsIndex);
  }
  _getLayerDomain(e3) {
    if (!this.fields) return null;
    for (const r of this.fields) if (r.name === e3 && r.domain) return r.domain;
    return null;
  }
};
e([y({ readOnly: true, json: { origins: { service: { read: true } } } })], B.prototype, "capabilities", void 0), e([y({ type: String, json: { write: true } })], B.prototype, "collectionId", void 0), e([y({ type: String })], B.prototype, "copyright", void 0), e([y({ readOnly: true })], B.prototype, "defaultPopupTemplate", null), e([y({ readOnly: true, type: String, json: { origins: { service: { name: "collection.description" } } } })], B.prototype, "description", void 0), e([y({ type: String })], B.prototype, "displayField", void 0), e([y({ type: Number })], B.prototype, "effectiveMaxRecordCount", null), e([y(d)], B.prototype, "elevationInfo", void 0), e([y({ type: [y2], json: { origins: { service: { name: "layerDefinition.fields" } } } })], B.prototype, "fields", void 0), e([y(U.fieldsIndex)], B.prototype, "fieldsIndex", void 0), e([y({ readOnly: true, type: w, json: { origins: { service: { name: "layerDefinition.extent" } } } })], B.prototype, "fullExtent", void 0), e([y({ type: o2.apiValues, json: { origins: { service: { name: "layerDefinition.geometryType", read: { reader: o2.read } } } } })], B.prototype, "geometryType", void 0), e([y({ type: Boolean, json: { origins: { service: { name: "layerDefinition.hasZ" } } } })], B.prototype, "hasZ", void 0), e([y({ type: Boolean, readOnly: true })], B.prototype, "isTable", null), e([y({ type: [C2], json: { origins: { "web-document": { name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: l4 }, write: true } } } })], B.prototype, "labelingInfo", void 0), e([y(l2)], B.prototype, "labelsVisible", void 0), e([y(y3)], B.prototype, "legendEnabled", void 0), e([y({ type: Number })], B.prototype, "maxRecordCount", void 0), e([y({ type: String, json: { origins: { service: { name: "layerDefinition.objectIdField" } } } })], B.prototype, "objectIdField", void 0), e([y({ type: ["OGCFeatureLayer"] })], B.prototype, "operationalLayerType", void 0), e([y(s2)], B.prototype, "popupEnabled", void 0), e([y({ type: k2, json: { name: "popupInfo", write: true } })], B.prototype, "popupTemplate", void 0), e([y({ types: m2, json: { origins: { service: { name: "layerDefinition.drawingInfo.renderer", write: false }, "web-scene": { types: u, name: "layerDefinition.drawingInfo.renderer", write: true } }, name: "layerDefinition.drawingInfo.renderer", write: true } })], B.prototype, "renderer", null), e([y(t)], B.prototype, "screenSizePerspectiveEnabled", void 0), e([y({ readOnly: true })], B.prototype, "source", void 0), e([y({ readOnly: true, type: f, json: { origins: { service: { read: true } } } })], B.prototype, "spatialReference", void 0), e([y({ type: String, json: { write: { enabled: true, ignoreOrigin: true, isRequired: true }, origins: { service: { name: "collection.title" } } } })], B.prototype, "title", void 0), e([y({ readOnly: true, json: { read: false } })], B.prototype, "type", void 0), e([y({ type: String, readOnly: true })], B.prototype, "typeIdField", void 0), e([y({ type: [n] })], B.prototype, "types", void 0), e([y(p)], B.prototype, "url", void 0), B = e([a("esri.layers.OGCFeatureLayer")], B);
var V = B;
export {
  V as default
};
//# sourceMappingURL=OGCFeatureLayer-X3GEJS3F.js.map
