import {
  o as o9,
  r as r4
} from "./chunk-LVLFR7HJ.js";
import {
  S as S3,
  _ as _2
} from "./chunk-LMPNMUNH.js";
import {
  u as u2
} from "./chunk-FMECO4I3.js";
import {
  d as d2,
  e as e14,
  v
} from "./chunk-AGBLTPV7.js";
import {
  c as c3,
  e as e13,
  s as s5
} from "./chunk-PTZQ7V6T.js";
import {
  O as O2,
  a as a7,
  i as i2,
  s as s4
} from "./chunk-J4UNWSS7.js";
import {
  a as a6,
  c as c2,
  e as e9,
  e2 as e10,
  e3 as e11,
  e4 as e12,
  n as n6,
  o as o5,
  o2 as o6,
  o3 as o8,
  t as t3
} from "./chunk-GRO6TRQ6.js";
import {
  s as s3
} from "./chunk-BMX34DUY.js";
import {
  a as a5,
  o as o7
} from "./chunk-2CZAGFZF.js";
import {
  n as n7,
  o as o4
} from "./chunk-V4RHVJ2H.js";
import {
  a as a3,
  c2 as c,
  e2 as e8
} from "./chunk-4ZTHXCOS.js";
import {
  a as a4
} from "./chunk-CL2YKTVD.js";
import {
  D,
  E,
  G,
  _,
  t as t2
} from "./chunk-POOHJZAR.js";
import {
  e as e5
} from "./chunk-RRSX64BO.js";
import {
  e as e7,
  o as o3
} from "./chunk-WX4IZMIC.js";
import {
  e as e6
} from "./chunk-T5CIHLIU.js";
import {
  n as n5
} from "./chunk-TNRF7MOE.js";
import {
  j
} from "./chunk-PNPG5IXD.js";
import {
  o as o2
} from "./chunk-CYGO6TZX.js";
import {
  n as n4,
  r as r3
} from "./chunk-NREDFKHH.js";
import {
  s as s2
} from "./chunk-DCOKV3EO.js";
import {
  n as n3
} from "./chunk-LTSQHA4C.js";
import {
  i
} from "./chunk-T4EIRKFE.js";
import {
  P,
  d
} from "./chunk-7PMYO342.js";
import {
  e as e4,
  f,
  h
} from "./chunk-6N5YXCNN.js";
import {
  O,
  e2 as e3,
  l as l2,
  n as n2,
  o,
  r as r2,
  u
} from "./chunk-MJ2NSPP7.js";
import {
  S as S2,
  e3 as e2,
  y
} from "./chunk-TJUEGVVG.js";
import {
  n
} from "./chunk-FXNOKZ3B.js";
import {
  a3 as a2
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  S
} from "./chunk-VMWKLHJD.js";
import {
  r,
  t
} from "./chunk-5AEITAWU.js";
import {
  l
} from "./chunk-G36SOMYZ.js";
import {
  s2 as s
} from "./chunk-YNL57W4I.js";
import {
  a
} from "./chunk-2PA5UPTB.js";

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js
var d3;
function o10(o24, v6) {
  switch (v6.textureCoordinateType) {
    case d3.Default:
      return o24.attributes.add(e5.UV0, "vec2"), o24.varyings.add("vuv0", "vec2"), void o24.vertex.code.add(o4`void forwardTextureCoordinates() {
vuv0 = uv0;
}`);
    case d3.Compressed:
      return o24.attributes.add(e5.UV0, "vec2"), o24.varyings.add("vuv0", "vec2"), void o24.vertex.code.add(o4`vec2 getUV0() {
return uv0 / 16384.0;
}
void forwardTextureCoordinates() {
vuv0 = getUV0();
}`);
    case d3.Atlas:
      return o24.attributes.add(e5.UV0, "vec2"), o24.varyings.add("vuv0", "vec2"), o24.attributes.add(e5.UVREGION, "vec4"), o24.varyings.add("vuvRegion", "vec4"), void o24.vertex.code.add(o4`void forwardTextureCoordinates() {
vuv0 = uv0;
vuvRegion = uvRegion;
}`);
    default:
      n3(v6.textureCoordinateType);
    case d3.None:
      return void o24.vertex.code.add(o4`void forwardTextureCoordinates() {}`);
    case d3.COUNT:
      return;
  }
}
!function(e30) {
  e30[e30.None = 0] = "None", e30[e30.Default = 1] = "Default", e30[e30.Atlas = 2] = "Atlas", e30[e30.Compressed = 3] = "Compressed", e30[e30.COUNT = 4] = "COUNT";
}(d3 || (d3 = {}));

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl.js
function e15(e30) {
  e30.fragment.code.add(o4`vec4 textureAtlasLookup(sampler2D tex, vec2 textureCoordinates, vec4 atlasRegion) {
vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;
vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;
float maxdUV = 0.125;
vec2 dUVdx = clamp(dFdx(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
vec2 dUVdy = clamp(dFdy(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
return textureGrad(tex, uvAtlas, dUVdx, dUVdy);
}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl.js
function s6(s12, a16) {
  switch (s12.include(o10, a16), a16.textureCoordinateType) {
    case d3.Default:
    case d3.Compressed:
      return void s12.fragment.code.add(o4`vec4 textureLookup(sampler2D tex, vec2 uv) {
return texture(tex, uv);
}`);
    case d3.Atlas:
      return s12.include(e15), void s12.fragment.code.add(o4`vec4 textureLookup(sampler2D tex, vec2 uv) {
return textureAtlasLookup(tex, uv, vuvRegion);
}`);
    default:
      n3(a16.textureCoordinateType);
    case d3.None:
    case d3.COUNT:
      return;
  }
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterial.js
var t4 = class {
  constructor(e30) {
    this._material = e30.material, this._techniques = e30.techniques, this._output = e30.output;
  }
  dispose() {
    this._techniques.release(this._technique);
  }
  get technique() {
    return this._technique;
  }
  get _stippleTextures() {
    return this._techniques.constructionContext.stippleTextures;
  }
  get _markerTextures() {
    return this._techniques.constructionContext.markerTextures;
  }
  ensureTechnique(e30, t15) {
    return this._technique = this._techniques.releaseAndAcquire(e30, this._material.getConfiguration(this._output, t15), this._technique), this._technique;
  }
  ensureResources(t15) {
    return a7.LOADED;
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLTextureMaterial.js
var u3 = class extends t4 {
  constructor(t15) {
    super(t15), this._numLoading = 0, this._disposed = false, this._textures = t15.textures, this._textureId = t15.textureId, this._acquire(t15.textureId, (t16) => this._texture = t16), this._acquire(t15.normalTextureId, (t16) => this._textureNormal = t16), this._acquire(t15.emissiveTextureId, (t16) => this._textureEmissive = t16), this._acquire(t15.occlusionTextureId, (t16) => this._textureOcclusion = t16), this._acquire(t15.metallicRoughnessTextureId, (t16) => this._textureMetallicRoughness = t16);
  }
  dispose() {
    this._texture = t(this._texture), this._textureNormal = t(this._textureNormal), this._textureEmissive = t(this._textureEmissive), this._textureOcclusion = t(this._textureOcclusion), this._textureMetallicRoughness = t(this._textureMetallicRoughness), this._disposed = true;
  }
  ensureResources(t15) {
    return 0 === this._numLoading ? a7.LOADED : a7.LOADING;
  }
  get textureBindParameters() {
    return new l3(null != this._texture ? this._texture.glTexture : null, null != this._textureNormal ? this._textureNormal.glTexture : null, null != this._textureEmissive ? this._textureEmissive.glTexture : null, null != this._textureOcclusion ? this._textureOcclusion.glTexture : null, null != this._textureMetallicRoughness ? this._textureMetallicRoughness.glTexture : null);
  }
  updateTexture(e30) {
    null != this._texture && e30 === this._texture.id || (this._texture = t(this._texture), this._textureId = e30, this._acquire(this._textureId, (t15) => this._texture = t15));
  }
  _acquire(s12, i10) {
    if (null == s12) return void i10(null);
    const r15 = this._textures.acquire(s12);
    if (S(r15)) return ++this._numLoading, void r15.then((e30) => {
      if (this._disposed) return t(e30), void i10(null);
      i10(e30);
    }).finally(() => --this._numLoading);
    i10(r15);
  }
};
var l3 = class extends n7 {
  constructor(t15 = null, e30 = null, s12 = null, i10 = null, r15 = null, u5, l15) {
    super(), this.texture = t15, this.textureNormal = e30, this.textureEmissive = s12, this.textureOcclusion = i10, this.textureMetallicRoughness = r15, this.scale = u5, this.normalTextureTransformMatrix = l15;
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js
var c4;
!function(e30) {
  e30[e30.Disabled = 0] = "Disabled", e30[e30.Normal = 1] = "Normal", e30[e30.Schematic = 2] = "Schematic", e30[e30.Water = 3] = "Water", e30[e30.WaterOnIntegratedMesh = 4] = "WaterOnIntegratedMesh", e30[e30.Simplified = 5] = "Simplified", e30[e30.TerrainWithWater = 6] = "TerrainWithWater", e30[e30.COUNT = 7] = "COUNT";
}(c4 || (c4 = {}));
function l4(n16, u5) {
  const l15 = n16.fragment, m7 = u5.hasMetallicRoughnessTexture || u5.hasEmissionTexture || u5.hasOcclusionTexture;
  if (u5.pbrMode === c4.Normal && m7 && n16.include(s6, u5), u5.pbrMode !== c4.Schematic) if (u5.pbrMode !== c4.Disabled) {
    if (u5.pbrMode === c4.Normal) {
      l15.code.add(o4`vec3 mrr;
vec3 emission;
float occlusion;`);
      const e30 = u5.pbrTextureBindType;
      u5.hasMetallicRoughnessTexture && (l15.uniforms.add(e30 === a4.Pass ? new s5("texMetallicRoughness", (e31) => e31.textureMetallicRoughness) : new s3("texMetallicRoughness", (e31) => e31.textureMetallicRoughness)), l15.code.add(o4`void applyMetallnessAndRoughness(vec2 uv) {
vec3 metallicRoughness = textureLookup(texMetallicRoughness, uv).rgb;
mrr[0] *= metallicRoughness.b;
mrr[1] *= metallicRoughness.g;
}`)), u5.hasEmissionTexture && (l15.uniforms.add(e30 === a4.Pass ? new s5("texEmission", (e31) => e31.textureEmissive) : new s3("texEmission", (e31) => e31.textureEmissive)), l15.code.add(o4`void applyEmission(vec2 uv) {
emission *= textureLookup(texEmission, uv).rgb;
}`)), u5.hasOcclusionTexture ? (l15.uniforms.add(e30 === a4.Pass ? new s5("texOcclusion", (e31) => e31.textureOcclusion) : new s3("texOcclusion", (e31) => e31.textureOcclusion)), l15.code.add(o4`void applyOcclusion(vec2 uv) {
occlusion *= textureLookup(texOcclusion, uv).r;
}
float getBakedOcclusion() {
return occlusion;
}`)) : l15.code.add(o4`float getBakedOcclusion() { return 1.0; }`), e30 === a4.Pass ? l15.uniforms.add(new e10("emissionFactor", (e31) => e31.emissiveFactor), new e10("mrrFactors", (e31) => e31.mrrFactors)) : l15.uniforms.add(new o6("emissionFactor", (e31) => e31.emissiveFactor), new o6("mrrFactors", (e31) => e31.mrrFactors)), l15.code.add(o4`
    void applyPBRFactors() {
      mrr = mrrFactors;
      emission = emissionFactor;
      occlusion = 1.0;

      ${u5.hasMetallicRoughnessTexture ? o4`applyMetallnessAndRoughness(${u5.hasMetallicRoughnessTextureTransform ? o4`metallicRoughnessUV` : "vuv0"});` : ""}

      ${u5.hasEmissionTexture ? o4`applyEmission(${u5.hasEmissiveTextureTransform ? o4`emissiveUV` : "vuv0"});` : ""}

      ${u5.hasOcclusionTexture ? o4`applyOcclusion(${u5.hasOcclusionTextureTransform ? o4`occlusionUV` : "vuv0"});` : ""}
    }
  `);
    }
  } else l15.code.add(o4`float getBakedOcclusion() { return 1.0; }`);
  else l15.code.add(o4`vec3 mrr = vec3(0.0, 0.6, 0.2);
vec3 emission = vec3(0.0);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/TransparencyPassType.js
var o11;
!function(o24) {
  o24[o24.ColorAlpha = 0] = "ColorAlpha", o24[o24.FrontFace = 1] = "FrontFace", o24[o24.NONE = 2] = "NONE", o24[o24.COUNT = 3] = "COUNT";
}(o11 || (o11 = {}));

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js
function o12(o24) {
  o24.attributes.add(e5.POSITION, "vec3"), o24.vertex.code.add(o4`vec3 positionModel() { return position; }`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js
function v2(r15, o24) {
  r15.include(o12);
  const e30 = r15.vertex;
  e30.include(c2, o24), r15.varyings.add("vPositionWorldCameraRelative", "vec3"), r15.varyings.add("vPosition_view", "vec3"), e30.uniforms.add(new e10("transformWorldFromViewTH", (r16) => r16.transformWorldFromViewTH), new e10("transformWorldFromViewTL", (r16) => r16.transformWorldFromViewTL), new e11("transformViewFromCameraRelativeRS", (r16) => r16.transformViewFromCameraRelativeRS), new e12("transformProjFromView", (r16) => r16.transformProjFromView), new o8("transformWorldFromModelRS", (r16) => r16.transformWorldFromModelRS), new o6("transformWorldFromModelTH", (r16) => r16.transformWorldFromModelTH), new o6("transformWorldFromModelTL", (r16) => r16.transformWorldFromModelTL)), e30.code.add(o4`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = transformWorldFromModelRS * positionModel();
vec3 transform_CameraRelativeFromModel = dpAdd(
transformWorldFromModelTL,
transformWorldFromModelTH,
-transformWorldFromViewTL,
-transformWorldFromViewTH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}`), e30.code.add(o4`
    void forwardPosition(float fOffset) {
      vPositionWorldCameraRelative = positionWorldCameraRelative();
      if (fOffset != 0.0) {
        vPositionWorldCameraRelative += fOffset * ${o24.spherical ? o4`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)` : o4`vec3(0.0, 0.0, 1.0)`};
      }

      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;
      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);
    }
  `), r15.fragment.uniforms.add(new e10("transformWorldFromViewTL", (r16) => r16.transformWorldFromViewTL)), e30.code.add(o4`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`), r15.fragment.code.add(o4`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`);
}
var F = class extends n7 {
  constructor() {
    super(...arguments), this.transformWorldFromViewTH = n2(), this.transformWorldFromViewTL = n2(), this.transformViewFromCameraRelativeRS = e6(), this.transformProjFromView = e7();
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js
function n8(o24, a16) {
  switch (a16.normalType) {
    case a6.Attribute:
    case a6.Compressed:
      o24.include(t3, a16), o24.varyings.add("vNormalWorld", "vec3"), o24.varyings.add("vNormalView", "vec3"), o24.vertex.uniforms.add(new o8("transformNormalGlobalFromModel", (r15) => r15.transformNormalGlobalFromModel), new e11("transformNormalViewFromGlobal", (r15) => r15.transformNormalViewFromGlobal)), o24.vertex.code.add(o4`void forwardNormal() {
vNormalWorld = transformNormalGlobalFromModel * normalModel();
vNormalView = transformNormalViewFromGlobal * vNormalWorld;
}`);
      break;
    case a6.Ground:
      o24.include(v2, a16), o24.varyings.add("vNormalWorld", "vec3"), o24.vertex.code.add(o4`
        void forwardNormal() {
          vNormalWorld = ${a16.spherical ? o4`normalize(vPositionWorldCameraRelative);` : o4`vec3(0.0, 0.0, 1.0);`}
        }
        `);
      break;
    case a6.ScreenDerivative:
      o24.vertex.code.add(o4`void forwardNormal() {}`);
      break;
    default:
      n3(a16.normalType);
    case a6.COUNT:
  }
}
var f2 = class extends F {
  constructor() {
    super(...arguments), this.transformNormalViewFromGlobal = e6();
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js
var o13 = 0.1;
var t5 = 1e-3;

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js
function t6(e30) {
  e30.varyings.add("linearDepth", "float");
}
function i3(e30) {
  e30.vertex.uniforms.add(new e13("nearFar", (e31, a16) => a16.camera.nearFar));
}
function d4(e30) {
  e30.vertex.code.add(o4`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`);
}
function n9(r15, n16) {
  const { vertex: s12 } = r15;
  switch (n16.output) {
    case o5.Color:
      if (n16.receiveShadows) return t6(r15), void s12.code.add(o4`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);
      break;
    case o5.Shadow:
    case o5.ShadowHighlight:
    case o5.ShadowExcludeHighlight:
    case o5.ViewshedShadow:
      return r15.include(v2, n16), t6(r15), i3(r15), d4(r15), void s12.code.add(o4`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`);
  }
  s12.code.add(o4`void forwardLinearDepth() {}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function e16(e30) {
  e30.vertex.code.add(o4`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js
function P2(e30, s12) {
  m(e30, s12, new o6("slicePlaneOrigin", (e31, i10) => H(s12, e31, i10)), new o6("slicePlaneBasis1", (e31, i10) => {
    var _a;
    return I(s12, e31, i10, (_a = i10.slicePlane) == null ? void 0 : _a.basis1);
  }), new o6("slicePlaneBasis2", (e31, i10) => {
    var _a;
    return I(s12, e31, i10, (_a = i10.slicePlane) == null ? void 0 : _a.basis2);
  }));
}
function m(e30, s12, ...i10) {
  if (!s12.hasSlicePlane) {
    const i11 = o4`#define rejectBySlice(_pos_) false
#define discardBySlice(_pos_) {}
#define highlightSlice(_color_, _pos_) (_color_)`;
    return s12.hasSliceInVertexProgram && e30.vertex.code.add(i11), void e30.fragment.code.add(i11);
  }
  s12.hasSliceInVertexProgram && e30.vertex.uniforms.add(...i10), e30.fragment.uniforms.add(...i10);
  const a16 = o4`struct SliceFactors {
float front;
float side0;
float side1;
float side2;
float side3;
};
SliceFactors calculateSliceFactors(vec3 pos) {
vec3 rel = pos - slicePlaneOrigin;
vec3 slicePlaneNormal = -cross(slicePlaneBasis1, slicePlaneBasis2);
float slicePlaneW = -dot(slicePlaneNormal, slicePlaneOrigin);
float basis1Len2 = dot(slicePlaneBasis1, slicePlaneBasis1);
float basis2Len2 = dot(slicePlaneBasis2, slicePlaneBasis2);
float basis1Dot = dot(slicePlaneBasis1, rel);
float basis2Dot = dot(slicePlaneBasis2, rel);
return SliceFactors(
dot(slicePlaneNormal, pos) + slicePlaneW,
-basis1Dot - basis1Len2,
basis1Dot - basis1Len2,
-basis2Dot - basis2Len2,
basis2Dot - basis2Len2
);
}
bool sliceByFactors(SliceFactors factors) {
return factors.front < 0.0
&& factors.side0 < 0.0
&& factors.side1 < 0.0
&& factors.side2 < 0.0
&& factors.side3 < 0.0;
}
bool sliceEnabled() {
return dot(slicePlaneBasis1, slicePlaneBasis1) != 0.0;
}
bool sliceByPlane(vec3 pos) {
return sliceEnabled() && sliceByFactors(calculateSliceFactors(pos));
}
#define rejectBySlice(_pos_) sliceByPlane(_pos_)
#define discardBySlice(_pos_) { if (sliceByPlane(_pos_)) discard; }`, l15 = o4`vec4 applySliceHighlight(vec4 color, vec3 pos) {
SliceFactors factors = calculateSliceFactors(pos);
const float HIGHLIGHT_WIDTH = 1.0;
const vec4 HIGHLIGHT_COLOR = vec4(0.0, 0.0, 0.0, 0.3);
factors.front /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.front);
factors.side0 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side0);
factors.side1 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side1);
factors.side2 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side2);
factors.side3 /= (2.0 * HIGHLIGHT_WIDTH) * fwidth(factors.side3);
if (sliceByFactors(factors)) {
return color;
}
float highlightFactor = (1.0 - step(0.5, factors.front))
* (1.0 - step(0.5, factors.side0))
* (1.0 - step(0.5, factors.side1))
* (1.0 - step(0.5, factors.side2))
* (1.0 - step(0.5, factors.side3));
return mix(color, vec4(HIGHLIGHT_COLOR.rgb, color.a), highlightFactor * HIGHLIGHT_COLOR.a);
}`, o24 = s12.hasSliceHighlight ? o4`
        ${l15}
        #define highlightSlice(_color_, _pos_) (sliceEnabled() ? applySliceHighlight(_color_, _pos_) : (_color_))
      ` : o4`#define highlightSlice(_color_, _pos_) (_color_)`;
  s12.hasSliceInVertexProgram && e30.vertex.code.add(a16), e30.fragment.code.add(a16), e30.fragment.code.add(o24);
}
function h2(e30, s12, i10) {
  return e30.instancedDoublePrecision ? o(b, i10.camera.viewInverseTransposeMatrix[3], i10.camera.viewInverseTransposeMatrix[7], i10.camera.viewInverseTransposeMatrix[11]) : s12.slicePlaneLocalOrigin;
}
function p(e30, s12) {
  return null != e30 ? e3(v3, s12.origin, e30) : s12.origin;
}
function g(s12, i10, a16) {
  return s12.hasSliceTranslatedView ? null != i10 ? i(S4, a16.camera.viewMatrix, i10) : a16.camera.viewMatrix : null;
}
function H(e30, s12, a16) {
  if (null == a16.slicePlane) return l2;
  const l15 = h2(e30, s12, a16), o24 = p(l15, a16.slicePlane), r15 = g(e30, l15, a16);
  return null != r15 ? O(v3, o24, r15) : o24;
}
function I(e30, s12, o24, r15) {
  if (null == r15 || null == o24.slicePlane) return l2;
  const t15 = h2(e30, s12, o24), n16 = p(t15, o24.slicePlane), f7 = g(e30, t15, o24);
  return null != f7 ? (u(B, r15, n16), O(v3, n16, f7), O(B, B, f7), e3(B, B, v3)) : r15;
}
var b = n2();
var v3 = n2();
var B = n2();
var S4 = e7();

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js
function o14(o24) {
  d4(o24), o24.vertex.code.add(o4`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`), o24.vertex.code.add(o4`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4DrawUniform.js
var o15 = class extends a5 {
  constructor(r15, o24) {
    super(r15, "mat4", a4.Draw, (e30, s12, t15) => e30.setUniformMatrix4fv(r15, o24(s12, t15)));
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js
function f3(r15, e30) {
  e30.instancedDoublePrecision ? r15.constants.add("cameraPosition", "vec3", l2) : r15.uniforms.add(new o6("cameraPosition", (r16, e31) => o(v4, e31.camera.viewInverseTransposeMatrix[3] - r16.origin[0], e31.camera.viewInverseTransposeMatrix[7] - r16.origin[1], e31.camera.viewInverseTransposeMatrix[11] - r16.origin[2])));
}
function d5(e30, a16) {
  if (!a16.instancedDoublePrecision) return void e30.uniforms.add(new e12("proj", (r15, e31) => e31.camera.projectionMatrix), new o15("view", (e31, i10) => i(l5, i10.camera.viewMatrix, e31.origin)), new o6("localOrigin", (r15) => r15.origin));
  const o24 = (r15) => o(v4, r15.camera.viewInverseTransposeMatrix[3], r15.camera.viewInverseTransposeMatrix[7], r15.camera.viewInverseTransposeMatrix[11]);
  e30.uniforms.add(new e12("proj", (r15, e31) => e31.camera.projectionMatrix), new e12("view", (e31, i10) => i(l5, i10.camera.viewMatrix, o24(i10))), new e10("localOrigin", (r15, e31) => o24(e31)));
}
var l5 = e7();
var v4 = n2();
function p2(r15) {
  r15.uniforms.add(new e12("viewNormal", (r16, e30) => e30.camera.viewInverseTransposeMatrix));
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechniqueConfiguration.js
var t7 = class extends n7 {
  constructor() {
    super(), this._key = "", this._keyDirty = false, this._parameterBits = this._parameterBits ? this._parameterBits.map(() => 0) : [], this._parameterNames || (this._parameterNames = []);
  }
  get key() {
    return this._keyDirty && (this._keyDirty = false, this._key = String.fromCharCode.apply(String, this._parameterBits)), this._key;
  }
  snapshot() {
    const e30 = this._parameterNames, t15 = { key: this.key };
    for (const r15 of e30) t15[r15] = this[r15];
    return t15;
  }
};
function r5(e30 = {}) {
  return (t15, r15) => {
    if (t15._parameterNames = t15._parameterNames ?? [], t15._parameterNames.push(r15), null != e30.constValue) Object.defineProperty(t15, r15, { get: () => e30.constValue });
    else {
      const s12 = t15._parameterNames.length - 1, a16 = e30.count || 2, i10 = Math.ceil(Math.log2(a16)), o24 = t15._parameterBits ?? [0];
      let h7 = 0;
      for (; o24[h7] + i10 > 16; ) h7++, h7 >= o24.length && o24.push(0);
      t15._parameterBits = o24;
      const n16 = o24[h7], m7 = (1 << i10) - 1 << n16;
      o24[h7] += i10, Object.defineProperty(t15, r15, { get() {
        return this[s12];
      }, set(e31) {
        if (this[s12] !== e31 && (this[s12] = e31, this._keyDirty = true, this._parameterBits[h7] = this._parameterBits[h7] & ~m7 | +e31 << n16 & m7, "number" != typeof e31 && "boolean" != typeof e31)) throw new Error("Configuration value for " + r15 + " must be boolean or number, got " + typeof e31);
      } });
    }
  };
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js
var O3 = class extends t7 {
  constructor() {
    super(...arguments), this.instancedDoublePrecision = false, this.hasModelTransformation = false;
  }
};
e([r5()], O3.prototype, "instancedDoublePrecision", void 0), e([r5()], O3.prototype, "hasModelTransformation", void 0);
var h3 = e6();
function N(e30, o24) {
  const i10 = o24.hasModelTransformation, c12 = o24.instancedDoublePrecision;
  i10 && (e30.vertex.uniforms.add(new e12("model", (e31) => e31.modelTransformation ?? o3)), e30.vertex.uniforms.add(new e11("normalLocalOriginFromModel", (e31) => (j(h3, e31.modelTransformation ?? o3), h3)))), o24.instanced && c12 && (e30.attributes.add(e5.INSTANCEMODELORIGINHI, "vec3"), e30.attributes.add(e5.INSTANCEMODELORIGINLO, "vec3"), e30.attributes.add(e5.INSTANCEMODEL, "mat3"), e30.attributes.add(e5.INSTANCEMODELNORMAL, "mat3"));
  const v6 = e30.vertex;
  c12 && (v6.include(c2, o24), v6.uniforms.add(new o6("viewOriginHi", (e31, r15) => o9(o(T, r15.camera.viewInverseTransposeMatrix[3], r15.camera.viewInverseTransposeMatrix[7], r15.camera.viewInverseTransposeMatrix[11]), T)), new o6("viewOriginLo", (e31, r15) => r4(o(T, r15.camera.viewInverseTransposeMatrix[3], r15.camera.viewInverseTransposeMatrix[7], r15.camera.viewInverseTransposeMatrix[11]), T)))), v6.code.add(o4`
    vec3 getVertexInLocalOriginSpace() {
      return ${i10 ? c12 ? "(model * vec4(instanceModel * localPosition().xyz, 1.0)).xyz" : "(model * localPosition()).xyz" : c12 ? "instanceModel * localPosition().xyz" : "localPosition().xyz"};
    }

    vec3 subtractOrigin(vec3 _pos) {
      ${c12 ? o4`
          // Negated inputs are intentionally the first two arguments. The other way around the obfuscation in dpAdd() stopped
          // working for macOS 14+ and iOS 17+.
          // Issue: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/56280
          vec3 originDelta = dpAdd(-instanceModelOriginHi, -instanceModelOriginLo, viewOriginHi, viewOriginLo);
          return _pos - originDelta;` : "return vpos;"}
    }
    `), v6.code.add(o4`
    vec3 dpNormal(vec4 _normal) {
      return normalize(${i10 ? c12 ? "normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz)" : "normalLocalOriginFromModel * _normal.xyz" : c12 ? "instanceModelNormal * _normal.xyz" : "_normal.xyz"});
    }
    `), o24.output === o5.Normal && (p2(v6), v6.code.add(o4`
    vec3 dpNormalView(vec4 _normal) {
      return normalize((viewNormal * ${i10 ? c12 ? "vec4(normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz), 1.0)" : "vec4(normalLocalOriginFromModel * _normal.xyz, 1.0)" : c12 ? "vec4(instanceModelNormal * _normal.xyz, 1.0)" : "_normal"}).xyz);
    }
    `)), o24.hasVertexTangents && v6.code.add(o4`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${i10 ? c12 ? "return vec4(normalLocalOriginFromModel * (instanceModelNormal * _tangent.xyz), _tangent.w);" : "return vec4(normalLocalOriginFromModel * _tangent.xyz, _tangent.w);" : c12 ? "return vec4(instanceModelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}
    }`);
}
var T = n2();

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/IntegerPassUniform.js
var e17 = class extends a5 {
  constructor(r15, e30) {
    super(r15, "int", a4.Pass, (s12, o24, i10) => s12.setUniform1i(r15, e30(o24, i10)));
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/screenSizePerspectiveUtils.js
function c5(e30) {
  return Math.abs(e30 * e30 * e30);
}
function l7(e30, t15, a16) {
  const r15 = a16.parameters;
  return F2.scale = Math.min(r15.divisor / (t15 - r15.offset), 1), F2.factor = c5(e30), F2;
}
function s7(t15, a16) {
  return f(t15 * Math.max(a16.scale, a16.minScaleFactor), t15, a16.factor);
}
function m2(e30, t15, a16, r15) {
  return s7(e30, l7(t15, a16, r15));
}
var v5 = { curvatureDependent: { min: { curvature: h(10), tiltAngle: h(12), scaleFallOffFactor: 0.5 }, max: { curvature: h(70), tiltAngle: h(40), scaleFallOffFactor: 0.8 } }, scaleStart: 0.3, scaleFallOffRange: 0.65, minPixelSize: 0 };
var F2 = { scale: 0, factor: 0, minScaleFactor: 0 };

// ../node_modules/@arcgis/core/views/3d/webgl-engine/materials/internal/MaterialUtil.js
function o16(t15, o24, e30, i10, l15) {
  let c12 = (e30.screenLength || 0) * t15.pixelRatio;
  null != l15 && (c12 = m2(c12, i10, o24, l15));
  const s12 = c12 * Math.tan(0.5 * t15.fovY) / (0.5 * t15.fullHeight);
  return e4(s12 * o24, e30.minWorldLength || 0, null != e30.maxWorldLength ? e30.maxWorldLength : 1 / 0);
}
function e18(t15, n16) {
  const r15 = n16 ? e18(n16) : {};
  for (const o24 in t15) {
    let n17 = t15[o24];
    (n17 == null ? void 0 : n17.forEach) && (n17 = l8(n17)), null == n17 && o24 in r15 || (r15[o24] = n17);
  }
  return r15;
}
function i4(n16, r15) {
  let o24 = false;
  for (const e30 in r15) {
    const i10 = r15[e30];
    void 0 !== i10 && (Array.isArray(i10) ? null === n16[e30] ? (n16[e30] = i10.slice(), o24 = true) : a(n16[e30], i10) && (o24 = true) : n16[e30] !== i10 && (o24 = true, n16[e30] = i10));
  }
  return o24;
}
function l8(t15) {
  const n16 = [];
  return t15.forEach((t16) => n16.push(t16)), n16;
}
var c6 = { multiply: 1, ignore: 2, replace: 3, tint: 4 };

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i5(i10, t15) {
  t15.hasSymbolColors ? (i10.include(e9), i10.attributes.add(e5.SYMBOLCOLOR, "vec4"), i10.varyings.add("colorMixMode", "mediump float"), i10.vertex.code.add(o4`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`)) : (i10.fragment.uniforms.add(new e17("colorMixMode", (o24) => c6[o24.colorMixMode])), i10.vertex.code.add(o4`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`));
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js
function e19(e30, d9) {
  d9.hasVertexColors ? (e30.attributes.add(e5.COLOR, "vec4"), e30.varyings.add("vColor", "vec4"), e30.vertex.code.add(o4`void forwardVertexColor() { vColor = color; }`), e30.vertex.code.add(o4`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)) : e30.vertex.code.add(o4`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/ScreenSizePerspective.glsl.js
function s8(e30) {
  e30.vertex.code.add(o4`float screenSizePerspectiveViewAngleDependentFactor(float absCosAngle) {
return absCosAngle * absCosAngle * absCosAngle;
}`), e30.vertex.code.add(o4`vec3 screenSizePerspectiveScaleFactor(float absCosAngle, float distanceToCamera, vec3 params) {
return vec3(
min(params.x / (distanceToCamera - params.y), 1.0),
screenSizePerspectiveViewAngleDependentFactor(absCosAngle),
params.z
);
}`), e30.vertex.code.add(o4`float applyScreenSizePerspectiveScaleFactorFloat(float size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`), e30.vertex.code.add(o4`float screenSizePerspectiveScaleFloat(float size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorFloat(
size,
screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params)
);
}`), e30.vertex.code.add(o4`vec2 applyScreenSizePerspectiveScaleFactorVec2(vec2 size, vec3 factor) {
return mix(size * clamp(factor.x, factor.z, 1.0), size, factor.y);
}`), e30.vertex.code.add(o4`vec2 screenSizePerspectiveScaleVec2(vec2 size, float absCosAngle, float distanceToCamera, vec3 params) {
return applyScreenSizePerspectiveScaleFactorVec2(size, screenSizePerspectiveScaleFactor(absCosAngle, distanceToCamera, params));
}`);
}
function o17(e30) {
  e30.uniforms.add(new e10("screenSizePerspectiveAlignment", (e31) => i6(e31.screenSizePerspectiveAlignment || e31.screenSizePerspective)));
}
function i6(a16) {
  return o(n10, a16.parameters.divisor, a16.parameters.offset, a16.minScaleFactor);
}
var n10 = n2();

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js
function a8(e30, r15) {
  const c12 = e30.vertex;
  r15.hasVerticalOffset ? (f4(c12), r15.hasScreenSizePerspective && (e30.include(s8), o17(c12), f3(e30.vertex, r15)), c12.code.add(o4`
      vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        float viewDistance = length((view * vec4(worldPos, 1.0)).xyz);
        ${r15.spherical ? o4`vec3 worldNormal = normalize(worldPos + localOrigin);` : o4`vec3 worldNormal = vec3(0.0, 0.0, 1.0);`}
        ${r15.hasScreenSizePerspective ? o4`
            float cosAngle = dot(worldNormal, normalize(worldPos - cameraPosition));
            float verticalOffsetScreenHeight = screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);` : o4`
            float verticalOffsetScreenHeight = verticalOffset.x;`}
        // Screen sized offset in world space, used for example for line callouts
        float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);
        return worldNormal * worldOffset;
      }

      vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) {
        return worldPos + calculateVerticalOffset(worldPos, localOrigin);
      }
    `)) : c12.code.add(o4`vec3 addVerticalOffset(vec3 worldPos, vec3 localOrigin) { return worldPos; }`);
}
var s9 = n4();
function f4(r15) {
  r15.uniforms.add(new e14("verticalOffset", (r16, t15) => {
    const { minWorldLength: l15, maxWorldLength: o24, screenLength: c12 } = r16.verticalOffset, i10 = Math.tan(0.5 * t15.camera.fovY) / (0.5 * t15.camera.fullViewport[3]), a16 = t15.camera.pixelRatio || 1;
    return s2(s9, c12 * a16, i10, l15, o24);
  }));
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float4sPassUniform.js
var e20 = class extends a5 {
  constructor(r15, e30, o24) {
    super(r15, "vec4", a4.Pass, (s12, o25, t15) => s12.setUniform4fv(r15, e30(o25, t15)), o24);
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/FloatsPassUniform.js
var o18 = class extends a5 {
  constructor(r15, o24, e30) {
    super(r15, "float", a4.Pass, (s12, e31, t15) => s12.setUniform1fv(r15, o24(e31, t15)), e30);
  }
};

// ../node_modules/@arcgis/core/views/3d/support/debugFlags.js
var T2 = class extends S2 {
  constructor() {
    super(...arguments), this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR = false, this.DECONFLICTOR_SHOW_VISIBLE = false, this.DECONFLICTOR_SHOW_INVISIBLE = false, this.DECONFLICTOR_SHOW_GRID = false, this.LABELS_SHOW_BORDER = false, this.TEXT_SHOW_BASELINE = false, this.TEXT_SHOW_BORDER = false, this.OVERLAY_DRAW_DEBUG_TEXTURE = false, this.OVERLAY_SHOW_CENTER = false, this.SHOW_POI = false, this.TESTS_DISABLE_OPTIMIZATIONS = false, this.TESTS_DISABLE_FAST_UPDATES = false, this.DRAW_MESH_GEOMETRY_NORMALS = false, this.FEATURE_TILE_FETCH_SHOW_TILES = false, this.FEATURE_TILE_TREE_SHOW_TILES = false, this.TERRAIN_TILE_TREE_SHOW_TILES = false, this.I3S_TREE_SHOW_TILES = false, this.I3S_SHOW_MODIFICATIONS = false, this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES = false, this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL = false, this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES = false, this.LINE_WIREFRAMES = false;
  }
};
e([y()], T2.prototype, "SCENEVIEW_HITTEST_RETURN_INTERSECTOR", void 0), e([y()], T2.prototype, "DECONFLICTOR_SHOW_VISIBLE", void 0), e([y()], T2.prototype, "DECONFLICTOR_SHOW_INVISIBLE", void 0), e([y()], T2.prototype, "DECONFLICTOR_SHOW_GRID", void 0), e([y()], T2.prototype, "LABELS_SHOW_BORDER", void 0), e([y()], T2.prototype, "TEXT_SHOW_BASELINE", void 0), e([y()], T2.prototype, "TEXT_SHOW_BORDER", void 0), e([y()], T2.prototype, "OVERLAY_DRAW_DEBUG_TEXTURE", void 0), e([y()], T2.prototype, "OVERLAY_SHOW_CENTER", void 0), e([y()], T2.prototype, "SHOW_POI", void 0), e([y()], T2.prototype, "TESTS_DISABLE_OPTIMIZATIONS", void 0), e([y()], T2.prototype, "TESTS_DISABLE_FAST_UPDATES", void 0), e([y()], T2.prototype, "DRAW_MESH_GEOMETRY_NORMALS", void 0), e([y()], T2.prototype, "FEATURE_TILE_FETCH_SHOW_TILES", void 0), e([y()], T2.prototype, "FEATURE_TILE_TREE_SHOW_TILES", void 0), e([y()], T2.prototype, "TERRAIN_TILE_TREE_SHOW_TILES", void 0), e([y()], T2.prototype, "I3S_TREE_SHOW_TILES", void 0), e([y()], T2.prototype, "I3S_SHOW_MODIFICATIONS", void 0), e([y()], T2.prototype, "LOD_INSTANCE_RENDERER_DISABLE_UPDATES", void 0), e([y()], T2.prototype, "LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL", void 0), e([y()], T2.prototype, "EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES", void 0), e([y()], T2.prototype, "LINE_WIREFRAMES", void 0), T2 = e([a2("esri.views.3d.support.debugFlags")], T2);
var t8 = new T2();

// ../node_modules/@arcgis/core/views/3d/layers/support/FastSymbolUpdates.js
var h4;
var y2;
!function(e30) {
  e30[e30.Undefined = 0] = "Undefined", e30[e30.DefinedSize = 1] = "DefinedSize", e30[e30.DefinedScale = 2] = "DefinedScale";
}(h4 || (h4 = {})), function(e30) {
  e30[e30.Undefined = 0] = "Undefined", e30[e30.DefinedAngle = 1] = "DefinedAngle";
}(y2 || (y2 = {}));
var Y = e7();
var Z = n2();
var ee = e7();

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObject.js
var r7 = class {
  constructor() {
    this.id = e2();
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/ContentObjectType.js
var e21;
!function(e30) {
  e30[e30.Layer = 0] = "Layer", e30[e30.Object = 1] = "Object", e30[e30.Mesh = 2] = "Mesh", e30[e30.Line = 3] = "Line", e30[e30.Point = 4] = "Point", e30[e30.Material = 5] = "Material", e30[e30.Texture = 6] = "Texture", e30[e30.COUNT = 7] = "COUNT";
}(e21 || (e21 = {}));

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/DefaultVertexAttributeLocations.js
var O4 = /* @__PURE__ */ new Map([[e5.POSITION, 0], [e5.NORMAL, 1], [e5.NORMALCOMPRESSED, 1], [e5.UV0, 2], [e5.COLOR, 3], [e5.COLORFEATUREATTRIBUTE, 3], [e5.SIZE, 4], [e5.TANGENT, 4], [e5.CENTEROFFSETANDDISTANCE, 5], [e5.SYMBOLCOLOR, 5], [e5.FEATUREATTRIBUTE, 6], [e5.INSTANCEFEATUREATTRIBUTE, 6], [e5.INSTANCECOLOR, 7], [e5.OBJECTANDLAYERIDCOLOR, 7], [e5.INSTANCEOBJECTANDLAYERIDCOLOR, 7], [e5.INSTANCEMODEL, 8], [e5.INSTANCEMODELNORMAL, 12], [e5.INSTANCEMODELORIGINHI, 11], [e5.INSTANCEMODELORIGINLO, 15]]);

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/Material.js
var c8 = class extends r7 {
  constructor(t15, r15) {
    super(), this.type = e21.Material, this.supportsEdges = false, this._visible = true, this._renderPriority = 0, this._vertexAttributeLocations = O4, this._pp0 = r2(0, 0, 1), this._pp1 = r2(0, 0, 0), this._parameters = e18(t15, r15), this.validateParameters(this._parameters);
  }
  get parameters() {
    return this._parameters;
  }
  update(e30) {
    return false;
  }
  setParameters(e30, t15 = true) {
    i4(this._parameters, e30) && (this.validateParameters(this._parameters), t15 && this.parametersChanged());
  }
  validateParameters(e30) {
  }
  get visible() {
    return this._visible;
  }
  set visible(e30) {
    e30 !== this._visible && (this._visible = e30, this.parametersChanged());
  }
  shouldRender(e30) {
    return this.isVisible() && this.isVisibleForOutput(e30.output) && (!this.parameters.isDecoration || e30.bindParameters.decorations === i2.ON) && !!(this.parameters.renderOccluded & e30.renderOccludedMask);
  }
  isVisibleForOutput(e30) {
    return true;
  }
  get renderPriority() {
    return this._renderPriority;
  }
  set renderPriority(e30) {
    e30 !== this._renderPriority && (this._renderPriority = e30, this.parametersChanged());
  }
  get vertexAttributeLocations() {
    return this._vertexAttributeLocations;
  }
  isVisible() {
    return this._visible;
  }
  parametersChanged() {
    var _a;
    (_a = this.repository) == null ? void 0 : _a.materialChanged(this);
  }
  queryRenderOccludedState(e30) {
    return this.isVisible() && this.parameters.renderOccluded === e30;
  }
  intersectDraped(e30, t15, r15, s12, i10, a16) {
    return this._pp0[0] = this._pp1[0] = s12[0], this._pp0[1] = this._pp1[1] = s12[1], this.intersect(e30, t15, r15, this._pp0, this._pp1, i10);
  }
};
var h5;
!function(e30) {
  e30[e30.None = 0] = "None", e30[e30.Occlude = 1] = "Occlude", e30[e30.Transparent = 2] = "Transparent", e30[e30.OccludeAndTransparent = 4] = "OccludeAndTransparent", e30[e30.OccludeAndTransparentStencil = 8] = "OccludeAndTransparentStencil", e30[e30.Opaque = 16] = "Opaque";
}(h5 || (h5 = {}));

// ../node_modules/@arcgis/core/views/3d/webgl-engine/materials/VisualVariablePassParameters.js
var e22 = 8;

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js
function l10(l15, n16) {
  const { vertex: s12, attributes: u5 } = l15;
  n16.hasVvInstancing && (n16.vvSize || n16.vvColor) && u5.add(e5.INSTANCEFEATUREATTRIBUTE, "vec4"), n16.vvSize ? (s12.uniforms.add(new e10("vvSizeMinSize", (e30) => e30.vvSize.minSize)), s12.uniforms.add(new e10("vvSizeMaxSize", (e30) => e30.vvSize.maxSize)), s12.uniforms.add(new e10("vvSizeOffset", (e30) => e30.vvSize.offset)), s12.uniforms.add(new e10("vvSizeFactor", (e30) => e30.vvSize.factor)), s12.uniforms.add(new e11("vvSymbolRotationMatrix", (e30) => e30.vvSymbolRotationMatrix)), s12.uniforms.add(new e10("vvSymbolAnchor", (e30) => e30.vvSymbolAnchor)), s12.code.add(o4`vec3 vvScale(vec4 _featureAttribute) {
return clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize);
}
vec4 vvTransformPosition(vec3 position, vec4 _featureAttribute) {
return vec4(vvSymbolRotationMatrix * ( vvScale(_featureAttribute) * (position + vvSymbolAnchor)), 1.0);
}`), s12.code.add(o4`
      const float eps = 1.192092896e-07;
      vec4 vvTransformNormal(vec3 _normal, vec4 _featureAttribute) {
        vec3 vvScale = clamp(vvSizeOffset + _featureAttribute.x * vvSizeFactor, vvSizeMinSize + eps, vvSizeMaxSize);
        return vec4(vvSymbolRotationMatrix * _normal / vvScale, 1.0);
      }

      ${n16.hasVvInstancing ? o4`
      vec4 vvLocalNormal(vec3 _normal) {
        return vvTransformNormal(_normal, instanceFeatureAttribute);
      }

      vec4 localPosition() {
        return vvTransformPosition(position, instanceFeatureAttribute);
      }` : ""}
    `)) : s12.code.add(o4`vec4 localPosition() { return vec4(position, 1.0); }
vec4 vvLocalNormal(vec3 _normal) { return vec4(_normal, 1.0); }`), n16.vvColor ? (s12.constants.add("vvColorNumber", "int", e22), s12.uniforms.add(new o18("vvColorValues", (e30) => e30.vvColor.values, e22), new e20("vvColorColors", (e30) => e30.vvColor.colors, e22)), s12.code.add(o4`
      vec4 interpolateVVColor(float value) {
        if (value <= vvColorValues[0]) {
          return vvColorColors[0];
        }

        for (int i = 1; i < vvColorNumber; ++i) {
          if (vvColorValues[i] >= value) {
            float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
            return mix(vvColorColors[i-1], vvColorColors[i], f);
          }
        }
        return vvColorColors[vvColorNumber - 1];
      }

      vec4 vvGetColor(vec4 featureAttribute) {
        return interpolateVVColor(featureAttribute.y);
      }

      ${n16.hasVvInstancing ? o4`
            vec4 vvColor() {
              return vvGetColor(instanceFeatureAttribute);
            }` : "vec4 vvColor() { return vec4(1.0); }"}
    `)) : s12.code.add(o4`vec4 vvColor() { return vec4(1.0); }`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlphaBlend.glsl.js
function d6(d9) {
  d9.fragment.code.add(o4`
    #define discardOrAdjustAlpha(color) { if (color.a < ${o4.float(t5)}) { discard; } }
  `);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js
function s10(a16, e30) {
  l11(a16, e30, new o7("textureAlphaCutoff", (a17) => a17.textureAlphaCutoff));
}
function l11(e30, r15, s12) {
  const t15 = e30.fragment;
  switch (r15.alphaDiscardMode !== s4.Mask && r15.alphaDiscardMode !== s4.MaskBlend || t15.uniforms.add(s12), r15.alphaDiscardMode) {
    case s4.Blend:
      return e30.include(d6);
    case s4.Opaque:
      t15.code.add(o4`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);
      break;
    case s4.Mask:
      t15.code.add(o4`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);
      break;
    case s4.MaskBlend:
      e30.fragment.code.add(o4`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`);
  }
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js
function d7(d9, t15) {
  const a16 = t15.output === o5.ObjectAndLayerIdColor, n16 = t15.objectAndLayerIdColorInstanced;
  a16 && (d9.varyings.add("objectAndLayerIdColorVarying", "vec4"), n16 ? d9.attributes.add(e5.INSTANCEOBJECTANDLAYERIDCOLOR, "vec4") : d9.attributes.add(e5.OBJECTANDLAYERIDCOLOR, "vec4")), d9.vertex.code.add(o4`
     void forwardObjectAndLayerIdColor() {
      ${a16 ? n16 ? o4`objectAndLayerIdColorVarying = instanceObjectAndLayerIdColor * 0.003921568627451;` : o4`objectAndLayerIdColorVarying = objectAndLayerIdColor * 0.003921568627451;` : o4``} }`), d9.fragment.code.add(o4`
      void outputObjectAndLayerIdColor() {
        ${a16 ? o4`fragColor = objectAndLayerIdColorVarying;` : o4``} }`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloat16Encoding.glsl.js
function a9(a16) {
  a16.code.add(o4`const float MAX_RGBA4_FLOAT =
15.0 / 16.0 +
15.0 / 16.0 / 16.0 +
15.0 / 16.0 / 16.0 / 16.0 +
15.0 / 16.0 / 16.0 / 16.0 / 16.0;
const vec4 FIXED_POINT_FACTORS_RGBA4 = vec4(1.0, 16.0, 16.0 * 16.0, 16.0 * 16.0 * 16.0);
vec4 floatToRgba4(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA4_FLOAT);
vec4 fixedPointU4 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS_RGBA4) * 16.0);
const float toU4AsFloat = 1.0 / 15.0;
return fixedPointU4 * toU4AsFloat;
}
const vec4 RGBA4_2_FLOAT_FACTORS = vec4(
15.0 / (16.0),
15.0 / (16.0 * 16.0),
15.0 / (16.0 * 16.0 * 16.0),
15.0 / (16.0 * 16.0 * 16.0 * 16.0)
);
float rgba4ToFloat(vec4 rgba) {
return dot(rgba, RGBA4_2_FLOAT_FACTORS);
}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js
function e24(e30, d9) {
  switch (d9.output) {
    case o5.Shadow:
    case o5.ShadowHighlight:
    case o5.ShadowExcludeHighlight:
    case o5.ViewshedShadow:
      e30.fragment.include(a9), e30.fragment.code.add(o4`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 20.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
return depth + SLOPE_SCALE * m + BIAS;
}
void outputDepth(float _linearDepth) {
fragColor = floatToRgba4(_calculateFragDepth(_linearDepth));
}`);
  }
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js
var r8 = r3(1, 1, 0, 1);
var d8 = r3(1, 0, 1, 1);
function a10(e30) {
  e30.fragment.uniforms.add(new s5("depthTexture", (e31, o24) => o24.mainDepth)), e30.fragment.constants.add("occludedHighlightFlag", "vec4", r8).add("unoccludedHighlightFlag", "vec4", d8), e30.fragment.code.add(o4`void outputHighlight() {
float sceneDepth = float(texelFetch(depthTexture, ivec2(gl_FragCoord.xy), 0).x);
if (gl_FragCoord.z > sceneDepth + 5e-7) {
fragColor = occludedHighlightFlag;
} else {
fragColor = unoccludedHighlightFlag;
}
}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function x2(x4, h7) {
  const { vertex: j3, fragment: O5 } = x4, w = h7.hasColorTexture && h7.alphaDiscardMode !== s4.Opaque;
  switch (h7.output) {
    case o5.Depth:
      d5(j3, h7), x4.include(o14, h7), x4.include(P2, h7), x4.include(o10, h7), w && O5.uniforms.add(new s5("tex", (o24) => o24.texture)), j3.code.add(o4`void main(void) {
vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();
}`), x4.include(s10, h7), O5.code.add(o4`
          void main(void) {
            discardBySlice(vpos);
            ${w ? o4`
                    vec4 texColor = texture(tex, ${h7.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
          }
        `);
      break;
    case o5.Shadow:
    case o5.ShadowHighlight:
    case o5.ShadowExcludeHighlight:
    case o5.ViewshedShadow:
    case o5.ObjectAndLayerIdColor:
      d5(j3, h7), x4.include(o14, h7), x4.include(o10, h7), x4.include(l10, h7), x4.include(e24, h7), x4.include(P2, h7), x4.include(d7, h7), i3(x4), x4.varyings.add("depth", "float"), w && O5.uniforms.add(new s5("tex", (o24) => o24.texture)), j3.code.add(o4`void main(void) {
vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
forwardTextureCoordinates();
forwardObjectAndLayerIdColor();
}`), x4.include(s10, h7), O5.code.add(o4`
          void main(void) {
            discardBySlice(vpos);
            ${w ? o4`
                    vec4 texColor = texture(tex, ${h7.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            ${h7.output === o5.ObjectAndLayerIdColor ? o4`outputObjectAndLayerIdColor();` : o4`outputDepth(depth);`}
          }
        `);
      break;
    case o5.Normal: {
      d5(j3, h7), x4.include(o14, h7), x4.include(t3, h7), x4.include(n8, h7), x4.include(o10, h7), x4.include(l10, h7), w && O5.uniforms.add(new s5("tex", (o25) => o25.texture)), h7.normalType === a6.ScreenDerivative && x4.varyings.add("vPositionView", "vec3");
      const o24 = h7.normalType === a6.Attribute || h7.normalType === a6.Compressed;
      j3.code.add(o4`
          void main(void) {
            vpos = getVertexInLocalOriginSpace();

            ${o24 ? o4`vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));` : o4`
                  // Get vertex position in camera space for screen-space derivative normals
                  vPositionView = (view * vec4(vpos, 1.0)).xyz;
                `}
            vpos = subtractOrigin(vpos);
            vpos = addVerticalOffset(vpos, localOrigin);
            gl_Position = transformPosition(proj, view, vpos);
            forwardTextureCoordinates();
          }
        `), x4.include(P2, h7), x4.include(s10, h7), O5.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${w ? o4`
                    vec4 texColor = texture(tex, ${h7.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}

            ${h7.normalType === a6.ScreenDerivative ? o4`vec3 normal = screenDerivativeNormal(vPositionView);` : o4`
                  vec3 normal = normalize(vNormalWorld);
                  if (gl_FrontFacing == false){
                    normal = -normal;
                  }`}
            fragColor = vec4(0.5 + 0.5 * normal, 1.0);
          }
        `);
      break;
    }
    case o5.Highlight:
      d5(j3, h7), x4.include(o14, h7), x4.include(o10, h7), x4.include(l10, h7), w && O5.uniforms.add(new s5("tex", (o24) => o24.texture)), j3.code.add(o4`void main(void) {
vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();
}`), x4.include(P2, h7), x4.include(s10, h7), x4.include(a10, h7), O5.code.add(o4`
          void main() {
            discardBySlice(vpos);
            ${w ? o4`
                    vec4 texColor = texture(tex, ${h7.hasColorTextureTransform ? o4`colorUV` : o4`vuv0`});
                    discardOrAdjustAlpha(texColor);` : ""}
            outputHighlight();
          }
        `);
  }
}

// ../node_modules/@arcgis/core/views/3d/webgl/formats.js
var R;
var E2;
!function(R2) {
  R2[R2.RED = 0] = "RED", R2[R2.RG = 1] = "RG", R2[R2.RGBA4 = 2] = "RGBA4", R2[R2.RGBA = 3] = "RGBA", R2[R2.RGBA_MIPMAP = 4] = "RGBA_MIPMAP", R2[R2.R16F = 5] = "R16F", R2[R2.RGBA16F = 6] = "RGBA16F";
}(R || (R = {})), function(R2) {
  R2[R2.DEPTH_STENCIL_TEXTURE = 0] = "DEPTH_STENCIL_TEXTURE", R2[R2.DEPTH16_BUFFER = 1] = "DEPTH16_BUFFER";
}(E2 || (E2 = {}));

// ../node_modules/@arcgis/core/views/3d/webgl/RenderNode.js
var a11 = class extends S2 {
  constructor(e30) {
    super(e30), this.view = null, this.consumes = { required: [] }, this.produces = "composite-color", this._context = null, this._dirty = true;
  }
  initialize() {
    this.addHandles([d(() => this.view.ready, (e30) => {
      var _a;
      e30 && ((_a = this.view._stage) == null ? void 0 : _a.renderer.addRenderNode(this));
    }, P)]);
  }
  destroy() {
    var _a, _b;
    (_b = (_a = this.view._stage) == null ? void 0 : _a.renderer) == null ? void 0 : _b.removeRenderNode(this);
  }
  render() {
    throw new s("RenderNode:render-function-not-implemented", "render() is not implemented.");
  }
  get camera() {
    return this.view.state.camera.clone();
  }
  get sunLight() {
    return this.bindParameters.lighting.legacy;
  }
  get gl() {
    return this.view._stage.renderView.renderingContext.gl;
  }
  acquireOutputFramebuffer() {
    var _a, _b, _c;
    const e30 = (_b = (_a = this._frameBuffer) == null ? void 0 : _a.getTexture()) == null ? void 0 : _b.descriptor, r15 = this.view._stage.renderer.fboCache.acquire((e30 == null ? void 0 : e30.width) ?? 640, (e30 == null ? void 0 : e30.height) ?? 480, this.produces);
    return (_c = r15.fbo) == null ? void 0 : _c.initializeAndBind(), r15;
  }
  bindRenderTarget() {
    var _a, _b;
    return (_b = (_a = this._frameBuffer) == null ? void 0 : _a.fbo) == null ? void 0 : _b.initializeAndBind(), this._frameBuffer;
  }
  requestRender(e30) {
    var _a;
    e30 === O2.UPDATE && ((_a = this.view._stage) == null ? void 0 : _a.renderView.requestRender(e30)), this._dirty = true;
  }
  resetWebGLState() {
    var _a;
    this.renderingContext.resetState(), this.renderingContext.bindFramebuffer((_a = this._frameBuffer) == null ? void 0 : _a.fbo);
  }
  get fboCache() {
    return this.view._stage.renderer.fboCache;
  }
  get bindParameters() {
    return this._context.bindParameters;
  }
  get renderingContext() {
    return this.view._stage.renderView.renderingContext;
  }
  updateAnimation() {
    return !!this._dirty && (this._dirty = false, true);
  }
  doRender(e30, r15) {
    this._context = r15, this._frameBuffer = e30.find(({ name: e31 }) => e31 === this.produces);
    try {
      return this.render(e30);
    } finally {
      this._frameBuffer = null;
    }
  }
};
e([y({ constructOnly: true })], a11.prototype, "view", void 0), e([y({ constructOnly: true })], a11.prototype, "consumes", void 0), e([y()], a11.prototype, "produces", void 0), a11 = e([a2("esri.views.3d.webgl.RenderNode")], a11);
var c9 = a11;

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ScreenSpaceConstants.js
var e25 = 3e5;
var o20 = 5e5;

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule.js
var t9 = class {
  constructor(t15, o24) {
    this._module = t15, this._loadModule = o24;
  }
  get() {
    return this._module;
  }
  async reload() {
    return this._module = await this._loadModule(), this._module;
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique.js
var r9 = class {
  constructor(i10, t15, r15) {
    this.release = r15, this.initializeConfiguration(i10, t15), this._configuration = t15.snapshot(), this._program = this.initializeProgram(i10), this._pipeline = this.initializePipeline(i10);
  }
  destroy() {
    this._program = r(this._program), this._pipeline = this._configuration = null;
  }
  reload(t15) {
    r(this._program), this._program = this.initializeProgram(t15), this._pipeline = this.initializePipeline(t15);
  }
  get program() {
    return this._program;
  }
  get compiled() {
    return this.program.compiled;
  }
  get key() {
    return this._configuration.key;
  }
  get configuration() {
    return this._configuration;
  }
  ensureAttributeLocations(i10) {
    this.program.assertCompatibleVertexAttributeLocations(i10);
  }
  get primitiveType() {
    return E.TRIANGLES;
  }
  getPipeline(i10, t15, r15) {
    return this._pipeline;
  }
  initializeConfiguration(i10, t15) {
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lib/Program.js
var r10 = class {
  constructor(r15, i10, s12) {
    this._context = r15, this._locations = s12, this._textures = /* @__PURE__ */ new Map(), this._freeTextureUnits = new l({ deallocator: null }), this._glProgram = r15.programCache.acquire(i10.generate("vertex"), i10.generate("fragment"), s12), this._glProgram.stop = () => {
      throw new Error("Wrapped _glProgram used directly");
    }, this.bindPass = i10.generateBindPass(this), this.bindDraw = i10.generateBindDraw(this), this._fragmentUniforms = a3() ? i10.fragmentUniforms : null;
  }
  dispose() {
    this._glProgram.dispose();
  }
  get glName() {
    return this._glProgram.glName;
  }
  get hasTransformFeedbackVaryings() {
    return this._glProgram.hasTransformFeedbackVaryings;
  }
  get compiled() {
    return this._glProgram.compiled;
  }
  setUniform1b(t15, e30) {
    this._glProgram.setUniform1i(t15, e30 ? 1 : 0);
  }
  setUniform1i(t15, e30) {
    this._glProgram.setUniform1i(t15, e30);
  }
  setUniform1f(t15, e30) {
    this._glProgram.setUniform1f(t15, e30);
  }
  setUniform2fv(t15, e30) {
    this._glProgram.setUniform2fv(t15, e30);
  }
  setUniform3fv(t15, e30) {
    this._glProgram.setUniform3fv(t15, e30);
  }
  setUniform4fv(t15, e30) {
    this._glProgram.setUniform4fv(t15, e30);
  }
  setUniformMatrix3fv(t15, e30) {
    this._glProgram.setUniformMatrix3fv(t15, e30);
  }
  setUniformMatrix4fv(t15, e30) {
    this._glProgram.setUniformMatrix4fv(t15, e30);
  }
  setUniform1fv(t15, e30) {
    this._glProgram.setUniform1fv(t15, e30);
  }
  setUniform1iv(t15, e30) {
    this._glProgram.setUniform1iv(t15, e30);
  }
  setUniform2iv(t15, e30) {
    this._glProgram.setUniform3iv(t15, e30);
  }
  setUniform3iv(t15, e30) {
    this._glProgram.setUniform3iv(t15, e30);
  }
  setUniform4iv(t15, e30) {
    this._glProgram.setUniform4iv(t15, e30);
  }
  assertCompatibleVertexAttributeLocations(t15) {
    t15.locations !== this._locations && console.error("VertexAttributeLocations are incompatible");
  }
  stop() {
    this._textures.clear(), this._freeTextureUnits.clear();
  }
  bindTexture(t15, e30) {
    if (null == (e30 == null ? void 0 : e30.glName)) {
      const e31 = this._textures.get(t15);
      return e31 && (this._context.bindTexture(null, e31.unit), this._freeTextureUnit(e31), this._textures.delete(t15)), null;
    }
    let r15 = this._textures.get(t15);
    return null == r15 ? (r15 = this._allocTextureUnit(e30), this._textures.set(t15, r15)) : r15.texture = e30, this._context.useProgram(this), this.setUniform1i(t15, r15.unit), this._context.bindTexture(e30, r15.unit), r15.unit;
  }
  rebindTextures() {
    var _a;
    this._context.useProgram(this), this._textures.forEach((t15, e30) => {
      this._context.bindTexture(t15.texture, t15.unit), this.setUniform1i(e30, t15.unit);
    }), (_a = this._fragmentUniforms) == null ? void 0 : _a.forEach((t15) => {
      "sampler2D" !== t15.type && "samplerCube" !== t15.type || this._textures.has(t15.name) || console.error(`Texture sampler ${t15.name} has no bound texture`);
    });
  }
  _allocTextureUnit(t15) {
    return { texture: t15, unit: 0 === this._freeTextureUnits.length ? this._textures.size : this._freeTextureUnits.pop() };
  }
  _freeTextureUnit(t15) {
    this._freeTextureUnits.push(t15.unit);
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOBlurTechnique.js
var a12 = class _a extends r9 {
  initializeProgram(r15) {
    return new r10(r15.rctx, _a.shader.get().build(), O4);
  }
  initializePipeline() {
    return S3({ colorWrite: _2 });
  }
};
a12.shader = new t9(u2, () => import("./SSAOBlur.glsl-CIBVXTGT.js"));

// ../node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAONoiseData.js
var e26 = "eXKEvZaUc66cjIKElE1jlJ6MjJ6Ufkl+jn2fcXp5jBx7c6KEflSGiXuXeW6OWs+tfqZ2Yot2Y7Zzfo2BhniEj3xoiXuXj4eGZpqEaHKDWjSMe7palFlzc3BziYOGlFVzg6Zzg7CUY5JrjFF7eYJ4jIKEcyyEonSXe7qUfqZ7j3xofqZ2c4R5lFZ5Y0WUbppoe1l2cIh2ezyUho+BcHN2cG6DbpqJhqp2e1GcezhrdldzjFGUcyxjc3aRjDyEc1h7Sl17c6aMjH92pb6Mjpd4dnqBjMOEhqZleIOBYzB7gYx+fnqGjJuEkWlwnCx7fGl+c4hjfGyRe5qMlNOMfnqGhIWHc6OMi4GDc6aMfqZuc6aMzqJzlKZ+lJ6Me3qRfoFue0WUhoR5UraEa6qMkXiPjMOMlJOGe7JrUqKMjK6MeYRzdod+Sl17boiPc6qEeYBlcIh2c1WEe7GDiWCDa0WMjEmMdod+Y0WcdntzhmN8WjyMjKJjiXtzgYxYaGd+a89zlEV7e2GJfnd+lF1rcK5zc4p5cHuBhL6EcXp5eYB7fnh8iX6HjIKEeaxuiYOGc66RfG2Ja5hzjlGMjEmMe9OEgXuPfHyGhPeEdl6JY02McGuMfnqGhFiMa3WJfnx2l4hwcG1uhmN8c0WMc39og1GBbrCEjE2EZY+JcIh2cIuGhIWHe0mEhIVrc09+gY5+eYBlnCyMhGCDl3drfmmMgX15aGd+gYx+fnuRfnhzY1SMsluJfnd+hm98WtNrcIuGh4SEj0qPdkqOjFF7jNNjdnqBgaqUjMt7boeBhnZ4jDR7c5pze4GGjEFrhLqMjHyMc0mUhKZze4WEa117kWlwbpqJjHZ2eX2Bc09zeId+e0V7WlF7jHJ2l72BfId8l3eBgXyBe897jGl7c66cgW+Xc76EjKNbgaSEjGx4fId8jFFjgZB8cG6DhlFziZhrcIh2fH6HgUqBgXiPY8dahGFzjEmMhEFre2dxhoBzc5SGfleGe6alc7aUeYBlhKqUdlp+cH5za4OEczxza0Gcc4J2jHZ5iXuXjH2Jh5yRjH2JcFx+hImBjH+MpddCl3dreZeJjIt8ZW18bm1zjoSEeIOBlF9oh3N7hlqBY4+UeYFwhLJjeYFwaGd+gUqBYxiEYot2fqZ2ondzhL6EYyiEY02Ea0VjgZB8doaGjHxoc66cjEGEiXuXiXWMiZhreHx8frGMe75rY02Ec5pzfnhzlEp4a3VzjM+EhFFza3mUY7Zza1V5e2iMfGyRcziEhDyEkXZ2Y4OBnCx7g5t2eyBjgV6EhEFrcIh2dod+c4Z+nJ5zjm15jEmUeYxijJp7nL6clIpjhoR5WrZraGd+fnuRa6pzlIiMg6ZzfHx5foh+eX1ufnB5eX1ufnB5aJt7UqKMjIh+e3aBfm5lbYSBhGFze6J4c39oc0mUc4Z+e0V7fKFVe0WEdoaGY02Ec4Z+Y02EZYWBfH6HgU1+gY5+hIWUgW+XjJ57ebWRhFVScHuBfJ6PhBx7WqJzlM+Ujpd4gHZziX6HjHmEgZN+lJt5boiPe2GJgX+GjIGJgHZzeaxufnB5hF2JtdN7jJ57hp57hK6ElFVzg6ZzbmiEbndzhIWHe3uJfoFue3qRhJd2j3xoc65zlE1jc3p8lE1jhniEgXJ7e657vZaUc3qBh52BhIF4aHKDa9drgY5+c52GWqZzbpqJe8tjnM+UhIeMfo2BfGl+hG1zSmmMjKJjZVaGgX15c1lze0mEp4OHa3mUhIWHhDyclJ6MeYOJkXiPc0VzhFiMlKaEboSJa5Jze41re3qRhn+HZYWBe0mEc4p5fnORbox5lEp4hGFjhGGEjJuEc1WEhLZjeHeGa7KlfHx2hLaMeX1ugY5+hIWHhKGPjMN7c1WEho1zhoBzZYx7fnhzlJt5exyUhFFziXtzfmmMa6qMYyiEiXxweV12kZSMeWqXSl17fnhzxmmMrVGEe1mcc4p5eHeGjK6MgY5+doaGa6pzlGV7g1qBh4KHkXiPeW6OaKqafqZ2eXZ5e1V7jGd7boSJc3BzhJd2e0mcYot2h1RoY8dahK6EQmWEWjx7e1l2lL6UgXyBdnR4eU9zc0VreX1umqaBhld7fo2Bc6KEc5Z+hDyEcIeBWtNrfHyGe5qMhMuMe5qMhEGEbVVupcNzg3aHhIF4boeBe0mEdlptc39ofFl5Y8uUlJOGiYt2UmGEcyxjjGx4jFF7a657ZYWBnElzhp57iXtrgZN+tfOEhIOBjE2HgU1+e8tjjKNbiWCDhE15gUqBgYN7fnqGc66ce9d7iYSBj0qPcG6DnGGcT3eGa6qMZY+JlIiMl4hwc3aRdnqBlGV7eHJ2hLZjfnuRhDyEeX6MSk17g6Z+c6aUjHmEhIF4gXyBc76EZW18fGl+fkl+jCxrhoVwhDyUhIqGlL2DlI6EhJd2tdN7eYORhEGMa2Faa6pzc3Bzc4R5lIRznM+UY9eMhDycc5Z+c4p5c4iGY117pb6MgXuPrbJafnx2eYOJeXZ5e657hDyEcziElKZjfoB5eHeGj4WRhGGEe6KGeX1utTStc76EhFGJnCyMa5hzfH6HnNeceYB7hmN8gYuMhIVrczSMgYF8h3N7c5pza5hzjJqEYIRdgYuMlL2DeYRzhGGEeX1uhLaEc4iGeZ1zdl6JhrVteX6Me2iMfm5lWqJzSpqEa6pzdnmchHx2c6OMhNdrhoR5g3aHczxzeW52gV6Ejm15frGMc0Vzc4Z+l3drfniJe+9rWq5rlF1rhGGEhoVwe9OEfoh+e7pac09+c3qBY0lrhDycdnp2lJ6MiYOGhGCDc3aRlL2DlJt5doaGdnp2gYF8gWeOjF2Uc4R5c5Z+jEmMe7KEc4mEeYJ4dmyBe0mcgXiPbqJ7eYB7fmGGiYSJjICGlF1reZ2PnElzbpqJfH6Hc39oe4WEc5eJhK6EhqyJc3qBgZB8c09+hEmEaHKDhFGJc5SGiXWMUpaEa89zc6OMnCyMiXtrho+Be5qMc7KEjJ57dmN+hKGPjICGbmiEe7prdod+hGCDdnmchBx7eX6MkXZ2hGGEa657hm98jFFjY5JreYOJgY2EjHZ2a295Y3FajJ6Mc1J+YzB7e4WBjF2Uc4R5eV12gYxzg1qBeId+c9OUc5pzjFFjgY5+hFiMlIaPhoR5lIpjjIKBlNdSe7KEeX2BfrGMhIqGc65zjE2UhK6EklZ+QmWEeziMWqZza3VzdnR4foh+gYF8n3iJiZhrnKp7gYF8eId+lJ6Me1lrcIuGjKJjhmN8c66MjFF7a6prjJ6UnJ5zezyUfruRWlF7nI5zfHyGe657h4SEe8tjhBx7jFFjc09+c39ojICMeZeJeXt+YzRzjHZ2c0WEcIeBeXZ5onSXkVR+gYJ+eYFwdldzgYF7eX2BjJ6UiXuXlE1jh4SEe1mchLJjc4Z+hqZ7eXZ5bm1zlL6Ue5p7iWeGhKqUY5pzjKJjcIeBe8t7gXyBYIRdlEp4a3mGnK6EfmmMZpqEfFl5gYxzjKZuhGFjhoKGhHx2fnx2eXuMe3aBiWeGvbKMe6KGa5hzYzB7gZOBlGV7hmN8hqZlYot2Y117a6pzc6KEfId8foB5rctrfneJfJ6PcHN2hFiMc5pzjH92c0VzgY2EcElzdmCBlFVzg1GBc65zY4OBboeBcHiBeYJ4ewxzfHx5lIRzlEmEnLKEbk1zfJ6PhmN8eYBljBiEnMOEiXxwezyUcIeBe76EdsKEeX2BdnR4jGWUrXWMjGd7fkl+j4WRlEGMa5Jzho+BhDyEfnqMeXt+g3aHlE1jczClhNN7ZW18eHx8hGFjZW18iXWMjKJjhH57gYuMcIuGWjyMe4ZtjJuExmmMj4WRdntzi4GDhFFzYIRdnGGcjJp7Y0F7e4WEkbCGiX57fnSHa657a6prhBCMe3Z+SmmMjH92eHJ2hK6EY1FzexhrvbKMnI5za4OEfnd+eXuMhImBe897hLaMjN+EfG+BeIOBhF1+eZeJi4GDkXZ2eXKEgZ6Ejpd4c2GHa1V5e5KUfqZuhCx7jKp7lLZrg11+hHx2hFWUoot2nI5zgbh5mo9zvZaUe3qRbqKMfqZ2kbCGhFiM";

// ../node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOParameters.js
var r11 = class extends n7 {
  constructor() {
    super(...arguments), this.projScale = 1;
  }
};
var t10 = class extends r11 {
  constructor() {
    super(...arguments), this.intensity = 1;
  }
};
var c10 = class extends n7 {
};
var o21 = class extends c10 {
  constructor() {
    super(...arguments), this.blurSize = n5();
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOTechnique.js
var l12 = class _l extends r9 {
  initializeProgram(e30) {
    return new r10(e30.rctx, _l.shader.get().build(), O4);
  }
  initializePipeline() {
    return S3({ colorWrite: _2 });
  }
};
l12.shader = new t9(v, () => import("./SSAO.glsl-OG7VIK5G.js"));

// ../node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAO.js
var g2 = 2;
var y3 = class extends c9 {
  constructor(e30) {
    super(e30), this.consumes = { required: ["normals"] }, this.produces = "ssao", this.isEnabled = () => false, this._enableTime = n(0), this._passParameters = new t10(), this._drawParameters = new o21();
  }
  initialize() {
    const e30 = Uint8Array.from(atob(e26), (e31) => e31.charCodeAt(0)), r15 = new e8();
    r15.wrapMode = D.CLAMP_TO_EDGE, r15.pixelFormat = G.RGB, r15.wrapMode = D.REPEAT, r15.hasMipmap = true, r15.width = 32, r15.height = 32, this._passParameters.noiseTexture = new c(this.renderingContext, r15, e30), this._ssaoTechnique = this.techniques.acquire(l12), this._blurTechnique = this.techniques.acquire(a12), this.addHandles(d(() => this.isEnabled(), () => this._enableTime = n(0)));
  }
  destroy() {
    this._passParameters.noiseTexture = r(this._passParameters.noiseTexture), this._blurTechnique.release(), this._ssaoTechnique.release();
  }
  render(e30) {
    const s12 = this.bindParameters, t15 = e30.find(({ name: e31 }) => "normals" === e31), o24 = t15 == null ? void 0 : t15.getTexture(), a16 = t15 == null ? void 0 : t15.getTexture(t2), c12 = this.fboCache, p4 = s12.camera, l15 = p4.fullViewport[2], d9 = p4.fullViewport[3], b2 = Math.round(l15 / g2), f7 = Math.round(d9 / g2);
    if (!this._ssaoTechnique.compiled || !this._blurTechnique.compiled) return this._enableTime = n(performance.now()), this.requestRender(), c12.acquire(b2, f7, "ssao", R.RED);
    0 === this._enableTime && (this._enableTime = n(performance.now()));
    const w = this.renderingContext, q = this.view.qualitySettings.fadeDuration, j3 = p4.relativeElevation, S5 = e4((o20 - j3) / (o20 - e25), 0, 1), y4 = q > 0 ? Math.min(q, performance.now() - this._enableTime) / q : 1, A2 = y4 * S5;
    this._passParameters.normalTexture = o24, this._passParameters.depthTexture = a16, this._passParameters.projScale = 1 / p4.computeScreenPixelSizeAtDist(1), this._passParameters.intensity = 4 * E3 / d2(p4) ** 6 * A2;
    const R2 = c12.acquire(l15, d9, "ssao input", R.RG);
    w.unbindTexture(R2.fbo.colorTexture), w.bindFramebuffer(R2.fbo), w.setViewport(0, 0, l15, d9), w.bindTechnique(this._ssaoTechnique, s12, this._passParameters, this._drawParameters), w.screen.draw();
    const v6 = c12.acquire(b2, f7, "ssao blur", R.RED);
    w.unbindTexture(v6.fbo.colorTexture), w.bindFramebuffer(v6.fbo), this._drawParameters.colorTexture = R2.getTexture(), o2(this._drawParameters.blurSize, 0, g2 / d9), w.bindTechnique(this._blurTechnique, s12, this._passParameters, this._drawParameters), w.setViewport(0, 0, b2, f7), w.screen.draw(), R2.release();
    const O5 = c12.acquire(b2, f7, "ssao", R.RED);
    return w.unbindTexture(O5.fbo.colorTexture), w.bindFramebuffer(O5.fbo), w.setViewport(0, 0, l15, d9), w.setClearColor(1, 1, 1, 0), w.clear(_.COLOR_BUFFER_BIT), this._drawParameters.colorTexture = v6.getTexture(), o2(this._drawParameters.blurSize, g2 / l15, 0), w.bindTechnique(this._blurTechnique, s12, this._passParameters, this._drawParameters), w.setViewport(0, 0, b2, f7), w.screen.draw(), w.setViewport4fv(p4.fullViewport), v6.release(), y4 < 1 && this.requestRender(O2.UPDATE), O5;
  }
};
e([y()], y3.prototype, "consumes", void 0), e([y()], y3.prototype, "produces", void 0), e([y({ constructOnly: true })], y3.prototype, "techniques", void 0), e([y({ constructOnly: true })], y3.prototype, "isEnabled", void 0), y3 = e([a2("esri.views.3d.webgl-engine.effects.ssao.SSAO")], y3);
var E3 = 0.5;

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js
function t11(t15, o24) {
  const a16 = t15.fragment;
  o24.receiveAmbientOcclusion ? (a16.uniforms.add(new s5("ssaoTex", (e30, s12) => {
    var _a;
    return (_a = s12.ssao) == null ? void 0 : _a.getTexture();
  })), a16.constants.add("blurSizePixelsInverse", "float", 1 / g2), a16.code.add(o4`float evaluateAmbientOcclusionInverse() {
vec2 ssaoTextureSizeInverse = 1.0 / vec2(textureSize(ssaoTex, 0));
return texture(ssaoTex, gl_FragCoord.xy * blurSizePixelsInverse * ssaoTextureSizeInverse).r;
}
float evaluateAmbientOcclusion() {
return 1.0 - evaluateAmbientOcclusionInverse();
}`)) : a16.code.add(o4`float evaluateAmbientOcclusionInverse() { return 1.0; }
float evaluateAmbientOcclusion() { return 0.0; }`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js
function t12(n16) {
  n16.uniforms.add(new e10("mainLightDirection", (i10, n17) => n17.lighting.mainLight.direction));
}
function a13(n16) {
  n16.uniforms.add(new e10("mainLightIntensity", (i10, n17) => n17.lighting.mainLight.intensity));
}
function o22(i10) {
  t12(i10.fragment), a13(i10.fragment), i10.fragment.code.add(o4`vec3 evaluateMainLighting(vec3 normal_global, float shadowing) {
float dotVal = clamp(dot(normal_global, mainLightDirection), 0.0, 1.0);
return mainLightIntensity * ((1.0 - shadowing) * dotVal);
}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js
function t13(t15) {
  const a16 = t15.fragment.code;
  a16.add(o4`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)
{
return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;
}`), a16.add(o4`float integratedRadiance(float cosTheta2, float roughness)
{
return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);
}`), a16.add(o4`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)
{
float cosTheta2 = 1.0 - RdotNG * RdotNG;
float intRadTheta = integratedRadiance(cosTheta2, roughness);
float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;
float sky = 2.0 - ground;
return (ground * ambientGround + sky * ambientSky) * 0.5;
}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js
function t14(t15) {
  t15.vertex.code.add(o4`const float PI = 3.141592653589793;`), t15.fragment.code.add(o4`const float PI = 3.141592653589793;
const float LIGHT_NORMALIZATION = 1.0 / PI;
const float INV_PI = 0.3183098861837907;
const float HALF_PI = 1.570796326794897;`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js
function n13(n16, r15) {
  const l15 = n16.fragment.code;
  n16.include(t14), r15.pbrMode !== c4.Normal && r15.pbrMode !== c4.Schematic && r15.pbrMode !== c4.Simplified && r15.pbrMode !== c4.TerrainWithWater || (l15.add(o4`float normalDistribution(float NdotH, float roughness)
{
float a = NdotH * roughness;
float b = roughness / (1.0 - NdotH * NdotH + a * a);
return b * b * INV_PI;
}`), l15.add(o4`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);
const vec2 c2 = vec2(-1.04, 1.04);
vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
return c2 * a004 + r.zw;
}`)), r15.pbrMode !== c4.Normal && r15.pbrMode !== c4.Schematic || (n16.include(t13), l15.add(o4`struct PBRShadingInfo
{
float NdotL;
float NdotV;
float NdotH;
float VdotH;
float LdotH;
float NdotNG;
float RdotNG;
float NdotAmbDir;
float NdotH_Horizon;
vec3 skyRadianceToSurface;
vec3 groundRadianceToSurface;
vec3 skyIrradianceToSurface;
vec3 groundIrradianceToSurface;
float averageAmbientRadiance;
float ssao;
vec3 albedoLinear;
vec3 f0;
vec3 f90;
vec3 diffuseColor;
float metalness;
float roughness;
};`), l15.add(o4`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {
vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);
vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);
vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;
vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);
vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;
vec3 specularComponent = specularColor * indirectSpecular;
return (diffuseComponent + specularComponent);
}`), l15.add(o4`float gamutMapChanel(float x, vec2 p){
return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );
}`), l15.add(o4`vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){
vec3 outColor;
vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));
outColor.x = gamutMapChanel(inColor.x, p) ;
outColor.y = gamutMapChanel(inColor.y, p) ;
outColor.z = gamutMapChanel(inColor.z, p) ;
return outColor;
}`));
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js
function r12(n16, g4) {
  const r15 = n16.fragment, o24 = void 0 !== g4.lightingSphericalHarmonicsOrder ? g4.lightingSphericalHarmonicsOrder : 2;
  0 === o24 ? (r15.uniforms.add(new e10("lightingAmbientSH0", (n17, t15) => o(a14, t15.lighting.sh.r[0], t15.lighting.sh.g[0], t15.lighting.sh.b[0]))), r15.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 1 === o24 ? (r15.uniforms.add(new e14("lightingAmbientSH_R", (i10, n17) => s2(m5, n17.lighting.sh.r[0], n17.lighting.sh.r[1], n17.lighting.sh.r[2], n17.lighting.sh.r[3])), new e14("lightingAmbientSH_G", (i10, n17) => s2(m5, n17.lighting.sh.g[0], n17.lighting.sh.g[1], n17.lighting.sh.g[2], n17.lighting.sh.g[3])), new e14("lightingAmbientSH_B", (i10, n17) => s2(m5, n17.lighting.sh.b[0], n17.lighting.sh.b[1], n17.lighting.sh.b[2], n17.lighting.sh.b[3]))), r15.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 2 === o24 && (r15.uniforms.add(new e10("lightingAmbientSH0", (n17, t15) => o(a14, t15.lighting.sh.r[0], t15.lighting.sh.g[0], t15.lighting.sh.b[0])), new e14("lightingAmbientSH_R1", (i10, n17) => s2(m5, n17.lighting.sh.r[1], n17.lighting.sh.r[2], n17.lighting.sh.r[3], n17.lighting.sh.r[4])), new e14("lightingAmbientSH_G1", (i10, n17) => s2(m5, n17.lighting.sh.g[1], n17.lighting.sh.g[2], n17.lighting.sh.g[3], n17.lighting.sh.g[4])), new e14("lightingAmbientSH_B1", (i10, n17) => s2(m5, n17.lighting.sh.b[1], n17.lighting.sh.b[2], n17.lighting.sh.b[3], n17.lighting.sh.b[4])), new e14("lightingAmbientSH_R2", (i10, n17) => s2(m5, n17.lighting.sh.r[5], n17.lighting.sh.r[6], n17.lighting.sh.r[7], n17.lighting.sh.r[8])), new e14("lightingAmbientSH_G2", (i10, n17) => s2(m5, n17.lighting.sh.g[5], n17.lighting.sh.g[6], n17.lighting.sh.g[7], n17.lighting.sh.g[8])), new e14("lightingAmbientSH_B2", (i10, n17) => s2(m5, n17.lighting.sh.b[5], n17.lighting.sh.b[6], n17.lighting.sh.b[7], n17.lighting.sh.b[8]))), r15.code.add(o4`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`), g4.pbrMode !== c4.Normal && g4.pbrMode !== c4.Schematic || r15.code.add(o4`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`));
}
var a14 = n2();
var m5 = n4();

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/BooleanPassUniform.js
var s11 = class extends a5 {
  constructor(o24, s12) {
    super(o24, "bool", a4.Pass, (r15, e30, t15) => r15.setUniform1b(o24, s12(e30, t15)));
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SphericalHarmonics.js
var P3 = n2();

// ../node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SceneLighting.js
var l14 = 0.4;
var L = n2();

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js
function u4(i10) {
  i10.constants.add("ambientBoostFactor", "float", l14);
}
function h6(i10) {
  i10.uniforms.add(new o7("lightingGlobalFactor", (i11, n16) => n16.lighting.globalFactor));
}
function p3(g4, p4) {
  const v6 = g4.fragment;
  switch (g4.include(t11, p4), p4.pbrMode !== c4.Disabled && g4.include(n13, p4), g4.include(r12, p4), g4.include(t14), v6.code.add(o4`
    const float GAMMA_SRGB = 2.1;
    const float INV_GAMMA_SRGB = 0.4761904;
    ${p4.pbrMode === c4.Disabled ? "" : "const vec3 GROUND_REFLECTANCE = vec3(0.2);"}
  `), u4(v6), h6(v6), t12(v6), v6.code.add(o4`
    float additionalDirectedAmbientLight(vec3 vPosWorld) {
      float vndl = dot(${p4.spherical ? o4`normalize(vPosWorld)` : o4`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);
      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));
    }
  `), a13(v6), v6.code.add(o4`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {
float additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);
return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;
}`), p4.pbrMode) {
    case c4.Disabled:
    case c4.WaterOnIntegratedMesh:
    case c4.Water:
      g4.include(o22), v6.code.add(o4`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight)
{
vec3 mainLighting = evaluateMainLighting(normalWorld, shadow);
vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);
vec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
vec3 totalLight = mainLighting + ambientLighting + additionalLight;
totalLight = min(totalLight, vec3(PI));
vec3 outColor = vec3((albedoLinear / PI) * totalLight);
return pow(outColor, vec3(INV_GAMMA_SRGB));
}`);
      break;
    case c4.Normal:
    case c4.Schematic:
      v6.code.add(o4`const float fillLightIntensity = 0.25;
const float horizonLightDiffusion = 0.4;
const float additionalAmbientIrradianceFactor = 0.02;
vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec3 _emission, float additionalAmbientIrradiance)
{
vec3 viewDirection = -viewDir;
vec3 h = normalize(viewDirection + mainLightDirection);
PBRShadingInfo inputs;
inputs.NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);
inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);
inputs.NdotH = clamp(dot(normal, h), 0.0, 1.0);
inputs.VdotH = clamp(dot(viewDirection, h), 0.0, 1.0);
inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);
vec3 reflectedView = normalize(reflect(viewDirection, normal));
inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);
inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
inputs.ssao = ssao;
inputs.metalness = mrr[0];
inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), v6.code.add(o4`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;
inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));
inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), p4.useFillLights ? v6.uniforms.add(new s11("hasFillLights", (i10, n16) => n16.enableFillLights)) : v6.constants.add("hasFillLights", "bool", false), v6.code.add(o4`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);
ambientDir = ambientDir != vec3(0.0) ? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));
inputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;
vec3 mainLightIrradianceComponent = inputs.NdotL * (1.0 - shadow) * mainLightIntensity;
vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;
inputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;
inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), v6.uniforms.add(new o7("lightingSpecularStrength", (i10, n16) => n16.lighting.mainLight.specularStrength), new o7("lightingEnvironmentStrength", (i10, n16) => n16.lighting.mainLight.environmentStrength)), v6.code.add(o4`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;
vec3 horizonRingH = normalize(viewDirection + horizonRingDir);
inputs.NdotH_Horizon = dot(normal, horizonRingH);
vec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(inputs.NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);
vec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;
vec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;
float normalDirectionModifier = mix(1., min(mix(0.1, 2.0, (inputs.NdotNG + 1.) * 0.5), 1.0), clamp(inputs.roughness * 5.0, 0.0 , 1.0));
inputs.skyRadianceToSurface = (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.groundRadianceToSurface = 0.5 * GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), v6.code.add(o4`
        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);
        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;
        vec3 emissionComponent = _emission == vec3(0.0) ? _emission : pow(_emission, vec3(GAMMA_SRGB));
        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;
        ${p4.pbrMode !== c4.Schematic || p4.hasColorTexture ? o4`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));` : o4`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`}
        return outColor;
      }
    `);
      break;
    case c4.Simplified:
    case c4.TerrainWithWater:
      g4.include(o22), v6.code.add(o4`const float roughnessTerrain = 0.5;
const float specularityTerrain = 0.5;
const vec3 fresnelReflectionTerrain = vec3(0.04);
vec3 evaluatePBRSimplifiedLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {
vec3 viewDirection = -vd;
vec3 h = normalize(viewDirection + mainLightDirection);
float NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);
float NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);
float NdotH = clamp(dot(n, h), 0.0, 1.0);
float NdotNG = clamp(dot(n, nup), -1.0, 1.0);
vec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));
float lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];
vec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;
vec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));
vec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;
vec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;
vec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;
vec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;
vec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;
vec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);
vec3 specularColor = f0 * dfg.x + f90 * dfg.y;
vec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;
vec3 outColorLinear = outDiffColor + specularComponent;
vec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));
return outColor;
}`);
      break;
    default:
      n3(p4.pbrMode);
    case c4.COUNT:
  }
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js
function a15(a16, o24) {
  if (!o24.multipassEnabled) return;
  a16.fragment.include(c3), a16.fragment.uniforms.add(new s5("terrainDepthTexture", (e30, t15) => {
    var _a;
    return (_a = t15.multipassTerrain.depth) == null ? void 0 : _a.attachment;
  }));
  const n16 = o24.occlusionPass;
  a16.fragment.code.add(o4`
   ${n16 ? "bool" : "void"} terrainDepthTest(float fragmentDepth) {
      float depth = texelFetch(terrainDepthTexture, ivec2(gl_FragCoord.xy), 0).r;
      float linearDepth = linearizeDepth(depth);
      ${n16 ? o4`return fragmentDepth < linearDepth && depth < 1.0;` : o4`
          if(fragmentDepth ${o24.cullAboveGround ? ">" : "<="} linearDepth){
            discard;
          }`}
    }`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sDrawUniform.js
var o23 = class extends a5 {
  constructor(r15, o24, s12) {
    super(r15, "mat4", a4.Draw, (e30, s13, t15, i10) => e30.setUniformMatrix4fv(r15, o24(s13, t15, i10)), s12);
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sPassUniform.js
var e28 = class extends a5 {
  constructor(r15, e30, o24) {
    super(r15, "mat4", a4.Pass, (s12, o25, t15) => s12.setUniformMatrix4fv(r15, e30(o25, t15)), o24);
  }
};

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js
function m6(e30, s12) {
  s12.receiveShadows && (e30.fragment.uniforms.add(new e28("shadowMapMatrix", (e31, s13) => s13.shadowMap.getShadowMapMatrices(e31.origin), 4)), f6(e30));
}
function x3(e30, s12) {
  s12.receiveShadows && (e30.fragment.uniforms.add(new o23("shadowMapMatrix", (e31, s13) => s13.shadowMap.getShadowMapMatrices(e31.origin), 4)), f6(e30));
}
function f6(e30) {
  const s12 = e30.fragment;
  s12.include(a9), s12.uniforms.add(new s5("shadowMap", (e31, s13) => s13.shadowMap.depthTexture), new e17("numCascades", (e31, s13) => s13.shadowMap.numCascades), new e14("cascadeDistances", (e31, s13) => s13.shadowMap.cascadeDistances)), s12.code.add(o4`int chooseCascade(float depth, out mat4 mat) {
vec4 distance = cascadeDistances;
int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;
mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];
return i;
}
vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
vec4 lv = mat * vec4(_vpos, 1.0);
lv.xy /= lv.w;
return 0.5 * lv.xyz + vec3(0.5);
}
vec2 cascadeCoordinates(int i, ivec2 textureSize, vec3 lvpos) {
float xScale = float(textureSize.y) / float(textureSize.x);
return vec2((float(i) + lvpos.x) * xScale, lvpos.y);
}
float readShadowMapDepth(ivec2 uv, sampler2D _depthTex) {
return rgba4ToFloat(texelFetch(_depthTex, uv, 0));
}
float posIsInShadow(ivec2 uv, vec3 lvpos, sampler2D _depthTex) {
return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;
}
float filterShadow(vec2 uv, vec3 lvpos, ivec2 texSize, sampler2D _depthTex) {
vec2 st = fract(uv * vec2(texSize) + vec2(0.5));
ivec2 base = ivec2(uv * vec2(texSize) - vec2(0.5));
float s00 = posIsInShadow(ivec2(base.x, base.y), lvpos, _depthTex);
float s10 = posIsInShadow(ivec2(base.x + 1, base.y), lvpos, _depthTex);
float s11 = posIsInShadow(ivec2(base.x + 1, base.y + 1), lvpos, _depthTex);
float s01 = posIsInShadow(ivec2(base.x, base.y + 1), lvpos, _depthTex);
return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);
}
float readShadowMap(const in vec3 _vpos, float _linearDepth) {
mat4 mat;
int i = chooseCascade(_linearDepth, mat);
if (i >= numCascades) { return 0.0; }
vec3 lvpos = lightSpacePosition(_vpos, mat);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }
ivec2 size = textureSize(shadowMap, 0);
vec2 uv = cascadeCoordinates(i, size, lvpos);
return filterShadow(uv, lvpos, size, shadowMap);
}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js
function e29(e30) {
  e30.code.add(o4`vec4 premultiplyAlpha(vec4 v) {
return vec4(v.rgb * v.a, v.a);
}
vec3 rgb2hsv(vec3 c) {
vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), min(d / (q.x + e), 1.0), q.x);
}
vec3 hsv2rgb(vec3 c) {
vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
float rgb2v(vec3 c) {
return max(c.x, max(c.y, c.z));
}`);
}

// ../node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js
function i9(i10) {
  i10.include(e29), i10.code.add(o4`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${o4.int(n6.Multiply)}) {
        return allMixed;
      }
      if (mode == ${o4.int(n6.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o4.int(n6.Replace)}) {
        return externalColor;
      }

      // tint (or something invalid)
      float vIn = rgb2v(internalMixed);
      vec3 hsvTint = rgb2hsv(externalColor);
      vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
      return hsv2rgb(hsvOut);
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in OSX using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${o4.int(n6.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o4.int(n6.Replace)}) {
        return externalOpacity;
      }

      // multiply or tint (or something invalid)
      return allMixed;
    }
  `);
}

export {
  r7 as r,
  e21 as e,
  d3 as d,
  o10 as o,
  s6 as s,
  u3 as u,
  c4 as c,
  l4 as l,
  O4 as O,
  o16 as o2,
  c8 as c2,
  h5 as h,
  o11 as o3,
  o12 as o4,
  n8 as n,
  f2 as f,
  o13 as o5,
  t5 as t,
  t9 as t2,
  r9 as r2,
  r10 as r3,
  n9 as n2,
  e16 as e2,
  P2 as P,
  o14 as o6,
  f3 as f2,
  d5 as d2,
  r5 as r4,
  O3 as O2,
  N,
  i5 as i,
  e19 as e3,
  a8 as a,
  l10 as l2,
  s10 as s2,
  x2 as x,
  t11 as t3,
  t12 as t4,
  a13 as a2,
  n13 as n3,
  u4 as u2,
  h6 as h2,
  p3 as p,
  a15 as a3,
  m6 as m,
  x3 as x2,
  i9 as i2
};
//# sourceMappingURL=chunk-KPCHTGP2.js.map
