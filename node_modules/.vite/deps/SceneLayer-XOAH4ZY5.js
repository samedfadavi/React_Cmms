import {
  j as j3
} from "./chunk-W45JEAP5.js";
import "./chunk-2SR7SQVX.js";
import {
  i as i3,
  m
} from "./chunk-6VBJAAUX.js";
import {
  s as s6
} from "./chunk-6RWJHMUC.js";
import {
  n as n3,
  p as p6
} from "./chunk-FHON4NYJ.js";
import {
  a as a4,
  m as m2,
  p as p5,
  y as y3
} from "./chunk-LM32XFFX.js";
import {
  C as C3,
  L
} from "./chunk-7VIMGDT3.js";
import {
  $ as $3,
  P,
  w as w2
} from "./chunk-2RXPQJAL.js";
import {
  $ as $2
} from "./chunk-FHB57LTD.js";
import "./chunk-PM3JMBUP.js";
import "./chunk-4CS2XXGQ.js";
import "./chunk-XOGASIUG.js";
import "./chunk-PO74HSB6.js";
import "./chunk-U4K563LI.js";
import {
  r as r2,
  t as t5
} from "./chunk-RMOPI4S6.js";
import {
  $
} from "./chunk-NRWOW5I4.js";
import "./chunk-4RKJDHFK.js";
import "./chunk-GRO6TRQ6.js";
import "./chunk-BMX34DUY.js";
import "./chunk-2CZAGFZF.js";
import "./chunk-V4RHVJ2H.js";
import "./chunk-2PUGZZAH.js";
import "./chunk-CL2YKTVD.js";
import "./chunk-GRVB2MLZ.js";
import "./chunk-3MDFTQ3N.js";
import "./chunk-ZEOXREFF.js";
import "./chunk-5BIU5HC2.js";
import "./chunk-4K57JS64.js";
import "./chunk-DOINOMWZ.js";
import "./chunk-NSJBY6SI.js";
import "./chunk-KWTQCB43.js";
import "./chunk-RRSX64BO.js";
import "./chunk-OUWBUGHV.js";
import "./chunk-3ZIQJRQY.js";
import "./chunk-GE4FYJHC.js";
import "./chunk-MKSCPZ7O.js";
import "./chunk-UPW2DNCP.js";
import "./chunk-6KYG4MCU.js";
import "./chunk-LSYTXHXV.js";
import "./chunk-VJBBHRSD.js";
import "./chunk-D7WIM7VD.js";
import "./chunk-XIC3SN6R.js";
import "./chunk-WX4IZMIC.js";
import "./chunk-T5CIHLIU.js";
import "./chunk-XXTMACWZ.js";
import "./chunk-OXBW45CN.js";
import "./chunk-UPDXKN2W.js";
import "./chunk-LAB5SETU.js";
import "./chunk-7W2VQZZM.js";
import "./chunk-XPEOBWSB.js";
import "./chunk-PYM2YVDF.js";
import {
  s as s3
} from "./chunk-7SBYPGB2.js";
import {
  a as a5
} from "./chunk-KJQQHZYX.js";
import "./chunk-YH5YACEX.js";
import "./chunk-CBN77ZVG.js";
import "./chunk-TNRF7MOE.js";
import "./chunk-PNPG5IXD.js";
import "./chunk-CYGO6TZX.js";
import "./chunk-JSJ34DFQ.js";
import {
  p as p3,
  t as t6
} from "./chunk-XNYIPE5U.js";
import "./chunk-YHUE64L3.js";
import {
  p as p2
} from "./chunk-NRWI2SUH.js";
import {
  i as i2
} from "./chunk-NGPLQQSE.js";
import {
  l as l2
} from "./chunk-HN3UL7DT.js";
import {
  s as s5
} from "./chunk-AMKKU676.js";
import {
  C as C2,
  l as l4
} from "./chunk-QBW6ZJYD.js";
import {
  u as u2
} from "./chunk-S7J6OTBX.js";
import "./chunk-GMJ4G37M.js";
import {
  f as f3
} from "./chunk-CSCLMZ7J.js";
import {
  d as d2,
  l as l3
} from "./chunk-BIJ6AA2G.js";
import {
  p as p4
} from "./chunk-FTURJXD3.js";
import "./chunk-LNOEFEG3.js";
import {
  e as e3
} from "./chunk-TJWXOPWU.js";
import {
  J as J2,
  v as v2
} from "./chunk-4SCOCLA2.js";
import "./chunk-WF67GKPJ.js";
import "./chunk-PVGZCS2Z.js";
import "./chunk-4HOM27T6.js";
import "./chunk-FO4JQZA5.js";
import "./chunk-XEELLOJE.js";
import "./chunk-JVNKXKH7.js";
import {
  F
} from "./chunk-ZT5UNVCE.js";
import "./chunk-2FW7ECQ2.js";
import "./chunk-LGQJAMGK.js";
import "./chunk-PVAXLXWO.js";
import "./chunk-D6KE2FST.js";
import "./chunk-W3XB5XWO.js";
import "./chunk-6QBE4YDH.js";
import {
  Z
} from "./chunk-LXDJBJSP.js";
import "./chunk-OPCT64AO.js";
import {
  j as j2
} from "./chunk-5LNCGIUN.js";
import {
  t as t4
} from "./chunk-HNXXFTFZ.js";
import {
  b as b2
} from "./chunk-KVPS4KFB.js";
import {
  d,
  l,
  s as s4,
  t as t2,
  y as y2
} from "./chunk-NSXZC33R.js";
import {
  S
} from "./chunk-E7HFITKU.js";
import "./chunk-ZFQCSBZ4.js";
import "./chunk-4PAHN45R.js";
import {
  n as n2
} from "./chunk-CRUGTXEH.js";
import "./chunk-CPGVDDHW.js";
import "./chunk-VEOZVJAT.js";
import "./chunk-3D32E2TW.js";
import "./chunk-ACWF4COQ.js";
import "./chunk-P35RWHDU.js";
import "./chunk-G5U2OA3R.js";
import "./chunk-OIFKYPGO.js";
import "./chunk-JNGB7HKP.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import {
  t as t3
} from "./chunk-CZ3DCLKN.js";
import "./chunk-7TO4QD67.js";
import "./chunk-DZNQTDMC.js";
import "./chunk-RM4VMFVT.js";
import {
  b as b3
} from "./chunk-LLJZCFHW.js";
import "./chunk-VIUFBDIY.js";
import "./chunk-TXIL3QUC.js";
import "./chunk-2ASAB4KA.js";
import {
  f as f2
} from "./chunk-EA74CF7B.js";
import {
  c
} from "./chunk-IGNUVZ34.js";
import "./chunk-LTSQHA4C.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-T4EIRKFE.js";
import {
  g
} from "./chunk-OHUWK5XV.js";
import "./chunk-PHVKM5OH.js";
import "./chunk-KQ5GHUVQ.js";
import {
  J,
  on
} from "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-ZK2DM5OJ.js";
import "./chunk-JQIB7GFW.js";
import {
  d as d3
} from "./chunk-CJJCN7PA.js";
import {
  k
} from "./chunk-IJUFAIOF.js";
import "./chunk-MNMU4ARP.js";
import "./chunk-7OW2VNCC.js";
import "./chunk-AFBYZF6Q.js";
import "./chunk-IJ42YN7D.js";
import "./chunk-4AGGGL2W.js";
import {
  i
} from "./chunk-FJPG3YI6.js";
import "./chunk-BJHLU2MM.js";
import {
  r
} from "./chunk-E5KBRIJQ.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-TW7VY7XV.js";
import {
  g as g2,
  p as p7,
  x
} from "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import "./chunk-BL2UGYYZ.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import {
  p
} from "./chunk-PNUUOKAJ.js";
import {
  C,
  v,
  w
} from "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import {
  V as V2
} from "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import {
  j
} from "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import {
  _
} from "./chunk-66KCMKB5.js";
import {
  o
} from "./chunk-ZART2Y5J.js";
import "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import {
  U,
  V
} from "./chunk-WC4SPMPL.js";
import {
  e as e2,
  f2 as f,
  u3 as u,
  y
} from "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import {
  a3 as a2,
  s3 as s2,
  t
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  a as a3,
  b
} from "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/layers/support/sceneLayerCacheUtils.js
function e4({ associatedLayer: e6, serviceUpdateTimeStamp: t8 }) {
  var _a;
  const n4 = (_a = e6 == null ? void 0 : e6.editingInfo) == null ? void 0 : _a.lastEditDate, r3 = e6 == null ? void 0 : e6.serverGens, a7 = null != n4, i5 = null != t8, s8 = a7 && i5 && t8.lastUpdate !== n4.getTime();
  return a7 && (s8 || !i5 && (r3 == null ? void 0 : r3.minServerGen) !== (r3 == null ? void 0 : r3.serverGen));
}

// ../node_modules/@arcgis/core/layers/mixins/TemporalSceneLayer.js
var a6 = (i5) => {
  let a7 = class extends i5 {
    constructor() {
      super(...arguments), this.serviceTimeInfo = null;
    }
    get timeInfo() {
      var _a;
      const e6 = (_a = this.associatedLayer) == null ? void 0 : _a.timeInfo;
      if (null == e6) return null;
      const t8 = e6.clone();
      return g2(t8, this.fieldsIndex), t8;
    }
    set timeInfo(e6) {
      g2(e6, this.fieldsIndex), this._override("timeInfo", e6);
    }
    get timeExtent() {
      var _a;
      return (_a = this.associatedLayer) == null ? void 0 : _a.timeExtent;
    }
    set timeExtent(e6) {
      this._override("timeExtent", e6);
    }
    get timeOffset() {
      var _a;
      return (_a = this.associatedLayer) == null ? void 0 : _a.timeOffset;
    }
    set timeOffset(e6) {
      this._override("timeOffset", e6);
    }
    get datesInUnknownTimezone() {
      var _a;
      return ((_a = this.associatedLayer) == null ? void 0 : _a.datesInUnknownTimezone) ?? false;
    }
    set datesInUnknownTimezone(e6) {
      this._override("datesInUnknownTimezone", e6);
    }
    async loadTimeInfoFromService(e6) {
      const { serviceTimeInfo: r3 } = this;
      if (null == r3) return;
      const { startTimeField: i6, endTimeField: s8 } = r3;
      if (null == i6 && null == s8) return;
      if (e4({ associatedLayer: this.associatedLayer, serviceUpdateTimeStamp: this.serviceUpdateTimeStamp })) return;
      const n4 = async (t8) => {
        var _a;
        let r4 = null;
        try {
          const i7 = await ((_a = this.fetchStatistics) == null ? void 0 : _a.call(this, t8, e6));
          r4 = i7 == null ? void 0 : i7.stats;
        } catch {
        }
        if (null == r4) return null;
        const { minTimeStr: s9, min: n5, maxTimeStr: o3, max: l6 } = r4, m3 = t8 === i6 ? s9 ?? n5 : o3 ?? l6;
        return null != m3 ? new Date(m3) : null;
      }, [o2, a8] = await Promise.all([n4(i6), n4(s8)]);
      if (null != i6 && null == o2 || null != s8 && null == a8) return;
      const c4 = new c({ start: o2, end: a8 });
      this.setAtOrigin("timeInfo", new d2({ endField: s8, startField: i6, fullTimeExtent: c4 }), "service");
    }
  };
  return e([y({ type: d2, json: { read: false, write: false } })], a7.prototype, "timeInfo", null), e([y({ type: c, json: { read: false, write: false } })], a7.prototype, "timeExtent", null), e([y({ type: l3, json: { read: false, write: false } })], a7.prototype, "timeOffset", null), e([y({ type: Boolean, nonNullable: true, json: { read: false, write: false } })], a7.prototype, "datesInUnknownTimezone", null), e([y({ type: c2, readOnly: true, json: { read: { source: "timeInfo" } } })], a7.prototype, "serviceTimeInfo", void 0), a7 = e([a2("esri.layers.mixins.TemporalSceneLayer")], a7), a7;
};
var c2 = class extends f {
  constructor() {
    super(...arguments), this.endTimeField = null, this.startTimeField = null;
  }
};
e([y({ type: String })], c2.prototype, "endTimeField", void 0), e([y({ type: String })], c2.prototype, "startTimeField", void 0), c2 = e([a2("esri.layers.mixins.TemporalSceneLayer.SceneServiceTimeInfo")], c2);

// ../node_modules/@arcgis/core/layers/support/RangeInfo.js
var s7 = class extends f {
  constructor() {
    super(...arguments), this.name = null, this.field = null, this.currentRangeExtent = null, this.fullRangeExtent = null, this.type = "rangeInfo";
  }
};
e([y({ type: String, json: { read: true, write: true } })], s7.prototype, "name", void 0), e([y({ type: String, json: { read: true, write: true } })], s7.prototype, "field", void 0), e([y({ type: [Number], json: { read: true, write: true } })], s7.prototype, "currentRangeExtent", void 0), e([y({ type: [Number], json: { read: true, write: true } })], s7.prototype, "fullRangeExtent", void 0), e([y({ type: ["rangeInfo"], readOnly: true, json: { read: false, write: true } })], s7.prototype, "type", void 0), s7 = e([a2("esri.layers.support.RangeInfo")], s7);

// ../node_modules/@arcgis/core/layers/support/PolygonCollection.js
var c3;
var p8 = c3 = class extends u(V2.ofType(j)) {
  constructor(e6) {
    super(e6);
  }
  clone() {
    return new c3(this.items.map((e6) => e6.clone()));
  }
  write(e6, r3) {
    return this.toJSON(r3);
  }
  toJSON(e6) {
    var _a;
    const r3 = (_a = e6 == null ? void 0 : e6.layer) == null ? void 0 : _a.spatialReference;
    return r3 ? this.toArray().map((t8) => {
      if (!r3.equals(t8.spatialReference)) {
        if (!J(t8.spatialReference, r3)) return (e6 == null ? void 0 : e6.messages) && e6.messages.push(new s2("scenefilter:unsupported", "Scene filters with incompatible spatial references are not supported", { modification: this, spatialReference: e6.layer.spatialReference, context: e6 })), null;
        const s9 = new j();
        on(t8, s9, r3), t8 = s9;
      }
      const s8 = t8.toJSON(e6);
      return delete s8.spatialReference, s8;
    }).filter((e7) => null != e7) : ((e6 == null ? void 0 : e6.messages) && e6.messages.push(new s2("scenefilter:unsupported", "Writing Scene filters without context layer is not supported", { modification: this, spatialReference: e6.layer.spatialReference, context: e6 })), this.toArray().map((r4) => r4.toJSON(e6)));
  }
  static fromJSON(e6, r3) {
    const t8 = new c3();
    return e6.forEach((e7) => t8.add(j.fromJSON(e7, r3))), t8;
  }
};
p8 = c3 = e([a2("esri.layers.support.PolygonCollection")], p8);
var l5 = p8;

// ../node_modules/@arcgis/core/layers/support/SceneFilter.js
var u3;
var g3 = u3 = class extends f {
  constructor(e6) {
    super(e6), this.spatialRelationship = "disjoint", this.geometries = new l5(), this._geometriesSource = null;
  }
  initialize() {
    this.addHandles(v(() => this.geometries, "after-changes", () => this.geometries = this.geometries, C));
  }
  readGeometries(e6, r3, o2) {
    Array.isArray(e6) ? this.geometries = l5.fromJSON(e6, o2) : this._geometriesSource = { url: p(e6, o2), context: o2 };
  }
  async loadGeometries(e6, o2) {
    if (null == this._geometriesSource) return;
    const { url: s8, context: t8 } = this._geometriesSource, i5 = await U(s8, { responseType: "json", signal: o2 == null ? void 0 : o2.signal }), a7 = e6.toJSON(), p9 = i5.data.map((e7) => ({ ...e7, spatialReference: a7 }));
    this.geometries = l5.fromJSON(p9, t8), this._geometriesSource = null;
  }
  clone() {
    const e6 = new u3({ geometries: a(this.geometries), spatialRelationship: this.spatialRelationship });
    return e6._geometriesSource = this._geometriesSource, e6;
  }
};
e([y({ type: ["disjoint", "contains"], nonNullable: true, json: { write: true } })], g3.prototype, "spatialRelationship", void 0), e([y({ type: l5, nonNullable: true, json: { write: true } }), j3({ origins: ["web-scene", "portal-item"], type: "resource", prefix: "geometries", contentAddressed: true })], g3.prototype, "geometries", void 0), e([o(["web-scene", "portal-item"], "geometries")], g3.prototype, "readGeometries", null), g3 = u3 = e([a2("esri.layers.support.SceneFilter")], g3);
var h = g3;

// ../node_modules/@arcgis/core/layers/support/sceneLayerStatistics.js
async function i4({ fieldName: i5, statisticsInfo: a7, errorContext: o2, fieldsIndex: r3, path: n4, customParameters: l6, apiKey: c4, signal: f4 }) {
  if (null == a7) throw new s(`${o2}:no-cached-statistics`, "Cached statistics are not available for this layer");
  const d4 = r3.get(i5);
  if (null == d4) throw new s(`${o2}:field-unexisting`, `Field '${i5}' does not exist on the layer`);
  const h2 = a7.find((t8) => t8.name === d4.name);
  if (null == h2) throw new s(`${o2}:no-cached-statistics`, "Cached statistics for this attribute are not available");
  const m3 = V(n4, h2.href), { data: u4 } = await U(m3, { query: { f: "json", ...l6, token: c4 }, responseType: "json", signal: f4 });
  return u4;
}

// ../node_modules/@arcgis/core/support/zipUtils.js
async function e5(e6) {
  const r3 = [];
  for (const n4 of e6) n4.name.toLowerCase().endsWith(".zip") ? r3.push(t7(n4)) : r3.push(Promise.resolve(n4));
  return (await Promise.all(r3)).flat();
}
async function t7(e6) {
  const { BlobReader: t8, ZipReader: r3, BlobWriter: n4 } = await import("./zipjs-wrapper-TKZRVNJW.js"), a7 = [], i5 = new r3(new t8(e6));
  return (await i5.getEntries()).forEach((e7) => {
    var _a;
    if (e7.directory || /^__MACOS/i.test(e7.filename)) return;
    const t9 = new n4(), r4 = (_a = e7.getData) == null ? void 0 : _a.call(e7, t9).then((t10) => new File([t10], e7.filename));
    r4 && a7.push(r4);
  }), Promise.all(a7);
}

// ../node_modules/@arcgis/core/layers/SceneLayer.js
var Ie = /* @__PURE__ */ new Set(["3DObject", "Point"]);
var Le = s5();
var je = class extends a6(F(L(l2(b2(j2(t4(S(e3(i2(i(f2))))))))))) {
  constructor(...e6) {
    super(...e6), this.featureReduction = null, this.rangeInfos = null, this.operationalLayerType = "ArcGISSceneServiceLayer", this.type = "scene", this.fields = null, this.floorInfo = null, this.outFields = null, this.nodePages = null, this.materialDefinitions = null, this.textureSetDefinitions = null, this.geometryDefinitions = null, this.serviceUpdateTimeStamp = null, this.excludeObjectIds = new V2(), this.definitionExpression = null, this.filter = null, this.path = null, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.priority = null, this.semantic = null, this.cachedDrawingInfo = { color: false }, this.popupEnabled = true, this.popupTemplate = null, this.objectIdField = null, this.globalIdField = null, this._fieldUsageInfo = {}, this.screenSizePerspectiveEnabled = true, this.serviceItemId = void 0;
  }
  normalizeCtorArgs(e6, t8) {
    return "string" == typeof e6 ? { url: e6, ...t8 } : e6;
  }
  destroy() {
    this._set("renderer", null);
  }
  getField(e6) {
    return this.fieldsIndex.get(e6);
  }
  getFieldDomain(e6, t8) {
    var _a, _b, _c;
    const r3 = (_b = (_a = this.getFeatureType(t8 == null ? void 0 : t8.feature)) == null ? void 0 : _a.domains) == null ? void 0 : _b[e6];
    return r3 && "inherited" !== r3.type ? r3 : ((_c = this.getField(e6)) == null ? void 0 : _c.domain) ?? null;
  }
  getFeatureType(e6) {
    return e6 && this.associatedLayer ? this.associatedLayer.getFeatureType(e6) : null;
  }
  get types() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.types) ?? [];
  }
  get typeIdField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.typeIdField) ?? null;
  }
  get templates() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.templates) ?? null;
  }
  get formTemplate() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.formTemplate) ?? null;
  }
  get fieldsIndex() {
    return new Z(this.fields);
  }
  readNodePages(e6, t8, r3) {
    return "Point" === t8.layerType && (e6 = t8.pointNodePages), null == e6 || "object" != typeof e6 ? null : p5.fromJSON(e6, r3);
  }
  set elevationInfo(e6) {
    this._set("elevationInfo", e6), this.loaded && this._validateElevationInfo();
  }
  get effectiveCapabilities() {
    var _a;
    return this._capabilitiesFromAssociatedFeatureLayer((_a = this.associatedLayer) == null ? void 0 : _a.effectiveCapabilities);
  }
  get effectiveEditingEnabled() {
    return null != this.associatedLayer && v2(this.associatedLayer);
  }
  get geometryType() {
    return Se[this.profile] || "mesh";
  }
  set renderer(e6) {
    p7(e6, this.fieldsIndex), this._set("renderer", e6);
  }
  readCachedDrawingInfo(e6) {
    return null != e6 && "object" == typeof e6 || (e6 = {}), null == e6.color && (e6.color = false), e6;
  }
  get capabilities() {
    var _a;
    return this._capabilitiesFromAssociatedFeatureLayer((_a = this.associatedLayer) == null ? void 0 : _a.capabilities);
  }
  _capabilitiesFromAssociatedFeatureLayer(e6) {
    var _a;
    e6 = null != e6 ? e6 : s6;
    const { query: t8, queryRelated: r3, editing: { supportsGlobalId: i5, supportsRollbackOnFailure: s8, supportsUploadWithItemId: o2, supportsGeometryUpdate: a7, supportsReturnServiceEditsInSourceSpatialReference: n4 }, data: { supportsZ: l6, supportsM: p9, isVersioned: d4, supportsAttachment: u4 }, operations: { supportsEditing: y4, supportsAdd: c4, supportsUpdate: h2, supportsDelete: m3, supportsQuery: f4, supportsQueryAttachments: g4, supportsAsyncConvert3D: v3 } } = e6, b4 = e6.operations.supportsChangeTracking, w3 = !!((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) && n2();
    return { query: t8, queryRelated: r3, editing: { supportsGlobalId: i5, supportsReturnServiceEditsInSourceSpatialReference: n4, supportsRollbackOnFailure: s8, supportsGeometryUpdate: w3 && a7, supportsUploadWithItemId: o2 }, data: { supportsAttachment: u4, supportsZ: l6, supportsM: p9, isVersioned: d4 }, operations: { supportsQuery: f4, supportsQueryAttachments: g4, supportsEditing: y4 && b4, supportsAdd: w3 && c4 && b4, supportsDelete: w3 && m3 && b4, supportsUpdate: h2 && b4, supportsAsyncConvert3D: v3 } };
  }
  get editingEnabled() {
    var _a;
    return this._isOverridden("editingEnabled") ? this._get("editingEnabled") : ((_a = this.associatedLayer) == null ? void 0 : _a.editingEnabled) ?? false;
  }
  set editingEnabled(e6) {
    this._overrideIfSome("editingEnabled", e6);
  }
  get infoFor3D() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) ?? null;
  }
  get relationships() {
    var _a;
    return (_a = this.associatedLayer) == null ? void 0 : _a.relationships;
  }
  get defaultPopupTemplate() {
    return this.associatedLayer || this.attributeStorageInfo ? this.createPopupTemplate() : null;
  }
  readObjectIdField(e6, t8) {
    return !e6 && t8.fields && t8.fields.some((t9) => ("esriFieldTypeOID" === t9.type && (e6 = t9.name), !!e6)), e6 || void 0;
  }
  readGlobalIdField(e6, t8) {
    return !e6 && t8.fields && t8.fields.some((t9) => ("esriFieldTypeGlobalID" === t9.type && (e6 = t9.name), !!e6)), e6 || void 0;
  }
  get displayField() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.displayField) ?? null;
  }
  readProfile(e6, t8) {
    const r3 = t8.store.profile;
    return null != r3 && Fe[r3] ? Fe[r3] : (n.getLogger(this).error("Unknown or missing profile", { profile: r3, layer: this }), "mesh-pyramids");
  }
  get useViewTime() {
    var _a;
    return ((_a = this.associatedLayer) == null ? void 0 : _a.useViewTime) ?? true;
  }
  set useViewTime(e6) {
    this._override("useViewTime", e6);
  }
  load(e6) {
    return this.addResolvingPromise(this._load(e6)), Promise.resolve(this);
  }
  async _load(e6) {
    const t8 = null != e6 ? e6.signal : null;
    await this.loadFromPortal({ supportedTypes: ["Scene Service"] }, e6).catch(a3), await this._fetchService(t8), await Promise.all([this._fetchIndexAndUpdateExtent(this.nodePages, t8), this._setAssociatedFeatureLayer(t8), this._loadFilterGeometries()]), this._validateElevationInfo(), this._applyAssociatedLayerOverrides(), this._populateFieldUsageInfo(), await this.loadTimeInfoFromService(e6), await t3(this, { origin: "service" }, t8), p7(this.renderer, this.fieldsIndex), await this.finishLoadEditablePortalLayer(e6);
  }
  async beforeSave() {
    null != this.filter && (this.filter = this.filter.clone(), await this.load());
  }
  async _loadFilterGeometries() {
    if (this.filter) try {
      await this.filter.loadGeometries(this.spatialReference);
    } catch (e6) {
      n.getLogger(this).error("#_loadFilterGeometries()", this, "Failed to load filter geometries. Geometry filter will not be applied for this layer.", { error: e6 }), this.filter = null;
    }
  }
  createQuery() {
    var _a;
    const e6 = new b3();
    return "mesh" === this.geometryType ? ((_a = this.associatedLayer) == null ? void 0 : _a.infoFor3D) && (e6.returnGeometry = true) : (e6.returnGeometry = true, e6.returnZ = true), e6.where = this.definitionExpression || "1=1", e6.sqlFormat = "standard", e6.outFields = ["*"], e6;
  }
  queryExtent(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryExtent(e6 || this.createQuery(), t8));
  }
  queryFeatureCount(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryFeatureCount(e6 || this.createQuery(), t8));
  }
  queryFeatures(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryFeatures(e6 || this.createQuery(), t8)).then((e7) => {
      if (e7 == null ? void 0 : e7.features) for (const t9 of e7.features) t9.layer = this, t9.sourceLayer = this;
      return e7;
    });
  }
  async queryRelatedFeatures(e6, t8) {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeatures(e6, t8);
  }
  async queryRelatedFeaturesCount(e6, t8) {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    return this.associatedLayer.queryRelatedFeaturesCount(e6, t8);
  }
  async queryCachedAttributes(e6, t8) {
    var _a;
    const r3 = x(this.fieldsIndex, await n3(this, p6(this)));
    return $(((_a = this.parsedUrl) == null ? void 0 : _a.path) ?? "", this.attributeStorageInfo ?? [], e6, t8, r3, this.apiKey, this.customParameters);
  }
  async queryCachedFeature(e6, r3) {
    const i5 = await this.queryCachedAttributes(e6, [r3]);
    if (!i5 || 0 === i5.length) throw new s("scenelayer:feature-not-in-cached-data", "Feature not found in cached data");
    const s8 = new d3();
    return s8.attributes = i5[0], s8.layer = this, s8.sourceLayer = this, s8;
  }
  queryObjectIds(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryObjectIds(e6 || this.createQuery(), t8));
  }
  queryAttachments(e6, t8) {
    return this._getAssociatedLayerForQuery().then((r3) => r3.queryAttachments(e6, t8));
  }
  getFieldUsageInfo(e6) {
    const t8 = { supportsLabelingInfo: false, supportsRenderer: false, supportsPopupTemplate: false, supportsLayerQuery: false };
    return this.loaded ? this._fieldUsageInfo[e6] || t8 : (n.getLogger(this).error("#getFieldUsageInfo()", "Unavailable until layer is loaded"), t8);
  }
  createPopupTemplate(e6) {
    return p4(this, e6);
  }
  _getAssociatedLayerForQuery() {
    const e6 = this.associatedLayer;
    return (e6 == null ? void 0 : e6.loaded) ? Promise.resolve(e6) : this._loadAssociatedLayerForQuery();
  }
  async _loadAssociatedLayerForQuery() {
    if (await this.load(), !this.associatedLayer) throw new s("scenelayer:query-not-available", "SceneLayer queries are not available without an associated feature layer", { layer: this });
    try {
      await this.associatedLayer.load();
    } catch (e6) {
      throw new s("scenelayer:query-not-available", "SceneLayer associated feature layer could not be loaded", { layer: this, error: e6 });
    }
    return this.associatedLayer;
  }
  hasCachedStatistics(e6) {
    return null != this.statisticsInfo && this.statisticsInfo.some((t8) => t8.name === e6);
  }
  async queryCachedStatistics(e6, t8) {
    return await this.load(t8), await this.fetchStatistics(e6, t8);
  }
  async saveAs(e6, t8) {
    return this._debouncedSaveOperations(C3.SAVE_AS, { ...t8, getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" }, e6);
  }
  async save() {
    const e6 = { getTypeKeywords: () => this._getTypeKeywords(), portalItemLayerType: "scene" };
    return this._debouncedSaveOperations(C3.SAVE, e6);
  }
  async applyEdits(e6, t8) {
    const { applyEdits: r3 } = await import("./editingSupport-J2DCR5VH.js");
    let i5 = t8;
    await this.load();
    const s8 = this.associatedLayer;
    if (!s8) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    await s8.load();
    const { globalIdField: o2 } = s8, n4 = !!s8.infoFor3D, l6 = (i5 == null ? void 0 : i5.globalIdUsed) ?? true;
    if (n4 && null == o2) throw new s(`${this.type}-layer:not-editable`, "Valid globalIdField expected on editable SceneLayer");
    if (n4 && !l6) throw new s(`${this.type}-layer:globalid-required`, "globalIdUsed must not be false for SceneLayer editing as globalIds are required.");
    return g(s8.url) && n4 && null != e6.deleteFeatures && null != o2 && (i5 = { ...i5, globalIdToObjectId: await J2(s8, e6.deleteFeatures, o2) }), r3(this, s8.source, e6, i5);
  }
  async uploadAssets(e6, t8) {
    if (await this.load(), null == this.associatedLayer) throw new s(`${this.type}-layer:not-editable`, "Service is not editable");
    return await this.associatedLayer.load(), this.associatedLayer.uploadAssets(e6, t8);
  }
  on(e6, t8) {
    return super.on(e6, t8);
  }
  async convertMesh(e6, t8) {
    const r3 = (e7) => {
      throw n.getLogger(this).error(".convertMesh()", e7.message), e7;
    };
    await this.load(), this.infoFor3D || r3(new s("invalid:layer", "SceneLayer has no capability for mesh conversion"));
    const i5 = await this.extractAndFilterFiles(e6), s8 = i5.reduce((e7, t9) => r2(this.infoFor3D, t9) ? e7 + 1 : e7, 0);
    0 === s8 && r3(new i3()), s8 > 1 && r3(new m());
    const o2 = this.spatialReference, l6 = (t8 == null ? void 0 : t8.location) ?? new _({ x: 0, y: 0, z: 0, spatialReference: o2 }), p9 = l6.spatialReference.isGeographic ? "local" : "georeferenced", d4 = $2.createWithExternalSource(l6, i5, { vertexSpace: p9 }), [u4] = await this.uploadAssets([d4], t8);
    return u4;
  }
  async extractAndFilterFiles(e6) {
    await this.load();
    const t8 = this.infoFor3D;
    if (!t8) return e6;
    return (await e5(e6)).filter((e7) => t5(t8, e7));
  }
  validateLayer(e6) {
    if (e6.layerType && !Ie.has(e6.layerType)) throw new s("scenelayer:layer-type-not-supported", "SceneLayer does not support this layer type", { layerType: e6.layerType });
    if (isNaN(this.version.major) || isNaN(this.version.minor)) throw new s("layer:service-version-not-supported", "Service version is not supported.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    if (this.version.major > 2) throw new s("layer:service-version-too-new", "Service version is too new.", { serviceVersion: this.version.versionString, supportedVersions: "1.x, 2.x" });
    function t8(e7, t9) {
      let r3 = false, i5 = false;
      if (null == e7) r3 = true, i5 = true;
      else {
        const s8 = t9 && t9.isGeographic;
        switch (e7) {
          case "east-north-up":
          case "earth-centered":
            r3 = true, i5 = s8;
            break;
          case "vertex-reference-frame":
            r3 = true, i5 = !s8;
            break;
          default:
            r3 = false;
        }
      }
      if (!r3) throw new s("scenelayer:unsupported-normal-reference-frame", "Normal reference frame is invalid.");
      if (!i5) throw new s("scenelayer:incompatible-normal-reference-frame", "Normal reference frame is incompatible with layer spatial reference.");
    }
    t8(this.normalReferenceFrame, this.spatialReference);
  }
  _getTypeKeywords() {
    const e6 = [];
    if ("points" === this.profile) e6.push("Point");
    else {
      if ("mesh-pyramids" !== this.profile) throw new s("scenelayer:unknown-profile", "SceneLayer:save() encountered an unknown SceneLayer profile: " + this.profile);
      e6.push("3DObject");
    }
    return e6;
  }
  _populateFieldUsageInfo() {
    var _a, _b, _c;
    if (this._fieldUsageInfo = {}, this.fields) for (const e6 of this.fields) {
      const t8 = !!((_a = this.attributeStorageInfo) == null ? void 0 : _a.some((t9) => t9.name === e6.name)), r3 = !!((_c = (_b = this.associatedLayer) == null ? void 0 : _b.fields) == null ? void 0 : _c.some((t9) => t9 && e6.name === t9.name)), i5 = { supportsLabelingInfo: t8, supportsRenderer: t8, supportsPopupTemplate: t8 || r3, supportsLayerQuery: r3 };
      this._fieldUsageInfo[e6.name] = i5;
    }
  }
  _applyAssociatedLayerOverrides() {
    this._applyAssociatedLayerFieldsOverrides(), this._applyAssociatedLayerPopupOverrides(), this._applyAssociatedLayerExtentOverride(), this._applyAssociatedLayerPrivileges();
  }
  _applyAssociatedLayerFieldsOverrides() {
    var _a;
    if (!((_a = this.associatedLayer) == null ? void 0 : _a.fields)) return;
    let e6 = null;
    for (const t8 of this.associatedLayer.fields) {
      const r3 = this.getField(t8.name);
      r3 ? (!r3.domain && t8.domain && (r3.domain = t8.domain.clone()), r3.editable = t8.editable, r3.nullable = t8.nullable, r3.length = t8.length) : (e6 || (e6 = this.fields ? this.fields.slice() : []), e6.push(t8.clone()));
    }
    e6 && this._set("fields", e6);
  }
  _applyAssociatedLayerPopupOverrides() {
    if (!this.associatedLayer) return;
    const e6 = ["popupTemplate", "popupEnabled"], t8 = t(this);
    for (let r3 = 0; r3 < e6.length; r3++) {
      const i5 = e6[r3], s8 = this.originIdOf(i5), o2 = this.associatedLayer.originIdOf(i5);
      s8 < o2 && (o2 === e2.SERVICE || o2 === e2.PORTAL_ITEM) && t8.setAtOrigin(i5, this.associatedLayer[i5], o2);
    }
  }
  _applyAssociatedLayerExtentOverride() {
    var _a, _b, _c;
    const e6 = (_a = this.associatedLayer) == null ? void 0 : _a.getAtOrigin("fullExtent", "service");
    if (!(n2() && null != ((_b = this.associatedLayer) == null ? void 0 : _b.infoFor3D) && e6 && g((_c = this.associatedLayer) == null ? void 0 : _c.url) && e4(this))) return;
    t(this).setAtOrigin("fullExtent", e6.clone(), e2.SERVICE);
  }
  _applyAssociatedLayerPrivileges() {
    const e6 = this.associatedLayer;
    e6 && (this._set("userHasEditingPrivileges", e6.userHasEditingPrivileges), this._set("userHasFullEditingPrivileges", e6.userHasFullEditingPrivileges), this._set("userHasUpdateItemPrivileges", e6.userHasUpdateItemPrivileges));
  }
  async _setAssociatedFeatureLayer(e6) {
    if (["mesh-pyramids", "points"].includes(this.profile)) try {
      const { serverUrl: t8, layerId: r3, portalItem: i5 } = await s3(`${this.url}/layers/${this.layerId}`, { sceneLayerItem: this.portalItem, customParameters: this.customParameters, apiKey: this.apiKey, signal: e6 }), s8 = await a5.FeatureLayer();
      this.associatedLayer = new s8({ url: t8, customParameters: this.customParameters, layerId: r3, portalItem: i5 }), await this.associatedLayer.load();
    } catch (t8) {
      b(t8) || this._logWarningOnPopupEnabled();
    }
  }
  async _logWarningOnPopupEnabled() {
    await w(() => this.popupEnabled && null != this.popupTemplate);
    const e6 = `this SceneLayer: ${this.title}`;
    null == this.attributeStorageInfo ? n.getLogger(this).warn(`Associated FeatureLayer could not be loaded and no binary attributes found. Popups will not work on ${e6}`) : n.getLogger(this).info(`Associated FeatureLayer could not be loaded. Falling back to binary attributes for Popups on ${e6}`);
  }
  _validateElevationInfo() {
    const e6 = this.elevationInfo;
    "mesh-pyramids" === this.profile && $3(n.getLogger(this), P("Mesh scene layers", "relative-to-scene", e6)), $3(n.getLogger(this), w2("Scene layers", e6));
  }
  async fetchStatistics(e6, t8) {
    var _a;
    return await i4({ fieldName: e6, statisticsInfo: this.statisticsInfo, errorContext: "scenelayer", fieldsIndex: this.fieldsIndex, path: ((_a = this.parsedUrl) == null ? void 0 : _a.path) ?? "", customParameters: this.customParameters, apiKey: this.apiKey, signal: t8 == null ? void 0 : t8.signal });
  }
};
e([y({ types: { key: "type", base: t6, typeMap: { selection: p3 } }, json: { origins: { "web-scene": { name: "layerDefinition.featureReduction", write: true }, "portal-item": { name: "layerDefinition.featureReduction", write: true } } } })], je.prototype, "featureReduction", void 0), e([y({ type: [s7], json: { read: false, origins: { "web-scene": { name: "layerDefinition.rangeInfos", write: true }, "portal-item": { name: "layerDefinition.rangeInfos", write: true } } } })], je.prototype, "rangeInfos", void 0), e([y({ json: { read: false } })], je.prototype, "associatedLayer", void 0), e([y({ type: ["show", "hide"] })], je.prototype, "listMode", void 0), e([y({ type: ["ArcGISSceneServiceLayer"] })], je.prototype, "operationalLayerType", void 0), e([y({ json: { read: false }, readOnly: true })], je.prototype, "type", void 0), e([y({ ...Le.fields, readOnly: true, json: { read: false, origins: { service: { read: true } } } })], je.prototype, "fields", void 0), e([y()], je.prototype, "types", null), e([y()], je.prototype, "typeIdField", null), e([y()], je.prototype, "templates", null), e([y()], je.prototype, "formTemplate", null), e([y({ readOnly: true, clonable: false })], je.prototype, "fieldsIndex", null), e([y({ type: p2, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], je.prototype, "floorInfo", void 0), e([y(Le.outFields)], je.prototype, "outFields", void 0), e([y({ type: p5, readOnly: true, json: { read: false } })], je.prototype, "nodePages", void 0), e([o("service", "nodePages", ["nodePages", "pointNodePages"])], je.prototype, "readNodePages", null), e([y({ type: [a4], readOnly: true })], je.prototype, "materialDefinitions", void 0), e([y({ type: [y3], readOnly: true })], je.prototype, "textureSetDefinitions", void 0), e([y({ type: [m2], readOnly: true })], je.prototype, "geometryDefinitions", void 0), e([y({ readOnly: true })], je.prototype, "serviceUpdateTimeStamp", void 0), e([y({ readOnly: true })], je.prototype, "attributeStorageInfo", void 0), e([y({ readOnly: true })], je.prototype, "statisticsInfo", void 0), e([y({ type: V2.ofType(Number), nonNullable: true, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.excludeObjectIds", write: { enabled: true } } })], je.prototype, "excludeObjectIds", void 0), e([y({ type: String, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], je.prototype, "definitionExpression", void 0), e([y({ type: h, json: { name: "layerDefinition.polygonFilter", write: { enabled: true, allowNull: true }, origins: { service: { read: false, write: false } } } })], je.prototype, "filter", void 0), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], je.prototype, "path", void 0), e([y(d)], je.prototype, "elevationInfo", null), e([y({ readOnly: true, json: { read: false } })], je.prototype, "effectiveCapabilities", null), e([y({ readOnly: true })], je.prototype, "effectiveEditingEnabled", null), e([y({ type: String })], je.prototype, "geometryType", null), e([y(l)], je.prototype, "labelsVisible", void 0), e([y({ type: [C2], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: { reader: l4 }, write: false } }, name: "layerDefinition.drawingInfo.labelingInfo", read: { reader: l4 }, write: true } })], je.prototype, "labelingInfo", void 0), e([y(y2)], je.prototype, "legendEnabled", void 0), e([y({ type: Number, json: { origins: { "web-document": { default: 1, write: { enabled: true, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } }, read: { source: ["opacity", "layerDefinition.drawingInfo.transparency"], reader(e6, t8) {
  var _a, _b;
  if ("number" == typeof e6 && e6 >= 0 && e6 <= 1) return e6;
  const r3 = (_b = (_a = t8.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.transparency;
  return void 0 !== r3 ? r(r3) : void 0;
} } }, "portal-item": { write: true }, service: { read: false } } } })], je.prototype, "opacity", void 0), e([y({ type: ["Low", "High"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], je.prototype, "priority", void 0), e([y({ type: ["Labels"], readOnly: true, json: { read: false, origins: { service: { read: true } } } })], je.prototype, "semantic", void 0), e([y({ types: u2, json: { origins: { service: { read: { source: "drawingInfo.renderer" } } }, name: "layerDefinition.drawingInfo.renderer", write: true }, value: null })], je.prototype, "renderer", null), e([y({ json: { read: false } })], je.prototype, "cachedDrawingInfo", void 0), e([o("service", "cachedDrawingInfo")], je.prototype, "readCachedDrawingInfo", null), e([y({ readOnly: true, json: { read: false } })], je.prototype, "capabilities", null), e([y({ type: Boolean, json: { read: false } })], je.prototype, "editingEnabled", null), e([y({ readOnly: true, json: { write: false, read: false } })], je.prototype, "infoFor3D", null), e([y({ readOnly: true, json: { write: false, read: false } })], je.prototype, "relationships", null), e([y(s4)], je.prototype, "popupEnabled", void 0), e([y({ type: k, json: { name: "popupInfo", write: true } })], je.prototype, "popupTemplate", void 0), e([y({ readOnly: true, json: { read: false } })], je.prototype, "defaultPopupTemplate", null), e([y({ type: String, json: { read: false } })], je.prototype, "objectIdField", void 0), e([o("service", "objectIdField", ["objectIdField", "fields"])], je.prototype, "readObjectIdField", null), e([y({ type: String, json: { read: false } })], je.prototype, "globalIdField", void 0), e([o("service", "globalIdField", ["globalIdField", "fields"])], je.prototype, "readGlobalIdField", null), e([y({ readOnly: true, type: String, json: { read: false } })], je.prototype, "displayField", null), e([y({ type: String, json: { read: false } })], je.prototype, "profile", void 0), e([o("service", "profile", ["store.profile"])], je.prototype, "readProfile", null), e([y({ readOnly: true, type: String, json: { origins: { service: { read: { source: "store.normalReferenceFrame" } } }, read: false } })], je.prototype, "normalReferenceFrame", void 0), e([y(t2)], je.prototype, "screenSizePerspectiveEnabled", void 0), e([y({ json: { read: false, origins: { service: { read: true } } } })], je.prototype, "serviceItemId", void 0), e([y(f3)], je.prototype, "useViewTime", null), je = e([a2("esri.layers.SceneLayer")], je);
var Fe = { "mesh-pyramids": "mesh-pyramids", meshpyramids: "mesh-pyramids", "features-meshes": "mesh-pyramids", points: "points", "features-points": "points", lines: "lines", "features-lines": "lines", polygons: "polygons", "features-polygons": "polygons" };
var Se = { "mesh-pyramids": "mesh", points: "point" };
var _e = je;
export {
  _e as default
};
//# sourceMappingURL=SceneLayer-XOAH4ZY5.js.map
