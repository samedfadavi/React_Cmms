import {
  a as a2
} from "./chunk-YIOOQ6H5.js";
import {
  d as d3
} from "./chunk-2AVWLUOJ.js";
import {
  i as i3
} from "./chunk-DJNOJGGH.js";
import {
  e as e2,
  t as t2
} from "./chunk-WDUHCD3V.js";
import {
  Ze
} from "./chunk-4X27YGEY.js";
import {
  r
} from "./chunk-4SCOCLA2.js";
import {
  c,
  c2,
  g,
  h,
  i as i2,
  l,
  t
} from "./chunk-ZT5UNVCE.js";
import {
  S as S3
} from "./chunk-E7HFITKU.js";
import {
  b as b2
} from "./chunk-LLJZCFHW.js";
import {
  d
} from "./chunk-OHUWK5XV.js";
import {
  S as S2
} from "./chunk-KQ5GHUVQ.js";
import {
  d as d2
} from "./chunk-CJJCN7PA.js";
import {
  o
} from "./chunk-Z32PAECZ.js";
import {
  y as y2
} from "./chunk-ZH4RVBER.js";
import {
  m
} from "./chunk-YTTIKQNA.js";
import {
  w
} from "./chunk-66KCMKB5.js";
import {
  f as f2
} from "./chunk-F4OBDVPS.js";
import {
  i,
  n as n2
} from "./chunk-Z6R2SP3D.js";
import {
  I,
  U
} from "./chunk-WC4SPMPL.js";
import {
  S,
  f2 as f,
  u3 as u2,
  y
} from "./chunk-TJUEGVVG.js";
import {
  a3 as a
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  b,
  u
} from "./chunk-VMWKLHJD.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-YNL57W4I.js";

// ../node_modules/@arcgis/core/networks/support/TopologyValidationJobInfo.js
var n3 = i()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var l2 = class extends i3 {
  constructor(t3) {
    super(t3), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t3) {
    const s3 = { ...t3, query: { f: "json" } }, { data: r2 } = await U(this.statusUrl, s3);
    return this.read(r2), this.editsResolver && this.editsResolver.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], exceededTransferLimit: true, historicMoment: null }), this;
  }
  async waitForJobCompletion(t3 = {}) {
    const { interval: e4 = 1e3, statusCallback: s3 } = t3;
    return new Promise((t4, o2) => {
      this._clearTimer();
      const i5 = setInterval(() => {
        this._timer || o2(u()), this.checkJobStatus().then((e5) => {
          const { status: r2 } = e5;
          switch (this.status = r2, r2) {
            case "job-succeeded":
              this._clearTimer(), t4(this);
              break;
            case "job-waiting":
            case "job-executing":
              s3 && s3(this);
          }
        }, (t5) => {
          this._clearTimer(), o2(t5);
        });
      }, e4);
      this._timer = i5;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
e([y()], l2.prototype, "editsResolver", void 0), e([y({ type: String, json: { write: true } })], l2.prototype, "statusUrl", void 0), e([o(n3)], l2.prototype, "status", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t3, e4) => {
  e4.submissionTime = t3 ? t3.getTime() : null;
} } } })], l2.prototype, "submissionTime", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t3, e4) => {
  e4.lastUpdatedTime = t3 ? t3.getTime() : null;
} } } })], l2.prototype, "lastUpdatedTime", void 0), l2 = e([a("esri.networks.support.TopologyValidationJobInfo")], l2);
var m2 = l2;

// ../node_modules/@arcgis/core/networks/support/utils.js
async function l3(e4, t3) {
  if ("Utility Network Layer" === e4) {
    const { default: e5 } = await import("./UtilityNetwork-H67GT5KV.js");
    return new e5({ layerUrl: t3 });
  }
  return null;
}
async function i4(r2) {
  var _a;
  let a5 = "portalItem" in r2 ? r2 : { portalItem: r2 };
  !a5.portalItem || a5.portalItem instanceof S2 || (a5 = { ...a5, portalItem: new S2(a5.portalItem) });
  const n6 = a5.portalItem;
  if (await n6.load(), "Feature Service" !== n6.type) throw new s("portal:unknown-item-type", "Unknown item type '${type}'", { type: n6.type });
  const s3 = n6.url, i5 = await U(s3, { responseType: "json", query: { f: "json" } }), u3 = "Network Layer";
  if ((_a = i5.data.type) == null ? void 0 : _a.includes(u3)) return l3(i5.data.type, s3);
  if (i5.data.layers) {
    const e4 = i5.data.layers.find((e5) => e5.type.includes(u3));
    if (e4) {
      const t3 = `${s3}/${e4.id}`;
      return l3(e4.type, t3);
    }
  }
  return null;
}

// ../node_modules/@arcgis/core/networks/Network.js
var k = class extends S3(m) {
  static fromPortalItem(e4) {
    return i4(e4);
  }
  constructor(e4) {
    super(e4), this.id = null, this.title = null, this.layerUrl = null, this.dataElement = null, this.fullExtent = null, this.spatialReference = null, this.type = null, this.sourceJSON = null, this.gdbVersion = null, this.historicMoment = null, this._applyEditsHandler = (e5) => {
      const { serviceUrl: t3, gdbVersion: r2, result: o2 } = e5, s3 = t3 === this.featureServiceUrl, i5 = g(t3, r2, this.gdbVersion);
      s3 && i5 && o2.then((e6) => {
        c(t3, r2) && (this.historicMoment = e6.historicMoment);
      });
    }, this._updateMomentHandler = (e5) => {
      const { serviceUrl: t3, gdbVersion: r2, moment: o2 } = e5, s3 = t3 === this.featureServiceUrl, i5 = g(t3, r2, this.gdbVersion);
      s3 && i5 && (this.historicMoment = o2);
    }, this.when().then(() => {
      this.addHandles([l(this._applyEditsHandler), h(this._updateMomentHandler)]);
    }, () => {
    });
  }
  initialize() {
    this.when().catch((e4) => {
      b(e4) || n.getLogger(this).error("#load()", `Failed to load layer (title: '${this.title ?? "no title"}', id: '${this.id ?? "no id"}')`, { error: e4 });
    });
  }
  get datasetName() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.name) ?? null;
  }
  get owner() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.userIdentity) ?? null;
  }
  get schemaGeneration() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.schemaGeneration) ?? null;
  }
  get parsedUrl() {
    return I(this.layerUrl);
  }
  get featureServiceUrl() {
    return d(this.parsedUrl.path).url.path;
  }
  get networkServiceUrl() {
    return this.featureServiceUrl.replace(/\/FeatureServer/i, "/UtilityNetworkServer");
  }
  get layerId() {
    return d(this.parsedUrl.path).sublayer;
  }
  get networkSystemLayers() {
    return null;
  }
  async load(e4) {
    return this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl, this.layerId.toString(), e4)), this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl, e4)), this;
  }
  getLayerIdBySourceId(e4) {
    if (this.dataElement) {
      const t3 = this.dataElement.domainNetworks;
      for (const r2 of t3) {
        for (const t4 of r2.edgeSources ?? []) if (t4.sourceId === e4) return t4.layerId;
        for (const t4 of r2.junctionSources ?? []) if (t4.sourceId === e4) return t4.layerId;
      }
      return null;
    }
    return null;
  }
  async queryNamedTraceConfigurations(e4, t3) {
    var _a;
    const [{ queryNamedTraceConfigurations: r2 }, { default: o2 }] = await Promise.all([import("./queryNamedTraceConfigurations-NWOFZ6B6.js"), import("./QueryNamedTraceConfigurationsParameters-CIJG34NQ.js")]), s3 = this.networkServiceUrl, i5 = o2.from(e4);
    return (_a = await r2(s3, i5, { ...t3 })) == null ? void 0 : _a.namedTraceConfigurations;
  }
  async validateTopology(e4, t3) {
    var _a, _b, _c;
    if (!e4.validateArea) throw new s("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    const [{ validateNetworkTopology: r2 }, { default: s3 }] = await Promise.all([import("./validateNetworkTopology-MMFA5G2J.js"), import("./ValidateNetworkTopologyParameters-PFWR3EGC.js")]), i5 = s3.from(e4);
    c(this.featureServiceUrl, this.gdbVersion || null) ? (i5.sessionID = t, await i2(this.featureServiceUrl, this.gdbVersion, true)) : i5.sessionID = null, i5.gdbVersion = this.gdbVersion;
    const a5 = this.networkServiceUrl, n6 = this.featureServiceUrl, l5 = c2(n6, null, this.gdbVersion, true), d5 = await r2(a5, i5, { ...t3 });
    if (d5 == null ? void 0 : d5.serviceEdits) {
      const e5 = [];
      for (const t4 of d5.serviceEdits) {
        const { editedFeatures: r3 } = t4, o2 = (r3 == null ? void 0 : r3.spatialReference) ? new f2(r3.spatialReference) : null;
        e5.push({ layerId: t4.layerId, editedFeatures: { adds: ((_a = r3 == null ? void 0 : r3.adds) == null ? void 0 : _a.map((e6) => N(e6, o2))) || [], updates: ((_b = r3 == null ? void 0 : r3.updates) == null ? void 0 : _b.map((e6) => ({ original: N(e6[0], o2), current: N(e6[1], o2) }))) || [], deletes: ((_c = r3 == null ? void 0 : r3.deletes) == null ? void 0 : _c.map((e6) => N(e6, o2))) || [], spatialReference: o2 } });
      }
      l5.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], editedFeatures: e5, exceededTransferLimit: false, historicMoment: d5.moment });
    }
    return d5;
  }
  async submitTopologyValidationJob(e4, t3) {
    let s3 = null;
    if (!e4.validateArea) throw new s("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    if (!this.gdbVersion) {
      const e5 = this.layerUrl.replace(/\/FeatureServer/i, "/VersionManagementServer").replace(/\/\d*$/, "");
      s3 = (await U(e5, { responseType: "json", query: { f: "json" } })).data.defaultVersionName;
    }
    const [{ submitValidateNetworkTopologyJob: i5 }, { default: a5 }] = await Promise.all([import("./validateNetworkTopology-MMFA5G2J.js"), import("./ValidateNetworkTopologyParameters-PFWR3EGC.js")]), n6 = a5.from(e4);
    c(this.featureServiceUrl, this.gdbVersion || null) ? (n6.sessionID = t, await i2(this.featureServiceUrl, this.gdbVersion, true)) : n6.sessionID = null, n6.gdbVersion = this.gdbVersion || s3;
    const l5 = this.networkServiceUrl, d5 = this.featureServiceUrl ? c2(this.featureServiceUrl, null, this.gdbVersion, true) : void 0, u3 = await i5(l5, n6, { ...t3 });
    return new m2({ statusUrl: u3, editsResolver: d5 });
  }
  async _fetchLayerMetaData(e4, t3) {
    const o2 = await U(e4, { responseType: "json", query: { f: "json" }, ...t3 });
    this.sourceJSON = o2.data, this.read(o2.data, { origin: "service" });
  }
  async _fetchDataElement(e4, t3, o2) {
    if (this.dataElement) return;
    const s3 = await U(`${e4}/queryDataElements`, { responseType: "json", query: { layers: JSON.stringify([t3]), f: "json" }, ...o2 }).then((e5) => {
      var _a;
      return (_a = e5.data.layerDataElements) == null ? void 0 : _a[0];
    });
    s3 && this.read(s3, { origin: "service" });
  }
};
function N(e4, r2) {
  return new d2({ attributes: e4.attributes, geometry: y2({ ...e4.geometry, spatialReference: r2 }) });
}
e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: true } }, read: false } })], k.prototype, "id", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: { source: "name" } } }, read: false } })], k.prototype, "title", void 0), e([y({ type: String, nonNullable: true, json: { origins: { "web-map": { read: { source: "url" }, write: { target: "url", isRequired: true } } }, read: false } })], k.prototype, "layerUrl", void 0), e([y({ type: Object, json: { origins: { service: { read: true } }, read: false } })], k.prototype, "dataElement", void 0), e([y({ type: w, json: { origins: { service: { read: { source: "extent" } } }, read: false } })], k.prototype, "fullExtent", void 0), e([y({ type: f2, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, read: false } })], k.prototype, "spatialReference", void 0), e([y({ type: ["utility", "trace"], readOnly: true, json: { read: false, write: false } })], k.prototype, "type", void 0), e([y({ readOnly: true })], k.prototype, "datasetName", null), e([y({ readOnly: true })], k.prototype, "owner", null), e([y({ readOnly: true })], k.prototype, "schemaGeneration", null), e([y({ readOnly: true })], k.prototype, "parsedUrl", null), e([y({ readOnly: true })], k.prototype, "featureServiceUrl", null), e([y({ readOnly: true })], k.prototype, "networkServiceUrl", null), e([y({ readOnly: true })], k.prototype, "layerId", null), e([y()], k.prototype, "sourceJSON", void 0), e([y({ readOnly: true })], k.prototype, "networkSystemLayers", null), e([y()], k.prototype, "gdbVersion", void 0), e([y({ type: Date })], k.prototype, "historicMoment", void 0), k = e([a("esri.networks.Network")], k);
var V = k;

// ../node_modules/@arcgis/core/networks/RulesTable.js
var a3 = class extends u2(m) {
  constructor(e4) {
    super(e4), this.rulesCategorized = { attachment: [], containment: [], connectivity: [] }, this.request = U;
  }
  initialize() {
  }
  async load(e4) {
    const t3 = this.layer.load(e4).then(() => this._initializeRulesTable());
    return this.addResolvingPromise(t3), this;
  }
  getFeatureSQL(e4, t3) {
    var _a, _b;
    const o2 = e4.layerId.toString(), s3 = (_a = e4.fieldsIndex) == null ? void 0 : _a.normalizeFieldName("assetGroup"), r2 = (_b = e4.fieldsIndex) == null ? void 0 : _b.normalizeFieldName("assetType"), i5 = s3 ? t3.attributes[s3] : null, n6 = r2 ? t3.attributes[r2] : null, a5 = this.rulesHash[o2];
    if (a5) {
      const e5 = a5.assetGroupHash[i5];
      if (e5) {
        return e5.assetTypeHash[n6] || null;
      }
    }
    return null;
  }
  async _initializeRulesTable() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const e4 = {};
    let t3;
    !function(e5) {
      e5[e5.from = 0] = "from", e5[e5.to = 1] = "to", e5[e5.via = 2] = "via";
    }(t3 || (t3 = {}));
    const o2 = [{ networkSourceId: "fromNetworkSource", assetGroupId: "fromAssetGroup", assetTypeId: "fromAssetType" }, { networkSourceId: "toNetworkSource", assetGroupId: "toAssetGroup", assetTypeId: "toAssetType" }, { networkSourceId: "viaNetworkSource", assetGroupId: "viaAssetGroup", assetTypeId: "viaAssetType" }];
    this.rulesCategorized = { attachment: [], containment: [], connectivity: [] };
    for (const s3 of this.rules) {
      if (s3.ruleType === t2.RTAttachment) {
        this.rulesCategorized.attachment.push(s3);
        continue;
      }
      if (s3.ruleType === t2.RTContainment) {
        this.rulesCategorized.containment.push(s3);
        continue;
      }
      if (s3.ruleType === t2.RTJunctionJunctionConnectivity) {
        this.rulesCategorized.connectivity.push(s3);
        continue;
      }
      this.rulesCategorized.connectivity.push(s3);
      let r2 = [[t3.from, t3.to], [t3.to, t3.from]];
      s3.ruleType === t2.RTEdgeJunctionEdgeConnectivity && (r2 = [[t3.from, t3.via], [t3.via, t3.from], [t3.to, t3.via], [t3.via, t3.to]]);
      for (const i5 of r2) {
        const r3 = i5.shift(), a5 = i5.shift();
        let c4 = false;
        switch (s3.ruleType) {
          case t2.RTEdgeJunctionEdgeConnectivity:
            c4 = r3 === t3.from || r3 === t3.to;
            break;
          case t2.RTJunctionEdgeConnectivity:
            c4 = r3 === t3.to;
        }
        const u3 = o2[r3], p4 = ((_a = s3[u3.networkSourceId]) == null ? void 0 : _a.layerId.toString()) ?? "", d5 = (_c = (_b = s3[u3.assetGroupId]) == null ? void 0 : _b.assetGroupCode) == null ? void 0 : _c.toString(), l5 = s3[u3.assetTypeId], y3 = (_d = l5 == null ? void 0 : l5.assetTypeCode) == null ? void 0 : _d.toString(), m4 = o2[a5], h2 = ((_e = s3[m4.networkSourceId]) == null ? void 0 : _e.layerId.toString()) ?? "", f4 = (_g = (_f = s3[m4.assetGroupId]) == null ? void 0 : _f.assetGroupCode) == null ? void 0 : _g.toString(), T2 = s3[m4.assetTypeId], g2 = (_h = T2 == null ? void 0 : T2.assetTypeCode) == null ? void 0 : _h.toString(), v = e4[p4] ?? { assetGroupHash: {} };
        if (!(d5 && y3 && f4 && g2)) continue;
        const I2 = v.assetGroupHash[d5] ?? { assetTypeHash: {} }, S4 = I2.assetTypeHash[y3] ?? {};
        if (S4[h2] = S4[h2] ?? {}, c4) {
          S4[p4] = S4[p4] ?? {};
          const e5 = `(assetgroup = ${d5} AND assettype = ${y3})`;
          S4[p4].anyVertex = S4[p4].anyVertex ? `${S4[p4].anyVertex}` : `${e5}`, "esriNECPEndVertex" === (T2 == null ? void 0 : T2.connectivityPolicy) && (S4[p4].endVertex = ((_i = S4[p4]) == null ? void 0 : _i.endVertex) ? `${S4[p4].endVertex}` : `${e5}`);
        }
        const C = `(assetgroup = ${f4} AND assettype = ${g2})`;
        S4[h2].anyVertex = ((_j = S4[h2]) == null ? void 0 : _j.anyVertex) ? `${S4[h2].anyVertex} OR ${C}` : `${C}`, "esriNECPEndVertex" === (T2 == null ? void 0 : T2.connectivityPolicy) && (S4[h2].endVertex = ((_k = S4[h2]) == null ? void 0 : _k.endVertex) ? `${S4[h2].endVertex} OR ${C}` : `${C}`), I2.assetTypeHash[y3] = S4, v.assetGroupHash[d5] = I2, e4[p4] = v;
      }
    }
    this.rulesHash = e4;
  }
};
e([y({ constructOnly: true })], a3.prototype, "layer", void 0), e([y({ constructOnly: true })], a3.prototype, "rules", void 0), e([y()], a3.prototype, "rulesHash", void 0), e([y()], a3.prototype, "rulesCategorized", void 0), e([y({ constructOnly: true })], a3.prototype, "request", void 0), a3 = e([a("esri.networks.RulesTable")], a3);
var c3 = a3;

// ../node_modules/@arcgis/core/networks/support/NetworkSystemLayers.js
var e3 = class extends S {
  constructor(r2) {
    super(r2), this.rulesTableId = null, this.rulesTableUrl = null, this.subnetworksTableId = null, this.subnetworksTableUrl = null, this.dirtyAreasLayerId = null, this.dirtyAreasLayerUrl = null, this.associationsTableId = null, this.associationsTableUrl = null;
  }
};
e([y({ constructOnly: true })], e3.prototype, "rulesTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "rulesTableUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "subnetworksTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "subnetworksTableUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "dirtyAreasLayerId", void 0), e([y({ constructOnly: true })], e3.prototype, "dirtyAreasLayerUrl", void 0), e([y({ constructOnly: true })], e3.prototype, "associationsTableId", void 0), e([y({ constructOnly: true })], e3.prototype, "associationsTableUrl", void 0), e3 = e([a("esri.networks.support.NetworkSystemLayers")], e3);
var l4 = e3;

// ../node_modules/@arcgis/core/networks/support/Terminal.js
var s2 = class extends f {
  constructor(r2) {
    super(r2), this.id = null, this.name = null;
  }
};
e([y({ type: Number, json: { read: { source: "terminalId" }, write: { target: "terminalId" } } })], s2.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalName" }, write: { target: "terminalName" } } })], s2.prototype, "name", void 0), e([y({ type: Boolean, json: { write: true } })], s2.prototype, "isUpstreamTerminal", void 0), s2 = e([a("esri.networks.support.Terminal")], s2);
var p = s2;

// ../node_modules/@arcgis/core/networks/support/TerminalConfiguration.js
var a4 = new n2({ esriUNTMBidirectional: "bidirectional", esriUNTMDirectional: "directional" });
var n4 = class extends f {
  constructor(r2) {
    super(r2), this.defaultConfiguration = null, this.id = null, this.name = null, this.terminals = [], this.traversabilityModel = null;
  }
};
e([y({ type: String, json: { write: true } })], n4.prototype, "defaultConfiguration", void 0), e([y({ type: Number, json: { read: { source: "terminalConfigurationId" }, write: { target: "terminalConfigurationId" } } })], n4.prototype, "id", void 0), e([y({ type: String, json: { read: { source: "terminalConfigurationName" }, write: { target: "terminalConfigurationName" } } })], n4.prototype, "name", void 0), e([y({ type: [p], json: { write: true } })], n4.prototype, "terminals", void 0), e([y({ type: a4.apiValues, json: { type: a4.jsonValues, read: a4.read, write: a4.write } })], n4.prototype, "traversabilityModel", void 0), n4 = e([a("esri.networks.support.TerminalConfiguration")], n4);
var p2 = n4;

// ../node_modules/@arcgis/core/networks/support/TraceJobInfo.js
var m3 = i()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var n5 = class extends a2 {
  constructor(t3) {
    super(t3), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t3) {
    const e4 = { ...t3, query: { f: "json" } }, { data: r2 } = await U(this.statusUrl, e4), o2 = r2.traceResults ? { ...r2.traceResults, ...r2 } : r2;
    return this.read(o2), this;
  }
  async waitForJobCompletion(t3 = {}) {
    const { interval: s3 = 1e3, statusCallback: e4 } = t3;
    return new Promise((t4, o2) => {
      this._clearTimer();
      const i5 = setInterval(() => {
        this._timer || o2(u()), this.checkJobStatus().then((s4) => {
          const { status: r2 } = s4;
          switch (this.status = r2, r2) {
            case "job-succeeded":
              this._clearTimer(), t4(this);
              break;
            case "job-waiting":
            case "job-executing":
              e4 && e4(this);
          }
        }, (t5) => {
          this._clearTimer(), o2(t5);
        });
      }, s3);
      this._timer = i5;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
e([y({ type: String, json: { write: true } })], n5.prototype, "statusUrl", void 0), e([o(m3)], n5.prototype, "status", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t3, s3) => {
  s3.submissionTime = t3 ? t3.getTime() : null;
} } } })], n5.prototype, "submissionTime", void 0), e([y({ type: Date, json: { type: Number, write: { writer: (t3, s3) => {
  s3.lastUpdatedTime = t3 ? t3.getTime() : null;
} } } })], n5.prototype, "lastUpdatedTime", void 0), n5 = e([a("esri.networks.support.TraceJobInfo")], n5);
var p3 = n5;

// ../node_modules/@arcgis/core/networks/UtilityNetwork.js
var f3 = class extends V {
  constructor(e4) {
    super(e4), this.sharedNamedTraceConfigurations = [], this.type = "utility";
  }
  get serviceTerritoryFeatureLayerId() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.serviceTerritoryFeatureLayerId) ?? null;
  }
  get networkSystemLayers() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return new l4({ rulesTableId: (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.rulesTableId, rulesTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_b = this.sourceJSON) == null ? void 0 : _b.systemLayers.rulesTableId}` : null, subnetworksTableId: (_c = this.sourceJSON) == null ? void 0 : _c.systemLayers.subnetworksTableId, subnetworksTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_d = this.sourceJSON) == null ? void 0 : _d.systemLayers.subnetworksTableId}` : null, dirtyAreasLayerId: (_e = this.sourceJSON) == null ? void 0 : _e.systemLayers.dirtyAreasLayerId, dirtyAreasLayerUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_f = this.sourceJSON) == null ? void 0 : _f.systemLayers.dirtyAreasLayerId}` : null, associationsTableId: (_g = this.sourceJSON) == null ? void 0 : _g.systemLayers.associationsTableId, associationsTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_h = this.sourceJSON) == null ? void 0 : _h.systemLayers.associationsTableId}` : null });
  }
  get terminalConfigurations() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.terminalConfigurations.map((e4) => p2.fromJSON(e4))) || [];
  }
  get domainNetworkNames() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.domainNetworks.map((e4) => e4.domainNetworkName)) || [];
  }
  get _utilityLayerList() {
    var _a, _b;
    const e4 = /* @__PURE__ */ new Set();
    return (_b = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks) == null ? void 0 : _b.map((t3) => {
      t3.edgeSources.map((t4) => {
        e4.add(t4.layerId);
      }), t3.junctionSources.map((t4) => {
        e4.add(t4.layerId);
      });
    }), e4;
  }
  async load(e4) {
    return this.addResolvingPromise(super.load(e4)), this.addResolvingPromise(this._loadNamedTraceConfigurationsFromNetwork(e4)), this;
  }
  getTerminalConfiguration(e4) {
    var _a, _b, _c, _d;
    let t3 = null, r2 = null;
    const o2 = e4.layer;
    let s3 = null;
    if ("feature" === (o2 == null ? void 0 : o2.type)) {
      if (s3 = o2.layerId, null === s3) return null;
    } else {
      if ("subtype-sublayer" !== (o2 == null ? void 0 : o2.type)) return null;
      if (s3 = ((_a = o2 == null ? void 0 : o2.parent) == null ? void 0 : _a.layerId) ?? null, null === s3) return null;
    }
    const a5 = e4.attributes;
    if (null == a5) return null;
    for (const l5 of Object.keys(a5)) "ASSETGROUP" === l5.toUpperCase() && (t3 = e4.getAttribute(l5)), "ASSETTYPE" === l5.toUpperCase() && (r2 = e4.getAttribute(l5));
    if (!this.dataElement) return null;
    let i5 = null;
    const n6 = this.dataElement.domainNetworks;
    for (const l5 of n6) {
      const e5 = (_b = l5.junctionSources) == null ? void 0 : _b.find((e6) => e6.layerId === s3);
      if (e5) {
        const o3 = (_c = e5.assetGroups) == null ? void 0 : _c.find((e6) => e6.assetGroupCode === t3);
        if (o3) {
          const e6 = (_d = o3.assetTypes) == null ? void 0 : _d.find((e7) => e7.assetTypeCode === r2);
          if (e6) {
            i5 = e6.terminalConfigurationId;
            break;
          }
        }
      }
    }
    if (null != i5) {
      const e5 = this.dataElement.terminalConfigurations, t4 = e5 == null ? void 0 : e5.find((e6) => e6.terminalConfigurationId === i5);
      return t4 ? p2.fromJSON(t4) : null;
    }
    return null;
  }
  getTierNames(e4) {
    var _a;
    const t3 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks.find((t4) => t4.domainNetworkName === e4);
    return (t3 == null ? void 0 : t3.tiers.map((e5) => e5.name)) || [];
  }
  async getRulesTable() {
    return this._sharedRulesTable || (this._sharedRulesTable = this._createRulesTable()), await this._sharedRulesTable;
  }
  isUtilityLayer(e4) {
    var _a;
    return this._utilityLayerList.has(e4.layerId) && (((_a = e4.url) == null ? void 0 : _a.startsWith(this.featureServiceUrl)) ?? false);
  }
  async queryAssociations(e4) {
    const [{ queryAssociations: t3 }, { default: r2 }] = await Promise.all([import("./queryAssociations-Q3MDQSZI.js"), import("./QueryAssociationsParameters-ISV7SVZI.js")]), o2 = r2.from(e4);
    o2.gdbVersion = this.gdbVersion, o2.moment = this.historicMoment;
    return (await t3(this.networkServiceUrl, o2)).associations;
  }
  async synthesizeAssociationGeometries(e4) {
    const [{ synthesizeAssociationGeometries: t3 }, { default: r2 }] = await Promise.all([import("./synthesizeAssociationGeometries-NAN5Q72B.js"), import("./SynthesizeAssociationGeometriesParameters-3Y2X2TFJ.js")]), o2 = r2.from(e4);
    return o2.gdbVersion = this.gdbVersion, o2.moment = this.historicMoment, t3(this.networkServiceUrl, o2);
  }
  async trace(e4) {
    const [{ trace: t3 }, { default: r2 }] = await Promise.all([import("./trace-GLB4NNXA.js"), import("./TraceParameters-US7ZEESR.js")]), o2 = r2.from(e4);
    return o2.gdbVersion = this.gdbVersion, o2.moment = this.historicMoment, t3(this.networkServiceUrl, o2);
  }
  async submitTraceJob(e4) {
    const [{ submitTraceJob: t3 }, { default: r2 }] = await Promise.all([import("./trace-GLB4NNXA.js"), import("./TraceParameters-US7ZEESR.js")]), o2 = r2.from(e4);
    o2.gdbVersion = this.gdbVersion, o2.moment = this.historicMoment;
    const s3 = await t3(this.networkServiceUrl, o2);
    return new p3({ statusUrl: s3 });
  }
  async canAddAssociation(e4) {
    const t3 = await this.getRulesTable();
    if (!t3) return false;
    await t3.load();
    const r2 = (e5, t4) => e5 ? 1 === e5.terminalId ? !(t4 == null ? void 0 : t4.terminalId) || (t4 == null ? void 0 : t4.terminalId) === e5.terminalId : e5.terminalId === (t4 == null ? void 0 : t4.terminalId) : !(t4 == null ? void 0 : t4.terminalId), o2 = (e5, t4) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      return ((_a = e5.fromNetworkSource) == null ? void 0 : _a.sourceId) === ((_b = t4.fromNetworkElement) == null ? void 0 : _b.networkSourceId) && ((_c = e5.toNetworkSource) == null ? void 0 : _c.sourceId) === ((_d = t4.toNetworkElement) == null ? void 0 : _d.networkSourceId) && ((_e = e5.fromAssetGroup) == null ? void 0 : _e.assetGroupCode) === ((_f = t4.fromNetworkElement) == null ? void 0 : _f.assetGroupCode) && ((_g = e5.fromAssetType) == null ? void 0 : _g.assetTypeCode) === ((_h = t4.fromNetworkElement) == null ? void 0 : _h.assetTypeCode) && ((_i = e5.toAssetGroup) == null ? void 0 : _i.assetGroupCode) === ((_j = t4.toNetworkElement) == null ? void 0 : _j.assetGroupCode) && ((_k = e5.toAssetType) == null ? void 0 : _k.assetTypeCode) === ((_l = t4.toNetworkElement) == null ? void 0 : _l.assetTypeCode) && r2(e5.fromTerminal, t4.fromNetworkElement) && r2(e5.toTerminal, t4.toNetworkElement);
    };
    if ("containment" === e4.associationType) {
      return t3.rulesCategorized.containment.some((t4) => o2(t4, e4));
    }
    if ("attachment" === e4.associationType) {
      return t3.rulesCategorized.attachment.some((t4) => o2(t4, e4));
    }
    return t3.rulesCategorized.connectivity.some((t4) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
      return t4.viaNetworkSource ? ((_a = t4.fromNetworkSource) == null ? void 0 : _a.sourceId) === ((_b = e4.fromNetworkElement) == null ? void 0 : _b.networkSourceId) && ((_c = t4.viaNetworkSource) == null ? void 0 : _c.sourceId) === ((_d = e4.toNetworkElement) == null ? void 0 : _d.networkSourceId) && ((_e = t4.fromAssetGroup) == null ? void 0 : _e.assetGroupCode) === ((_f = e4.fromNetworkElement) == null ? void 0 : _f.assetGroupCode) && ((_g = t4.fromAssetType) == null ? void 0 : _g.assetTypeCode) === ((_h = e4.fromNetworkElement) == null ? void 0 : _h.assetTypeCode) && ((_i = t4.viaAssetGroup) == null ? void 0 : _i.assetGroupCode) === ((_j = e4.toNetworkElement) == null ? void 0 : _j.assetGroupCode) && ((_k = t4.viaAssetType) == null ? void 0 : _k.assetTypeCode) === ((_l = e4.toNetworkElement) == null ? void 0 : _l.assetTypeCode) && r2(t4.fromTerminal, e4.fromNetworkElement) && r2(t4.viaTerminal, e4.toNetworkElement) || ((_m = t4.viaNetworkSource) == null ? void 0 : _m.sourceId) === ((_n = e4.fromNetworkElement) == null ? void 0 : _n.networkSourceId) && ((_o = t4.toNetworkSource) == null ? void 0 : _o.sourceId) === ((_p = e4.toNetworkElement) == null ? void 0 : _p.networkSourceId) && ((_q = t4.viaAssetGroup) == null ? void 0 : _q.assetGroupCode) === ((_r = e4.fromNetworkElement) == null ? void 0 : _r.assetGroupCode) && ((_s = t4.viaAssetType) == null ? void 0 : _s.assetTypeCode) === ((_t = e4.fromNetworkElement) == null ? void 0 : _t.assetTypeCode) && ((_u = t4.toAssetGroup) == null ? void 0 : _u.assetGroupCode) === ((_v = e4.toNetworkElement) == null ? void 0 : _v.assetGroupCode) && ((_w = t4.toAssetType) == null ? void 0 : _w.assetTypeCode) === ((_x = e4.toNetworkElement) == null ? void 0 : _x.assetTypeCode) && r2(t4.viaTerminal, e4.fromNetworkElement) && r2(t4.toTerminal, e4.toNetworkElement) : o2(t4, e4);
    });
  }
  generateAddAssociations(e4) {
    return { addFeatures: e4.map((e5) => {
      var _a, _b, _c, _d, _e, _f;
      return new d2({ attributes: { fromnetworksourceid: (_a = e5.fromNetworkElement) == null ? void 0 : _a.networkSourceId, fromglobalid: (_b = e5.fromNetworkElement) == null ? void 0 : _b.globalId, fromterminalid: (_c = e5.fromNetworkElement) == null ? void 0 : _c.terminalId, tonetworksourceid: (_d = e5.toNetworkElement) == null ? void 0 : _d.networkSourceId, toglobalid: (_e = e5.toNetworkElement) == null ? void 0 : _e.globalId, toterminalid: (_f = e5.toNetworkElement) == null ? void 0 : _f.terminalId, associationtype: e2[e5.associationType], iscontentvisible: e5.isContentVisible ? 1 : 0, percentalong: e5.percentAlong, globalid: e5.globalId } });
    }), id: this.networkSystemLayers.associationsTableId, identifierFields: { globalIdField: "globalid", objectIdField: "objectid" } };
  }
  generateDeleteAssociations(e4) {
    return { deleteFeatures: e4.map((e5) => ({ globalId: e5.globalId })), id: this.networkSystemLayers.associationsTableId, identifierFields: { globalIdField: "globalid", objectIdField: "objectid" } };
  }
  async _loadNamedTraceConfigurationsFromNetwork(e4) {
    var _a;
    if (0 === ((_a = this.sharedNamedTraceConfigurations) == null ? void 0 : _a.length)) return;
    const t3 = this.sharedNamedTraceConfigurations.map((e5) => e5.globalId), r2 = await this.queryNamedTraceConfigurations({ globalIds: t3 }, e4);
    for (const o2 of this.sharedNamedTraceConfigurations) {
      const e5 = r2 == null ? void 0 : r2.find((e6) => e6.globalId === o2.globalId);
      if (e5) {
        const t4 = e5.write({}, { origin: "service" });
        o2.read(t4, { origin: "service" });
      }
    }
  }
  async _createRulesTable() {
    var _a;
    const e4 = this.networkSystemLayers.rulesTableUrl, t3 = new Ze({ url: e4 });
    await t3.load();
    const r2 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks;
    if (!r2) return null;
    const o2 = r2.flatMap((e5) => [...e5.edgeSources || [], ...e5.junctionSources || []]), a5 = (await w2(t3)).map((e5) => this._hydrateRuleInfo(t3, o2, e5));
    return new c3({ layer: t3, rules: a5 });
  }
  _hydrateRuleInfo(e4, t3, r2) {
    const o2 = e4.fieldsIndex, s3 = o2.get("RULETYPE"), a5 = o2.get("CREATIONDATE"), i5 = o2.get("FROMNETWORKSOURCEID"), n6 = o2.get("FROMASSETGROUP"), l5 = o2.get("FROMASSETTYPE"), u3 = o2.get("FROMTERMINALID"), m4 = o2.get("TONETWORKSOURCEID"), d5 = o2.get("TOASSETGROUP"), c4 = o2.get("TOASSETTYPE"), y3 = o2.get("TOTERMINALID"), f4 = o2.get("VIANETWORKSOURCEID"), w3 = o2.get("VIAASSETGROUP"), T2 = o2.get("VIAASSETTYPE"), I2 = o2.get("VIATERMINALID"), g2 = r2.attributes[s3.name], k2 = new Date(r2.attributes[a5.name]), b3 = [{ networkSourceId: r2.attributes[i5.name], assetGroupId: r2.attributes[n6.name], assetTypeId: r2.attributes[l5.name], terminalId: r2.attributes[u3.name] }, { networkSourceId: r2.attributes[m4.name], assetGroupId: r2.attributes[d5.name], assetTypeId: r2.attributes[c4.name], terminalId: r2.attributes[y3.name] }, { networkSourceId: r2.attributes[f4.name], assetGroupId: r2.attributes[w3.name], assetTypeId: r2.attributes[T2.name], terminalId: r2.attributes[I2.name] }];
    let h2;
    !function(e5) {
      e5[e5.from = 0] = "from", e5[e5.to = 1] = "to", e5[e5.via = 2] = "via";
    }(h2 || (h2 = {}));
    const N2 = { ruleType: g2, creationDate: k2 };
    for (const S4 of [h2.from, h2.to, h2.via]) {
      if (g2 !== t2.RTEdgeJunctionEdgeConnectivity && S4 === h2.via) continue;
      const e5 = b3[S4], r3 = t3.find((t4) => t4.sourceId === e5.networkSourceId), o3 = r3 == null ? void 0 : r3.assetGroups.find((t4) => t4.assetGroupCode === e5.assetGroupId), s4 = o3 == null ? void 0 : o3.assetTypes.find((t4) => t4.assetTypeCode === e5.assetTypeId), a6 = this._getTerminal(s4, e5);
      let i6 = "";
      switch (S4) {
        case h2.from:
          i6 = "from";
          break;
        case h2.to:
          i6 = "to";
          break;
        case h2.via:
          i6 = "via";
      }
      N2[`${i6}NetworkSource`] = r3, N2[`${i6}AssetGroup`] = o3, N2[`${i6}AssetType`] = s4, N2[`${i6}Terminal`] = a6 == null ? void 0 : a6.toJSON();
    }
    return N2;
  }
  _getTerminal(e4, t3) {
    var _a, _b;
    const r2 = e4 == null ? void 0 : e4.terminalConfigurationId, o2 = (_a = this.terminalConfigurations) == null ? void 0 : _a.find((e5) => e5.id === r2);
    return ((_b = o2 == null ? void 0 : o2.terminals) == null ? void 0 : _b.find((e5) => e5.id === t3.terminalId)) ?? null;
  }
};
async function w2(e4) {
  const t3 = new b2({ where: "1=1", outFields: ["*"] });
  return (await r(e4, t3)).features;
}
e([y({ type: [d3], json: { origins: { "web-map": { read: { source: "traceConfigurations" }, write: { target: "traceConfigurations" } }, service: { read: { source: "traceConfigurations" } } }, read: false } })], f3.prototype, "sharedNamedTraceConfigurations", void 0), e([y({ type: ["utility"], readOnly: true, json: { read: false, write: false } })], f3.prototype, "type", void 0), e([y({ readOnly: true })], f3.prototype, "serviceTerritoryFeatureLayerId", null), e([y({ readOnly: true })], f3.prototype, "networkSystemLayers", null), e([y({ readOnly: true })], f3.prototype, "terminalConfigurations", null), e([y({ readOnly: true })], f3.prototype, "domainNetworkNames", null), f3 = e([a("esri.networks.UtilityNetwork")], f3);
var T = f3;

export {
  T
};
//# sourceMappingURL=chunk-BS7EHO4L.js.map
