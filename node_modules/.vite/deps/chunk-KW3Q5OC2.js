import {
  p as p2,
  t
} from "./chunk-XNYIPE5U.js";
import {
  x
} from "./chunk-YHUE64L3.js";
import {
  C as C2
} from "./chunk-QBW6ZJYD.js";
import {
  m,
  o as o4
} from "./chunk-S7J6OTBX.js";
import {
  U
} from "./chunk-4SCOCLA2.js";
import {
  p
} from "./chunk-WF67GKPJ.js";
import {
  b,
  j
} from "./chunk-4HOM27T6.js";
import {
  a as a4
} from "./chunk-FO4JQZA5.js";
import {
  a as a3,
  l,
  s as s2
} from "./chunk-NSXZC33R.js";
import {
  k
} from "./chunk-IJUFAIOF.js";
import {
  M
} from "./chunk-7OW2VNCC.js";
import {
  y as y2
} from "./chunk-IJ42YN7D.js";
import {
  i
} from "./chunk-FJPG3YI6.js";
import {
  o as o2
} from "./chunk-Z32PAECZ.js";
import {
  o as o3
} from "./chunk-BL2UGYYZ.js";
import {
  C,
  d
} from "./chunk-7PMYO342.js";
import {
  o
} from "./chunk-ZART2Y5J.js";
import {
  r
} from "./chunk-F4OBDVPS.js";
import {
  f2 as f,
  y
} from "./chunk-TJUEGVVG.js";
import {
  a3 as a2
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  a,
  e as e2,
  n2 as n,
  s2 as s
} from "./chunk-YNL57W4I.js";
import {
  has
} from "./chunk-2PA5UPTB.js";

// ../node_modules/@arcgis/core/layers/support/ExpressionInfo.js
var p3 = class extends i(f) {
  constructor(r2) {
    super(r2), this.expression = null, this.title = null, this.returnType = null;
  }
};
e([y({ type: String, json: { write: true } })], p3.prototype, "expression", void 0), e([y({ type: String, json: { write: true } })], p3.prototype, "title", void 0), e([y({ type: String, json: { write: true } })], p3.prototype, "returnType", void 0), p3 = e([a2("esri.layers.support.ExpressionInfo")], p3);
var i2 = p3;

// ../node_modules/@arcgis/core/layers/support/AggregateField.js
var p4;
var n2 = p4 = class extends f {
  constructor(t2) {
    super(t2), this.isAutoGenerated = false, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new p4({ name: this.name, alias: this.alias, isAutoGenerated: this.isAutoGenerated, onStatisticExpression: a(this.onStatisticExpression), onStatisticField: this.onStatisticField, statisticType: this.statisticType });
  }
};
e([y({ type: Boolean, json: { write: true } })], n2.prototype, "isAutoGenerated", void 0), e([y({ type: String, json: { write: true } })], n2.prototype, "name", void 0), e([y({ type: String, json: { write: true } })], n2.prototype, "alias", void 0), e([y({ type: String, json: { write: true } })], n2.prototype, "onStatisticField", void 0), e([y({ type: i2, json: { write: true } })], n2.prototype, "onStatisticExpression", void 0), e([y({ type: String, json: { write: true } })], n2.prototype, "statisticType", void 0), n2 = p4 = e([a2("esri.layers.support.AggregateField")], n2);
var a5 = n2;

// ../node_modules/@arcgis/core/layers/support/FeatureReductionBinning.js
var h;
var g = h = class extends t {
  constructor(e3) {
    super(e3), this.type = "binning", this.binType = "geohash", this.fixedBinLevel = null, this.labelingInfo = null, this.labelsVisible = true, this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.size = o3("12px"), this.fields = [], this.renderer = null;
  }
  writeFields(e3, r2, o6) {
    const t2 = e3.filter((e4) => "avg_angle" !== e4.statisticType).map((e4) => e4.toJSON());
    e2(o6, t2, r2);
  }
  readRenderer(e3, r2, t2) {
    var _a;
    const s3 = (_a = r2.drawingInfo) == null ? void 0 : _a.renderer;
    return s3 ? o4(s3, r2, t2) ?? void 0 : U(r2, t2);
  }
  clone() {
    return new h({ fields: a(this.fields), fixedBinLevel: this.fixedBinLevel, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, maxScale: this.maxScale, popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate), renderer: a(this.renderer), binType: a(this.binType), size: this.size });
  }
};
e([o2({ binning: "binning" })], g.prototype, "type", void 0), e([o2({ geohash: "geohash", square: "square" }), y({ type: ["geohash", "square"] })], g.prototype, "binType", void 0), e([y({ type: Number, json: { write: true } })], g.prototype, "fixedBinLevel", void 0), e([y({ type: [C2], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], g.prototype, "labelingInfo", void 0), e([y(l)], g.prototype, "labelsVisible", void 0), e([y({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], g.prototype, "maxScale", void 0), e([y(s2)], g.prototype, "popupEnabled", void 0), e([y({ type: k, json: { name: "popupInfo", write: true } })], g.prototype, "popupTemplate", void 0), e([y({ type: Number, cast: (e3) => "auto" === e3 ? e3 : o3(e3) })], g.prototype, "size", void 0), e([y({ type: [a5], json: { write: true } })], g.prototype, "fields", void 0), e([r("fields")], g.prototype, "writeFields", null), e([y({ types: m, json: { write: { target: "drawingInfo.renderer" } } })], g.prototype, "renderer", void 0), e([o("renderer", ["drawingInfo.renderer"])], g.prototype, "readRenderer", null), g = h = e([a2("esri.layers.support.FeatureReductionBinning")], g);
var v = g;

// ../node_modules/@arcgis/core/layers/support/FeatureReductionCluster.js
var g2;
function S(e3) {
  var _a;
  return "simple" === e3.type && !((_a = e3.visualVariables) == null ? void 0 : _a.length);
}
var w = g2 = class extends f {
  constructor(e3) {
    super(e3), this.type = "cluster", this.clusterRadius = o3("80px"), this.clusterMinSize = o3("12px"), this.clusterMaxSize = o3("50px"), this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.renderer = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = true, this.fields = [];
  }
  readRenderer(e3, r2, t2) {
    var _a, _b;
    const s3 = (_a = r2.drawingInfo) == null ? void 0 : _a.renderer;
    return ((_b = s3 == null ? void 0 : s3.authoringInfo) == null ? void 0 : _b.isAutoGenerated) ? null : s3 ? S(s3) ? null : o4(s3, r2, t2) ?? void 0 : U(r2, t2);
  }
  readSymbol(e3, r2, t2) {
    var _a, _b;
    const s3 = (_a = r2.drawingInfo) == null ? void 0 : _a.renderer;
    if ((_b = s3 == null ? void 0 : s3.authoringInfo) == null ? void 0 : _b.isAutoGenerated) return null;
    if (s3 && S(s3)) {
      const e4 = o4(s3, r2, t2);
      return e4 == null ? void 0 : e4.symbol;
    }
    return null;
  }
  writeSymbol(e3, r2, o6, s3) {
    var _a, _b;
    const i3 = (_b = (_a = this.renderer) == null ? void 0 : _a.authoringInfo) == null ? void 0 : _b.isAutoGenerated;
    if (!this.renderer || i3) {
      const o7 = new p({ symbol: e3 });
      r2.drawingInfo = { renderer: o7.write({}, s3) };
    }
  }
  writeFields(e3, r2, t2) {
    const o6 = e3.filter((e4) => "avg_angle" !== e4.statisticType).map((e4) => e4.toJSON());
    e2(t2, o6, r2);
  }
  readFields(e3, r2, t2) {
    return e3.filter((e4) => !e4.isAutoGenerated).map((e4) => a5.fromJSON(e4));
  }
  clone() {
    return new g2({ clusterRadius: this.clusterRadius, clusterMinSize: this.clusterMinSize, clusterMaxSize: this.clusterMaxSize, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, fields: a(this.fields), maxScale: this.maxScale, renderer: a(this.renderer), symbol: a(this.symbol), popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate) });
  }
};
e([y({ type: ["cluster"], readOnly: true, json: { write: true } })], w.prototype, "type", void 0), e([y({ type: Number, cast: (e3) => "auto" === e3 ? e3 : o3(e3), json: { write: true } })], w.prototype, "clusterRadius", void 0), e([y({ type: Number, cast: o3, json: { write: true } })], w.prototype, "clusterMinSize", void 0), e([y({ type: Number, cast: o3, json: { write: true } })], w.prototype, "clusterMaxSize", void 0), e([y({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], w.prototype, "maxScale", void 0), e([y(s2)], w.prototype, "popupEnabled", void 0), e([y({ type: k, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], w.prototype, "popupTemplate", void 0), e([y({ types: m, json: { write: { target: "drawingInfo.renderer" } } })], w.prototype, "renderer", void 0), e([o("renderer", ["drawingInfo.renderer"])], w.prototype, "readRenderer", null), e([y({ types: M })], w.prototype, "symbol", void 0), e([o("symbol", ["drawingInfo.renderer"])], w.prototype, "readSymbol", null), e([r("symbol")], w.prototype, "writeSymbol", null), e([y({ type: [C2], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], w.prototype, "labelingInfo", void 0), e([y(l)], w.prototype, "labelsVisible", void 0), e([y({ type: [a5], json: { write: true } })], w.prototype, "fields", void 0), e([r("fields")], w.prototype, "writeFields", null), e([o("fields")], w.prototype, "readFields", null), w = g2 = e([a2("esri.layers.support.FeatureReductionCluster")], w);
var I = w;

// ../node_modules/@arcgis/core/layers/support/featureReductionUtils.js
var o5 = { key: "type", base: t, typeMap: { cluster: I, binning: v } };
var p5 = { types: { key: "type", base: t, typeMap: { selection: p2, cluster: I, binning: v } }, json: { name: "layerDefinition.featureReduction", write: { allowNull: true }, origins: { "web-map": { types: o5 }, "portal-item": { types: o5 }, "web-scene": { types: { key: "type", base: t, typeMap: { selection: p2 } }, name: "layerDefinition.featureReduction", write: { layerContainerTypes: a3 } } } } };

// ../node_modules/@arcgis/core/views/2d/layers/support/clusterUtils.js
var l2 = () => n.getLogger("esri.views.2d.layers.support.clusterUtils");
has.add("esri-cluster-arcade-enabled", true);
var u = has("esri-cluster-arcade-enabled");
var p6 = /* @__PURE__ */ new Set(["simple-line", "simple-fill", "picture-fill"]);
function d2(r2, s3) {
  let n3 = s3.clone();
  if (!c(n3)) return n3;
  if (s3.getSymbols().some((e3) => p6.has(e3.type)) && (n3 = new p({ symbol: new y2() })), n3.authoringInfo || (n3.authoringInfo = new j()), n3.authoringInfo.isAutoGenerated = true, "visualVariables" in n3) {
    const e3 = (n3.visualVariables || []).filter((e4) => "$view.scale" !== e4.valueExpression);
    e3.forEach((e4) => {
      "rotation" === e4.type ? e4.field ? e4.field = g3(r2, e4.field, "avg_angle", "number") : e4.valueExpression && (e4.field = b2(r2, e4.valueExpression, "avg_angle", "number"), e4.valueExpression = null) : e4.normalizationField ? (e4.field = g3(r2, e4.field, "avg_norm", "number", e4.normalizationField), e4.normalizationField = null) : e4.field ? e4.field = g3(r2, e4.field, "avg", "number") : e4.valueExpression && (e4.field = b2(r2, e4.valueExpression, "avg", "number"), e4.valueExpression = null);
    }), n3.visualVariables = e3;
  }
  switch (n3.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const e3 of n3.attributes) e3.field ? e3.field = g3(r2, e3.field, "sum", "number") : e3.valueExpression && (e3.field = b2(r2, e3.valueExpression, "sum", "number"), e3.valueExpression = null);
      break;
    case "unique-value":
      n3.field ? n3.field = g3(r2, n3.field, "mode", "string") : n3.valueExpression && (n3.field = b2(r2, n3.valueExpression, "mode", "string"), n3.valueExpression = null);
      break;
    case "class-breaks":
      n3.normalizationField ? (n3.field = g3(r2, n3.field, "avg_norm", "number", n3.normalizationField), n3.normalizationField = null) : n3.field ? n3.field = g3(r2, n3.field, "avg", "number") : n3.valueExpression && (n3.field = b2(r2, n3.valueExpression, "avg", "number"), n3.valueExpression = null);
  }
  return n3;
}
var c = (e3) => {
  const r2 = (r3) => l2().error(new s("Unsupported-renderer", r3, { renderer: e3 }));
  if (!e3) return false;
  switch (e3.type) {
    case "unique-value":
      if (e3.field2 || e3.field3) return r2("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
      break;
    case "class-breaks":
      if (e3.normalizationField) {
        const s3 = e3.normalizationType;
        if ("field" !== s3) return r2(`FeatureReductionCluster does not support a normalizationType of ${s3}`), false;
      }
      break;
    case "simple":
    case "pie-chart":
      break;
    default:
      return r2(`FeatureReductionCluster does not support renderers of type ${e3.type}`), false;
  }
  if (!u) {
    if ("valueExpression" in e3 && e3.valueExpression) return r2("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in e3 && e3.visualVariables || []).some((e4) => !(!("valueExpression" in e4) || !e4.valueExpression))) return r2("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function v2(e3, r2, s3) {
  switch (e3) {
    case "sum":
      return `cluster_sum_${r2}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${r2}`;
    case "mode":
      return `cluster_type_${r2}`;
    case "avg_norm": {
      const e4 = s3, i3 = "field", t2 = r2.toLowerCase() + ",norm:" + i3 + "," + e4.toLowerCase();
      return "cluster_avg_" + x(t2);
    }
  }
}
function b2(e3, r2, s3, o6) {
  const a6 = x(r2), l3 = "mode" === s3 ? `cluster_type_${a6}` : "sum" === s3 ? `cluster_sum_${a6}` : `cluster_avg_${a6}`;
  return e3.some((e4) => e4.name === l3) || e3.push(new a5({ name: l3, isAutoGenerated: true, onStatisticExpression: new i2({ expression: r2, returnType: o6 }), statisticType: s3 })), l3;
}
function g3(e3, r2, s3, n3, o6) {
  if ("cluster_count" === r2 || e3.some((e4) => e4.name === r2)) return r2;
  const a6 = v2(s3, r2, o6);
  return e3.some((e4) => e4.name === a6) || ("avg_norm" === s3 ? e3.push(new a5({ name: a6, isAutoGenerated: true, onStatisticExpression: new i2({ expression: `$feature.${r2} / $feature.${o6}`, returnType: n3 }), statisticType: "avg" })) : e3.push(new a5({ name: a6, isAutoGenerated: true, onStatisticField: r2, statisticType: s3 }))), a6;
}

// ../node_modules/@arcgis/core/layers/mixins/FeatureReductionLayer.js
var c2 = (c3) => {
  let p7 = class extends c3 {
    constructor(...e3) {
      super(...e3), this.addHandles(d(() => this.renderer, () => {
        if (this.featureReduction) {
          const e4 = this._normalizeFeatureReduction(this.featureReduction);
          this._set("featureReduction", e4);
        }
      }, C));
    }
    set featureReduction(e3) {
      const r2 = this._normalizeFeatureReduction(e3);
      this._set("featureReduction", r2);
    }
    set renderer(e3) {
    }
    _withClusterVariable(e3, r2, s3) {
      const t2 = e3.clone();
      if ("visualVariables" in t2) {
        t2.visualVariables || (t2.visualVariables = []);
        t2.visualVariables.some((e4) => "size" === e4.type) || t2.visualVariables.push(new b({ field: "cluster_count", stops: [new a4({ value: 1 }), new a4({ useMinValue: true, size: r2 }), new a4({ useMaxValue: true, size: s3 })] }));
      }
      return t2;
    }
    _normalizeFeatureReduction(e3) {
      var _a;
      if ("cluster" !== (e3 == null ? void 0 : e3.type)) return e3;
      const s3 = e3.clone(), t2 = [new a5({ name: "cluster_count", isAutoGenerated: true, statisticType: "count" })], i3 = (s3.fields ?? []).filter((e4) => !e4.isAutoGenerated), n3 = e3.renderer && !((_a = e3.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated), { clusterMinSize: a6, clusterMaxSize: u2 } = s3;
      if (n3) {
        s3.fields = [...t2, ...i3];
        const e4 = this._withClusterVariable(s3.renderer, a6, u2);
        return s3.effectiveFeatureRenderer = e4, s3.effectiveClusterRenderer = e4, s3;
      }
      if (e3.symbol) {
        if (s3.fields = [...t2, ...i3], s3.renderer = null, !this.renderer) return s3.effectiveFeatureRenderer = null, s3.effectiveClusterRenderer = null, s3;
        const n4 = d2(t2, this.renderer), o6 = this._withClusterVariable(n4, a6, u2), l4 = "visualVariables" in o6 && o6.visualVariables ? o6.visualVariables : [], c5 = new p({ symbol: e3.symbol, visualVariables: l4 });
        return s3.fields = [...t2, ...i3], s3.effectiveFeatureRenderer = o6, s3.effectiveClusterRenderer = c5, s3;
      }
      if (!this.renderer) return e3;
      const l3 = d2(t2, this.renderer);
      s3.fields = [...t2, ...i3], s3.renderer = l3;
      const c4 = this._withClusterVariable(l3, a6, u2);
      return s3.effectiveFeatureRenderer = c4, s3.effectiveClusterRenderer = c4, s3;
    }
  };
  return e([y(p5)], p7.prototype, "featureReduction", null), p7 = e([a2("esri.layers.mixins.FeatureReductionLayer")], p7), p7;
};

export {
  p5 as p,
  c2 as c
};
//# sourceMappingURL=chunk-KW3Q5OC2.js.map
