import {
  i as i2
} from "./chunk-RC7SOLZI.js";
import {
  i as i3
} from "./chunk-IX2O3H2Q.js";
import {
  f as f3,
  y as y2
} from "./chunk-ZCZQCHTP.js";
import "./chunk-SB76Q4D6.js";
import {
  r as r6
} from "./chunk-ZGAEGZY4.js";
import {
  E as E3
} from "./chunk-55VZQ2O4.js";
import {
  o as o2
} from "./chunk-JYOYXNA4.js";
import "./chunk-4RKJDHFK.js";
import {
  e as e7,
  s as s2
} from "./chunk-HER6RLMM.js";
import {
  c as c3,
  e as e6,
  t as t2
} from "./chunk-HDF4ZNLN.js";
import {
  L,
  l as l2
} from "./chunk-6JPHDDUC.js";
import {
  E as E2,
  I as I2
} from "./chunk-X7AJQ4XD.js";
import {
  a as a5,
  i,
  l,
  n as n3,
  r as r4
} from "./chunk-OXVX5F4E.js";
import "./chunk-SLK2EUZ5.js";
import "./chunk-QBIZASGH.js";
import "./chunk-TLURKUXV.js";
import {
  c
} from "./chunk-235Z7ZG7.js";
import "./chunk-JSBYWL75.js";
import {
  c2,
  e2 as e5
} from "./chunk-4ZTHXCOS.js";
import {
  t
} from "./chunk-CRF5P7HT.js";
import {
  d as d2,
  w
} from "./chunk-Y55T56UT.js";
import "./chunk-TCGVPS3X.js";
import "./chunk-A2WMIQD6.js";
import "./chunk-GRVB2MLZ.js";
import "./chunk-G44Z4LKI.js";
import "./chunk-LXZ5X57H.js";
import {
  D,
  F,
  G as G2,
  I,
  O,
  R
} from "./chunk-POOHJZAR.js";
import {
  n as n2
} from "./chunk-MTDWQK7X.js";
import "./chunk-F54TE5DA.js";
import "./chunk-ZPZCSP4J.js";
import "./chunk-5YPRHJQA.js";
import "./chunk-ZVC7ZICV.js";
import {
  h
} from "./chunk-V3JQJNA6.js";
import "./chunk-4C2THXV6.js";
import {
  e as e8,
  r as r5
} from "./chunk-XMJZJ562.js";
import "./chunk-WWC7JPAN.js";
import {
  m
} from "./chunk-VVQOSOJY.js";
import {
  h as h3,
  s
} from "./chunk-WI6OODG3.js";
import "./chunk-GQ3ZCFNN.js";
import "./chunk-QKCF7BZB.js";
import {
  e as e4
} from "./chunk-2U77OHLU.js";
import "./chunk-O45ZPWWN.js";
import "./chunk-VXVUW2QY.js";
import "./chunk-H6PZORTK.js";
import "./chunk-TNRF7MOE.js";
import {
  M,
  f as f2,
  h as h2,
  o
} from "./chunk-PNPG5IXD.js";
import "./chunk-CYGO6TZX.js";
import "./chunk-6V4RA3W6.js";
import {
  r as r3
} from "./chunk-YJXOPMOL.js";
import "./chunk-UFNQVX5G.js";
import {
  z
} from "./chunk-JFTJTGUT.js";
import "./chunk-4N73DVTU.js";
import "./chunk-LGQJAMGK.js";
import {
  d,
  p
} from "./chunk-W3XB5XWO.js";
import {
  e as e3
} from "./chunk-OPCT64AO.js";
import "./chunk-QUNQAVSE.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import {
  p as p2
} from "./chunk-ZRA2NDCA.js";
import "./chunk-JJIIUFER.js";
import "./chunk-ITGBXG45.js";
import "./chunk-YUQFVZCH.js";
import "./chunk-T4EIRKFE.js";
import "./chunk-JQIB7GFW.js";
import {
  d as d3
} from "./chunk-CJJCN7PA.js";
import "./chunk-IJUFAIOF.js";
import "./chunk-MNMU4ARP.js";
import "./chunk-7OW2VNCC.js";
import "./chunk-AFBYZF6Q.js";
import "./chunk-IJ42YN7D.js";
import "./chunk-4AGGGL2W.js";
import "./chunk-FJPG3YI6.js";
import "./chunk-BJHLU2MM.js";
import "./chunk-E5KBRIJQ.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-TW7VY7XV.js";
import "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import "./chunk-BL2UGYYZ.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import {
  E,
  a as a4,
  u as u2
} from "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import {
  _
} from "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import "./chunk-F4OBDVPS.js";
import {
  G
} from "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import {
  Et,
  U
} from "./chunk-WC4SPMPL.js";
import {
  y
} from "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import {
  a3 as a2,
  r
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  a as a3,
  b,
  f,
  v
} from "./chunk-VMWKLHJD.js";
import {
  e as e2,
  r as r2,
  u
} from "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  a,
  n2 as n
} from "./chunk-YNL57W4I.js";
import {
  A2 as A
} from "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e9 = class {
  constructor(e11, t8) {
    this._width = 0, this._height = 0, this._free = [], this._width = e11, this._height = t8, this._free.push(new t(0, 0, e11, t8));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e11, t8) {
    if (e11 > this._width || t8 > this._height) return new t();
    let i8 = null, s5 = -1;
    for (let h9 = 0; h9 < this._free.length; ++h9) {
      const w3 = this._free[h9];
      e11 <= w3.width && t8 <= w3.height && (null === i8 || w3.y <= i8.y && w3.x <= i8.x) && (i8 = w3, s5 = h9);
    }
    return null === i8 ? new t() : (this._free.splice(s5, 1), i8.width < i8.height ? (i8.width > e11 && this._free.push(new t(i8.x + e11, i8.y, i8.width - e11, t8)), i8.height > t8 && this._free.push(new t(i8.x, i8.y + t8, i8.width, i8.height - t8))) : (i8.width > e11 && this._free.push(new t(i8.x + e11, i8.y, i8.width - e11, i8.height)), i8.height > t8 && this._free.push(new t(i8.x, i8.y + t8, e11, i8.height - t8))), new t(i8.x, i8.y, e11, t8));
  }
  release(h9) {
    for (let e11 = 0; e11 < this._free.length; ++e11) {
      const t8 = this._free[e11];
      if (t8.y === h9.y && t8.height === h9.height && t8.x + t8.width === h9.x) t8.width += h9.width;
      else if (t8.x === h9.x && t8.width === h9.width && t8.y + t8.height === h9.y) t8.height += h9.height;
      else if (h9.y === t8.y && h9.height === t8.height && h9.x + h9.width === t8.x) t8.x = h9.x, t8.width += h9.width;
      else {
        if (h9.x !== t8.x || h9.width !== t8.width || h9.y + h9.height !== t8.y) continue;
        t8.y = h9.y, t8.height += h9.height;
      }
      this._free.splice(e11, 1), this.release(h9);
    }
    this._free.push(h9);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var n4 = class {
  constructor(e11, s5, i8) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e11, this.height = s5, this._glyphSource = i8, this._binPack = new e9(e11 - 4, s5 - 4), this._glyphData.push(new Uint8Array(e11 * s5)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s5, i8) {
    const h9 = [], r12 = this._glyphSource, n9 = /* @__PURE__ */ new Set(), o6 = 1 / 256;
    for (const t8 of i8) {
      const e11 = Math.floor(t8 * o6);
      n9.add(e11);
    }
    const a8 = [];
    return n9.forEach((t8) => {
      const e11 = s5 + t8;
      if (this._rangePromises.has(e11)) a8.push(this._rangePromises.get(e11));
      else {
        const i9 = r12.getRange(s5, t8).then(() => {
          this._rangePromises.delete(e11);
        }, () => {
          this._rangePromises.delete(e11);
        });
        this._rangePromises.set(e11, i9), a8.push(i9);
      }
    }), Promise.all(a8).then(() => {
      let n10 = this._glyphIndex[s5];
      n10 || (n10 = {}, this._glyphIndex[s5] = n10);
      for (const o7 of i8) {
        const i9 = n10[o7];
        if (i9) {
          h9[o7] = { sdf: true, rect: i9.rect, metrics: i9.metrics, page: i9.page, code: o7 };
          continue;
        }
        const a9 = r12.getGlyph(s5, o7);
        if (!(a9 == null ? void 0 : a9.metrics)) continue;
        const l6 = a9.metrics;
        let c9;
        if (0 === l6.width) c9 = new t(0, 0, 0, 0);
        else {
          const e11 = 3, s6 = l6.width + 2 * e11, i10 = l6.height + 2 * e11;
          let h10 = s6 % 4 ? 4 - s6 % 4 : 4, r13 = i10 % 4 ? 4 - i10 % 4 : 4;
          1 === h10 && (h10 = 5), 1 === r13 && (r13 = 5), c9 = this._binPack.allocate(s6 + h10, i10 + r13), c9.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e9(this.width - 4, this.height - 4), c9 = this._binPack.allocate(s6 + h10, i10 + r13));
          const n11 = this._glyphData[this._currentPage], o8 = a9.bitmap;
          let g, _3;
          if (o8) for (let t8 = 0; t8 < i10; t8++) {
            g = s6 * t8, _3 = this.width * (c9.y + t8 + 1) + c9.x;
            for (let t9 = 0; t9 < s6; t9++) n11[_3 + t9 + 1] = o8.at(g + t9);
          }
        }
        n10[o7] = { rect: c9, metrics: l6, tileIDs: null, page: this._currentPage }, h9[o7] = { sdf: true, rect: c9, metrics: l6, page: this._currentPage, code: o7 }, this._dirties[this._currentPage] = true;
      }
      return h9;
    });
  }
  removeGlyphs(t8) {
    for (const e11 in this._glyphIndex) {
      const s5 = this._glyphIndex[e11];
      if (!s5) continue;
      let i8;
      for (const e12 in s5) if (i8 = s5[e12], i8.tileIDs.delete(t8), 0 === i8.tileIDs.size) {
        const t9 = this._glyphData[i8.page], h9 = i8.rect;
        let r12, n9;
        for (let e13 = 0; e13 < h9.height; e13++) for (r12 = this.width * (h9.y + e13) + h9.x, n9 = 0; n9 < h9.width; n9++) t9[r12 + n9] = 0;
        delete s5[e12], this._dirties[i8.page] = true;
      }
    }
  }
  bind(t8, e11, n9, o6 = 0) {
    if (!this._textures[n9]) {
      const e12 = new e5();
      e12.pixelFormat = G2.ALPHA, e12.wrapMode = D.CLAMP_TO_EDGE, e12.width = this.width, e12.height = this.height, this._textures[n9] = new c2(t8, e12, new Uint8Array(this.width * this.height));
    }
    const a8 = this._textures[n9];
    a8.setSamplingMode(e11), this._dirties[n9] && a8.setData(this._glyphData[n9]), t8.bindTexture(a8, o6), this._dirties[n9] = false;
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._glyphData.length = 0, this._binPack = null;
    for (const t8 of this._textures) t8 && t8.dispose();
    this._textures.length = 0;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s3 = class {
  constructor(t8) {
    if (this._metrics = [], !t8) return void (this._allBitmaps = null);
    const e11 = /* @__PURE__ */ new Map();
    let s5 = 0;
    for (; t8.next(); ) switch (t8.tag()) {
      case 1: {
        const a9 = t8.getMessage();
        for (; a9.next(); ) switch (a9.tag()) {
          case 3: {
            const t9 = a9.getMessage();
            let r13, n9, i8, c9, o6, g, h9;
            for (; t9.next(); ) switch (t9.tag()) {
              case 1:
                r13 = t9.getUInt32();
                break;
              case 2:
                n9 = t9.getBytes();
                break;
              case 3:
                i8 = t9.getUInt32();
                break;
              case 4:
                c9 = t9.getUInt32();
                break;
              case 5:
                o6 = t9.getSInt32();
                break;
              case 6:
                g = t9.getSInt32();
                break;
              case 7:
                h9 = t9.getUInt32();
                break;
              default:
                t9.skip();
            }
            if (t9.release(), r13) {
              const t10 = (n9 == null ? void 0 : n9.length) ?? 0;
              this._metrics[r13] = { width: i8, height: c9, left: o6, top: g, advance: h9, startOffset: s5, length: t10 }, e11.set(r13, n9), s5 += t10;
            }
            break;
          }
          default:
            a9.skip();
        }
        a9.release();
        break;
      }
      default:
        t8.skip();
    }
    const a8 = new Uint8Array(s5), r12 = this._metrics;
    for (const [n9, i8] of e11) {
      const { startOffset: t9, length: e12 } = r12[n9];
      if (i8) for (let s6 = 0; s6 < e12; ++s6) a8[t9 + s6] = i8[s6];
    }
    this._allBitmaps = a8;
  }
  getMetrics(t8) {
    return this._metrics[t8];
  }
  getBitmap(t8) {
    if (!this._allBitmaps) return;
    const e11 = this._metrics[t8];
    if (void 0 === e11) return;
    const { startOffset: s5, length: a8 } = e11;
    return 0 !== a8 ? new n5(this._allBitmaps, s5, a8) : void 0;
  }
};
var a6 = class {
  constructor() {
    this._ranges = [];
  }
  get ranges() {
    return this._ranges;
  }
  getRange(t8) {
    return this._ranges[t8];
  }
  addRange(t8, e11) {
    this._ranges[t8] = e11;
  }
};
var r7 = class {
  constructor(t8) {
    this._glyphInfo = {}, this._baseURL = t8;
  }
  getRange(a8, r12) {
    const n9 = this._getFontStack(a8);
    if (n9.getRange(r12)) return Promise.resolve();
    const i8 = 256 * r12, c9 = i8 + 255;
    if (this._baseURL) {
      const o6 = this._baseURL.replace("{fontstack}", a8).replace("{range}", i8 + "-" + c9);
      return U(o6, { responseType: "array-buffer" }).then((t8) => {
        n9.addRange(r12, new s3(new n2(new Uint8Array(t8.data), new DataView(t8.data))));
      }).catch(() => {
        n9.addRange(r12, new s3());
      });
    }
    return n9.addRange(r12, new s3()), Promise.resolve();
  }
  getGlyph(t8, e11) {
    const s5 = this._getFontStack(t8);
    if (!s5) return;
    const a8 = Math.floor(e11 / 256), r12 = s5.getRange(a8);
    return r12 ? { metrics: r12.getMetrics(e11), bitmap: r12.getBitmap(e11) } : void 0;
  }
  _getFontStack(t8) {
    let e11 = this._glyphInfo[t8];
    return e11 || (e11 = this._glyphInfo[t8] = new a6()), e11;
  }
};
var n5 = class {
  constructor(t8, e11, s5) {
    this._array = t8, this._start = e11, this.length = s5;
  }
  at(t8) {
    return 0 <= t8 && t8 < this.length ? this._array[this._start + t8] : void 0;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var r8 = "dasharray-";
var o3 = class _o {
  constructor(t8, s5, e11 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, s5 <= 0 && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t8, this._pageHeight = s5, e11 > 0 && (this._maxItemSize = e11), this._binPack = new e9(t8 - 4, s5 - 4);
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._binPack = null, this._mosaicsData.length = 0, this._mosaicRects = {};
    for (const t8 of this._textures) t8 && t8.dispose();
    this._textures.length = 0;
  }
  getWidth(t8) {
    return t8 >= this._size.length ? -1 : this._size[t8][0];
  }
  getHeight(t8) {
    return t8 >= this._size.length ? -1 : this._size[t8][1];
  }
  getPageSize(t8) {
    return t8 >= this._size.length ? null : this._size[t8];
  }
  setSpriteSource(t8) {
    if (this.dispose(), this.pixelRatio = t8.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e9(this._pageWidth - 4, this._pageHeight - 4);
      const t9 = Math.floor(this._pageWidth), s5 = Math.floor(this._pageHeight), e11 = new Uint32Array(t9 * s5);
      this._mosaicsData[0] = e11, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t8;
  }
  getSpriteItem(t8, i8 = false) {
    let s5, e11, h9 = this._mosaicRects[t8];
    if (h9) return h9;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus) return null;
    if (t8 && t8.startsWith(r8) ? ([s5, e11] = this._rasterizeDash(t8), i8 = true) : s5 = this._sprites.getSpriteInfo(t8), !(s5 == null ? void 0 : s5.width) || !s5.height || s5.width < 0 || s5.height < 0) return null;
    const a8 = s5.width, o6 = s5.height, [n9, _3, g] = this._allocateImage(a8, o6);
    return n9.width <= 0 ? null : (this._copy(n9, s5, _3, g, i8, e11), h9 = { type: "sprite", rect: n9, width: a8, height: o6, sdf: s5.sdf, simplePattern: false, rasterizationScale: s5.pixelRatio, page: _3 }, this._mosaicRects[t8] = h9, h9);
  }
  getSpriteItems(t8) {
    const i8 = {};
    for (const s5 of t8) i8[s5.name] = this.getSpriteItem(s5.name, s5.repeat);
    return i8;
  }
  getMosaicItemPosition(t8, i8) {
    const s5 = this.getSpriteItem(t8, i8), e11 = s5 == null ? void 0 : s5.rect;
    if (!e11) return null;
    e11.width = s5.width, e11.height = s5.height;
    const h9 = s5.width, a8 = s5.height, r12 = 2;
    return { tl: [e11.x + r12, e11.y + r12], br: [e11.x + r12 + h9, e11.y + r12 + a8], page: s5.page };
  }
  bind(t8, i8, s5 = 0, r12 = 0) {
    if (s5 >= this._size.length || s5 >= this._mosaicsData.length) return;
    if (!this._textures[s5]) {
      const i9 = new e5();
      i9.wrapMode = D.CLAMP_TO_EDGE, i9.width = this._size[s5][0], i9.height = this._size[s5][1], this._textures[s5] = new c2(t8, i9, new Uint8Array(this._mosaicsData[s5].buffer));
    }
    const o6 = this._textures[s5];
    o6.setSamplingMode(i8), this._dirties[s5] && o6.setData(new Uint8Array(this._mosaicsData[s5].buffer)), t8.bindTexture(o6, r12), this._dirties[s5] = false;
  }
  static _copyBits(t8, i8, s5, e11, h9, a8, r12, o6, n9, _3, g) {
    let c9 = e11 * i8 + s5, p5 = o6 * a8 + r12;
    if (g) {
      p5 -= a8;
      for (let r13 = -1; r13 <= _3; r13++, c9 = ((r13 + _3) % _3 + e11) * i8 + s5, p5 += a8) for (let i9 = -1; i9 <= n9; i9++) h9[p5 + i9] = t8[c9 + (i9 + n9) % n9];
    } else for (let l6 = 0; l6 < _3; l6++) {
      for (let i9 = 0; i9 < n9; i9++) h9[p5 + i9] = t8[c9 + i9];
      c9 += i8, p5 += a8;
    }
  }
  _copy(t8, i8, s5, e11, h9, a8) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || s5 >= this._mosaicsData.length) return;
    const r12 = new Uint32Array(a8 ? a8.buffer : this._sprites.image.buffer), n9 = this._mosaicsData[s5], _3 = 2, g = a8 ? i8.width : this._sprites.width;
    _o._copyBits(r12, g, i8.x, i8.y, n9, e11[0], t8.x + _3, t8.y + _3, i8.width, i8.height, h9), this._dirties[s5] = true;
  }
  _allocateImage(t8, e11) {
    t8 += 2, e11 += 2;
    const h9 = Math.max(t8, e11);
    if (this._maxItemSize && this._maxItemSize < h9) {
      const i8 = new t(0, 0, t8, e11);
      return this._mosaicsData.push(new Uint32Array(t8 * e11)), this._dirties.push(true), this._size.push([t8, e11]), this._textures.push(void 0), [i8, this._mosaicsData.length - 1, [t8, e11]];
    }
    let a8 = t8 % 4 ? 4 - t8 % 4 : 4, r12 = e11 % 4 ? 4 - e11 % 4 : 4;
    1 === a8 && (a8 = 5), 1 === r12 && (r12 = 5);
    const o6 = this._binPack.allocate(t8 + a8, e11 + r12);
    return o6.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e9(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t8, e11)) : [o6, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i8) {
    const s5 = /\[(.*?)\]/, e11 = i8.match(s5);
    if (!e11) return null;
    const h9 = e11[1].split(",").map(Number), a8 = i8.slice(i8.lastIndexOf("-") + 1), [r12, o6, n9] = i2(h9, a8);
    return [{ x: 0, y: 0, width: o6, height: n9, sdf: true, pixelRatio: 1 }, new Uint8Array(r12.buffer)];
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var h4 = class {
  constructor(t8, e11, s5, r12) {
    this._layer = t8, this._styleRepository = e11, this.devicePixelRatio = s5, this._sourceDataMaxLOD = r12, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    var _a, _b, _c;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null, this._styleRepository = null, this._layer = null, (_b = this._spriteMosaic) == null ? void 0 : _b.destroy(), this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e2(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && ((_c = this._startOptionsInputSignal) == null ? void 0 : _c.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t8) {
    this._requestSprite(t8);
    const s5 = this._layer.currentStyleInfo.glyphsUrl, r12 = new r7(s5 ? Et(s5, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new n4(1024, 1024, r12), this._broadcastPromise = p2("WorkerTileHandler", { client: this, schedule: t8.schedule, signal: t8.signal }).then((s6) => {
      var _a;
      if (this._layer && ((_a = this._connection) == null ? void 0 : _a.close(), this._connection = s6, this._layer && !this._connection.closed)) {
        const r13 = s6.broadcast("setStyle", { style: this._layer.currentStyleInfo.style, sourceDataMaxLOD: this._sourceDataMaxLOD }, t8);
        Promise.all(r13).catch((t9) => f(t9));
      }
    });
  }
  _requestSprite(t8) {
    var _a, _b;
    (_a = this._spriteSourceAbortController) == null ? void 0 : _a.abort();
    const e11 = new AbortController();
    this._spriteSourceAbortController = e11;
    const r12 = t8 == null ? void 0 : t8.signal;
    this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, r12 && (this._inputSignalEventListener = p3(e11), r12.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i8 } = e11, o6 = { ...t8, signal: i8 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o6), this._spriteSourcePromise.then((t9) => {
      a3(i8), this._spriteMosaic = new o3(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t9);
    });
  }
  async updateStyle(t8) {
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", t8)), this._broadcastPromise;
  }
  setSpriteSource(t8) {
    const e11 = new o3(1024, 1024, 250);
    return e11.setSpriteSource(t8), this._spriteMosaic = e11, this._spriteSourcePromise = Promise.resolve(t8), this._spriteSourceAbortController = null, e11;
  }
  async setStyle(t8, e11, s5) {
    await this._broadcastPromise, this._styleRepository = t8, this._sourceDataMaxLOD = s5, this._requestSprite();
    const r12 = new r7(this._layer.currentStyleInfo.glyphsUrl ? Et(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new n4(1024, 1024, r12), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", { style: e11, sourceDataMaxLOD: this._sourceDataMaxLOD })), this._broadcastPromise;
  }
  async fetchTileData(t8, e11) {
    const s5 = await this._getRefKeys(t8, e11);
    return this._getSourcesData(Object.keys(this._layer.sourceNameToSource), s5, e11);
  }
  async fetchTilePBFs(t8) {
    const e11 = Object.keys(this._layer.sourceNameToSource), s5 = {}, r12 = await this._getRefKeys(t8, s5), i8 = [], o6 = [];
    for (let n9 = 0; n9 < r12.length; n9++) if (null == r12[n9].value || null == e11[n9]) o6.push(null);
    else {
      const t9 = r12[n9].value, a8 = this._getTilePayload(t9, e11[n9], s5);
      a8.then((e12) => {
        i8.push({ ...e12, key: t9 });
      }), o6.push(a8);
    }
    return Promise.all(o6).then(() => i8);
  }
  async parseTileData(t8, e11) {
    const s5 = t8 && t8.data;
    if (!s5) return null;
    const { sourceName2DataAndRefKey: r12, transferList: i8 } = s5;
    return 0 === Object.keys(r12).length ? null : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t8.key.id, sourceName2DataAndRefKey: r12, styleLayerUIDs: t8.styleLayerUIDs }, { ...e11, transferList: i8 }));
  }
  async getSprites(t8) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t8);
  }
  getGlyphs(t8) {
    return this._glyphMosaic.getGlyphItems(t8.font, t8.codePoints);
  }
  async _getTilePayload(t8, e11, s5) {
    const i8 = e4.pool.acquire(t8.id), o6 = this._layer.sourceNameToSource[e11], { level: n9, row: a8, col: l6 } = i8;
    e4.pool.release(i8);
    try {
      return { protobuff: await o6.requestTile(n9, a8, l6, s5), sourceName: e11 };
    } catch (c9) {
      if (b(c9)) throw c9;
      return { protobuff: null, sourceName: e11 };
    }
  }
  async _getRefKeys(t8, e11) {
    const s5 = this._layer.sourceNameToSource, r12 = new Array();
    for (const i8 in s5) {
      const o6 = s5[i8].getRefKey(t8, e11);
      r12.push(o6);
    }
    return v(r12);
  }
  _getSourcesData(t8, e11, s5) {
    const r12 = [];
    for (let i8 = 0; i8 < e11.length; i8++) if (null == e11[i8].value || null == t8[i8]) r12.push(null);
    else {
      const o6 = e11[i8].value, n9 = this._getTilePayload(o6, t8[i8], s5);
      r12.push(n9);
    }
    return v(r12).then((t9) => {
      const s6 = {}, r13 = [];
      for (let i8 = 0; i8 < t9.length; i8++) {
        const o6 = t9[i8].value;
        if (o6 && (o6.protobuff && o6.protobuff.byteLength > 0)) {
          const t10 = e11[i8].value.id;
          s6[o6.sourceName] = { refKey: t10, protobuff: o6.protobuff }, r13.push(o6.protobuff);
        }
      }
      return { sourceName2DataAndRefKey: s6, transferList: r13 };
    });
  }
};
function p3(t8) {
  return () => t8.abort();
}

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var r9 = 512;
var n6 = 1e-6;
var a7 = (e11, i8) => e11 + 1 / (1 << 2 * i8);
var h5 = class {
  constructor(i8, t8) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e3(40, (e11) => e11.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i8.acquireTile, this.releaseTile = i8.releaseTile, this.tileInfoView = i8.tileInfoView, this._container = t8;
  }
  destroy() {
    for (const [e11, i8] of this._tiles) i8.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e11) {
    this._updateCacheSize(e11);
    const i8 = this.tileInfoView, t8 = i8.getTileCoverage(e11.state, 0, true, "smallest");
    if (!t8) return true;
    const { spans: l6, lodInfo: r12 } = t8, { level: n9 } = r12, a8 = this._tiles, h9 = /* @__PURE__ */ new Set(), c9 = /* @__PURE__ */ new Set();
    for (const { row: s5, colFrom: _3, colTo: f5 } of l6) for (let e12 = _3; e12 <= f5; e12++) {
      const i9 = e4.getId(n9, s5, r12.normalizeCol(e12), r12.getWorldForColumn(e12)), t9 = this._getOrAcquireTile(i9);
      h9.add(i9), t9.processed() ? this._addToContainer(t9) : c9.add(new e4(i9));
    }
    for (const [s5, o6] of a8) o6.isCoverage = h9.has(s5);
    for (const s5 of c9) this._findPlaceholdersForMissingTiles(s5, h9);
    let d7 = false;
    for (const [s5, o6] of a8) o6.neededForCoverage = h9.has(s5), o6.neededForCoverage || o6.isHoldingForFade && i8.intersects(t8, o6.key) && h9.add(s5), o6.isFading && (d7 = true);
    for (const [s5, o6] of this._tiles) h9.has(s5) || this._releaseTile(s5);
    return s.pool.release(t8), !d7;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  getIntersectingTiles(e11, s5, o6, r12, n9) {
    const a8 = [0, 0], h9 = [0, 0];
    r12.toMap(a8, e11 - o6, s5 + o6), r12.toMap(h9, e11 + o6, s5 - o6);
    const c9 = Math.min(a8[0], h9[0]), d7 = Math.min(a8[1], h9[1]), _3 = Math.max(a8[0], h9[0]), f5 = Math.max(a8[1], h9[1]), T = a4(c9, d7, _3, f5), p5 = u2(), u5 = [];
    for (const [i8, t8] of this._visibleTiles) this.tileInfoView.getTileBounds(p5, t8.key), E(T, p5) && u5.push(t8);
    if (null != n9 && n9.length > 0) {
      const e12 = new Set(u5.map((e13) => e13.id)), i8 = n9.filter((i9) => !e12.has(i9.tileKey.id)).map((e13) => this._visibleTiles.get(e13.tileKey.id)).filter((e13) => void 0 !== e13);
      u5.push(...i8);
    }
    return u5;
  }
  _findPlaceholdersForMissingTiles(e11, i8) {
    const t8 = [];
    for (const [s5, o6] of this._tiles) this._addPlaceholderChild(t8, o6, e11, i8);
    const l6 = t8.reduce(a7, 0);
    Math.abs(1 - l6) < n6 || this._addPlaceholderParent(e11.id, i8);
  }
  _addPlaceholderChild(e11, i8, t8, l6) {
    i8.key.level <= t8.level || !i8.hasData() || d4(t8, i8.key) && (this._addToContainer(i8), l6.add(i8.id), e11.push(i8.key.level - t8.level));
  }
  _addPlaceholderParent(e11, i8) {
    const t8 = this._tiles;
    let l6 = e11;
    for (; ; ) {
      if (l6 = c4(l6), !l6 || i8.has(l6)) return;
      const e12 = t8.get(l6);
      if (e12 == null ? void 0 : e12.hasData()) return this._addToContainer(e12), void i8.add(e12.id);
    }
  }
  _getOrAcquireTile(e11) {
    let i8 = this._tiles.get(e11);
    return i8 || (i8 = this._tileCache.pop(e11), i8 || (i8 = this.acquireTile(new e4(e11))), this._tiles.set(e11, i8), i8);
  }
  _releaseTile(e11) {
    const i8 = this._tiles.get(e11);
    this.releaseTile(i8), this._removeFromContainer(i8), this._tiles.delete(e11), i8.hasData() ? this._tileCache.put(e11, i8, 1) : i8.dispose();
  }
  _addToContainer(e11) {
    let i8;
    const t8 = [], l6 = this._container;
    if (l6.contains(e11)) return;
    const s5 = this._visibleTiles;
    for (const [o6, r12] of s5) this._canConnectDirectly(e11, r12) && t8.push(r12), null == i8 && this._canConnectDirectly(r12, e11) && (i8 = r12);
    if (null != i8) {
      for (const l7 of t8) i8.childrenTiles.delete(l7), e11.childrenTiles.add(l7), l7.parentTile = e11;
      i8.childrenTiles.add(e11), e11.parentTile = i8;
    } else for (const o6 of t8) e11.childrenTiles.add(o6), o6.parentTile = e11;
    s5.set(e11.id, e11), l6.addChild(e11);
  }
  _removeFromContainer(e11) {
    if (this._visibleTiles.delete(e11.id), this._container.removeChild(e11), null != e11.parentTile) {
      e11.parentTile.childrenTiles.delete(e11);
      for (const i8 of e11.childrenTiles) null != e11.parentTile && e11.parentTile.childrenTiles.add(i8);
    }
    for (const i8 of e11.childrenTiles) i8.parentTile = e11.parentTile;
    e11.parentTile = null, e11.childrenTiles.clear();
  }
  _canConnectDirectly(e11, i8) {
    const t8 = e11.key;
    let { level: l6, row: s5, col: o6, world: r12 } = i8.key;
    const n9 = this._visibleTiles;
    for (; l6 > 0; ) {
      if (l6--, s5 >>= 1, o6 >>= 1, t8.level === l6 && t8.row === s5 && t8.col === o6 && t8.world === r12) return true;
      if (n9.has(`${l6}/${s5}/${o6}/${r12}`)) return false;
    }
    return false;
  }
  _updateCacheSize(e11) {
    const i8 = e11.state.size;
    if (i8[0] === this._viewSize[0] && i8[1] === this._viewSize[1]) return;
    const t8 = Math.ceil(i8[0] / r9) + 1, l6 = Math.ceil(i8[1] / r9) + 1;
    this._viewSize[0] = i8[0], this._viewSize[1] = i8[1], this._tileCache.maxSize = 5 * t8 * l6;
  }
};
function c4(e11) {
  const [i8, t8, l6, s5] = e11.split("/"), o6 = parseInt(i8, 10);
  return 0 === o6 ? null : `${o6 - 1}/${parseInt(t8, 10) >> 1}/${parseInt(l6, 10) >> 1}/${parseInt(s5, 10)}`;
}
function d4(e11, i8) {
  const t8 = i8.level - e11.level;
  return e11.row === i8.row >> t8 && e11.col === i8.col >> t8 && e11.world === i8.world;
}

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/core.js
var t3 = class {
  constructor(t8, s5) {
    this.sourceTile = s5, this.xTile = 0, this.yTile = 0, this.hash = 0, this.priority = 1, this.featureIndex = 0, this.colliders = [], this.textVertexRanges = [], this.iconVertexRanges = [], this.tile = t8;
  }
};
var s4 = class {
  constructor() {
    this.tileSymbols = [], this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }], this.show = false;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/util.js
function o4(t8, e11, s5, o6, i8, l6) {
  const r12 = s5 - i8;
  if (r12 >= 0) return (e11 >> r12) + (o6 - (l6 << r12)) * (t8 >> r12);
  const n9 = -r12;
  return e11 - (l6 - (o6 << n9)) * (t8 >> n9) << n9;
}
var i4 = class {
  constructor(t8, e11, s5) {
    this._rows = Math.ceil(e11 / s5), this._columns = Math.ceil(t8 / s5), this._cellSize = s5, this.cells = new Array(this._rows);
    for (let o6 = 0; o6 < this._rows; o6++) {
      this.cells[o6] = new Array(this._columns);
      for (let t9 = 0; t9 < this._columns; t9++) this.cells[o6][t9] = [];
    }
  }
  getCell(t8, e11) {
    const s5 = Math.min(Math.max(Math.floor(e11 / this._cellSize), 0), this._rows - 1), o6 = Math.min(Math.max(Math.floor(t8 / this._cellSize), 0), this._columns - 1);
    return this.cells[s5] && this.cells[s5][o6] || null;
  }
  getCellSpan(t8, e11, s5, o6) {
    return [Math.min(Math.max(Math.floor(t8 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(e11 / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(s5 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(o6 / this._cellSize), 0), this.rows - 1)];
  }
  get cellSize() {
    return this._cellSize;
  }
  get columns() {
    return this._columns;
  }
  get rows() {
    return this._rows;
  }
};
function l3(t8, e11, o6, i8, l6, r12, n9) {
  const c9 = e11[i8++];
  for (let a8 = 0; a8 < c9; a8++) {
    const c10 = new t3(r12, n9);
    c10.xTile = e11[i8++], c10.yTile = e11[i8++], c10.hash = e11[i8++], c10.priority = e11[i8++], c10.featureIndex = e11[i8++];
    const a9 = e11[i8++];
    for (let t9 = 0; t9 < a9; t9++) {
      const t10 = e11[i8++], s5 = e11[i8++], l7 = e11[i8++], r13 = e11[i8++], n10 = !!e11[i8++], a10 = e11[i8++], h10 = o6[i8++], u6 = o6[i8++], f5 = e11[i8++], m5 = e11[i8++];
      c10.colliders.push({ xTile: t10, yTile: s5, dxPixels: l7, dyPixels: r13, hard: n10, partIndex: a10, width: f5, height: m5, minLod: h10, maxLod: u6 });
    }
    const h9 = t8[i8++];
    for (let e12 = 0; e12 < h9; e12++) c10.textVertexRanges.push([t8[i8++], t8[i8++]]);
    const u5 = t8[i8++];
    for (let e12 = 0; e12 < u5; e12++) c10.iconVertexRanges.push([t8[i8++], t8[i8++]]);
    l6.push(c10);
  }
  return i8;
}
function r10(t8, e11, s5) {
  for (const [o6, i8] of t8.symbols) n7(t8, e11, s5, i8, o6);
}
function n7(e11, s5, o6, i8, l6) {
  const r12 = e11.layerData.get(l6);
  if (r12.type === E2.SYMBOL) {
    for (const t8 of i8) {
      const s6 = t8.unique;
      let i9;
      if (t8.selectedForRendering) {
        const t9 = s6.parts[0], l7 = t9.startOpacity, r13 = t9.targetOpacity;
        e11.allSymbolsFadingOut = e11.allSymbolsFadingOut && 0 === r13;
        const n9 = o6 ? Math.floor(127 * l7) | r13 << 7 : r13 ? 255 : 0;
        i9 = n9 << 24 | n9 << 16 | n9 << 8 | n9;
      } else i9 = 0;
      for (const [e12, o7] of t8.iconVertexRanges) for (let t9 = e12; t9 < e12 + o7; t9 += 4) r12.iconOpacity[t9 / 4] = i9;
      if (t8.selectedForRendering) {
        const t9 = s6.parts[1], l7 = t9.startOpacity, r13 = t9.targetOpacity;
        e11.allSymbolsFadingOut = e11.allSymbolsFadingOut && 0 === r13;
        const n9 = o6 ? Math.floor(127 * l7) | r13 << 7 : r13 ? 255 : 0;
        i9 = n9 << 24 | n9 << 16 | n9 << 8 | n9;
      } else i9 = 0;
      for (const [e12, o7] of t8.textVertexRanges) for (let t9 = e12; t9 < e12 + o7; t9 += 4) r12.textOpacity[t9 / 4] = i9;
    }
    r12.lastOpacityUpdate = s5, r12.opacityChanged = true;
  }
}
function c5(t8, s5, o6, i8) {
  const l6 = t8.colliders;
  let r12, n9, c9, a8;
  for (const h9 of l6) {
    if (t8.unique.show && t8.unique.parts[h9.partIndex].show && (r12 = h9.xScreen - i8[0] + h9.dxScreen, n9 = h9.yScreen - i8[1] + h9.dyScreen, c9 = r12 + h9.width, a8 = n9 + h9.height, w(o6, s5.x, s5.y, r12, n9, c9, a8))) return true;
  }
  return false;
}

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/RenderBucket.js
var h6 = class {
  constructor(t8, e11) {
    this.layerUIDs = [], this.isDestroyed = false, this._data = t8;
    let r12 = 1;
    const n9 = new Uint32Array(t8);
    this.layerUIDs = [];
    const s5 = n9[r12++];
    for (let i8 = 0; i8 < s5; i8++) this.layerUIDs[i8] = n9[r12++];
    this.bufferDataOffset = r12, e11 && (this.layer = e11.getStyleLayerByUID(this.layerUIDs[0]));
  }
  get isPreparedForRendering() {
    return null == this._data;
  }
  get offset() {
    return this.bufferDataOffset;
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.isDestroyed || (this.doDestroy(), this._data = null, this.isDestroyed = true);
  }
  prepareForRendering(t8) {
    null != this._data && (this.doPrepareForRendering(t8, this._data, this.bufferDataOffset), this._data = null);
  }
};
var f4 = class extends h6 {
  constructor(t8, e11) {
    super(t8, e11), this.type = E2.LINE, this.lineIndexStart = 0, this.lineIndexCount = 0;
    const r12 = new Uint32Array(t8);
    let s5 = this.bufferDataOffset;
    this.lineIndexStart = r12[s5++], this.lineIndexCount = r12[s5++];
    const i8 = r12[s5++];
    if (i8 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t9 = 0; t9 < i8; t9++) {
        const t10 = r12[s5++], e12 = r12[s5++], n9 = r12[s5++];
        this.patternMap.set(t10, [e12, n9]);
      }
    }
    this.bufferDataOffset = s5;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.usedMemory) ?? 0);
  }
  hasData() {
    return this.lineIndexCount > 0;
  }
  triangleCount() {
    return this.lineIndexCount / 3;
  }
  doDestroy() {
    this.vao = r2(this.vao);
  }
  doPrepareForRendering(t8, e11, r12) {
    const n9 = new Uint32Array(e11), s5 = new Int32Array(n9.buffer), h9 = n9[r12++], f5 = c.createVertex(t8, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r12, h9));
    r12 += h9;
    const l6 = n9[r12++], c9 = c.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r12, l6));
    r12 += l6;
    const u5 = this.layer.lineMaterial;
    this.vao = new o2(t8, u5.getAttributeLocations(), u5.getLayoutInfo(), { geometry: f5 }, c9);
  }
};
var l4 = class extends h6 {
  constructor(t8, e11) {
    super(t8, e11), this.type = E2.FILL, this.fillIndexStart = 0, this.fillIndexCount = 0, this.outlineIndexStart = 0, this.outlineIndexCount = 0;
    const r12 = new Uint32Array(t8);
    let s5 = this.bufferDataOffset;
    this.fillIndexStart = r12[s5++], this.fillIndexCount = r12[s5++], this.outlineIndexStart = r12[s5++], this.outlineIndexCount = r12[s5++];
    const i8 = r12[s5++];
    if (i8 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t9 = 0; t9 < i8; t9++) {
        const t10 = r12[s5++], e12 = r12[s5++], n9 = r12[s5++];
        this.patternMap.set(t10, [e12, n9]);
      }
    }
    this.bufferDataOffset = s5;
  }
  get memoryUsed() {
    var _a, _b, _c;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.fillVAO) == null ? void 0 : _b.usedMemory) ?? 0) + (((_c = this.outlineVAO) == null ? void 0 : _c.usedMemory) ?? 0);
  }
  hasData() {
    return this.fillIndexCount > 0 || this.outlineIndexCount > 0;
  }
  triangleCount() {
    return (this.fillIndexCount + this.outlineIndexCount) / 3;
  }
  doDestroy() {
    this.fillVAO = r2(this.fillVAO), this.outlineVAO = r2(this.outlineVAO);
  }
  doPrepareForRendering(t8, e11, r12) {
    const n9 = new Uint32Array(e11), s5 = new Int32Array(n9.buffer), h9 = n9[r12++], f5 = c.createVertex(t8, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r12, h9));
    r12 += h9;
    const l6 = n9[r12++], c9 = c.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r12, l6));
    r12 += l6;
    const u5 = n9[r12++], y5 = c.createVertex(t8, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r12, u5));
    r12 += u5;
    const d7 = n9[r12++], A3 = c.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r12, d7));
    r12 += d7;
    const I4 = this.layer, p5 = I4.fillMaterial, g = I4.outlineMaterial;
    this.fillVAO = new o2(t8, p5.getAttributeLocations(), p5.getLayoutInfo(), { geometry: f5 }, c9), this.outlineVAO = new o2(t8, g.getAttributeLocations(), g.getLayoutInfo(), { geometry: y5 }, A3);
  }
};
var c6 = class extends h6 {
  constructor(t8, e11, i8) {
    super(t8, e11), this.type = E2.SYMBOL, this.iconPerPageElementsMap = /* @__PURE__ */ new Map(), this.glyphPerPageElementsMap = /* @__PURE__ */ new Map(), this.symbolInstances = [], this.isIconSDF = false, this.opacityChanged = false, this.lastOpacityUpdate = 0, this.symbols = [];
    const a8 = new Uint32Array(t8), o6 = new Int32Array(t8), h9 = new Float32Array(t8);
    let f5 = this.bufferDataOffset;
    this.isIconSDF = !!a8[f5++];
    const l6 = a8[f5++], c9 = a8[f5++], u5 = a8[f5++], y5 = new e4(l6, c9, u5, 0), d7 = a8[f5++];
    for (let r12 = 0; r12 < d7; r12++) {
      const t9 = a8[f5++], e12 = a8[f5++], r13 = a8[f5++];
      this.iconPerPageElementsMap.set(t9, [e12, r13]);
    }
    const A3 = a8[f5++];
    for (let r12 = 0; r12 < A3; r12++) {
      const t9 = a8[f5++], e12 = a8[f5++], r13 = a8[f5++];
      this.glyphPerPageElementsMap.set(t9, [e12, r13]);
    }
    const I4 = a8[f5++], p5 = a8[f5++];
    this.iconOpacity = new Int32Array(I4), this.textOpacity = new Int32Array(p5), f5 = l3(a8, o6, h9, f5, this.symbols, i8, y5), this.bufferDataOffset = f5;
  }
  get memoryUsed() {
    var _a, _b, _c2;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.iconVAO) == null ? void 0 : _b.usedMemory) ?? 0) + (((_c2 = this.textVAO) == null ? void 0 : _c2.usedMemory) ?? 0) + A(this.iconOpacity) + A(this.textOpacity);
  }
  hasData() {
    return this.iconPerPageElementsMap.size > 0 || this.glyphPerPageElementsMap.size > 0;
  }
  triangleCount() {
    let t8 = 0;
    for (const [e11, r12] of this.iconPerPageElementsMap) t8 += r12[1];
    for (const [e11, r12] of this.glyphPerPageElementsMap) t8 += r12[1];
    return t8 / 3;
  }
  doDestroy() {
    this.iconVAO = r2(this.iconVAO), this.textVAO = r2(this.textVAO);
  }
  updateOpacityInfo() {
    if (!this.opacityChanged) return;
    this.opacityChanged = false;
    const t8 = this.iconOpacity, e11 = this.iconVAO.vertexBuffers.opacity;
    t8.length > 0 && t8.byteLength === e11.usedMemory && e11.setSubData(t8, 0, 0, t8.length);
    const r12 = this.textOpacity, n9 = this.textVAO.vertexBuffers.opacity;
    r12.length > 0 && r12.byteLength === n9.usedMemory && n9.setSubData(r12, 0, 0, r12.length);
  }
  doPrepareForRendering(t8, e11, r12) {
    const n9 = new Uint32Array(e11), s5 = new Int32Array(n9.buffer), h9 = n9[r12++], f5 = c.createVertex(t8, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r12, h9));
    r12 += h9;
    const l6 = n9[r12++], c9 = c.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r12, l6));
    r12 += l6;
    const u5 = n9[r12++], y5 = c.createVertex(t8, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r12, u5));
    r12 += u5;
    const d7 = n9[r12++], A3 = c.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r12, d7));
    r12 += d7;
    const I4 = c.createVertex(t8, F.STATIC_DRAW, this.iconOpacity.buffer), p5 = c.createVertex(t8, F.STATIC_DRAW, this.textOpacity.buffer), g = this.layer, x = g.iconMaterial, m5 = g.textMaterial;
    this.iconVAO = new o2(t8, x.getAttributeLocations(), x.getLayoutInfo(), { geometry: f5, opacity: I4 }, c9), this.textVAO = new o2(t8, m5.getAttributeLocations(), m5.getLayoutInfo(), { geometry: y5, opacity: p5 }, A3);
  }
};
var u3 = class extends h6 {
  constructor(t8, e11) {
    super(t8, e11), this.type = E2.CIRCLE, this.circleIndexStart = 0, this.circleIndexCount = 0;
    const r12 = new Uint32Array(t8);
    let s5 = this.bufferDataOffset;
    this.circleIndexStart = r12[s5++], this.circleIndexCount = r12[s5++], this.bufferDataOffset = s5;
  }
  get memoryUsed() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.usedMemory) ?? 0);
  }
  hasData() {
    return this.circleIndexCount > 0;
  }
  triangleCount() {
    return this.circleIndexCount / 3;
  }
  doDestroy() {
    this.vao = r2(this.vao);
  }
  doPrepareForRendering(t8, e11, r12) {
    const n9 = new Uint32Array(e11), s5 = new Int32Array(n9.buffer), h9 = n9[r12++], f5 = c.createVertex(t8, F.STATIC_DRAW, new Int32Array(s5.buffer, 4 * r12, h9));
    r12 += h9;
    const l6 = n9[r12++], c9 = c.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r12, l6));
    r12 += l6;
    const u5 = this.layer.circleMaterial;
    this.vao = new o2(t8, u5.getAttributeLocations(), u5.getLayoutInfo(), { geometry: f5 }, c9);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTile.js
var d5 = class _d extends r6 {
  constructor(e11, t8, s5, a8, r12, i8, o6, h9 = null) {
    super(e11, t8, s5, a8, r12, i8, 4096, 4096), this.styleRepository = o6, this._memCache = h9, this.type = "vector-tile", this._referenced = 0, this._hasSymbolBuckets = false, this._memoryUsedByLayerData = 0, this.layerData = /* @__PURE__ */ new Map(), this.status = "loading", this.allSymbolsFadingOut = false, this.lastOpacityUpdate = 0, this.symbols = /* @__PURE__ */ new Map(), this.isCoverage = false, this.neededForCoverage = false, this.decluttered = false, this.parentTile = null, this.childrenTiles = /* @__PURE__ */ new Set(), this.featureIndex = null, this.triangleCount = 0, this._processed = false, this._referenced = 1, this.id = e11.id;
  }
  get hasSymbolBuckets() {
    return this._hasSymbolBuckets;
  }
  get isFading() {
    return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < e6;
  }
  get isHoldingForFade() {
    return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < e6);
  }
  get wasRequested() {
    return "errored" === this.status || "loaded" === this.status || "reloading" === this.status;
  }
  setData(e11) {
    this.changeDataImpl(e11), this.requestRender(), this.ready(), this._processed = true;
  }
  deleteLayerData(e11) {
    var _a, _b;
    let t8 = false;
    for (const s5 of e11) {
      const e12 = this.layerData.get(s5);
      e12 && (this._memoryUsedByLayerData -= e12.memoryUsed, e12.type === E2.SYMBOL && this.symbols.delete(s5) && (t8 = true), e12.destroy(), this.layerData.delete(s5));
    }
    (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this._memoryUsedByLayerData), t8 && ((_b = this.featureIndex) == null ? void 0 : _b.clear(), this.emit("symbols-changed")), this.requestRender();
  }
  processed() {
    return this._processed;
  }
  hasData() {
    return this.layerData.size > 0;
  }
  dispose() {
    "unloaded" !== this.status && (this.featureIndex = null, m2.delete(this), _d._destroyRenderBuckets(this.layerData), this.layerData.clear(), this._memoryUsedByLayerData = 0, this.destroy(), this.status = "unloaded");
  }
  release() {
    return 0 == --this._referenced && (this.dispose(), this.stage = null, true);
  }
  retain() {
    ++this._referenced;
  }
  get referenced() {
    return this._referenced;
  }
  get usedMemory() {
    return this._memoryUsedByLayerData + 256;
  }
  changeDataImpl(e11) {
    var _a, _b;
    (_a = this.featureIndex) == null ? void 0 : _a.clear();
    let t8 = false;
    if (e11) {
      const { bucketsWithData: s5, emptyBuckets: a8 } = e11, r12 = this._createRenderBuckets(s5);
      if (a8 && a8.byteLength > 0) {
        const e12 = new Uint32Array(a8);
        for (const t9 of e12) this._deleteLayerData(t9);
      }
      for (const [e12, o6] of r12) this._deleteLayerData(e12), o6.type === E2.SYMBOL && (this.symbols.set(e12, o6.symbols), t8 = true), this._memoryUsedByLayerData += o6.memoryUsed, this.layerData.set(e12, o6);
      (_b = this._memCache) == null ? void 0 : _b.updateSize(this.key.id, this, this.usedMemory);
    }
    this._hasSymbolBuckets = false;
    for (const [s5, a8] of this.layerData) a8.type === E2.SYMBOL && (this._hasSymbolBuckets = true);
    t8 && this.emit("symbols-changed");
  }
  attachWithContext(e11) {
    this.stage = { context: e11, trashDisplayObject(e12) {
      e12.processDetach();
    }, untrashDisplayObject: () => false };
  }
  setTransform(r12) {
    super.setTransform(r12);
    const i8 = this.resolution / (r12.resolution * r12.pixelRatio), o6 = this.width / this.rangeX * i8, h9 = this.height / this.rangeY * i8, n9 = [0, 0];
    r12.toScreen(n9, [this.x, this.y]);
    const l6 = this.transforms.tileUnitsToPixels;
    o(l6), M(l6, l6, n9), h2(l6, l6, Math.PI * r12.rotation / 180), f2(l6, l6, [o6, h9, 1]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e8(), tileMat3: e8(), tileUnitsToPixels: e8() };
  }
  static _destroyRenderBuckets(e11) {
    if (!e11) return;
    const t8 = /* @__PURE__ */ new Set();
    for (const s5 of e11.values()) t8.has(s5) || (s5.destroy(), t8.add(s5));
    e11.clear();
  }
  _createRenderBuckets(e11) {
    const t8 = /* @__PURE__ */ new Map(), s5 = /* @__PURE__ */ new Map();
    for (const a8 of e11) {
      const e12 = this._deserializeBucket(a8, s5);
      for (const s6 of e12.layerUIDs) t8.set(s6, e12);
    }
    return t8;
  }
  _deserializeBucket(e11, t8) {
    let s5 = t8.get(e11);
    if (s5) return s5;
    switch (new Uint32Array(e11)[0]) {
      case E2.FILL:
        s5 = new l4(e11, this.styleRepository);
        break;
      case E2.LINE:
        s5 = new f4(e11, this.styleRepository);
        break;
      case E2.SYMBOL:
        s5 = new c6(e11, this.styleRepository, this);
        break;
      case E2.CIRCLE:
        s5 = new u3(e11, this.styleRepository);
    }
    return t8.set(e11, s5), s5;
  }
  _deleteLayerData(e11) {
    if (!this.layerData.has(e11)) return;
    const t8 = this.layerData.get(e11);
    this._memoryUsedByLayerData -= t8.memoryUsed, t8.destroy(), this.layerData.delete(e11);
  }
};
var m2 = /* @__PURE__ */ new Map();

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i5(e11, t8, n9, o6, i8, l6) {
  const { iconRotationAlignment: a8, textRotationAlignment: c9, iconTranslate: h9, iconTranslateAnchor: u5, textTranslate: d7, textTranslateAnchor: y5 } = o6;
  let x = 0;
  for (const g of e11.colliders) {
    const [e12, o7] = 0 === g.partIndex ? h9 : d7, m5 = 0 === g.partIndex ? u5 : y5, f5 = g.minLod <= l6 && l6 <= g.maxLod;
    x += f5 ? 0 : 1, g.enabled = f5, g.xScreen = g.xTile * i8[0] + g.yTile * i8[3] + i8[6], g.yScreen = g.xTile * i8[1] + g.yTile * i8[4] + i8[7], m5 === r4.MAP ? (g.xScreen += n9 * e12 - t8 * o7, g.yScreen += t8 * e12 + n9 * o7) : (g.xScreen += e12, g.yScreen += o7), l.VIEWPORT === (0 === g.partIndex ? a8 : c9) ? (g.dxScreen = g.dxPixels, g.dyScreen = g.dyPixels) : (g.dxScreen = n9 * (g.dxPixels + g.width / 2) - t8 * (g.dyPixels + g.height / 2) - g.width / 2, g.dyScreen = t8 * (g.dxPixels + g.width / 2) + n9 * (g.dyPixels + g.height / 2) - g.height / 2);
  }
  e11.colliders.length > 0 && x === e11.colliders.length && (e11.unique.show = false);
}
var l5 = class {
  constructor(o6, r12, s5, i8, l6, a8) {
    this._symbols = o6, this._styleRepository = i8, this._zoom = l6, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new i4(r12, s5, t2), this._si = Math.sin(Math.PI * a8 / 180), this._co = Math.cos(Math.PI * a8 / 180);
    for (const t8 of o6) for (const n9 of t8.symbols) this._allNeededMatrices.has(n9.tile) || this._allNeededMatrices.set(n9.tile, r5(n9.tile.transforms.tileUnitsToPixels));
  }
  work(e11) {
    const t8 = this._gridIndex;
    function n9(e12) {
      const n10 = e12.xScreen + e12.dxScreen, o7 = e12.yScreen + e12.dyScreen, r12 = n10 + e12.width, s5 = o7 + e12.height, [i8, l6, a8, c9] = t8.getCellSpan(n10, o7, r12, s5);
      for (let h9 = l6; h9 <= c9; h9++) for (let e13 = i8; e13 <= a8; e13++) {
        const i9 = t8.cells[h9][e13];
        for (const e14 of i9) {
          const t9 = e14.xScreen + e14.dxScreen, i10 = e14.yScreen + e14.dyScreen, l7 = t9 + e14.width, a9 = i10 + e14.height;
          if (!(r12 < t9 || n10 > l7 || s5 < i10 || o7 > a9)) return true;
        }
      }
      return false;
    }
    const o6 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t9 = this._symbols[this._currentLayerCursor], r12 = this._getProperties(t9.styleLayerUID);
      for (; this._currentSymbolCursor < t9.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o6 > e11) return false;
        const s5 = t9.symbols[this._currentSymbolCursor];
        if (!s5.unique.show) continue;
        i5(s5, this._si, this._co, r12, this._allNeededMatrices.get(s5.tile), this._zoom);
        const l6 = s5.unique;
        if (!l6.show) continue;
        const { iconAllowOverlap: a8, iconIgnorePlacement: c9, textAllowOverlap: h9, textIgnorePlacement: u5 } = r12;
        for (const e12 of s5.colliders) {
          if (!e12.enabled) continue;
          const t10 = l6.parts[e12.partIndex];
          if (!t10.show) continue;
          !(e12.partIndex ? h9 : a8) && n9(e12) && (e12.hard ? l6.show = false : t10.show = false);
        }
        if (l6.show) for (const e12 of s5.colliders) {
          if (!e12.enabled) continue;
          if (e12.partIndex ? u5 : c9) continue;
          if (!l6.parts[e12.partIndex].show) continue;
          const t10 = e12.xScreen + e12.dxScreen, n10 = e12.yScreen + e12.dyScreen, o7 = t10 + e12.width, r13 = n10 + e12.height, [s6, i8, a9, h10] = this._gridIndex.getCellSpan(t10, n10, o7, r13);
          for (let l7 = i8; l7 <= h10; l7++) for (let t11 = s6; t11 <= a9; t11++) {
            this._gridIndex.cells[l7][t11].push(e12);
          }
        }
      }
    }
    return true;
  }
  _getProperties(e11) {
    const t8 = this._styleProps.get(e11);
    if (t8) return t8;
    const n9 = this._zoom, s5 = this._styleRepository.getStyleLayerByUID(e11), i8 = s5.getLayoutValue("symbol-placement", n9) !== n3.POINT;
    let l6 = s5.getLayoutValue("icon-rotation-alignment", n9);
    l6 === l.AUTO && (l6 = i8 ? l.MAP : l.VIEWPORT);
    let a8 = s5.getLayoutValue("text-rotation-alignment", n9);
    a8 === l.AUTO && (a8 = i8 ? l.MAP : l.VIEWPORT);
    const c9 = s5.getPaintValue("icon-translate", n9), h9 = s5.getPaintValue("icon-translate-anchor", n9), u5 = s5.getPaintValue("text-translate", n9), d7 = s5.getPaintValue("text-translate-anchor", n9), y5 = { iconAllowOverlap: s5.getLayoutValue("icon-allow-overlap", n9), iconIgnorePlacement: s5.getLayoutValue("icon-ignore-placement", n9), textAllowOverlap: s5.getLayoutValue("text-allow-overlap", n9), textIgnorePlacement: s5.getLayoutValue("text-ignore-placement", n9), iconRotationAlignment: l6, textRotationAlignment: a8, iconTranslateAnchor: h9, iconTranslate: c9, textTranslateAnchor: d7, textTranslate: u5 };
    return this._styleProps.set(e11, y5), y5;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function t4(o6, t8) {
  if (o6.priority - t8.priority) return o6.priority - t8.priority;
  const e11 = o6.tile.key, i8 = t8.tile.key;
  return e11.world - i8.world ? e11.world - i8.world : e11.level - i8.level ? e11.level - i8.level : e11.row - i8.row ? e11.row - i8.row : e11.col - i8.col ? e11.col - i8.col : o6.xTile - t8.xTile ? o6.xTile - t8.xTile : o6.yTile - t8.yTile;
}
var e10 = class {
  get running() {
    return this._running;
  }
  constructor(o6, t8, e11, i8, s5, n9) {
    this._visibleTiles = o6, this._symbolRepository = t8, this._createCollisionJob = e11, this._assignTileSymbolsOpacity = i8, this._symbolLayerSorter = s5, this._isLayerVisible = n9, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  setScreenSize(o6, t8) {
    this._screenWidth === o6 && this._screenHeight === t8 || this.restart(), this._screenWidth = o6, this._screenHeight = t8;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o6) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const t8 = performance.now();
      if (!this._selectionJob.work(o6)) return false;
      if (this._selectionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - t8)))) return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const t8 = performance.now();
      if (!this._collisionJob.work(o6)) return false;
      if (this._collisionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - t8)))) return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const t8 = performance.now();
      if (!this._opacityJob.work(o6)) return false;
      if (this._opacityJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - t8)))) return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o6 = this._symbolRepository.uniqueSymbols;
    for (let t8 = 0; t8 < o6.length; t8++) {
      const e12 = o6[t8];
      for (let o7 = 0; o7 < e12.uniqueSymbols.length; o7++) {
        const t9 = e12.uniqueSymbols[o7];
        for (const o8 of t9.tileSymbols) o8.selectedForRendering = false;
      }
    }
    const e11 = [];
    let i8 = 0, s5 = 0;
    const n9 = this._isLayerVisible;
    function r12(r13) {
      let l7;
      const c9 = performance.now();
      for (; s5 < o6.length; s5++, i8 = 0) {
        const t8 = o6[s5], h9 = t8.styleLayerUID;
        if (!n9(h9)) {
          e11[s5] || (e11[s5] = { styleLayerUID: h9, symbols: [] });
          continue;
        }
        e11[s5] = e11[s5] || { styleLayerUID: h9, symbols: [] };
        const a8 = e11[s5];
        for (; i8 < t8.uniqueSymbols.length; i8++) {
          if (l7 = t8.uniqueSymbols[i8], i8 % 100 == 99 && performance.now() - c9 > r13) return false;
          let o7 = null, e12 = false, s6 = false;
          for (const t9 of l7.tileSymbols) if (!s6 || !e12) {
            const i9 = t9.tile;
            (!o7 || i9.isCoverage || i9.neededForCoverage && !e12) && (o7 = t9, (i9.neededForCoverage || i9.isCoverage) && (s6 = true), i9.isCoverage && (e12 = true));
          }
          if (o7.selectedForRendering = true, s6) {
            a8.symbols.push(o7), l7.show = true;
            for (const o8 of l7.parts) o8.show = true;
          } else l7.show = false;
        }
      }
      for (const o7 of e11) o7.symbols.sort(t4);
      return true;
    }
    const l6 = this._symbolLayerSorter;
    return { work: r12, get sortedSymbols() {
      return e11.sort(l6);
    } };
  }
  _createOpacityJob() {
    const o6 = this._assignTileSymbolsOpacity, t8 = this._visibleTiles;
    let e11 = 0;
    function s5(t9, e12) {
      const n9 = t9.symbols;
      for (const [o7, s6] of n9) i6(s6, e12);
      o6(t9, e12);
      for (const o7 of t9.childrenTiles) s5(o7, e12);
    }
    return { work(o7) {
      const i8 = performance.now();
      for (; e11 < t8.length; e11++) {
        if (performance.now() - i8 > o7) return false;
        const n9 = t8[e11];
        if (null != n9.parentTile) continue;
        s5(n9, performance.now());
      }
      return true;
    } };
  }
};
function i6(t8, e11) {
  for (const i8 of t8) {
    const t9 = i8.unique;
    for (const i9 of t9.parts) {
      const s5 = i9.targetOpacity > 0.5 ? 1 : -1;
      i9.startOpacity += s5 * ((e11 - i9.startTime) / e6), i9.startOpacity = Math.min(Math.max(i9.startOpacity, 0), 1), i9.startTime = e11, i9.targetOpacity = t9.show && i9.show ? 1 : 0;
    }
  }
}

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var o5 = 32;
var t5 = 8;
var i7 = 64;
var n8 = 20;
var r11 = class {
  constructor(e11, s5, l6) {
    this.tileCoordRange = e11, this._visibleTiles = s5, this._createUnique = l6, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return null == this._uniqueSymbolLayerArray && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  get uniqueSymbolsReferences() {
    return this._uniqueSymbolsReferences;
  }
  add(s5, l6) {
    this._uniqueSymbolLayerArray = null;
    let n9 = this._tiles.get(s5.id);
    n9 || (n9 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(s5.id, n9));
    const r12 = /* @__PURE__ */ new Map();
    if (l6) for (const e11 of l6) n9.symbols.has(e11) && (r12.set(e11, n9.symbols.get(e11)), n9.symbols.delete(e11));
    else for (const [e11, o6] of s5.layerData) n9.symbols.has(e11) && (r12.set(e11, n9.symbols.get(e11)), n9.symbols.delete(e11));
    this._removeSymbols(r12);
    const y5 = s5.symbols, a8 = /* @__PURE__ */ new Map();
    for (const [f5, u5] of y5) {
      let s6 = u5.length;
      if (s6 >= o5) {
        let l7 = this.tileCoordRange;
        do {
          l7 /= 2, s6 /= 4;
        } while (s6 > t5 && l7 > i7);
        const o6 = new i4(this.tileCoordRange, this.tileCoordRange, l7);
        a8.set(f5, { flat: u5, index: o6 }), n9.symbols.set(f5, { flat: u5, index: o6 });
        for (const e11 of u5) o6.getCell(e11.xTile, e11.yTile).push(e11);
      } else a8.set(f5, { flat: u5 }), n9.symbols.set(f5, { flat: u5 });
    }
    this._addSymbols(s5.key, y5);
  }
  deleteStyleLayers(e11) {
    this._uniqueSymbolLayerArray = null;
    for (const [s5, l6] of this._tiles) {
      const o6 = /* @__PURE__ */ new Map();
      for (const s6 of e11) l6.symbols.has(s6) && (o6.set(s6, l6.symbols.get(s6)), l6.symbols.delete(s6));
      this._removeSymbols(o6), 0 === l6.symbols.size && this._tiles.delete(s5);
    }
  }
  removeTile(e11) {
    this._uniqueSymbolLayerArray = null;
    const s5 = this._tiles.get(e11.id);
    if (!s5) return;
    const l6 = /* @__PURE__ */ new Map();
    for (const [o6, t8] of e11.symbols) s5.symbols.has(o6) && (l6.set(o6, s5.symbols.get(o6)), s5.symbols.delete(o6));
    this._removeSymbols(l6), 0 === s5.symbols.size && this._tiles.delete(e11.id);
  }
  querySymbols(e11, l6, o6, t8) {
    const i8 = [], n9 = this.uniqueSymbols;
    for (const r12 of n9) {
      const t9 = r12.styleLayerUID, n10 = r12.uniqueSymbols;
      for (const r13 of n10) {
        const n11 = r13.tileSymbols.find((e12) => e12.selectedForRendering);
        n11 && c5(n11, e11, l6 * (window.devicePixelRatio || 1), o6) && i8.push({ vtlSymbol: n11, styleLayerUID: t9, tileKey: n11.tile.key });
      }
    }
    return i8;
  }
  _removeSymbols(e11) {
    for (const [s5, { flat: l6 }] of e11) for (const e12 of l6) {
      const l7 = e12.unique, o6 = l7.tileSymbols, t8 = o6.length - 1;
      for (let s6 = 0; s6 < t8; s6++) if (o6[s6] === e12) {
        o6[s6] = o6[t8];
        break;
      }
      if (o6.length = t8, 0 === t8) {
        const e13 = this._uniqueSymbolsReferences.get(s5);
        e13.delete(l7), 0 === e13.size && this._uniqueSymbolsReferences.delete(s5);
      }
      e12.unique = null;
    }
  }
  _addSymbols(e11, s5) {
    if (0 === s5.size) return;
    const l6 = this._visibleTiles;
    for (const o6 of l6) o6.parentTile || o6.key.world !== e11.world || o6.key.level === e11.level && !o6.key.equals(e11) || this._matchSymbols(o6, e11, s5);
    for (const [o6, t8] of s5) for (const e12 of t8) if (null == e12.unique) {
      const s6 = this._createUnique();
      e12.unique = s6, s6.tileSymbols.push(e12);
      let l7 = this._uniqueSymbolsReferences.get(o6);
      l7 || (l7 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(o6, l7)), l7.add(s6);
    }
  }
  _matchSymbols(e11, s5, o6) {
    if (e11.key.level > s5.level) {
      const l6 = e11.key.level - s5.level;
      if (e11.key.row >> l6 !== s5.row || e11.key.col >> l6 !== s5.col) return;
    }
    if (s5.level > e11.key.level) {
      const l6 = s5.level - e11.key.level;
      if (s5.row >> l6 !== e11.key.row || s5.col >> l6 !== e11.key.col) return;
    }
    if (s5.equals(e11.key)) {
      for (const l6 of e11.childrenTiles) this._matchSymbols(l6, s5, o6);
      return;
    }
    const t8 = /* @__PURE__ */ new Map();
    for (const [i8, r12] of o6) {
      const o7 = [];
      for (const t9 of r12) {
        const i9 = o4(this.tileCoordRange, t9.xTile, s5.level, s5.col, e11.key.level, e11.key.col), n9 = o4(this.tileCoordRange, t9.yTile, s5.level, s5.row, e11.key.level, e11.key.row);
        i9 >= 0 && i9 < this.tileCoordRange && n9 >= 0 && n9 < this.tileCoordRange && o7.push({ symbol: t9, xTransformed: i9, yTransformed: n9 });
      }
      const y5 = [], a8 = (e11.key.level < s5.level ? 1 : 1 << e11.key.level - s5.level) + n8, f5 = this._tiles.get(e11.id).symbols.get(i8);
      if (f5) {
        const e12 = f5.flat;
        for (const s6 of o7) {
          let l6, o8 = false;
          const t9 = s6.xTransformed, i9 = s6.yTransformed;
          l6 = null != f5.index ? f5.index.getCell(t9, i9) : e12;
          const n9 = s6.symbol, r13 = n9.hash;
          for (const e13 of l6) if (r13 === e13.hash && Math.abs(t9 - e13.xTile) <= a8 && Math.abs(i9 - e13.yTile) <= a8) {
            const s7 = e13.unique;
            n9.unique = s7, s7.tileSymbols.push(n9), o8 = true;
            break;
          }
          o8 || y5.push(n9);
        }
      }
      y5.length > 0 && t8.set(i8, y5);
    }
    for (const l6 of e11.childrenTiles) this._matchSymbols(l6, s5, t8);
  }
  _createUniqueSymbolLayerArray() {
    const e11 = this._uniqueSymbolsReferences, s5 = new Array(e11.size);
    let l6, o6 = 0;
    for (const [t8, i8] of e11) {
      const e12 = new Array(i8.size);
      l6 = 0;
      for (const s6 of i8) e12[l6++] = s6;
      s5[o6] = { styleLayerUID: t8, uniqueSymbols: e12 }, o6++;
    }
    return s5;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var c7 = 0.5;
var h7 = 1e-6;
var _2 = class {
  constructor(e11, i8) {
    this.styleRepository = e11, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._offsetFromScreenCenter = [0, 0], this._completed = false, this._fading = r3(false), this._symbolRepository = new r11(4096, i8, () => new s4()), this._symbolDeclutterer = new e10(i8, this._symbolRepository, (t8, e12, i9) => this._createCollisionJob(t8, e12, i9), (t8, e12) => {
      t8.allSymbolsFadingOut = true, t8.lastOpacityUpdate = e12, r10(t8, e12, true), t8.decluttered = true, t8.requestRender();
    }, (t8, e12) => this.styleRepository.getStyleLayerByUID(t8.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e12.styleLayerUID).z, (t8) => {
      const e12 = this.styleRepository.getStyleLayerByUID(t8);
      if (this._zoom + h7 < e12.minzoom || this._zoom - h7 >= e12.maxzoom) return false;
      const i9 = e12.getLayoutProperty("visibility");
      return !i9 || i9.getValue() !== i.NONE;
    });
  }
  get symbolRepository() {
    return this._symbolRepository;
  }
  _createCollisionJob(t8, e11, i8) {
    return this.updateDecluttererViewState(), new l5(t8, e11, i8, this.styleRepository, this._zoom, this._viewState.rotation);
  }
  get fading() {
    return this._fading.value;
  }
  get decluttererOffset() {
    return this._offsetFromScreenCenter;
  }
  addTile(t8) {
    t8.decluttered = false, this._tileToHandle.set(t8, t8.on("symbols-changed", () => {
      this._symbolRepository.add(t8), this.restartDeclutter();
    })), this._symbolRepository.add(t8), this.restartDeclutter();
  }
  removeTile(t8) {
    const e11 = this._tileToHandle.get(t8);
    e11 && (this._symbolRepository.removeTile(t8), this.restartDeclutter(), e11.remove(), this._tileToHandle.delete(t8));
  }
  update(t8, e11) {
    this._zoom = t8, this._viewState = { scale: e11.scale, rotation: e11.rotation, center: [e11.center[0], e11.center[1]], size: [e11.size[0], e11.size[1]] };
    const i8 = [0, 0];
    e11.toScreen(i8, e11.center);
    const s5 = [0, 0];
    return e11.toScreen(s5, this._declutterViewState.center), this._offsetFromScreenCenter[0] = i8[0] - s5[0], this._offsetFromScreenCenter[1] = i8[1] - s5[1], this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t8) => t8.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t8) {
    this._symbolRepository.deleteStyleLayers(t8);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this.updateDecluttererViewState(), this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c3), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    null != this._stableNotificationHandle && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this._fading.value = false;
    }, (1 + c7) * e6);
  }
  _notifyUnstable() {
    null != this._stableNotificationHandle && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this._fading.value = true;
  }
  updateDecluttererViewState() {
    this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._offsetFromScreenCenter[0] = 0, this._offsetFromScreenCenter[1] = 0;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t6 = class extends r6 {
  _createTransforms() {
    return { displayViewScreenMat3: e8(), tileMat3: e8() };
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var y3 = 1e-6;
function p4(e11, t8) {
  if (e11) {
    const s5 = e11.getLayoutProperty("visibility");
    if (!s5 || s5.getValue() !== i.NONE && (void 0 === e11.minzoom || e11.minzoom < t8 + y3) && (void 0 === e11.maxzoom || e11.maxzoom >= t8 - y3)) return true;
  }
  return false;
}
var m3 = class extends i3 {
  constructor(e11) {
    super(e11), this._backgroundTiles = [], this._computeDisplayInfoView(e11);
  }
  destroy() {
    var _a, _b;
    this.removeAllChildren(), (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = null, (_b = this._glyphMosaic) == null ? void 0 : _b.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [];
  }
  get fading() {
    var _a;
    return ((_a = this._symbolFader) == null ? void 0 : _a.fading) ?? false;
  }
  get symbolFader() {
    return this._symbolFader;
  }
  get symbolRepository() {
    var _a;
    return (_a = this._symbolFader) == null ? void 0 : _a.symbolRepository;
  }
  setStyleResources(e11, t8, r12, i8) {
    this._spriteMosaic = e11, this._glyphMosaic = t8, this._styleRepository = r12, this._tileInfoView = i8, this._computeDisplayInfoView(i8), null == this._symbolFader && (this._symbolFader = new _2(this._styleRepository, this.children)), this._symbolFader.styleRepository = r12;
  }
  setSpriteMosaic(e11) {
    var _a;
    (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = e11;
  }
  deleteStyleLayers(e11) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e11);
  }
  createRenderParams(e11) {
    return { ...super.createRenderParams(e11), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e11) {
    !this.visible || e11.drawPhase !== E3.MAP && e11.drawPhase !== E3.DEBUG || void 0 === this._spriteMosaic || super.doRender(e11);
  }
  addChild(e11) {
    return super.addChild(e11), null != this._symbolFader ? this._symbolFader.addTile(e11) : e11.decluttered = true, this.requestRender(), e11;
  }
  removeChild(e11) {
    return null != this._symbolFader && this._symbolFader.removeTile(e11), this.requestRender(), super.removeChild(e11);
  }
  renderChildren(e11) {
    const { drawPhase: t8 } = e11;
    t8 !== E3.DEBUG ? this._doRender(e11) : super.renderChildren(e11);
  }
  removeAllChildren() {
    for (let e11 = 0; e11 < this.children.length; e11++) {
      const t8 = this.children[e11];
      null != this._symbolFader && this._symbolFader.removeTile(t8), t8.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e11) => e11.neededForCoverage && e11.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e11) {
    const { context: t8, state: s5 } = e11, r12 = this._styleRepository;
    if (!r12) return;
    const i8 = r12.layers, o6 = this._displayInfo.scaleToZoom(s5.scale);
    r12.backgroundBucketIds.length > 0 && (e11.renderPass = "background", this._renderBackgroundLayers(e11, r12.backgroundBucketIds, o6)), super.renderChildren(e11), e11.drawPhase === E3.MAP && this._fade(o6, s5);
    const n9 = this.children.filter((e12) => e12.visible && e12.hasData());
    if (!n9 || 0 === n9.length) return t8.bindVAO(), t8.setStencilTestEnabled(true), void t8.setBlendingEnabled(true);
    for (const l6 of n9) l6.triangleCount = 0;
    t8.setStencilWriteMask(0), t8.setColorMask(true, true, true, true), t8.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), t8.setStencilTestEnabled(true), t8.setBlendingEnabled(false), t8.setDepthTestEnabled(true), t8.setDepthWriteEnabled(true), t8.setDepthFunction(O.LEQUAL), t8.setClearDepth(1), t8.clear(t8.gl.DEPTH_BUFFER_BIT), e11.renderPass = "opaque";
    for (let l6 = i8.length - 1; l6 >= 0; l6--) this._renderStyleLayer(i8[l6], e11, n9);
    t8.setDepthWriteEnabled(false), t8.setBlendingEnabled(true), t8.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e11.renderPass = "translucent";
    for (let l6 = 0; l6 < i8.length; l6++) this._renderStyleLayer(i8[l6], e11, n9);
    t8.bindVAO(), t8.setStencilTestEnabled(true), t8.setBlendingEnabled(true);
    for (const l6 of n9) l6.debugInfo.display.triangleCount = l6.triangleCount;
  }
  _fade(e11, t8) {
    null != this._symbolFader && (this._symbolFader.update(e11, t8) || this.requestRender());
  }
  _renderStyleLayer(e11, t8, s5) {
    const { displayLevel: l6, painter: o6, renderPass: n9 } = t8;
    if (void 0 === e11) return;
    const a8 = e11.getLayoutProperty("visibility");
    if (a8 && a8.getValue() === i.NONE) return;
    let d7;
    switch (e11.type) {
      case a5.BACKGROUND:
        return;
      case a5.FILL:
        if ("opaque" !== n9 && "translucent" !== t8.renderPass) return;
        d7 = "vtlFill";
        break;
      case a5.LINE:
        if ("translucent" !== n9) return;
        d7 = "vtlLine";
        break;
      case a5.CIRCLE:
        if ("translucent" !== n9) return;
        d7 = "vtlCircle";
        break;
      case a5.SYMBOL:
        if ("translucent" !== n9) return;
        d7 = "vtlSymbol";
    }
    if (s5 = e11.type === a5.SYMBOL ? s5.filter((e12) => e12.decluttered) : s5.filter((e12) => e12.neededForCoverage), "vtlSymbol" !== d7 && (0 === s5.length || void 0 !== e11.minzoom && e11.minzoom >= l6 + y3 || void 0 !== e11.maxzoom && e11.maxzoom < l6 - y3)) return;
    const h9 = e11.uid;
    t8.styleLayerUID = h9, t8.styleLayer = e11;
    for (const r12 of s5) if (r12.layerData.has(h9)) {
      o6.renderObjects(t8, s5, d7);
      break;
    }
  }
  _renderBackgroundLayers(t8, s5, r12) {
    const { context: l6, painter: n9, state: u5 } = t8, y5 = this._styleRepository;
    let m5 = false;
    for (const e11 of s5) {
      if (y5.getLayerById(e11).type === a5.BACKGROUND && p4(y5.getLayerById(e11), r12)) {
        m5 = true;
        break;
      }
    }
    if (!m5) return;
    const f5 = this._tileInfoView, g = f5.getTileCoverage(t8.state, 0, true, "smallest"), { spans: _3, lodInfo: b2 } = g, { level: E4 } = b2, C = u2(), F2 = [];
    if (this._renderPasses) {
      const e11 = this._renderPasses[0];
      null != this._clippingInfos && (e11.brushes[0].prepareState(t8), e11.brushes[0].drawMany(t8, this._clippingInfos));
    }
    const L2 = this._backgroundTiles;
    let R2, v2 = 0;
    for (const { row: i8, colFrom: a8, colTo: h9 } of _3) for (let t9 = a8; t9 <= h9; t9++) {
      if (v2 < L2.length) R2 = L2[v2], R2.key.set(E4, i8, b2.normalizeCol(t9), b2.getWorldForColumn(t9)), f5.getTileBounds(C, R2.key, false), R2.x = C[0], R2.y = C[3], R2.resolution = f5.getTileResolution(E4);
      else {
        const s6 = new e4(E4, i8, b2.normalizeCol(t9), b2.getWorldForColumn(t9)), r13 = f5.getTileBounds(u2(), s6), l7 = f5.getTileResolution(E4);
        R2 = new t6(s6, l7, r13[0], r13[3], 512, 512, 4096, 4096), L2.push(R2);
      }
      R2.setTransform(u5), F2.push(R2), v2++;
    }
    l6.setStencilWriteMask(0), l6.setColorMask(true, true, true, true), l6.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), l6.setStencilFunction(O.EQUAL, 0, 255), l6.setStencilTestEnabled(true);
    for (const e11 of s5) {
      const s6 = y5.getLayerById(e11);
      s6.type === a5.BACKGROUND && p4(s6, r12) && (t8.styleLayerUID = s6.uid, t8.styleLayer = s6, n9.renderObjects(t8, F2, "vtlBackground"));
    }
    s.pool.release(g);
  }
  _computeDisplayInfoView(e11) {
    let s5 = e11.tileInfo.lods[0].scale;
    const r12 = Math.max(25, e11.tileInfo.lods.length), i8 = [];
    for (let t8 = 0; t8 <= r12; t8++) i8.push(s5), s5 /= 2;
    this._displayInfo = z.create({ scales: i8, size: 512, spatialReference: e11.spatialReference, numLODs: r12 });
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileFeatureIndex.js
var y4 = 8;
var c8 = 512;
var u4 = 4096;
var h8 = (e11, t8) => {
  const s5 = e11.vtlSymbol.sourceTile, r12 = t8.vtlSymbol.sourceTile;
  return s5.level !== r12.level ? s5.level - r12.level : s5.row !== r12.row ? s5.row - r12.row : s5.col !== r12.col ? s5.col - r12.col : e11.styleLayerUID - t8.styleLayerUID;
};
var d6 = class _d {
  constructor(e11, t8, s5, r12, i8) {
    this.tileKey = e11, this._index = null, this._styleRepository = null, this._tileHandler = null, this._tileKeyToPBF = /* @__PURE__ */ new Map(), this._tileLayerData = t8, this._styleRepository = s5, this._tileHandler = r12, this._parentLayer = i8;
  }
  static create(e11, t8, s5, r12, i8) {
    return new _d(e11, t8, s5, r12, i8);
  }
  clear() {
    var _a;
    (_a = this._index) == null ? void 0 : _a.clear(), this._tileKeyToPBF.clear();
  }
  async queryAttributes(e11, t8, s5, i8, l6) {
    if (0 === this._tileLayerData.size || !this._styleRepository || !this._tileHandler) return [];
    null === this._index && (this._index = new h(100, m4), await this._indexLayers());
    const o6 = [];
    return this._queryIndex(o6, e11, t8, s5, this.tileKey.level, i8), l6 && (l6 == null ? void 0 : l6.length) > 0 && await this._getSymbolsAttributes(o6, l6), o6;
  }
  async _indexLayers() {
    const e11 = this.tileKey, t8 = this._styleRepository.layers, s5 = await this._getTilePayload(e11);
    for (const [r12, l6] of this._tileLayerData) {
      const o6 = t8[r12], n9 = s5.find((e12) => e12.sourceName === o6.source);
      if (!n9) continue;
      const { protobuff: a8, key: y5 } = n9;
      if (l6.type !== E2.SYMBOL) {
        const t9 = 1 << e11.level - y5.level, s6 = e11.row - y5.row * t9, r13 = e11.col - y5.col * t9;
        this._indexLayer(o6, a8, e11.level, t9, s6, r13);
      }
    }
  }
  _indexLayer(e11, t8, r12, i8, y5, h9) {
    const d7 = e11.sourceLayer, m5 = e11.getFeatureFilter(), f5 = r12, _3 = r12 + 1, p5 = d2(f5), g = new n2(new Uint8Array(t8), new DataView(t8));
    for (; g.next(); ) switch (g.tag()) {
      case 3: {
        const t9 = g.getMessage(), s5 = new e7(t9);
        if (t9.release(), s5.name !== d7) continue;
        const o6 = s5.getData(), w3 = s5.extent / i8, x = w3 * h9 - p5, b2 = w3 * y5 - p5, I4 = x + w3 + 2 * p5, L2 = b2 + w3 + 2 * p5, v2 = w3 / c8, D3 = u4 / w3, T = w3 * h9, S2 = w3 * y5;
        for (; o6.nextTag(2); ) {
          const t10 = o6.getMessage(), i9 = new s2(t10, s5);
          if (t10.release(), m5 && !m5.filter(i9, r12)) continue;
          const n9 = i9.values || {}, y6 = n9._minzoom, c9 = n9._maxzoom;
          if (y6 && y6 >= 10 * _3 || c9 && c9 <= 10 * f5) continue;
          const u5 = e11.getFeatureInflatedBounds(i9, f5, s5.extent, v2);
          null == u5 || u5[0] > I4 || u5[1] > L2 || u5[2] < x || u5[3] < b2 || (u5[0] = (u5[0] - T) * D3, u5[1] = (u5[1] - S2) * D3, u5[2] = (u5[2] - T) * D3, u5[3] = (u5[3] - S2) * D3, this._index.insert(new L(e11, i9, u5, D3, T, S2)));
        }
        break;
      }
      default:
        g.skip();
    }
  }
  async _getSymbolsAttributes(e11, t8) {
    if (!t8 || 0 === t8.length) return e11;
    const s5 = [];
    t8.sort(h8);
    let r12 = t8[0].styleLayerUID, i8 = 0;
    for (let a8 = 0; a8 < t8.length; a8++) r12 !== t8[a8].styleLayerUID && (s5.push({ from: i8, to: a8, styleLayerUID: r12, sourceTileKey: t8[a8].vtlSymbol.sourceTile }), i8 = a8, r12 = t8[a8].styleLayerUID);
    s5.push({ from: i8, to: t8.length, styleLayerUID: r12, sourceTileKey: t8[t8.length - 1].vtlSymbol.sourceTile });
    const l6 = this._styleRepository.layers;
    let o6, n9 = null;
    for (const a8 of s5) {
      const s6 = await this._getTilePayload(a8.sourceTileKey);
      o6 = l6[a8.styleLayerUID], n9 = !!o6 && s6.find((e12) => e12.sourceName === o6.source), n9 && this._addSymbolsAttributes(e11, t8.slice(a8.from, a8.to).map((e12) => e12.vtlSymbol), r12, n9);
    }
    return e11;
  }
  _addSymbolsAttributes(t8, s5, r12, i8) {
    const l6 = this._styleRepository.layers, o6 = i8.key, n9 = this.tileKey, a8 = 1 << n9.level - o6.level, y5 = n9.row - o6.row * a8, c9 = n9.col - o6.col * a8;
    this._getSymbolAttributes(i8.protobuff, s5, r12, a8, y5, c9).forEach((s6) => {
      const { attributes: i9, tilePoint: o7 } = s6;
      t8.push({ layerId: l6[r12].id, layerIndex: r12, graphic: new d3({ attributes: i9, origin: { type: "vector-tile", layerId: l6[r12].id, layerIndex: r12, layer: this._parentLayer } }), tilePoint: o7 });
    });
  }
  _getSymbolAttributes(e11, t8, r12, i8, o6, a8) {
    const y5 = [], c9 = this._styleRepository.layers;
    let h9 = 0;
    t8.sort((e12, t9) => e12.featureIndex - t9.featureIndex);
    const d7 = new n2(new Uint8Array(e11), new DataView(e11));
    for (; d7.next(); ) switch (d7.tag()) {
      case 3: {
        const e12 = d7.getMessage(), s5 = new e7(e12);
        if (e12.release(), s5.name !== c9[r12].sourceLayer) continue;
        const m5 = s5.getData(), f5 = s5.extent / i8, _3 = u4 / f5, p5 = f5 * a8, g = f5 * o6;
        let w3 = 0;
        for (; m5.nextTag(2); ) {
          const e13 = m5.getMessage();
          if (w3++ === t8[h9].featureIndex) {
            const t9 = new s2(e13, s5), r13 = t9.values, i9 = t9.getGeometry(), o7 = null != i9 ? [_3 * (i9[0][0].x - p5), _3 * (i9[0][0].y - g)] : null;
            y5.push({ attributes: r13, tilePoint: o7 }), h9++;
          }
          if (e13.release(), h9 === t8.length) return y5;
        }
        break;
      }
      default:
        d7.skip();
    }
    return y5;
  }
  _queryIndex(t8, s5, r12, i8, l6, o6) {
    var _a;
    const n9 = y4 * i8 * (window.devicePixelRatio || 1);
    return (_a = this._index) == null ? void 0 : _a.search({ minX: s5 - n9, minY: r12 - n9, maxX: s5 + n9, maxY: r12 + n9 }, (n10) => {
      const { layer: a8, feature: y5 } = n10;
      a8.isIntersectingFeature(s5, r12, i8, y5, l6, o6, n10) && t8.push({ layerId: a8.id, layerIndex: a8.uid, tilePoint: null, graphic: new d3({ attributes: y5.values, origin: { type: "vector-tile", layerId: n10.layer.id, layerIndex: n10.layer.uid, layer: this._parentLayer } }) });
    }), t8;
  }
  async _getTilePayload(e11) {
    return r(this._tileKeyToPBF, e11.id, () => this._tileHandler.fetchTilePBFs(e11)).then((e12) => e12);
  }
};
var m4 = (e11) => ({ minX: e11.bounds[0], minY: e11.bounds[1], maxX: e11.bounds[2], maxY: e11.bounds[3] });

// ../node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t7 = class extends h3 {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e11) {
    const l6 = e4.pool.acquire(e11), t8 = 0 === l6.level ? null : e4.getId(l6.level - 1, l6.row >> 1, l6.col >> 1, l6.world);
    return e4.pool.release(l6), t8;
  }
  getTileCoverage(e11, l6, s5 = true, t8) {
    const o6 = super.getTileCoverage(e11, l6, s5, t8);
    if (!o6) return o6;
    const i8 = 1 << o6.lodInfo.level;
    return o6.spans = o6.spans.filter((e12) => e12.row >= 0 && e12.row < i8), o6;
  }
  scaleToLevel(e11) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e11]) return this._levelByScale[e11];
    {
      const l6 = this._fullCacheLodInfos;
      if (e11 > l6[0].scale) return l6[0].level;
      let s5, t8;
      for (let o6 = 0; o6 < l6.length - 1; o6++) if (t8 = l6[o6 + 1], e11 > t8.scale) return s5 = l6[o6], s5.level + (s5.scale - e11) / (s5.scale - t8.scale);
      return l6[l6.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l6) {
    let s5;
    if (0 === l6[0].level) s5 = l6.map((e11) => ({ level: e11.level, resolution: e11.resolution, scale: e11.scale }));
    else {
      const l7 = this.tileInfo.size[0], t8 = this.tileInfo.spatialReference;
      s5 = z.create({ size: l7, spatialReference: t8 }).lods.map((e11) => ({ level: e11.level, resolution: e11.resolution, scale: e11.scale }));
    }
    for (let e11 = 0; e11 < s5.length; e11++) this._levelByScale[s5[e11].scale] = s5[e11].level;
    this._fullCacheLodInfos = s5;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var w2 = 2;
var I3 = 8;
var D2 = 512;
var P = class extends f3(y2) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false;
  }
  get fading() {
    var _a;
    return ((_a = this._vectorTileContainer) == null ? void 0 : _a.fading) ?? false;
  }
  async hitTest(e11, t8) {
    var _a, _b;
    const i8 = this._tileHandlerPromise, s5 = (_a = this._vectorTileContainer) == null ? void 0 : _a.symbolFader;
    if (!i8 || !this._isTileHandlerReady || !s5) return;
    await i8;
    let r12 = null;
    const a8 = (_b = this._vectorTileContainer) == null ? void 0 : _b.symbolRepository;
    a8 && (r12 = a8.querySymbols(t8, w2, s5.decluttererOffset, {}));
    const l6 = this.view.state, n9 = this._tileManager.getIntersectingTiles(t8.x, t8.y, w2, l6, r12);
    if ((!n9 || 0 === n9.length) && 0 === (r12 == null ? void 0 : r12.length)) return null;
    e11 = e11.clone().normalize();
    const o6 = [], h9 = [];
    for (const y5 of n9) o6.push(this._queryTile(h9, e11, w2, this.view.state.rotation, y5, r12 == null ? void 0 : r12.filter((e12) => e12.tileKey.id === y5.id)));
    return await Promise.all(o6), h9;
  }
  update(e11) {
    if (this._tileHandlerPromise && this._isTileHandlerReady) return e11.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e11.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.state = e11.state, this._parseQueue.state = e11.state, this._tileManager.update(e11) || this.requestUpdate(), this._parseQueue.resume(), this._fetchQueue.resume()));
  }
  attach() {
    const { style: e11 } = this.layer.currentStyleInfo;
    this._styleRepository = new l2(e11), this._tileInfoView = new t7(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new m3(this._tileInfoView), this._tileHandler = new h4(this.layer, this._styleRepository, window.devicePixelRatio || 1, this.layer.tileInfo.lods.length - 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this.layer.on("paint-change", (e12) => {
      var _a, _b;
      if (e12.isDataDriven) this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: e12 }), this.requestUpdate();
      else {
        const t8 = this._styleRepository, i8 = t8.getLayerById(e12.layer);
        if (!i8) return;
        const s5 = i8.type === a5.SYMBOL;
        t8.setPaintProperties(e12.layer, e12.paint), s5 && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender();
      }
    }), this.layer.on("layout-change", (e12) => {
      var _a, _b;
      const t8 = this._styleRepository, i8 = t8.getLayerById(e12.layer);
      if (!i8) return;
      const s5 = d(i8.layout, e12.layout);
      if (null != s5) {
        if (p(s5, "visibility") && 1 === S(s5)) return t8.setLayoutProperties(e12.layer, e12.layout), i8.type === a5.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), void ((_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
        this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: e12 }), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e12) => {
      var _a, _b;
      const t8 = this._styleRepository, i8 = t8.getLayerById(e12.layer);
      i8 && (t8.setStyleLayerVisibility(e12.layer, e12.visibility), i8.type === a5.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
    }), this.layer.on("style-layer-change", (e12) => {
      this._styleChanges.push({ type: I2.LAYER_CHANGED, data: e12 }), this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e12) => {
      this._styleChanges.push({ type: I2.LAYER_REMOVED, data: e12 }), this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e12) => {
      this._styleChanges.push({ type: I2.SPRITES_CHANGED, data: e12 });
      const t8 = this._styleRepository.layers;
      for (const i8 of t8) switch (i8.type) {
        case a5.SYMBOL:
          i8.getLayoutProperty("icon-image") && this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: { layer: i8.id, layout: i8.layout } });
          break;
        case a5.LINE:
          i8.getPaintProperty("line-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i8.id, paint: i8.paint, isDataDriven: i8.isPainterDataDriven() } });
          break;
        case a5.FILL:
          i8.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i8.id, paint: i8.paint, isDataDriven: i8.isPainterDataDriven() } });
      }
      this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = u(this._vectorTileContainer), this._tileHandler = u(this._tileHandler);
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  supportsSpatialReference(e11) {
    var _a;
    return G((_a = this.layer.tileInfo) == null ? void 0 : _a.spatialReference, e11);
  }
  canResume() {
    let e11 = super.canResume();
    const { currentStyleInfo: t8 } = this.layer;
    if (e11 && (t8 == null ? void 0 : t8.layerDefinition)) {
      const i8 = this.view.scale, { minScale: s5, maxScale: r12 } = t8.layerDefinition;
      (t8 == null ? void 0 : t8.layerDefinition) && (s5 && s5 < i8 && (e11 = false), r12 && r12 > i8 && (e11 = false));
    }
    return e11;
  }
  isUpdating() {
    return this.fading;
  }
  acquireTile(e11) {
    const t8 = this._createVectorTile(e11);
    return this._updatingHandles.addPromise(this._fetchQueue.push(t8.key).then((e12) => this._parseQueue.push({ key: t8.key, data: e12 })).then((e12) => {
      t8.once("attach", () => this.requestUpdate()), t8.setData(e12), this.requestUpdate();
    }).catch((e12) => {
      b(e12) || n.getLogger(this).error(e12);
    })), t8;
  }
  releaseTile(e11) {
    const t8 = e11.key.id;
    this._fetchQueue.abort(t8), this._parseQueue.abort(t8), this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new h5({ acquireTile: (e12) => this.acquireTile(e12), releaseTile: (e12) => this.releaseTile(e12), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo) return;
    const e11 = new AbortController(), t8 = this._tileHandler.start({ signal: e11.signal }).then(() => {
      this._fetchQueue = new m({ tileInfoView: this._tileInfoView, process: (e12, t9) => this._getTileData(e12, t9), concurrency: 15 }), this._parseQueue = new m({ tileInfoView: this._tileInfoView, process: (e12, t9) => this._parseTileData(e12, t9), concurrency: 8 }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e12) => {
      this._vectorTileContainer.setStyleResources(e12, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this.requestUpdate();
    }), this._tileHandlerAbortController = e11, this._tileHandlerPromise = t8;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer) return;
    const e11 = this._tileHandlerAbortController;
    e11 && e11.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = u(this._fetchQueue), this._parseQueue = u(this._parseQueue), this._tileManager = u(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e11, t8) {
    return this._tileHandler.fetchTileData(e11, t8);
  }
  async _parseTileData(e11, t8) {
    return this._tileHandler.parseTileData(e11, t8);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._tileManager.clearCache();
    const e11 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e11);
    } catch (l6) {
      n.getLogger(this).error("error applying vector-tiles style update", l6.message), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true;
    }
    const t8 = this._styleRepository, s5 = /* @__PURE__ */ new Set();
    e11.forEach((e12) => {
      if (e12.type !== I2.LAYER_REMOVED) return;
      const i8 = e12.data, r13 = t8.getLayerById(i8.layer);
      r13 && s5.add(r13.uid);
    });
    const r12 = /* @__PURE__ */ new Set();
    e11.forEach((e12) => {
      let i8;
      switch (e12.type) {
        case I2.PAINTER_CHANGED:
          t8.setPaintProperties(e12.data.layer, e12.data.paint), i8 = e12.data.layer;
          break;
        case I2.LAYOUT_CHANGED:
          t8.setLayoutProperties(e12.data.layer, e12.data.layout), i8 = e12.data.layer;
          break;
        case I2.LAYER_REMOVED:
          return void t8.deleteStyleLayer(e12.data.layer);
        case I2.LAYER_CHANGED:
          t8.setStyleLayer(e12.data.layer, e12.data.index), i8 = e12.data.layer.id;
          break;
        case I2.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(e12.data.spriteSource));
      }
      if (i8) {
        const e13 = t8.getLayerById(i8);
        e13 && r12.add(e13.uid);
      }
    });
    const a8 = this._vectorTileContainer.children;
    if (s5.size > 0) {
      const e12 = Array.from(s5);
      this._vectorTileContainer.deleteStyleLayers(e12);
      for (const t9 of a8) t9.deleteLayerData(e12);
    }
    if (this._fetchQueue.resume(), this._parseQueue.resume(), r12.size > 0) {
      const e12 = Array.from(r12), t9 = [];
      for (const i8 of a8) {
        const s6 = this._updatingHandles.addPromise(this._fetchQueue.push(i8.key).then((t10) => this._parseQueue.push({ key: i8.key, data: t10, styleLayerUIDs: e12 })).then((e13) => i8.setData(e13)));
        t9.push(s6);
      }
      await Promise.all(t9);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e11 } = this.layer.currentStyleInfo, i8 = a(e11);
    this._isTileHandlerReady = false, this._fetchQueue.pause(), this._parseQueue.pause(), this._fetchQueue.clear(), this._parseQueue.clear(), this._styleRepository = new l2(i8), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s5 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, i8, this.layer.tileInfo.lods.length - 1), await this._tileHandlerPromise;
    } catch (n9) {
      if (!b(n9)) throw n9;
    }
    if (s5.aborted) return this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, void this.requestUpdate();
    const a8 = await this._tileHandler.spriteMosaic, l6 = this._vectorTileContainer;
    this._tileInfoView = new t7(this.layer.tileInfo, this.layer.fullExtent), l6.setStyleResources(a8, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this._tileManager = new h5({ acquireTile: (e12) => this.acquireTile(e12), releaseTile: (e12) => this.releaseTile(e12), tileInfoView: this._tileInfoView }, this._vectorTileContainer), this._fetchQueue.resume(), this._parseQueue.resume(), this._isTileHandlerReady = true, this.requestUpdate();
  }
  _createVectorTile(e11) {
    const t8 = this._tileInfoView.getTileBounds(u2(), e11), i8 = this._tileInfoView.getTileResolution(e11.level);
    return new d5(e11, i8, t8[0], t8[3], 512, 512, this._styleRepository);
  }
  async _queryTile(e11, t8, i8, s5, r12, a8) {
    if (0 === r12.layerData.size) return;
    const l6 = this._ensureTileIndex(r12), n9 = this._tileInfoView.getTileBounds(u2(), r12.key, true), o6 = I3 * D2 * ((t8.x - n9[0]) / (n9[2] - n9[0])), h9 = I3 * D2 * (1 - (t8.y - n9[1]) / (n9[3] - n9[1])), c9 = await l6.queryAttributes(o6, h9, i8, s5, a8);
    for (const y5 of c9) y5.graphic.geometry = this._tileToMapPoint(y5.tilePoint, r12.transforms.tileUnitsToPixels), e11.push({ type: "graphic", layer: this.layer, graphic: y5.graphic, mapPoint: t8.clone() });
    e11.sort((e12, t9) => t9.graphic.origin.layerIndex - e12.graphic.origin.layerIndex);
  }
  _tileToMapPoint(e11, t8) {
    if (!e11) return null;
    const i8 = e11[0] * t8[0] + e11[1] * t8[3] + t8[6], s5 = e11[0] * t8[1] + e11[1] * t8[4] + t8[7], r12 = this.view.state, a8 = [0, 0];
    return r12.toMap(a8, [i8, s5]), new _({ x: a8[0], y: a8[1], spatialReference: r12.spatialReference });
  }
  _ensureTileIndex(e11) {
    let t8 = e11.featureIndex;
    return t8 || (t8 = d6.create(e11.key, e11.layerData, this._styleRepository, this._tileHandler, this.layer), e11.featureIndex = t8), t8;
  }
};
function S(e11) {
  if (null == e11) return 0;
  switch (e11.type) {
    case "partial":
      return Object.keys(e11.diff).length;
    case "complete":
      return Math.max(Object.keys(e11.oldValue).length, Object.keys(e11.newValue).length);
    case "collection":
      return Object.keys(e11.added).length + Object.keys(e11.changed).length + Object.keys(e11.removed).length;
  }
}
e([y()], P.prototype, "_isTileHandlerReady", void 0), P = e([a2("esri.views.2d.layers.VectorTileLayerView2D")], P);
var A2 = P;
export {
  A2 as default
};
//# sourceMappingURL=VectorTileLayerView2D-QFW5T3V4.js.map
