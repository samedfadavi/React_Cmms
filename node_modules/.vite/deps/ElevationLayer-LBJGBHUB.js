import {
  h
} from "./chunk-GXXLIOV2.js";
import {
  p as p2
} from "./chunk-W42XP47Q.js";
import "./chunk-L5PQJ4ZT.js";
import "./chunk-2TBXKHHI.js";
import "./chunk-IOHBILME.js";
import "./chunk-JFTJTGUT.js";
import "./chunk-4N73DVTU.js";
import {
  l
} from "./chunk-HN3UL7DT.js";
import "./chunk-OPCT64AO.js";
import {
  j
} from "./chunk-5LNCGIUN.js";
import {
  b
} from "./chunk-KVPS4KFB.js";
import {
  p
} from "./chunk-NSXZC33R.js";
import {
  S
} from "./chunk-E7HFITKU.js";
import "./chunk-ZFQCSBZ4.js";
import "./chunk-4PAHN45R.js";
import "./chunk-G5U2OA3R.js";
import "./chunk-7TO4QD67.js";
import "./chunk-ZRA2NDCA.js";
import {
  v as v2
} from "./chunk-RM4VMFVT.js";
import "./chunk-JJIIUFER.js";
import "./chunk-ITGBXG45.js";
import {
  f
} from "./chunk-EA74CF7B.js";
import "./chunk-IGNUVZ34.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-OHUWK5XV.js";
import "./chunk-PHVKM5OH.js";
import "./chunk-KQ5GHUVQ.js";
import "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-MNMU4ARP.js";
import "./chunk-E5KBRIJQ.js";
import "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import "./chunk-66KCMKB5.js";
import {
  o
} from "./chunk-ZART2Y5J.js";
import "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import {
  U,
  v
} from "./chunk-WC4SPMPL.js";
import {
  y
} from "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import {
  a3 as a
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  a as a2,
  s as s2
} from "./chunk-VMWKLHJD.js";
import {
  t
} from "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  s2 as s
} from "./chunk-YNL57W4I.js";
import "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/layers/support/ElevationTileData.js
var a3 = class {
  constructor(a4, t3, s4, e2) {
    this._hasNoDataValues = null, this._minValue = null, this._maxValue = null, "pixelData" in a4 ? (this.values = a4.pixelData, this.width = a4.width, this.height = a4.height, this.noDataValue = a4.noDataValue) : (this.values = a4, this.width = t3, this.height = s4, this.noDataValue = e2);
  }
  get hasNoDataValues() {
    if (null == this._hasNoDataValues) {
      const a4 = this.noDataValue;
      this._hasNoDataValues = this.values.includes(a4);
    }
    return this._hasNoDataValues;
  }
  get minValue() {
    return this._ensureBounds(), this._minValue;
  }
  get maxValue() {
    return this._ensureBounds(), this._maxValue;
  }
  _ensureBounds() {
    if (null != this._minValue) return;
    const { noDataValue: a4, values: t3 } = this;
    let s4 = 1 / 0, e2 = -1 / 0, i = true;
    for (const u of t3) u === a4 ? this._hasNoDataValues = true : (s4 = u < s4 ? u : s4, e2 = u > e2 ? u : e2, i = false);
    i ? (this._minValue = 0, this._maxValue = 0) : (this._minValue = s4, this._maxValue = e2 > -3e38 ? e2 : 0);
  }
};

// ../node_modules/@arcgis/core/layers/support/LercDecoder.js
var r = class extends h {
  constructor(e2 = null) {
    super("LercWorker", "_decode", { _decode: (e3) => [e3.buffer] }, e2, { strategy: "dedicated" }), this.schedule = e2, this.ref = 0;
  }
  decode(e2, r2, t3) {
    return e2 && 0 !== e2.byteLength ? this.invoke({ buffer: e2, options: r2 }, t3) : Promise.resolve(null);
  }
  release() {
    --this.ref <= 0 && (t2.forEach((e2, r2) => {
      e2 === this && t2.delete(r2);
    }), this.destroy());
  }
};
var t2 = /* @__PURE__ */ new Map();
function s3(e2 = null) {
  let s4 = t2.get(e2);
  return s4 || (null != e2 ? (s4 = new r((r2) => e2.immediate.schedule(r2)), t2.set(e2, s4)) : (s4 = new r(), t2.set(null, s4))), ++s4.ref, s4;
}

// ../node_modules/@arcgis/core/layers/ElevationLayer.js
var w = class extends p2(l(b(j(S(f))))) {
  constructor(...e2) {
    super(...e2), this.capabilities = { operations: { supportsTileMap: false } }, this.copyright = null, this.heightModelInfo = null, this.path = null, this.minScale = void 0, this.maxScale = void 0, this.opacity = 1, this.operationalLayerType = "ArcGISTiledElevationServiceLayer", this.sourceJSON = null, this.type = "elevation", this.url = null, this.version = null, this._lercDecoder = s3();
  }
  normalizeCtorArgs(e2, r2) {
    return "string" == typeof e2 ? { url: e2, ...r2 } : e2;
  }
  destroy() {
    this._lercDecoder = t(this._lercDecoder);
  }
  readCapabilities(e2, r2) {
    const t3 = r2.capabilities && r2.capabilities.split(",").map((e3) => e3.toLowerCase().trim());
    if (!t3) return { operations: { supportsTileMap: false } };
    return { operations: { supportsTileMap: t3.includes("tilemap") } };
  }
  readVersion(e2, r2) {
    let t3 = r2.currentVersion;
    return t3 || (t3 = 9.3), t3;
  }
  load(e2) {
    const r2 = null != e2 ? e2.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"], supportsData: false, validateItem: (e3) => {
      if (e3.typeKeywords) {
        for (let r3 = 0; r3 < e3.typeKeywords.length; r3++) if ("elevation 3d layer" === e3.typeKeywords[r3].toLowerCase()) return true;
      }
      throw new s("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}' ", { type: "Image Service", expectedType: "Image Service Elevation 3D Layer" });
    } }, e2).catch(a2).then(() => this._fetchImageService(r2))), Promise.resolve(this);
  }
  fetchTile(e2, t3, i, o2) {
    const s4 = null != (o2 = o2 || { signal: null }).signal ? o2.signal : o2.signal = new AbortController().signal, a4 = { responseType: "array-buffer", signal: s4 }, p3 = { noDataValue: o2.noDataValue, returnFileInfo: true };
    return this.load().then(() => this._fetchTileAvailability(e2, t3, i, o2)).then(() => U(this.getTileUrl(e2, t3, i), a4)).then((e3) => this._lercDecoder.decode(e3.data, p3, s4)).then((e3) => new a3(e3));
  }
  getTileUrl(e2, r2, t3) {
    const i = !this.capabilities.operations.supportsTileMap && this.supportsBlankTile, o2 = v({ ...this.parsedUrl.query, blankTile: !i && null });
    return `${this.parsedUrl.path}/tile/${e2}/${r2}/${t3}${o2 ? "?" + o2 : ""}`;
  }
  async queryElevation(e2, r2) {
    const { ElevationQuery: t3 } = await import("./ElevationQuery-2JLHE3OU.js");
    s2(r2);
    return new t3().query(this, e2, r2);
  }
  async createElevationSampler(e2, r2) {
    const { ElevationQuery: t3 } = await import("./ElevationQuery-2JLHE3OU.js");
    s2(r2);
    return new t3().createSampler(this, e2, r2);
  }
  _fetchTileAvailability(e2, r2, t3, i) {
    return this.tilemapCache ? this.tilemapCache.fetchAvailability(e2, r2, t3, i) : Promise.resolve("unknown");
  }
  async _fetchImageService(e2) {
    var _a;
    if (this.sourceJSON) return this.sourceJSON;
    const t3 = { query: { f: "json", ...this.parsedUrl.query }, responseType: "json", signal: e2 }, i = await U(this.parsedUrl.path, t3);
    i.ssl && (this.url = (_a = this.url) == null ? void 0 : _a.replace(/^http:/i, "https:")), this.sourceJSON = i.data, this.read(i.data, { origin: "service", url: this.parsedUrl });
  }
  get hasOverriddenFetchTile() {
    return !this.fetchTile[S2];
  }
};
e([y({ readOnly: true })], w.prototype, "capabilities", void 0), e([o("service", "capabilities", ["capabilities"])], w.prototype, "readCapabilities", null), e([y({ json: { read: { source: "copyrightText" } } })], w.prototype, "copyright", void 0), e([y({ readOnly: true, type: v2 })], w.prototype, "heightModelInfo", void 0), e([y({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], w.prototype, "path", void 0), e([y({ type: ["show", "hide"] })], w.prototype, "listMode", void 0), e([y({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], w.prototype, "minScale", void 0), e([y({ json: { read: false, write: false, origins: { service: { read: false, write: false }, "portal-item": { read: false, write: false }, "web-document": { read: false, write: false } } }, readOnly: true })], w.prototype, "maxScale", void 0), e([y({ json: { read: false, write: false, origins: { "web-document": { read: false, write: false } } } })], w.prototype, "opacity", void 0), e([y({ type: ["ArcGISTiledElevationServiceLayer"] })], w.prototype, "operationalLayerType", void 0), e([y()], w.prototype, "sourceJSON", void 0), e([y({ json: { read: false }, value: "elevation", readOnly: true })], w.prototype, "type", void 0), e([y(p)], w.prototype, "url", void 0), e([y()], w.prototype, "version", void 0), e([o("version", ["currentVersion"])], w.prototype, "readVersion", null), w = e([a("esri.layers.ElevationLayer")], w);
var S2 = Symbol("default-fetch-tile");
w.prototype.fetchTile[S2] = true;
var T = w;
export {
  T as default
};
//# sourceMappingURL=ElevationLayer-LBJGBHUB.js.map
