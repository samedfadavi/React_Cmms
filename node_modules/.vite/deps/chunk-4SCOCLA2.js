import {
  p
} from "./chunk-WF67GKPJ.js";
import {
  c
} from "./chunk-PVGZCS2Z.js";
import {
  A
} from "./chunk-4HOM27T6.js";
import {
  d
} from "./chunk-JVNKXKH7.js";
import {
  b as b2
} from "./chunk-LLJZCFHW.js";
import {
  x
} from "./chunk-PHVKM5OH.js";
import {
  h5 as h
} from "./chunk-7OW2VNCC.js";
import {
  e
} from "./chunk-KK4UI5LV.js";
import {
  b
} from "./chunk-7R5XEKR3.js";
import {
  n
} from "./chunk-Z6R2SP3D.js";
import {
  t2 as t
} from "./chunk-WC4SPMPL.js";
import {
  u3 as u
} from "./chunk-GEH2VXFC.js";
import {
  s2 as s
} from "./chunk-YNL57W4I.js";

// ../node_modules/@arcgis/core/layers/support/featureQueryAll.js
async function r(e2, r2, a2) {
  r2 = r2.clone(), e2.capabilities.query.supportsMaxRecordCountFactor && (r2.maxRecordCountFactor = u2(e2));
  const n2 = t2(e2), o = e2.capabilities.query.supportsPagination;
  r2.start = 0, r2.num = n2;
  let i = null;
  for (; ; ) {
    const t3 = await e2.source.queryFeaturesJSON(r2, a2);
    if (null == i ? i = t3 : i.features = i.features.concat(t3.features), i.exceededTransferLimit = t3.exceededTransferLimit, !o || !t3.exceededTransferLimit) break;
    r2.start += n2;
  }
  return i;
}
function t2(e2) {
  return u2(e2) * a(e2);
}
function a(e2) {
  return e2.capabilities.query.maxRecordCount || 2e3;
}
function u2(r2) {
  return r2.capabilities.query.supportsMaxRecordCountFactor ? b2.MAX_MAX_RECORD_COUNT_FACTOR : 1;
}

// ../node_modules/@arcgis/core/layers/support/featureLayerUtils.js
var y = new n({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" });
async function m(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (await h2(t3, e2, o), !a2.addAttachment) throw new s(o, "Layer source does not support addAttachment capability");
  return a2.addAttachment(e2, r2);
}
function h2(t3, e2, r2) {
  var _a, _b;
  const { attributes: o } = e2, { objectIdField: a2 } = t3;
  return ((_b = (_a = t3.capabilities) == null ? void 0 : _a.data) == null ? void 0 : _b.supportsAttachment) ? e2 ? o ? a2 && o[a2] ? Promise.resolve() : Promise.reject(new s(r2, `feature is missing the identifying attribute ${a2}`)) : Promise.reject(new s(r2, "'attributes' are required on a feature to query attachments")) : Promise.reject(new s(r2, "A feature is required to add/delete/update attachments")) : Promise.reject(new s(r2, "this layer doesn't support attachments"));
}
async function w(t3, e2, r2, o, a2) {
  const i = await G(t3);
  if (await h2(t3, e2, a2), !i.updateAttachment) throw new s(a2, "Layer source does not support updateAttachment capability");
  return i.updateAttachment(e2, r2, o);
}
async function b3(t3, e2, r2) {
  const { applyEdits: n2 } = await import("./editingSupport-J2DCR5VH.js"), o = await t3.load();
  let a2 = r2;
  return "feature" === o.type && o.infoFor3D && null != e2.deleteFeatures && null != o.globalIdField && (a2 = { ...a2, globalIdToObjectId: await J(o, e2.deleteFeatures, o.globalIdField) }), n2(o, o.source, e2, r2);
}
async function g(t3, e2, r2) {
  const { uploadAssets: n2 } = await import("./editingSupport-J2DCR5VH.js"), o = await t3.load();
  return n2(o, o.source, e2, r2);
}
async function j(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (await h2(t3, e2, o), !a2.deleteAttachments) throw new s(o, "Layer source does not support deleteAttachments capability");
  return a2.deleteAttachments(e2, r2);
}
async function I(t3, e2, r2) {
  const o = (await t3.load({ signal: e2 == null ? void 0 : e2.signal })).source;
  if (!o.fetchRecomputedExtents) throw new s(r2, "Layer source does not support fetchUpdates capability");
  return o.fetchRecomputedExtents(e2);
}
async function q(t3, e2, r2, o) {
  var _a, _b;
  e2 = c.from(e2), await t3.load();
  const a2 = t3.source, i = t3.capabilities;
  if (!((_a = i == null ? void 0 : i.data) == null ? void 0 : _a.supportsAttachment)) throw new s(o, "this layer doesn't support attachments");
  const { attachmentTypes: s2, objectIds: u3, globalIds: l, num: c2, size: d2, start: f, where: y2 } = e2;
  if (!((_b = i == null ? void 0 : i.operations) == null ? void 0 : _b.supportsQueryAttachments)) {
    if ((s2 == null ? void 0 : s2.length) > 0 || (l == null ? void 0 : l.length) > 0 || (d2 == null ? void 0 : d2.length) > 0 || c2 || f || y2) throw new s(o, "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", e2);
  }
  if (!((u3 == null ? void 0 : u3.length) || (l == null ? void 0 : l.length) || y2)) throw new s(o, "'objectIds', 'globalIds', or 'where' are required to perform attachment query", e2);
  if (!a2.queryAttachments) throw new s(o, "Layer source does not support queryAttachments capability", e2);
  return a2.queryAttachments(e2);
}
async function F(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryObjectIds) throw new s(o, "Layer source does not support queryObjectIds capability");
  return a2.queryObjectIds(b2.from(e2) ?? t3.createQuery(), r2);
}
async function A2(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryFeatureCount) throw new s(o, "Layer source does not support queryFeatureCount capability");
  return a2.queryFeatureCount(b2.from(e2) ?? t3.createQuery(), r2);
}
async function O(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryExtent) throw new s(o, "Layer source does not support queryExtent capability");
  return a2.queryExtent(b2.from(e2) ?? t3.createQuery(), r2);
}
async function P(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryRelatedFeatures) throw new s(o, "Layer source does not support queryRelatedFeatures capability");
  return a2.queryRelatedFeatures(d.from(e2), r2);
}
async function S(t3, e2, r2, o) {
  const a2 = await G(t3);
  if (!a2.queryRelatedFeaturesCount) throw new s(o, "Layer source does not support queryRelatedFeaturesCount capability");
  return a2.queryRelatedFeaturesCount(d.from(e2), r2);
}
async function E(t3) {
  const e2 = t3.source;
  if (e2 == null ? void 0 : e2.refresh) try {
    const { dataChanged: r2, updates: n2 } = await e2.refresh();
    if (null != n2 && (t3.sourceJSON = { ...t3.sourceJSON, ...n2 }, t3.read(n2, { origin: "service", url: t3.parsedUrl })), r2) return true;
  } catch {
  }
  if (t3.definitionExpression) try {
    return (await e(t3.definitionExpression, t3.fieldsIndex)).hasDateFunctions;
  } catch {
  }
  return false;
}
function x2(t3) {
  var _a, _b;
  const e2 = new b2(), r2 = (_a = t3.capabilities) == null ? void 0 : _a.data, n2 = (_b = t3.capabilities) == null ? void 0 : _b.query;
  e2.historicMoment = t3.historicMoment, e2.gdbVersion = t3.gdbVersion, e2.returnGeometry = true, n2 && (e2.compactGeometryEnabled = n2.supportsCompactGeometry, e2.defaultSpatialReferenceEnabled = n2.supportsDefaultSpatialReference), r2 && (r2.supportsZ && null != t3.returnZ && (e2.returnZ = t3.returnZ), r2.supportsM && null != t3.returnM && (e2.returnM = t3.returnM)), e2.outFields = ["*"];
  const { timeOffset: o, timeExtent: a2 } = t3;
  return e2.timeExtent = null != o && null != a2 ? a2.offset(-o.value, o.unit) : a2 || null, e2.multipatchOption = "multipatch" === t3.geometryType ? "xyFootprint" : null, e2;
}
function R(t3) {
  const { globalIdField: e2, fields: r2 } = t3;
  if (e2) return e2;
  if (r2) {
    for (const n2 of r2) if ("esriFieldTypeGlobalID" === n2.type) return n2.name;
  }
}
function M(t3) {
  const { objectIdField: e2, fields: r2 } = t3;
  if (e2) return e2;
  if (r2) {
    for (const n2 of r2) if ("esriFieldTypeOID" === n2.type) return n2.name;
  }
}
function C(t3) {
  return t3.currentVersion ? t3.currentVersion : t3.hasOwnProperty("capabilities") || t3.hasOwnProperty("drawingInfo") || t3.hasOwnProperty("hasAttachments") || t3.hasOwnProperty("htmlPopupType") || t3.hasOwnProperty("relationships") || t3.hasOwnProperty("timeInfo") || t3.hasOwnProperty("typeIdField") || t3.hasOwnProperty("types") ? 10 : 9.3;
}
function L(t3, e2) {
  const { subtypes: r2, subtypeField: n2 } = t3;
  if (!e2 || !(r2 == null ? void 0 : r2.length) || !n2) return null;
  const o = e2.attributes[n2];
  return null == o ? null : r2.find((t4) => t4.code === o);
}
async function G(t3) {
  return (await t3.load()).source;
}
async function Q(e2, r2) {
  if (!t) return;
  if (t.findCredential(e2)) return;
  let n2;
  try {
    const o = await x(e2, r2);
    o && (n2 = await t.checkSignInStatus(`${o}/sharing`));
  } catch (o) {
  }
  if (n2) try {
    const n3 = null != r2 ? r2.signal : null;
    await t.getCredential(e2, { signal: n3 });
  } catch (o) {
  }
}
async function T(t3, e2, r2) {
  var _a;
  const n2 = (_a = t3.parsedUrl) == null ? void 0 : _a.path;
  n2 && t3.authenticationTriggerEvent === e2 && await Q(n2, r2);
}
function v(t3) {
  return !Z(t3) && (t3.userHasUpdateItemPrivileges || t3.editingEnabled);
}
var D = u({ types: h });
function U(t3, e2) {
  var _a;
  if (t3.defaultSymbol) return ((_a = t3.types) == null ? void 0 : _a.length) ? new A({ defaultSymbol: D(t3.defaultSymbol, t3, e2), field: t3.typeIdField, uniqueValueInfos: t3.types.map((t4) => ({ id: t4.id, symbol: D(t4.symbol, t4, e2) })) }) : new p({ symbol: D(t3.defaultSymbol, t3, e2) });
}
function V(t3) {
  var _a, _b, _c;
  let e2 = (_a = t3.sourceJSON) == null ? void 0 : _a.cacheMaxAge;
  if (!e2) return false;
  const r2 = (_c = (_b = t3.editingInfo) == null ? void 0 : _b.lastEditDate) == null ? void 0 : _c.getTime();
  return null == r2 || (e2 *= 1e3, Date.now() - r2 < e2);
}
async function J(t3, e2, n2) {
  if (null == e2) return null;
  const o = [], { objectIdField: a2 } = t3;
  if (e2.forEach((t4) => {
    let e3 = null;
    if ("attributes" in t4) {
      const { attributes: r2 } = t4;
      e3 = { globalId: r2[n2], objectId: null != r2[a2] && -1 !== r2[a2] ? r2[a2] : null };
    } else e3 = { globalId: t4.globalId, objectId: null != t4.objectId && -1 !== t4.objectId ? t4.objectId : null };
    null != e3.globalId && (null != e3.objectId && -1 !== e3.objectId || o.push(e3.globalId));
  }), 0 === o.length) return null;
  const i = t3.createQuery();
  i.where = o.map((t4) => `${n2}='${t4}'`).join(" OR "), i.returnGeometry = false, i.outFields = [a2, n2], i.cacheHint = false;
  const u3 = await b(r(t3, i));
  if (!u3.ok) return null;
  const l = /* @__PURE__ */ new Map(), c2 = u3.value.features;
  for (const r2 of c2) {
    const t4 = r2.attributes[n2], e3 = r2.attributes[a2];
    null != t4 && null != e3 && -1 !== e3 && l.set(t4, e3);
  }
  return l;
}
function N(t3, e2, r2) {
  if (!e2 || !r2 || !t3) return null;
  const n2 = r2.getAttribute(e2);
  return null == n2 ? null : t3.find((t4) => {
    const { id: e3 } = t4;
    return null != e3 && e3.toString() === n2.toString();
  }) ?? null;
}
function Z(t3) {
  var _a;
  return ((_a = t3.sourceJSON) == null ? void 0 : _a.isMultiServicesView) || $(t3);
}
function $(t3) {
  var _a, _b;
  return !!((_b = (_a = t3.sourceJSON) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.toLowerCase().split(",").map((t4) => t4.trim()).includes("map"));
}

export {
  r,
  y,
  m,
  w,
  b3 as b,
  g,
  j,
  I,
  q,
  F,
  A2 as A,
  O,
  P,
  S,
  E,
  x2 as x,
  R,
  M,
  C,
  L,
  T,
  v,
  U,
  V,
  J,
  N,
  Z
};
//# sourceMappingURL=chunk-4SCOCLA2.js.map
