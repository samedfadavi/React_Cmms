import {
  t as t3
} from "./chunk-FVHY5NHZ.js";
import {
  n as n4
} from "./chunk-ZGAEGZY4.js";
import {
  e2 as e3
} from "./chunk-JYOYXNA4.js";
import {
  t
} from "./chunk-YCDX7TWD.js";
import {
  t as t2
} from "./chunk-HGR37N5M.js";
import {
  N,
  O,
  U
} from "./chunk-TCGVPS3X.js";
import {
  _ as _2
} from "./chunk-SHY2ZONT.js";
import {
  $,
  Gt,
  Rt,
  bt,
  kt,
  pt,
  rt
} from "./chunk-UF7MKJFM.js";
import {
  n as n3
} from "./chunk-TNRF7MOE.js";
import {
  o as o3,
  r as r2,
  u as u2
} from "./chunk-CYGO6TZX.js";
import {
  m
} from "./chunk-EGMIKFPM.js";
import {
  c,
  i
} from "./chunk-BL2UGYYZ.js";
import {
  p
} from "./chunk-7PMYO342.js";
import {
  o
} from "./chunk-ZK4LSXOH.js";
import {
  e as e2
} from "./chunk-6N5YXCNN.js";
import {
  g,
  n as n2,
  o as o2,
  r,
  s2 as s
} from "./chunk-MJ2NSPP7.js";
import {
  _
} from "./chunk-66KCMKB5.js";
import {
  S,
  y
} from "./chunk-TJUEGVVG.js";
import {
  n
} from "./chunk-FXNOKZ3B.js";
import {
  a3 as a
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  u
} from "./chunk-5AEITAWU.js";
import {
  has
} from "./chunk-2PA5UPTB.js";

// ../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BitBlitPrograms.js
var e4 = { shaders: { vertexShader: n4("bitBlit/bitBlit.vert"), fragmentShader: n4("bitBlit/bitBlit.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]) };

// ../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/StencilPrograms.js
var r3 = { shaders: { vertexShader: n4("stencil/stencil.vert"), fragmentShader: n4("stencil/stencil.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };

// ../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/HighlightPrograms.js
var t4 = { shaders: { vertexShader: n4("highlight/textured.vert"), fragmentShader: n4("highlight/highlight.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };
var r4 = { shaders: { vertexShader: n4("highlight/textured.vert"), fragmentShader: n4("highlight/blur.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };

// ../node_modules/@arcgis/core/views/2d/engine/webgl/Profiler.js
var r5 = has("esri-2d-profiler");
var n5 = class {
  constructor(n7, i2) {
    if (this._events = new o(), this._entries = /* @__PURE__ */ new Map(), this._timings = new t2(10), this._currentContainer = null, this._currentPass = null, this._currentBrush = null, this._currentSummary = null, !r5) return;
    this._ext = t3(n7.gl, {}), this._debugOutput = i2;
    const o5 = n7.gl;
    if (!this.enableCommandLogging) return;
    let a6;
    for (a6 in o5) if ("function" == typeof o5[a6]) {
      const e6 = o5[a6], t8 = a6.includes("draw");
      o5[a6] = (...s5) => (this._events.emit("command", { container: this._currentContainer, pass: this._currentPass, brush: this._currentBrush, method: a6, args: s5, isDrawCommand: t8 }), this._currentSummary && (this._currentSummary.commands++, t8 && this._currentSummary.drawCommands++), e6.apply(o5, s5));
    }
  }
  get enableCommandLogging() {
    return !("object" == typeof r5 && r5.disableCommands);
  }
  recordContainerStart(e6) {
    r5 && (this._currentContainer = e6);
  }
  recordContainerEnd() {
    r5 && (this._currentContainer = null);
  }
  recordPassStart(e6) {
    r5 && (this._currentPass = e6, this._initSummary());
  }
  recordPassEnd() {
    r5 && (this._currentPass = null, this._emitSummary());
  }
  recordBrushStart(e6) {
    r5 && (this._currentBrush = e6);
  }
  recordBrushEnd() {
    r5 && (this._currentBrush = null);
  }
  recordStart(e6) {
    if (r5 && null != this._ext) {
      if (this._entries.has(e6)) {
        const t9 = this._entries.get(e6), s5 = this._ext.resultAvailable(t9.query), r10 = this._ext.disjoint();
        if (s5 && !r10) {
          const s6 = this._ext.getResult(t9.query) / 1e6;
          let r11 = 0;
          if (null != this._timings.enqueue(s6)) {
            const e7 = this._timings.entries, t10 = e7.length;
            let s7 = 0;
            for (const r12 of e7) s7 += r12;
            r11 = s7 / t10;
          }
          const n7 = s6.toFixed(2), i2 = r11 ? r11.toFixed(2) : "--";
          this.enableCommandLogging ? (console.groupCollapsed(`Frame report for ${e6}, ${n7} ms (${i2} last 10 avg)
${t9.commandsLen} Commands (${t9.drawCommands} draw)`), console.log("RenderPass breakdown: "), console.table(t9.summaries), console.log("Commands: ", t9.commands), console.groupEnd()) : console.log(`Frame report for ${e6}, ${n7} ms (${i2} last 10 avg)`), this._debugOutput.innerHTML = `${n7} (${i2})`;
        }
        for (const e7 of t9.handles) e7.remove();
        this._ext.deleteQuery(t9.query), this._entries.delete(e6);
      }
      const t8 = { name: e6, query: this._ext.createQuery(), commands: [], commandsLen: 0, drawCommands: 0, summaries: [], handles: [] };
      this.enableCommandLogging && (t8.handles.push(this._events.on("command", (e7) => {
        t8.commandsLen++, t8.commands.push(e7), e7.isDrawCommand && t8.drawCommands++;
      })), t8.handles.push(this._events.on("summary", (e7) => {
        t8.summaries.push(e7);
      }))), this._ext.beginTimeElapsed(t8.query), this._entries.set(e6, t8);
    }
  }
  recordEnd(e6) {
    r5 && null != this._ext && this._entries.has(e6) && this._ext.endTimeElapsed();
  }
  _initSummary() {
    this.enableCommandLogging && (this._currentSummary = { container: this._currentContainer, pass: this._currentPass, drawCommands: 0, commands: 0 });
  }
  _emitSummary() {
    this.enableCommandLogging && this._currentSummary && this._events.emit("summary", this._currentSummary);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionGrid.js
var e5 = 1;
var h = 0;
var o4 = 1;
var r6 = 2;
var l = class {
  constructor(t8, s5, h3) {
    this._width = t8 * h3, this._height = s5 * h3, this._pixelRatio = h3;
    const o5 = Math.ceil(this._width / e5), r10 = Math.ceil(this._height / e5);
    this._cols = o5, this._rows = r10, this._cells = t.create(o5 * r10);
  }
  insertMetrics(t8) {
    this._markMetrics(t8);
  }
  hasCollision(t8) {
    let i2 = 0;
    for (const { computedX: e6, computedY: h3, width: l4, height: c5 } of t8.bounds) {
      const t9 = (l4 + U) * this._pixelRatio, a6 = (c5 + U) * this._pixelRatio;
      switch (this._collide(e6, h3, t9, a6)) {
        case r6:
          return r6;
        case o4:
          i2++;
      }
    }
    return i2 === t8.bounds.length ? o4 : h;
  }
  getCellId(t8, s5) {
    return t8 + s5 * this._cols;
  }
  has(t8) {
    return this._cells.has(t8);
  }
  hasRange(t8, s5) {
    return this._cells.hasRange(t8, s5);
  }
  set(t8) {
    this._cells.set(t8);
  }
  setRange(t8, s5) {
    this._cells.setRange(t8, s5);
  }
  _collide(s5, i2, l4, c5) {
    const a6 = s5 - l4 / 2, n7 = i2 - c5 / 2, _5 = a6 + l4, f4 = n7 + c5;
    if (_5 < 0 || f4 < 0 || a6 > this._width || n7 > this._height) return o4;
    const u3 = e2(Math.floor(a6 / e5), 0, this._cols), d7 = e2(Math.floor(n7 / e5), 0, this._rows), m2 = e2(Math.ceil(_5 / e5), 0, this._cols), p2 = e2(Math.ceil(f4 / e5), 0, this._rows);
    for (let t8 = d7; t8 <= p2; t8++) for (let s6 = u3; s6 <= m2; s6++) {
      const i3 = this.getCellId(s6, t8);
      if (this.has(i3)) return r6;
    }
    return h;
  }
  _mark(s5, i2, h3, o5, r10) {
    const l4 = s5 - h3 / 2, c5 = i2 - o5 / 2, a6 = l4 + h3, n7 = c5 + o5, _5 = e2(Math.floor(l4 / e5), 0, this._cols), f4 = e2(Math.floor(c5 / e5), 0, this._rows), u3 = e2(Math.ceil(a6 / e5), 0, this._cols), d7 = e2(Math.ceil(n7 / e5), 0, this._rows);
    for (let t8 = f4; t8 <= d7; t8++) for (let s6 = _5; s6 <= u3; s6++) {
      const i3 = this.getCellId(s6, t8);
      this.set(i3);
    }
    return false;
  }
  _markMetrics(t8) {
    for (const { computedX: i2, computedY: e6, width: h3, height: o5 } of t8.bounds) {
      const r10 = (h3 + U) * this._pixelRatio, l4 = (o5 + U) * this._pixelRatio;
      this._mark(i2, e6, r10, l4, t8.entityTexel);
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionEngine.js
var s2 = 254;
var r7 = 255;
var c2 = 0;
function a2(e6, t8) {
  const o5 = e6.children.slice();
  o5.sort((e7, t9) => e7.tileAge - t9.tileAge), o5.forEach((e7) => {
    null != e7.labelMetrics && e7.isReady && t8(e7, e7.labelMetrics);
  });
}
function f(e6, t8) {
  return (!e6.minScale || e6.minScale >= t8) && (!e6.maxScale || e6.maxScale <= t8);
}
var d = class {
  run(e6, t8, o5, i2) {
    var _a;
    const n7 = [];
    for (let l4 = e6.length - 1; l4 >= 0; l4--) {
      const t9 = e6[l4];
      ((_a = t9.labelingCollisionInfos) == null ? void 0 : _a.length) && n7.push(...t9.labelingCollisionInfos);
    }
    has("esri-2d-update-debug") && n7.length && console.debug("CollisionEngine.run"), this._transformMetrics(n7), this._runCollision(n7, t8, o5, i2);
    for (const l4 of n7) l4.container.requestRender();
  }
  _runCollision(e6, t8, i2, n7) {
    const [l4, d7] = t8.state.size, u3 = new l(l4, d7, t8.pixelRatio);
    for (const { container: o5, deconflictionEnabled: b, visible: h3 } of e6) {
      const e7 = o5.attributeView;
      b ? h3 ? (this._prepare(o5), this._collideVisible(u3, o5, i2, n7), this._collideInvisible(u3, o5)) : a2(o5, (t9, o6) => {
        for (const i3 of o6) e7.setLabelMinZoom(i3.entityTexel, r7);
      }) : a2(o5, (t9, o6) => {
        for (const n8 of o6) f(n8, i2) ? (e7.setLabelMinZoom(n8.entityTexel, c2), h3 && u3.insertMetrics(n8)) : e7.setLabelMinZoom(n8.entityTexel, s2);
      });
    }
  }
  _isFiltered(o5, i2, n7) {
    const l4 = i2.getFilterFlags(o5), s5 = !n7.hasFilter || !!(l4 & N), r10 = null == n7.featureEffect || n7.featureEffect.excludedLabelsVisible || !!(l4 & O);
    return !(s5 && r10);
  }
  _prepare(e6) {
    const t8 = e6.attributeView, o5 = /* @__PURE__ */ new Set();
    a2(e6, (i2, n7) => {
      for (const l4 of n7) {
        const i3 = l4.entityTexel;
        if (o5.has(i3)) continue;
        if (o5.add(i3), this._isFiltered(i3, t8, e6.layerView)) {
          t8.setLabelMinZoom(i3, s2);
          continue;
        }
        t8.getLabelMinZoom(i3) !== c2 ? t8.setLabelMinZoom(i3, r7) : t8.setLabelMinZoom(i3, c2);
      }
    });
  }
  _collideVisible(e6, t8, o5, r10) {
    const d7 = t8.attributeView, u3 = /* @__PURE__ */ new Set();
    a2(t8, (t9, a6) => {
      for (let b = 0; b < a6.length; b++) {
        const h3 = a6[b].entityTexel;
        if (u3.has(h3)) continue;
        if (t9.key.level !== r10) {
          d7.setLabelMinZoom(h3, s2), u3.add(h3);
          continue;
        }
        if (!f(a6[b], o5)) {
          d7.setLabelMinZoom(h3, s2), u3.add(h3);
          continue;
        }
        if (0 !== d7.getLabelMinZoom(h3)) {
          u3.add(h3);
          continue;
        }
        let m2 = false, M = true;
        const g4 = b;
        let p2 = b;
        for (; p2 < a6.length; p2++) {
          const t10 = a6[p2];
          if (t10.entityTexel !== h3) break;
          if (m2) continue;
          switch (e6.hasCollision(t10)) {
            case o4:
              break;
            case r6:
              m2 = true, M = false;
              break;
            case h:
              M = false;
          }
        }
        if (!m2) for (let t10 = g4; t10 < p2; t10++) e6.insertMetrics(a6[t10]);
        b = p2 - 1, M || (u3.add(h3), d7.setLabelMinZoom(h3, m2 ? s2 : c2));
      }
    });
  }
  _collideInvisible(e6, t8) {
    const o5 = t8.attributeView, s5 = /* @__PURE__ */ new Set();
    a2(t8, (t9, a6) => {
      for (let f4 = 0; f4 < a6.length; f4++) {
        const t10 = a6[f4].entityTexel;
        if (s5.has(t10)) continue;
        if (o5.getLabelMinZoom(t10) !== r7) {
          s5.add(t10);
          continue;
        }
        let d7 = false, u3 = true;
        const b = f4;
        let h3 = f4;
        for (; h3 < a6.length; h3++) {
          const o6 = a6[h3];
          if (o6.entityTexel !== t10) break;
          if (d7) continue;
          switch (e6.hasCollision(o6)) {
            case o4:
              break;
            case r6:
              d7 = true, u3 = false;
              break;
            case h:
              u3 = false;
          }
        }
        if (!d7) for (let o6 = b; o6 < h3; o6++) e6.insertMetrics(a6[o6]);
        f4 = h3 - 1, u3 || (s5.add(t10), o5.setLabelMinZoom(t10, d7 ? r7 : c2));
      }
    });
  }
  _transformMetrics(e6) {
    for (const { container: t8, geometryType: o5, vvEvaluators: i2 } of e6) a2(t8, (e7, n7) => {
      var _a;
      const l4 = t8.attributeView, s5 = e7.transforms.labelMat2d;
      s5[4] = Math.round(s5[4]), s5[5] = Math.round(s5[5]);
      const r10 = "polyline" === o5;
      for (const t9 of n7) {
        const { entityTexel: e8, anchorX: o6, anchorY: n8 } = t9;
        let c5 = ((_a = t9.referenceBounds) == null ? void 0 : _a.size) ?? 0;
        const a6 = i2[0];
        if (null != a6) {
          const t10 = a6(l4.getVVSize(e8));
          c5 = isNaN(t10) || null == t10 || t10 === 1 / 0 ? c5 : t10;
        }
        const f4 = t9.directionX * (c5 / 2), d7 = t9.directionY * (c5 / 2);
        for (const i3 of t9.bounds) {
          let e9 = o6, t10 = n8;
          if (r10) {
            let o7 = e9 + i3.x + f4, n9 = t10 + i3.y + d7;
            o7 = s5[0] * o7 + s5[2] * n9 + s5[4], n9 = s5[1] * o7 + s5[3] * n9 + s5[5], i3.computedX = Math.floor(o7), i3.computedY = Math.floor(n9);
          } else {
            e9 = s5[0] * o6 + s5[2] * n8 + s5[4], t10 = s5[1] * o6 + s5[3] * n8 + s5[5];
            const l5 = e9 + i3.x + f4, r11 = t10 + i3.y + d7;
            i3.computedX = l5, i3.computedY = r11;
          }
        }
      }
    });
  }
};

// ../node_modules/@arcgis/core/views/2d/LabelManager.js
var r8 = 32;
var a3 = class extends S {
  constructor(e6) {
    super(e6), this._lastUpdate = 0, this.collisionEngine = new d(), this.lastUpdateId = -1, this.updateRequested = false, this.view = null;
  }
  get updating() {
    return has("esri-2d-log-updating") && console.log(`Updating LabelManager ${this.updateRequested}:
-> updateRequested: ${this.updateRequested}`), this.updateRequested;
  }
  update(e6) {
    const t8 = performance.now();
    t8 - this._lastUpdate >= r8 ? (this._lastUpdate = t8, this.doUpdate(e6)) : this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    var _a;
    this.updateRequested || (this.updateRequested = true, (_a = this.view) == null ? void 0 : _a.requestUpdate());
  }
  processUpdate(e6) {
    this.updateRequested && (this.updateRequested = false, this.update(e6));
  }
  doUpdate(e6) {
    const t8 = this.view;
    if (t8) try {
      const s5 = e6.state.scale, o5 = t8.featuresTilingScheme.getClosestInfoForScale(s5).level;
      this.collisionEngine.run(t8.allLayerViews.items, e6, s5, o5);
    } catch (s5) {
    }
  }
};
e([y()], a3.prototype, "updateRequested", void 0), e([y()], a3.prototype, "updating", null), e([y()], a3.prototype, "view", void 0), a3 = e([a("esri.views.2d.LabelManager")], a3);

// ../node_modules/@arcgis/core/views/2d/navigation/ZoomBox.js
var n6 = "esri-zoom-box";
var h2 = { container: `${n6}__container`, overlay: `${n6}__overlay`, background: `${n6}__overlay-background`, box: `${n6}__outline` };
var l2 = { zoom: "Shift", counter: "Control" };
var d2 = class extends S {
  constructor(t8) {
    super(t8), this._container = null, this._overlay = null, this._backgroundShape = null, this._boxShape = null, this._box = { x: 0, y: 0, width: 0, height: 0 }, this._rafId = null, this._redraw = this._redraw.bind(this);
  }
  destroy() {
    this.view = null;
  }
  set view(t8) {
    this.removeAllHandles(), this._destroyOverlay(), this._set("view", t8), t8 && this.addHandles([t8.on("drag", [l2.zoom], (t9) => this._handleDrag(t9, 1), _2.INTERNAL), t8.on("drag", [l2.zoom, l2.counter], (t9) => this._handleDrag(t9, -1), _2.INTERNAL)]);
  }
  _start() {
    this._createContainer(), this._createOverlay(), this.navigation.begin();
  }
  _update(t8, e6, i2, o5) {
    this._box.x = t8, this._box.y = e6, this._box.width = i2, this._box.height = o5, this._rafId || (this._rafId = requestAnimationFrame(this._redraw));
  }
  _end(t8, e6, r10, s5, a6) {
    const n7 = this.view, h3 = n7.toMap(c(t8 + 0.5 * r10, e6 + 0.5 * s5));
    let l4 = Math.max(r10 / n7.width, s5 / n7.height);
    -1 === a6 && (l4 = 1 / l4), this._destroyOverlay(), this.navigation.end(), n7.goTo({ center: h3, scale: n7.scale * l4 }, { animationMode: "always", duration: n(has("mapview-essential-goto-duration")) });
  }
  _updateBox(t8, e6, i2, o5) {
    const r10 = this._boxShape;
    r10.setAttributeNS(null, "x", "" + t8), r10.setAttributeNS(null, "y", "" + e6), r10.setAttributeNS(null, "width", "" + i2), r10.setAttributeNS(null, "height", "" + o5), r10.setAttributeNS(null, "class", h2.box);
  }
  _updateBackground(t8, e6, i2, o5) {
    this._backgroundShape.setAttributeNS(null, "d", this._toSVGPath(t8, e6, i2, o5, this.view.width, this.view.height));
  }
  _createContainer() {
    const t8 = document.createElement("div");
    t8.className = h2.container, this.view.root.appendChild(t8), this._container = t8;
  }
  _createOverlay() {
    const t8 = this.view.width, e6 = this.view.height, i2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    i2.setAttributeNS(null, "d", "M 0 0 L " + t8 + " 0 L " + t8 + " " + e6 + " L 0 " + e6 + " Z"), i2.setAttributeNS(null, "class", h2.background);
    const o5 = document.createElementNS("http://www.w3.org/2000/svg", "rect"), r10 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    r10.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"), r10.setAttributeNS(null, "class", h2.overlay), r10.appendChild(i2), r10.appendChild(o5), this._container.appendChild(r10), this._backgroundShape = i2, this._boxShape = o5, this._overlay = r10;
  }
  _destroyOverlay() {
    this._container && this._container.parentNode && this._container.parentNode.removeChild(this._container), this._container = this._backgroundShape = this._boxShape = this._overlay = null;
  }
  _toSVGPath(t8, e6, i2, o5, r10, s5) {
    const a6 = t8 + i2, n7 = e6 + o5;
    return "M 0 0 L " + r10 + " 0 L " + r10 + " " + s5 + " L 0 " + s5 + " ZM " + t8 + " " + e6 + " L " + t8 + " " + n7 + " L " + a6 + " " + n7 + " L " + a6 + " " + e6 + " Z";
  }
  _handleDrag(t8, e6) {
    const i2 = t8.x, o5 = t8.y, r10 = t8.origin.x, s5 = t8.origin.y;
    let a6, n7, h3, l4;
    switch (i2 > r10 ? (a6 = r10, h3 = i2 - r10) : (a6 = i2, h3 = r10 - i2), o5 > s5 ? (n7 = s5, l4 = o5 - s5) : (n7 = o5, l4 = s5 - o5), t8.action) {
      case "start":
        this._start();
        break;
      case "update":
        this._update(a6, n7, h3, l4);
        break;
      case "end":
        this._end(a6, n7, h3, l4, e6);
    }
    t8.stopPropagation();
  }
  _redraw() {
    if (!this._rafId) return;
    if (this._rafId = null, !this._overlay) return;
    const { x: t8, y: e6, width: i2, height: o5 } = this._box;
    this._updateBox(t8, e6, i2, o5), this._updateBackground(t8, e6, i2, o5), this._rafId = requestAnimationFrame(this._redraw);
  }
};
e([y()], d2.prototype, "navigation", void 0), e([y()], d2.prototype, "view", null), d2 = e([a("esri.views.2d.navigation.ZoomBox")], d2);
var c3 = d2;

// ../node_modules/@arcgis/core/views/navigation/FilteredFiniteDifference.js
var t5 = class {
  constructor(t8) {
    this._gain = t8, this.lastValue = void 0, this.filteredDelta = void 0;
  }
  update(t8) {
    if (this.hasLastValue()) {
      const e6 = this.computeDelta(t8);
      this._updateDelta(e6);
    }
    this.lastValue = t8;
  }
  reset() {
    this.lastValue = void 0, this.filteredDelta = void 0;
  }
  hasLastValue() {
    return void 0 !== this.lastValue;
  }
  hasFilteredDelta() {
    return void 0 !== this.filteredDelta;
  }
  computeDelta(t8) {
    return void 0 === this.lastValue ? NaN : t8 - this.lastValue;
  }
  _updateDelta(t8) {
    void 0 !== this.filteredDelta ? this.filteredDelta = (1 - this._gain) * this.filteredDelta + this._gain * t8 : this.filteredDelta = t8;
  }
};

// ../node_modules/@arcgis/core/views/navigation/Momentum.js
var t6 = class {
  constructor(t8, i2, o5) {
    this._initialVelocity = t8, this._stopVelocity = i2, this._friction = o5, this._duration = Math.abs(Math.log(Math.abs(this._initialVelocity) / this._stopVelocity) / Math.log(1 - this._friction));
  }
  get duration() {
    return this._duration;
  }
  isFinished(t8) {
    return t8 > this.duration;
  }
  get friction() {
    return this._friction;
  }
  value(t8) {
    return this.valueFromInitialVelocity(this._initialVelocity, t8);
  }
  valueDelta(t8, i2) {
    const o5 = this.value(t8);
    return this.value(t8 + i2) - o5;
  }
  valueFromInitialVelocity(t8, i2) {
    i2 = Math.min(i2, this.duration);
    const o5 = 1 - this.friction;
    return t8 * (o5 ** i2 - 1) / Math.log(o5);
  }
};

// ../node_modules/@arcgis/core/views/navigation/PanPlanarMomentumEstimator.js
var l3 = class extends t6 {
  constructor(e6, t8, i2, s5, n7) {
    super(e6, t8, i2), this._sceneVelocity = s5, this.direction = n7;
  }
  value(e6) {
    return super.valueFromInitialVelocity(this._sceneVelocity, e6);
  }
};
var c4 = class {
  constructor(e6 = 300, t8 = 12, i2 = 0.84) {
    this._minimumInitialVelocity = e6, this._stopVelocity = t8, this._friction = i2, this.enabled = true, this._time = new t5(0.6), this._screen = [new t5(0.4), new t5(0.4)], this._scene = [new t5(0.6), new t5(0.6), new t5(0.6)], this._tmpDirection = n2();
  }
  add(e6, t8, i2) {
    if (this.enabled) {
      if (this._time.hasLastValue()) {
        if (this._time.computeDelta(i2) < 0.015) return;
      }
      this._screen[0].update(e6[0]), this._screen[1].update(e6[1]), this._scene[0].update(t8[0]), this._scene[1].update(t8[1]), this._scene[2].update(t8[2]), this._time.update(i2);
    }
  }
  reset() {
    this._screen[0].reset(), this._screen[1].reset(), this._scene[0].reset(), this._scene[1].reset(), this._scene[2].reset(), this._time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this._screen[0].hasFilteredDelta() || !this._time.hasFilteredDelta()) return null;
    const e6 = this._screen[0].filteredDelta, t8 = this._screen[1].filteredDelta, i2 = null == e6 || null == t8 ? 0 : Math.sqrt(e6 * e6 + t8 * t8), s5 = this._time.filteredDelta, n7 = null == s5 || null == i2 ? 0 : i2 / s5;
    return Math.abs(n7) < this._minimumInitialVelocity ? null : this.createMomentum(n7, this._stopVelocity, this._friction);
  }
  createMomentum(s5, n7, r10) {
    o2(this._tmpDirection, this._scene[0].filteredDelta ?? 0, this._scene[1].filteredDelta ?? 0, this._scene[2].filteredDelta ?? 0);
    const c5 = s(this._tmpDirection);
    c5 > 0 && g(this._tmpDirection, this._tmpDirection, 1 / c5);
    const h3 = this._time.filteredDelta;
    return new l3(s5, n7, r10, null == h3 ? 0 : c5 / h3, this._tmpDirection);
  }
};

// ../node_modules/@arcgis/core/views/2d/navigation/actions/Pan.js
var v = class extends S {
  constructor(t8) {
    super(t8), this.animationTime = 0, this.momentumEstimator = new c4(500, 6, 0.92), this.momentum = null, this.tmpMomentum = n2(), this.momentumFinished = false, this.viewpoint = new m({ targetGeometry: new _(), scale: 0, rotation: 0 }), this._previousDrag = null, p(() => this.momentumFinished, () => this.navigation.stop());
  }
  begin(t8, i2) {
    this.navigation.begin(), this.momentumEstimator.reset(), this.addToEstimator(i2), this._previousDrag = i2;
  }
  update(t8, i2) {
    this.addToEstimator(i2);
    let o5 = i2.center.x, e6 = i2.center.y;
    const s5 = this._previousDrag;
    o5 = s5 ? s5.center.x - o5 : -o5, e6 = s5 ? e6 - s5.center.y : e6, t8.viewpoint = kt(this.viewpoint, t8.viewpoint, [o5 || 0, e6 || 0]), this._previousDrag = i2;
  }
  end(t8, i2) {
    this.addToEstimator(i2);
    const o5 = t8.navigation.effectiveMomentumEnabled;
    this.momentum = o5 ? this.momentumEstimator.evaluateMomentum() : null, this.animationTime = 0, this.momentum && this.onAnimationUpdate(t8), this._previousDrag = null, this.navigation.end();
  }
  addToEstimator(t8) {
    const i2 = t8.center.x, o5 = t8.center.y, e6 = i(-i2, o5), m2 = r(-i2, o5, 0);
    this.momentumEstimator.add(e6, m2, 1e-3 * t8.timestamp);
  }
  onAnimationUpdate(t8) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinuous(t8.viewpoint, (i2, o5) => {
      const { momentum: e6, animationTime: s5, tmpMomentum: m2 } = this, n7 = 1e-3 * o5;
      if (!(this.momentumFinished = !e6 || e6.isFinished(s5))) {
        const o6 = e6.valueDelta(s5, n7);
        g(m2, e6.direction, o6), kt(i2, i2, m2), t8.constraints.constrainByGeometry(i2);
      }
      this.animationTime += n7;
    });
  }
  stopMomentumNavigation() {
    this.momentum && (this.momentumEstimator.reset(), this.momentum = null, this.navigation.stop());
  }
};
e([y()], v.prototype, "momentumFinished", void 0), e([y()], v.prototype, "viewpoint", void 0), e([y()], v.prototype, "navigation", void 0), v = e([a("esri.views.2d.navigation.actions.Pan")], v);
var d3 = v;

// ../node_modules/@arcgis/core/views/navigation/MomentumEstimator.js
var s3 = class {
  constructor(t8 = 2.5, i2 = 0.01, s5 = 0.95, l4 = 12) {
    this._minimumInitialVelocity = t8, this._stopVelocity = i2, this._friction = s5, this._maxVelocity = l4, this.enabled = true, this.value = new t5(0.8), this.time = new t5(0.3);
  }
  add(t8, e6) {
    if (this.enabled && null != e6) {
      if (this.time.hasLastValue()) {
        if (this.time.computeDelta(e6) < 0.01) return;
        if (this.value.hasFilteredDelta()) {
          const e7 = this.value.computeDelta(t8);
          this.value.filteredDelta * e7 < 0 && this.value.reset();
        }
      }
      this.time.update(e6), this.value.update(t8);
    }
  }
  reset() {
    this.value.reset(), this.time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this.value.hasFilteredDelta() || !this.time.hasFilteredDelta()) return null;
    let e6 = this.value.filteredDelta / this.time.filteredDelta;
    return e6 = e2(e6, -this._maxVelocity, this._maxVelocity), Math.abs(e6) < this._minimumInitialVelocity ? null : this.createMomentum(e6, this._stopVelocity, this._friction);
  }
  createMomentum(t8, e6, s5) {
    return new t6(t8, e6, s5);
  }
};

// ../node_modules/@arcgis/core/views/navigation/RotationMomentumEstimator.js
var a4 = class extends s3 {
  constructor(t8 = 3, a6 = 0.01, s5 = 0.95, o5 = 12) {
    super(t8, a6, s5, o5);
  }
  add(t8, a6) {
    const s5 = this.value.lastValue;
    if (null != s5) {
      let a7 = t8 - s5;
      for (; a7 > Math.PI; ) a7 -= 2 * Math.PI;
      for (; a7 < -Math.PI; ) a7 += 2 * Math.PI;
      t8 = s5 + a7;
    }
    super.add(t8, a6);
  }
};

// ../node_modules/@arcgis/core/views/navigation/ZoomMomentumEstimator.js
var r9 = class extends t6 {
  constructor(e6, t8, r10) {
    super(e6, t8, r10);
  }
  value(e6) {
    const t8 = super.value(e6);
    return Math.exp(t8);
  }
  valueDelta(e6, t8) {
    const r10 = super.value(e6), s5 = super.value(e6 + t8) - r10;
    return Math.exp(s5);
  }
};
var s4 = class extends s3 {
  constructor(e6 = 2.5, t8 = 0.01, r10 = 0.95, s5 = 12) {
    super(e6, t8, r10, s5);
  }
  add(e6, t8) {
    super.add(Math.log(e6), t8);
  }
  createMomentum(e6, t8, s5) {
    return new r9(e6, t8, s5);
  }
};

// ../node_modules/@arcgis/core/views/2d/navigation/actions/Pinch.js
var _3 = class extends S {
  constructor(t8) {
    super(t8), this._animationTime = 0, this._momentumFinished = false, this._previousAngle = 0, this._previousRadius = 0, this._previousCenter = null, this._rotationMomentumEstimator = new a4(0.6, 0.15, 0.95), this._rotationDirection = 1, this._startAngle = 0, this._startRadius = 0, this._updateTimestamp = null, this._zoomDirection = 1, this._zoomMomentumEstimator = new s4(), this._zoomOnly = null, this.viewpoint = new m({ targetGeometry: new _(), scale: 0, rotation: 0 }), this.zoomMomentum = null, this.rotateMomentum = null, this.addHandles(p(() => this._momentumFinished, () => this.navigation.stop()));
  }
  begin(t8, o5) {
    this.navigation.begin(), this._rotationMomentumEstimator.reset(), this._zoomMomentumEstimator.reset(), this._zoomOnly = null, this._previousAngle = this._startAngle = o5.angle, this._previousRadius = this._startRadius = o5.radius, this._previousCenter = o5.center, this._updateTimestamp = null, t8.constraints.rotationEnabled && this.addToRotateEstimator(0, o5.timestamp), this.addToZoomEstimator(o5, 1);
  }
  update(t8, o5) {
    null === this._updateTimestamp && (this._updateTimestamp = o5.timestamp);
    const i2 = o5.angle, s5 = o5.radius, e6 = o5.center, n7 = Math.abs(180 * (i2 - this._startAngle) / Math.PI), m2 = Math.abs(s5 - this._startRadius), a6 = this._startRadius / s5;
    if (this._previousRadius && this._previousCenter) {
      const r10 = s5 / this._previousRadius;
      let h3 = 180 * (i2 - this._previousAngle) / Math.PI;
      this._rotationDirection = h3 >= 0 ? 1 : -1, this._zoomDirection = r10 >= 1 ? 1 : -1, t8.constraints.rotationEnabled ? (null === this._zoomOnly && o5.timestamp - this._updateTimestamp > 200 && (this._zoomOnly = m2 - n7 > 0), null === this._zoomOnly || this._zoomOnly ? h3 = 0 : this.addToRotateEstimator(i2 - this._startAngle, o5.timestamp)) : h3 = 0, this.addToZoomEstimator(o5, a6), this.navigation.setViewpoint([e6.x, e6.y], 1 / r10, h3, [this._previousCenter.x - e6.x, e6.y - this._previousCenter.y]);
    }
    this._previousAngle = i2, this._previousRadius = s5, this._previousCenter = e6;
  }
  end(t8) {
    this.rotateMomentum = this._rotationMomentumEstimator.evaluateMomentum(), this.zoomMomentum = this._zoomMomentumEstimator.evaluateMomentum(), this._animationTime = 0, (this.rotateMomentum || this.zoomMomentum) && this.onAnimationUpdate(t8), this.navigation.end();
  }
  addToRotateEstimator(t8, o5) {
    this._rotationMomentumEstimator.add(t8, 1e-3 * o5);
  }
  addToZoomEstimator(t8, o5) {
    this._zoomMomentumEstimator.add(o5, 1e-3 * t8.timestamp);
  }
  canZoomIn(t8) {
    const o5 = t8.scale, i2 = t8.constraints.effectiveMaxScale;
    return 0 === i2 || o5 > i2;
  }
  canZoomOut(t8) {
    const o5 = t8.scale, i2 = t8.constraints.effectiveMinScale;
    return 0 === i2 || o5 < i2;
  }
  onAnimationUpdate(t8) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinuous(t8.viewpoint, (o5, i2) => {
      const s5 = !this.canZoomIn(t8) && this._zoomDirection > 1 || !this.canZoomOut(t8) && this._zoomDirection < 1, e6 = !this.rotateMomentum || this.rotateMomentum.isFinished(this._animationTime), n7 = s5 || !this.zoomMomentum || this.zoomMomentum.isFinished(this._animationTime), h3 = 1e-3 * i2;
      if (this._momentumFinished = e6 && n7, !this._momentumFinished) {
        const i3 = this.rotateMomentum ? Math.abs(this.rotateMomentum.valueDelta(this._animationTime, h3)) * this._rotationDirection * 180 / Math.PI : 0;
        let s6 = this.zoomMomentum ? Math.abs(this.zoomMomentum.valueDelta(this._animationTime, h3)) : 1;
        const e7 = n3(), n8 = n3();
        if (this._previousCenter) {
          o3(e7, this._previousCenter.x, this._previousCenter.y), rt(n8, t8.size, t8.padding), u2(e7, e7, n8);
          const { constraints: r10, scale: h4 } = t8, p2 = h4 * s6;
          s6 < 1 && !r10.canZoomInTo(p2) ? (s6 = h4 / r10.effectiveMaxScale, this.zoomMomentum = null, this.rotateMomentum = null) : s6 > 1 && !r10.canZoomOutTo(p2) && (s6 = h4 / r10.effectiveMinScale, this.zoomMomentum = null, this.rotateMomentum = null), Gt(o5, t8.viewpoint, s6, i3, e7, t8.size), t8.constraints.constrainByGeometry(o5);
        }
      }
      this._animationTime += h3;
    });
  }
  stopMomentumNavigation() {
    (this.rotateMomentum || this.zoomMomentum) && (this.rotateMomentum && (this._rotationMomentumEstimator.reset(), this.rotateMomentum = null), this.zoomMomentum && (this._zoomMomentumEstimator.reset(), this.zoomMomentum = null), this.navigation.stop());
  }
};
e([y()], _3.prototype, "_momentumFinished", void 0), e([y()], _3.prototype, "viewpoint", void 0), e([y()], _3.prototype, "navigation", void 0), _3 = e([a("esri.views.2d.navigation.actions.Pinch")], _3);
var d4 = _3;

// ../node_modules/@arcgis/core/views/2d/navigation/actions/Rotate.js
var d5 = n3();
var g2 = n3();
var j = class extends S {
  constructor(t8) {
    super(t8), this._previousCenter = n3(), this.viewpoint = new m({ targetGeometry: new _(), scale: 0, rotation: 0 });
  }
  begin(t8, e6) {
    this.navigation.begin(), o3(this._previousCenter, e6.center.x, e6.center.y);
  }
  update(t8, e6) {
    const { state: { size: o5, padding: r10 } } = t8;
    o3(d5, e6.center.x, e6.center.y), $(g2, o5, r10), t8.viewpoint = bt(this.viewpoint, t8.state.paddedViewState.viewpoint, pt(g2, this._previousCenter, d5)), r2(this._previousCenter, d5);
  }
  end() {
    this.navigation.end();
  }
};
e([y()], j.prototype, "viewpoint", void 0), e([y()], j.prototype, "navigation", void 0), j = e([a("esri.views.2d.navigation.actions.Rotate")], j);
var f2 = j;

// ../node_modules/@arcgis/core/views/2d/navigation/MapViewNavigation.js
var v2 = 10;
var g3 = 1;
var d6 = new m({ targetGeometry: new _() });
var _4 = [0, 0];
var T = 250;
var f3 = class extends S {
  constructor(t8) {
    super(t8), this._endTimer = null, this._lastEventTimestamp = null, this.animationManager = null, this.interacting = false;
  }
  initialize() {
    this.pan = new d3({ navigation: this }), this.rotate = new f2({ navigation: this }), this.pinch = new d4({ navigation: this }), this.zoomBox = new c3({ view: this.view, navigation: this });
  }
  destroy() {
    this.pan = u(this.pan), this.rotate = u(this.rotate), this.pinch = u(this.pinch), this.zoomBox = u(this.zoomBox), this.animationManager = null;
  }
  begin() {
    this.stop(), this._set("interacting", true);
  }
  end() {
    this._lastEventTimestamp = performance.now(), this._startTimer(T);
  }
  async zoom(t8, i2 = this._getDefaultAnchor()) {
    if (this.begin(), this.view.constraints.snapToZoom && this.view.constraints.effectiveLODs) return t8 < 1 ? this.zoomIn(i2) : this.zoomOut(i2);
    this.setViewpoint(i2, t8, 0, [0, 0]);
  }
  async zoomIn(t8) {
    const i2 = this.view, o5 = i2.constraints.snapToNextScale(i2.scale);
    return this._zoomToScale(o5, t8);
  }
  async zoomOut(t8) {
    const i2 = this.view, o5 = i2.constraints.snapToPreviousScale(i2.scale);
    return this._zoomToScale(o5, t8);
  }
  setViewpoint(t8, i2, o5, n7) {
    this.begin(), this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, t8, i2, o5, n7), this.end();
  }
  setViewpointImmediate(t8, i2 = 0, o5 = [0, 0], n7 = this._getDefaultAnchor()) {
    this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, n7, t8, i2, o5);
  }
  continuousRotateClockwise() {
    var _a;
    const t8 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinuous(t8, (t9) => {
      bt(t9, t9, -g3);
    });
  }
  continuousRotateCounterclockwise() {
    var _a;
    const t8 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinuous(t8, (t9) => {
      bt(t9, t9, g3);
    });
  }
  resetRotation() {
    this.view.constraints.rotationEnabled && (this.view.rotation = 0);
  }
  continuousPanLeft() {
    this._continuousPan([-v2, 0]);
  }
  continuousPanRight() {
    this._continuousPan([v2, 0]);
  }
  continuousPanUp() {
    this._continuousPan([0, v2]);
  }
  continuousPanDown() {
    this._continuousPan([0, -v2]);
  }
  continuousPanVector({ x: t8, y: i2 }) {
    this._continuousPan([t8 * v2, i2 * v2]);
  }
  stop() {
    var _a;
    this.pan.stopMomentumNavigation(), (_a = this.animationManager) == null ? void 0 : _a.stop(), this.end(), null !== this._endTimer && (clearTimeout(this._endTimer), this._endTimer = null, this._set("interacting", false));
  }
  _continuousPan(t8) {
    var _a;
    const i2 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinuous(i2, (i3) => {
      kt(i3, i3, t8), this.view.constraints.constrainByGeometry(i3);
    });
  }
  _startTimer(t8) {
    return null !== this._endTimer || (this._endTimer = setTimeout(() => {
      this._endTimer = null;
      const t9 = performance.now() - (this._lastEventTimestamp ?? 0);
      t9 < T ? this._endTimer = this._startTimer(t9) : this._set("interacting", false);
    }, t8)), this._endTimer;
  }
  _getDefaultAnchor() {
    const { size: t8, padding: { left: i2, right: o5, top: n7, bottom: e6 } } = this.view;
    return _4[0] = 0.5 * (t8[0] - o5 + i2), _4[1] = 0.5 * (t8[1] - e6 + n7), _4;
  }
  async _zoomToScale(t8, i2 = this._getDefaultAnchor()) {
    const { view: o5 } = this, { constraints: n7, scale: s5, viewpoint: a6, size: r10, padding: c5 } = o5, m2 = n7.canZoomInTo(t8), p2 = n7.canZoomOutTo(t8);
    if (!(t8 < s5 && !m2 || t8 > s5 && !p2)) return Rt(d6, a6, t8 / s5, 0, i2, r10, c5), n7.constrainByGeometry(d6), o5.goTo(d6, { animate: true, animationMode: "always", duration: n(has("mapview-essential-goto-duration")), pickClosestTarget: false });
  }
  _scaleRotateTranslateViewpoint(t8, i2, o5, n7, e6) {
    const { view: s5 } = this, { size: a6, padding: r10, constraints: c5, scale: p2, viewpoint: u3 } = s5, l4 = p2 * o5, w = c5.canZoomInTo(l4), v3 = c5.canZoomOutTo(l4);
    return (o5 < 1 && !w || o5 > 1 && !v3) && (o5 = 1), kt(u3, u3, e6), Rt(t8, u3, o5, n7, i2, a6, r10), c5.constrainByGeometry(t8);
  }
};
e([y()], f3.prototype, "animationManager", void 0), e([y({ type: Boolean, readOnly: true })], f3.prototype, "interacting", void 0), e([y()], f3.prototype, "pan", void 0), e([y()], f3.prototype, "pinch", void 0), e([y()], f3.prototype, "rotate", void 0), e([y()], f3.prototype, "view", void 0), e([y()], f3.prototype, "zoomBox", void 0), f3 = e([a("esri.views.2d.navigation.MapViewNavigation")], f3);
var y2 = f3;

// ../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/MagnifierPrograms.js
var a5 = { shaders: { vertexShader: n4("magnifier/magnifier.vert"), fragmentShader: n4("magnifier/magnifier.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };
function t7(r10) {
  return e3(r10, a5);
}

export {
  e4 as e,
  r3 as r,
  t4 as t,
  r4 as r2,
  n5 as n,
  a3 as a,
  y2 as y,
  a5 as a2,
  t7 as t2
};
//# sourceMappingURL=chunk-7UHIQF2L.js.map
