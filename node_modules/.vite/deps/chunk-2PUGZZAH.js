import {
  c,
  f,
  f2
} from "./chunk-4K57JS64.js";
import {
  n as n3,
  r as r2
} from "./chunk-NREDFKHH.js";
import {
  L as L2,
  a
} from "./chunk-DCOKV3EO.js";
import {
  p as p2
} from "./chunk-T4EIRKFE.js";
import {
  n
} from "./chunk-WLUQPLAY.js";
import {
  L,
  m
} from "./chunk-6N5YXCNN.js";
import {
  A,
  O,
  P,
  _2 as _,
  e2,
  g,
  n as n2,
  o,
  p,
  q,
  r2 as r,
  s2 as s,
  t as t2,
  u,
  v,
  x,
  z
} from "./chunk-MJ2NSPP7.js";
import {
  e
} from "./chunk-6YSPJNLC.js";
import {
  t2 as t
} from "./chunk-GEH2VXFC.js";

// ../node_modules/@arcgis/core/core/ObjectStack.js
var s2 = class {
  constructor(t3) {
    this._allocator = t3, this._items = [], this._itemsPtr = 0, this._grow();
  }
  get() {
    return 0 === this._itemsPtr && t(() => this._reset()), this._itemsPtr === this._items.length && this._grow(), this._items[this._itemsPtr++];
  }
  _reset() {
    const t3 = Math.min(3 * Math.max(8, this._itemsPtr), this._itemsPtr + 3 * i);
    this._items.length = Math.min(t3, this._items.length), this._itemsPtr = 0;
  }
  _grow() {
    for (let t3 = 0; t3 < Math.max(8, Math.min(this._items.length, i)); t3++) this._items.push(this._allocator());
  }
};
var i = 1024;

// ../node_modules/@arcgis/core/geometry/support/ray.js
function m2(i2) {
  return i2 ? j(t2(i2.origin), t2(i2.direction)) : j(n2(), n2());
}
function j(i2, r3) {
  return { origin: i2, direction: r3 };
}
function l(i2, r3) {
  const n4 = q2.get();
  return n4.origin = i2, n4.direction = r3, n4;
}
function k(i2, r3, t3 = m2()) {
  return r(t3.origin, i2), e2(t3.direction, r3, i2), t3;
}
function S(i2, r3, n4) {
  const t3 = P(i2.direction, e2(n4, r3, i2.origin));
  return u(n4, i2.origin, g(n4, i2.direction, t3)), n4;
}
var q2 = new s2(() => m2());
var w = n2();

// ../node_modules/@arcgis/core/chunks/sphere.js
var C = _2();
function _2() {
  return n3();
}
var w2 = L2;
var O2 = L2;
function T(t3, r3) {
  return a(r3, t3);
}
function k2(t3, r3) {
  return r2(t3[0], t3[1], t3[2], r3);
}
function z2(t3) {
  return t3;
}
function E(t3) {
  t3[0] = t3[1] = t3[2] = t3[3] = 0;
}
function L3(t3, r3) {
  return t3[0] = t3[1] = t3[2] = 0, t3[3] = r3, t3;
}
function N(t3) {
  return t3[3];
}
function V(t3) {
  return t3;
}
function Z(t3, r3, n4, o2) {
  return r2(t3, r3, n4, o2);
}
function B(t3, r3, n4) {
  return t3 !== n4 && (n4[0] = t3[0], n4[1] = t3[1], n4[2] = t3[2]), n4[3] = t3[3] + r3, n4;
}
function U(t3, r3, n4) {
  return t3 !== n4 && T(t3, n4), n4;
}
function X(t3, r3, n4) {
  if (null == r3) return false;
  if (!F(t3, r3, D)) return false;
  let { t0: o2, t1: s3 } = D;
  if ((o2 < 0 || s3 < o2 && s3 > 0) && (o2 = s3), o2 < 0) return false;
  if (n4) {
    const { origin: t4, direction: s4 } = r3;
    n4[0] = t4[0] + s4[0] * o2, n4[1] = t4[1] + s4[1] * o2, n4[2] = t4[2] + s4[2] * o2;
  }
  return true;
}
function Y(t3, r3, n4) {
  const o2 = k(r3, n4);
  if (!F(t3, o2, D)) return [];
  const { origin: s3, direction: e3 } = o2, { t0: i2, t1: a2 } = D, c2 = (r4) => {
    const n5 = n2();
    return q(n5, s3, e3, r4), Q(t3, n5, n5);
  };
  return Math.abs(i2 - a2) < e() ? [c2(i2)] : [c2(i2), c2(a2)];
}
var D = { t0: 0, t1: 0 };
function F(t3, r3, n4) {
  const { origin: o2, direction: s3 } = r3, e3 = G;
  e3[0] = o2[0] - t3[0], e3[1] = o2[1] - t3[1], e3[2] = o2[2] - t3[2];
  const i2 = s3[0] * s3[0] + s3[1] * s3[1] + s3[2] * s3[2];
  if (0 === i2) return false;
  const a2 = 2 * (s3[0] * e3[0] + s3[1] * e3[1] + s3[2] * e3[2]), c2 = a2 * a2 - 4 * i2 * (e3[0] * e3[0] + e3[1] * e3[1] + e3[2] * e3[2] - t3[3] * t3[3]);
  if (c2 < 0) return false;
  const u2 = Math.sqrt(c2);
  return n4.t0 = (-a2 - u2) / (2 * i2), n4.t1 = (-a2 + u2) / (2 * i2), true;
}
var G = n2();
function H(t3, r3) {
  return X(t3, r3, null);
}
function I(t3, r3, n4) {
  if (X(t3, r3, n4)) return n4;
  const a2 = J(t3, r3, c.get());
  return u(n4, r3.origin, g(c.get(), r3.direction, x(r3.origin, a2) / s(r3.direction))), n4;
}
function J(t3, r3, o2) {
  const e3 = c.get(), u2 = f2.get();
  _(e3, r3.origin, r3.direction);
  const f3 = N(t3);
  _(o2, e3, r3.origin), g(o2, o2, 1 / s(o2) * f3);
  const m3 = $(t3, r3.origin), l2 = f(r3.origin, o2);
  return p2(u2, l2 + m3, e3), O(o2, o2, u2), o2;
}
function K2(t3, r3, n4) {
  return X(t3, r3, n4) ? n4 : (S(r3, V(t3), n4), Q(t3, n4, n4));
}
function Q(t3, r3, n4) {
  const e3 = e2(c.get(), r3, V(t3)), a2 = g(c.get(), e3, t3[3] / s(e3));
  return u(n4, a2, V(t3));
}
function W(t3, r3) {
  const n4 = e2(c.get(), r3, V(t3)), o2 = v(n4), s3 = t3[3] * t3[3];
  return Math.sqrt(Math.abs(o2 - s3));
}
function $(r3, n4) {
  const o2 = e2(c.get(), n4, V(r3)), s3 = s(o2), e3 = N(r3), a2 = e3 + Math.abs(e3 - s3);
  return m(e3 / a2);
}
var tt = n2();
function rt(t3, n4, o2, s3) {
  const e3 = e2(tt, n4, V(t3));
  switch (o2) {
    case n.X: {
      const t4 = L(e3, tt)[2];
      return o(s3, -Math.sin(t4), Math.cos(t4), 0);
    }
    case n.Y: {
      const t4 = L(e3, tt), n5 = t4[1], o3 = t4[2], i2 = Math.sin(n5);
      return o(s3, -i2 * Math.cos(o3), -i2 * Math.sin(o3), Math.cos(n5));
    }
    case n.Z:
      return z(s3, e3);
    default:
      return;
  }
}
function nt(t3, r3) {
  const n4 = e2(it, r3, V(t3));
  return s(n4) - t3[3];
}
function ot(t3, r3, n4, e3) {
  const i2 = nt(t3, r3), a2 = rt(t3, r3, n.Z, it), c2 = g(it, a2, n4 - i2);
  return u(e3, r3, c2);
}
function st(t3, r3) {
  const n4 = p(V(t3), r3), o2 = N(t3);
  return n4 <= o2 * o2;
}
function et(t3, r3, n4 = n3()) {
  const o2 = x(V(t3), V(r3)), s3 = t3[3], i2 = r3[3];
  return o2 + i2 < s3 ? (a(n4, t3), n4) : o2 + s3 < i2 ? (a(n4, r3), n4) : (A(n4, V(t3), V(r3), (o2 + i2 - s3) / (2 * o2)), n4[3] = (o2 + s3 + i2) / 2, n4);
}
var it = n2();
var at = _2();
var ct = Object.freeze(Object.defineProperty({ __proto__: null, NullSphere: C, altitudeAt: nt, angleToSilhouette: $, axisAt: rt, clear: E, closestPoint: K2, closestPointOnSilhouette: J, containsPoint: st, copy: T, create: _2, distanceToSilhouette: W, elevate: B, equals: O2, exactEquals: w2, fromCenterAndRadius: k2, fromRadius: L3, fromValues: Z, getCenter: V, getRadius: N, intersectLine: Y, intersectRay: X, intersectRayClosestSilhouette: I, intersectsRay: H, projectPoint: Q, setAltitudeAt: ot, setExtent: U, tmpSphere: at, union: et, wrap: z2 }, Symbol.toStringTag, { value: "Module" }));

export {
  s2 as s,
  m2 as m,
  l,
  _2 as _,
  T,
  N,
  V,
  H,
  st
};
//# sourceMappingURL=chunk-2PUGZZAH.js.map
