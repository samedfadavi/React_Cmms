import {
  M,
  c,
  f as f2,
  h as h2,
  i,
  s as s2,
  u as u3
} from "./chunk-QKCF7BZB.js";
import {
  n as n2,
  r as r2
} from "./chunk-TNRF7MOE.js";
import {
  B,
  S,
  e,
  j,
  l,
  o,
  q,
  r,
  u as u2,
  v as v2,
  x,
  y
} from "./chunk-CYGO6TZX.js";
import {
  P,
  v
} from "./chunk-P3MZKJDB.js";
import {
  m
} from "./chunk-EGMIKFPM.js";
import {
  J,
  K,
  W as W2,
  _ as _2
} from "./chunk-RTULPMO3.js";
import {
  V
} from "./chunk-3DBICPHD.js";
import {
  h
} from "./chunk-6N5YXCNN.js";
import {
  u
} from "./chunk-6YSPJNLC.js";
import {
  _,
  n,
  w
} from "./chunk-66KCMKB5.js";
import {
  f
} from "./chunk-F4OBDVPS.js";
import {
  G,
  N,
  W2 as W,
  s3 as s
} from "./chunk-X3IFQMC4.js";

// ../node_modules/@arcgis/core/core/libs/gl-matrix-2/factories/mat2df64.js
function e2() {
  return [1, 0, 0, 1, 0, 0];
}
function r3(e3) {
  return [e3[0], e3[1], e3[2], e3[3], e3[4], e3[5]];
}
function t(e3, r4, t2, n4, o3, u5) {
  return [e3, r4, t2, n4, o3, u5];
}
function n3(e3, r4) {
  return new Float64Array(e3, r4, 6);
}
var o2 = e2();
var u4 = Object.freeze(Object.defineProperty({ __proto__: null, IDENTITY: o2, clone: r3, create: e2, createView: n3, fromValues: t }, Symbol.toStringTag, { value: "Module" }));

// ../node_modules/@arcgis/core/views/2d/viewpointUtils.js
var O = 96;
var Q = 39.37;
var T = 180 / Math.PI;
function B2(t2) {
  return t2.wkid ? t2 : t2.spatialReference || f.WGS84;
}
function D(t2, e3) {
  return e3.type ? o(t2, e3.x, e3.y) : r(t2, e3);
}
function W3(t2) {
  return W(t2);
}
function H(t2, e3, n4 = 0) {
  let o3 = t2.width, a = t2.height;
  if (0 !== n4) {
    const e4 = h(n4), i3 = Math.abs(Math.cos(e4)), c3 = Math.abs(Math.sin(e4));
    o3 = t2.width * i3 + t2.height * c3, a = t2.width * c3 + t2.height * i3;
  }
  const i2 = Math.max(1, e3[0]), c2 = Math.max(1, e3[1]);
  return Math.max(o3 / i2, a / c2) * ct(t2.spatialReference);
}
async function J2(t2, r4, n4, o3) {
  var _a, _b;
  let a, i2;
  if (!t2) return null;
  if (Array.isArray(t2) && !t2.length) return null;
  if (V.isCollection(t2) && (t2 = t2.toArray()), Array.isArray(t2) && t2.length && "object" == typeof t2[0]) {
    const e3 = t2.every((t3) => "attributes" in t3), a2 = t2.some((t3) => !t3.geometry);
    let i3 = t2;
    if (e3 && a2 && r4 && r4.allLayerViews) {
      const e4 = /* @__PURE__ */ new Map();
      for (const r5 of t2) {
        const t3 = r5.layer, n6 = e4.get(t3) || [], o5 = r5.attributes[t3.objectIdField];
        null != o5 && n6.push(o5), e4.set(t3, n6);
      }
      const n5 = [];
      e4.forEach((t3, e5) => {
        const o5 = r4.allLayerViews.find((t4) => t4.layer.id === e5.id);
        if (o5 && "queryFeatures" in o5) {
          const r5 = e5.createQuery();
          r5.objectIds = t3, r5.returnGeometry = true, n5.push(o5.queryFeatures(r5));
        }
      });
      const o4 = await Promise.all(n5), a3 = [];
      for (const t3 of o4) if (t3 && t3.features && t3.features.length) for (const e5 of t3.features) null != e5.geometry && a3.push(e5.geometry);
      i3 = a3;
    }
    for (const t3 of i3) o3 = await J2(t3, r4, n4, o3);
    return o3;
  }
  if (Array.isArray(t2) && 2 === t2.length && "number" == typeof t2[0] && "number" == typeof t2[1]) a = new _(t2);
  else if (t2 instanceof n) a = t2;
  else if ("geometry" in t2) {
    if (t2.geometry) a = t2.geometry;
    else if (t2.layer) {
      const e3 = t2.layer, n5 = r4.allLayerViews.find((t3) => t3.layer.id === e3.id);
      if (n5 && "queryFeatures" in n5) {
        const r5 = e3.createQuery();
        r5.objectIds = [t2.attributes[e3.objectIdField]], r5.returnGeometry = true;
        const o4 = await n5.queryFeatures(r5);
        a = (_b = (_a = o4 == null ? void 0 : o4.features) == null ? void 0 : _a[0]) == null ? void 0 : _b.geometry;
      }
    }
  }
  if (null == a) return null;
  switch (a.type) {
    case "point":
      i2 = new w({ xmin: a.x, ymin: a.y, xmax: a.x, ymax: a.y, spatialReference: a.spatialReference });
      break;
    case "extent":
    case "multipoint":
    case "polygon":
    case "polyline":
      i2 = v(a);
      break;
    default:
      i2 = a.extent;
  }
  if (!i2) return null;
  _2() || J(i2.spatialReference, n4) || await W2();
  const c2 = K(i2, n4);
  if (!c2) return null;
  if (o3) {
    const t3 = c2.center, e3 = t3.clone();
    e3.x = P(t3.x, o3.center.x, n4), e3.x !== t3.x && c2.centerAt(e3), o3 = o3.union(c2);
  } else o3 = c2;
  return o3;
}
function K2(t2) {
  var _a;
  if (t2 && (!Array.isArray(t2) || "number" != typeof t2[0]) && ("object" == typeof t2 || Array.isArray(t2) && "object" == typeof t2[0])) {
    if ("layer" in t2 && null != ((_a = t2.layer) == null ? void 0 : _a.minScale) && null != t2.layer.maxScale) {
      const e3 = t2.layer;
      return { min: e3.minScale, max: e3.maxScale };
    }
    if (Array.isArray(t2) && t2.length && t2.every((t3) => "layer" in t3)) {
      let e3 = 0, r4 = 0;
      for (const n4 of t2) {
        const t3 = n4.layer;
        (t3 == null ? void 0 : t3.minScale) && t3.maxScale && (e3 = t3.minScale < e3 ? t3.minScale : e3, r4 = t3.maxScale > r4 ? t3.maxScale : r4);
      }
      return e3 && r4 ? { min: e3, max: r4 } : null;
    }
  }
}
function X(t2, e3) {
  return G(B2(t2), e3) ? t2 : K(t2, e3);
}
async function Y(e3, r4) {
  var _a;
  if (!e3 || !r4) return new m({ targetGeometry: new _(), scale: 0, rotation: 0 });
  let n4 = r4.spatialReference;
  const { constraints: o3, padding: a, viewpoint: i2, size: c2 } = r4, s3 = [a ? c2[0] - a.left - a.right : c2[0], a ? c2[1] - a.top - a.bottom : c2[1]];
  let u5 = null;
  e3 instanceof m ? u5 = e3 : e3.viewpoint ? u5 = e3.viewpoint : e3.target && "esri.Viewpoint" === e3.target.declaredClass && (u5 = e3.target);
  let l2 = null;
  (u5 == null ? void 0 : u5.targetGeometry) ? l2 = u5.targetGeometry : e3 instanceof w ? l2 = e3 : e3 instanceof n ? l2 = await J2(e3, r4, n4) : e3 && (l2 = await J2(e3.center, r4, n4) || await J2(e3.target, r4, n4) || await J2(e3, r4, n4)), !l2 && (i2 == null ? void 0 : i2.targetGeometry) ? l2 = i2.targetGeometry : !l2 && r4.extent && (l2 = r4.extent), n4 || (n4 = B2(r4.spatialReference || r4.extent || l2)), _2() || G(l2.spatialReference, n4) || J(l2.spatialReference, n4) || await W2();
  const f3 = X(l2, n4), m2 = "center" in f3 ? f3.center : f3;
  false !== r4.pickClosestTarget && "point" === m2.type && "point" === ((_a = i2.targetGeometry) == null ? void 0 : _a.type) && (m2.x = P(m2.x, i2.targetGeometry.x, m2.spatialReference));
  let y2 = 0;
  u5 ? y2 = u5.rotation : e3.hasOwnProperty("rotation") ? y2 = e3.rotation : i2 && (y2 = i2.rotation);
  let p = 0;
  p = null != (u5 == null ? void 0 : u5.targetGeometry) && "point" === u5.targetGeometry.type ? u5.scale : "scale" in e3 && e3.scale ? e3.scale : "zoom" in e3 && -1 !== e3.zoom && o3 && o3.effectiveLODs ? o3.zoomToScale(e3.zoom) : Array.isArray(l2) || "point" === l2.type || "extent" === l2.type && 0 === l2.width && 0 === l2.height ? i2.scale : H(X(l2.extent, n4), s3, y2);
  const g = K2(e3.target ?? e3);
  g && (g.min && g.min < p ? p = g.min : g.max && g.max > p && (p = g.max));
  let x2 = new m({ targetGeometry: m2, scale: p, rotation: y2 });
  return o3 && (x2 = o3.fit(x2), o3.constrainByGeometry(x2), o3.rotationEnabled || (x2.rotation = i2.rotation)), x2;
}
function Z(t2, e3) {
  const r4 = t2.targetGeometry, n4 = e3.targetGeometry;
  return r4.x = n4.x, r4.y = n4.y, r4.spatialReference = n4.spatialReference, t2.scale = e3.scale, t2.rotation = e3.rotation, t2;
}
function $(t2, e3, r4) {
  return r4 ? o(t2, 0.5 * (e3[0] - r4.right + r4.left), 0.5 * (e3[1] - r4.bottom + r4.top)) : l(t2, e3, 0.5);
}
var _3 = function() {
  const t2 = n2();
  return function(e3, r4, n4) {
    const o3 = r4.targetGeometry;
    D(t2, o3);
    const a = 0.5 * ot(r4);
    return e3.xmin = t2[0] - a * n4[0], e3.ymin = t2[1] - a * n4[1], e3.xmax = t2[0] + a * n4[0], e3.ymax = t2[1] + a * n4[1], e3.spatialReference = o3.spatialReference, e3;
  };
}();
function tt(t2, e3, r4, n4, o3) {
  var _a;
  return xt(t2, e3, r4.center), t2.scale = H(r4, n4), (_a = o3 == null ? void 0 : o3.constraints) == null ? void 0 : _a.constrain(t2), t2;
}
function et(t2, e3, r4, n4) {
  return lt(t2, e3, r4, n4), u3(t2, t2);
}
var rt = function() {
  const t2 = n2();
  return function(e3, r4, n4) {
    return B(e3, st(e3, r4), $(t2, r4, n4));
  };
}();
var nt = function() {
  const t2 = e2(), e3 = n2();
  return function(r4, n4, o3, s3) {
    const u5 = ot(n4), l2 = it(n4);
    return o(e3, u5, u5), h2(t2, e3), s2(t2, t2, l2), i(t2, t2, rt(e3, o3, s3)), i(t2, t2, [0, s3.top - s3.bottom]), o(r4, t2[4], t2[5]);
  };
}();
function ot(t2) {
  var _a;
  return t2.scale * at((_a = t2.targetGeometry) == null ? void 0 : _a.spatialReference);
}
function at(t2) {
  return null != t2 && N(t2) ? 1 / (W3(t2) * Q * O) : 1;
}
function it(t2) {
  return u(t2.rotation) || 0;
}
function ct(t2) {
  return N(t2) ? W3(t2) * Q * O : 1;
}
function st(t2, e3) {
  return l(t2, e3, 0.5);
}
var ut = function() {
  const t2 = n2(), e3 = n2(), r4 = n2();
  return function(n4, o3, a, l2, f3, m2) {
    return x(t2, o3), l(e3, a, 0.5 * m2), o(r4, 1 / l2 * m2, -1 / l2 * m2), f2(n4, e3), f3 && s2(n4, n4, f3), c(n4, n4, r4), i(n4, n4, t2), n4;
  };
}();
var lt = function() {
  const t2 = n2();
  return function(e3, r4, n4, o3) {
    const a = ot(r4), i2 = it(r4);
    return D(t2, r4.targetGeometry), ut(e3, t2, n4, a, i2, o3);
  };
}();
var ft = function() {
  const t2 = n2();
  return function(e3, r4, n4, o3) {
    const a = ot(r4);
    return D(t2, r4.targetGeometry), ut(e3, t2, n4, a, 0, o3);
  };
}();
function mt(t2) {
  const e3 = s(t2);
  return e3 ? e3.valid[1] - e3.valid[0] : 0;
}
function yt(t2, e3) {
  return Math.round(mt(t2) / e3);
}
var pt = function() {
  const t2 = n2(), e3 = n2(), r4 = [0, 0, 0];
  return function(n4, o3, a) {
    e(t2, n4, o3), v2(t2, t2), e(e3, n4, a), v2(e3, e3), y(r4, t2, e3);
    let i2 = Math.acos(j(t2, e3) / (q(t2) * q(e3))) * T;
    return r4[2] < 0 && (i2 = -i2), isNaN(i2) && (i2 = 0), i2;
  };
}();
var gt = function() {
  const t2 = n2();
  return function(e3, r4, n4, o3) {
    const a = e3.targetGeometry;
    return Z(e3, r4), nt(t2, r4, n4, o3), a.x += t2[0], a.y += t2[1], e3;
  };
}();
var xt = function(t2, e3, r4) {
  Z(t2, e3);
  const n4 = t2.targetGeometry;
  return n4.x = r4.x, n4.y = r4.y, n4.spatialReference = r4.spatialReference, t2;
};
var ht = function() {
  const t2 = n2();
  return function(e3, r4, n4, o3, a) {
    a || (a = "center"), B(t2, n4, o3), l(t2, t2, 0.5);
    const i2 = t2[0], c2 = t2[1];
    switch (a) {
      case "center":
        o(t2, 0, 0);
        break;
      case "left":
        o(t2, -i2, 0);
        break;
      case "top":
        o(t2, 0, c2);
        break;
      case "right":
        o(t2, i2, 0);
        break;
      case "bottom":
        o(t2, 0, -c2);
        break;
      case "top-left":
        o(t2, -i2, c2);
        break;
      case "bottom-left":
        o(t2, -i2, -c2);
        break;
      case "top-right":
        o(t2, i2, c2);
        break;
      case "bottom-right":
        o(t2, i2, -c2);
    }
    return kt(e3, r4, t2), e3;
  };
}();
function bt(t2, e3, r4) {
  return Z(t2, e3), t2.rotation += r4, t2;
}
function wt(t2, e3, r4) {
  return Z(t2, e3), t2.rotation = r4, t2;
}
var dt = function() {
  const t2 = n2();
  return function(e3, r4, n4, o3, a) {
    return Z(e3, r4), isNaN(n4) || 0 === n4 || (At(t2, o3, r4, a), e3.scale = r4.scale * n4, St(t2, t2, e3, a), kt(e3, e3, o(t2, t2[0] - o3[0], o3[1] - t2[1]))), e3;
  };
}();
function jt(t2, e3, r4) {
  return Z(t2, e3), t2.scale = r4, t2;
}
var Gt = function() {
  const t2 = n2();
  return function(e3, r4, n4, o3, a, i2) {
    return Z(e3, r4), isNaN(n4) || 0 === n4 || (At(t2, a, r4, i2), e3.scale = r4.scale * n4, e3.rotation += o3, St(t2, t2, e3, i2), kt(e3, e3, o(t2, t2[0] - a[0], a[1] - t2[1]))), e3;
  };
}();
var Rt = function() {
  const t2 = n2(), e3 = n2();
  return function(r4, n4, o3, a, i2, c2, s3) {
    return rt(e3, c2, s3), u2(t2, i2, e3), a ? Gt(r4, n4, o3, a, t2, c2) : dt(r4, n4, o3, t2, c2);
  };
}();
var At = function() {
  const t2 = e2();
  return function(e3, r4, n4, o3) {
    return S(e3, r4, et(t2, n4, o3, 1));
  };
}();
var St = function() {
  const t2 = e2();
  return function(e3, r4, n4, o3) {
    return S(e3, r4, lt(t2, n4, o3, 1));
  };
}();
var kt = function() {
  const t2 = n2(), e3 = e2();
  return function(r4, n4, o3) {
    Z(r4, n4);
    const a = ot(n4), i2 = r4.targetGeometry;
    return M(e3, it(n4)), c(e3, e3, r2(a, a)), S(t2, o3, e3), i2.x += t2[0], i2.y += t2[1], r4;
  };
}();

export {
  e2 as e,
  H,
  Y,
  Z,
  $,
  _3 as _,
  tt,
  rt,
  ot,
  at,
  ut,
  lt,
  ft,
  mt,
  yt,
  pt,
  gt,
  xt,
  ht,
  bt,
  wt,
  jt,
  Gt,
  Rt,
  kt
};
//# sourceMappingURL=chunk-UF7MKJFM.js.map
