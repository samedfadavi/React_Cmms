import {
  h
} from "./chunk-VRHSV3YE.js";
import {
  h as h2
} from "./chunk-BTSZKQPH.js";
import {
  _,
  n,
  w
} from "./chunk-66KCMKB5.js";
import {
  f,
  r
} from "./chunk-F4OBDVPS.js";
import {
  y
} from "./chunk-TJUEGVVG.js";
import {
  a3 as a2
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  a
} from "./chunk-YNL57W4I.js";

// ../node_modules/@arcgis/core/geometry/Multipoint.js
var h3;
function l(t) {
  return (s, e2) => null == s ? e2 : null == e2 ? s : t(s, e2);
}
function c(t) {
  return t && ("esri.geometry.SpatialReference" === t.declaredClass || null != t.wkid);
}
var m = h3 = class extends n {
  constructor(...t) {
    super(...t), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t, s) {
    var _a;
    if (!t && !s) return {};
    const e2 = {};
    Array.isArray(t) ? (e2.points = t, e2.spatialReference = s) : c(t) ? e2.spatialReference = t : (t.points && (e2.points = t.points), t.spatialReference && (e2.spatialReference = t.spatialReference), t.hasZ && (e2.hasZ = t.hasZ), t.hasM && (e2.hasM = t.hasM));
    const i = (_a = e2.points) == null ? void 0 : _a[0];
    return i && (void 0 === e2.hasZ && void 0 === e2.hasM ? (e2.hasZ = i.length > 2, e2.hasM = false) : void 0 === e2.hasZ ? e2.hasZ = i.length > 3 : void 0 === e2.hasM && (e2.hasM = i.length > 3)), e2;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t = this.points;
    if (!t.length) return null;
    const s = new w(), e2 = this.hasZ, i = this.hasM, r2 = e2 ? 3 : 2, n2 = t[0], a3 = l(Math.min), p = l(Math.max);
    let h4, c3, m3, u3, [f3, y2] = n2, [d, g] = n2;
    for (let o = 0, l2 = t.length; o < l2; o++) {
      const s2 = t[o], [n3, l3] = s2;
      if (f3 = a3(f3, n3), y2 = a3(y2, l3), d = p(d, n3), g = p(g, l3), e2 && s2.length > 2) {
        const t2 = s2[2];
        h4 = a3(h4, t2), m3 = p(m3, t2);
      }
      if (i && s2.length > r2) {
        const t2 = s2[r2];
        c3 = a3(c3, t2), u3 = p(u3, t2);
      }
    }
    return s.xmin = f3, s.ymin = y2, s.xmax = d, s.ymax = g, s.spatialReference = this.spatialReference, e2 ? (s.zmin = h4, s.zmax = m3) : (s.zmin = void 0, s.zmax = void 0), i ? (s.mmin = c3, s.mmax = u3) : (s.mmin = void 0, s.mmax = void 0), s;
  }
  writePoints(t, e2) {
    e2.points = a(this.points);
  }
  addPoint(t) {
    return h(this, t), Array.isArray(t) ? this.points.push(t) : this.points.push(t.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t = { points: a(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t.hasZ = true), this.hasM && (t.hasM = true), new h3(t);
  }
  getPoint(t) {
    if (!this._validateInputs(t)) return null;
    const s = this.points[t], e2 = { x: s[0], y: s[1], spatialReference: this.spatialReference };
    let i = 2;
    return this.hasZ && (e2.z = s[2], i = 3), this.hasM && (e2.m = s[i]), new _(e2);
  }
  removePoint(t) {
    if (!this._validateInputs(t)) return null;
    const s = new _(this.points.splice(t, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s;
  }
  setPoint(t, s) {
    return this._validateInputs(t) ? (h(this, s), Array.isArray(s) || (s = s.toArray()), this.points[t] = s, this.notifyChange("points"), this) : this;
  }
  toJSON(t) {
    return this.write({}, t);
  }
  _validateInputs(t) {
    return null != t && t >= 0 && t < this.points.length;
  }
};
e([y({ readOnly: true })], m.prototype, "cache", null), e([y()], m.prototype, "extent", null), e([y({ type: [[Number]], json: { write: { isRequired: true } } })], m.prototype, "points", void 0), e([r("points")], m.prototype, "writePoints", null), m = h3 = e([a2("esri.geometry.Multipoint")], m), m.prototype.toJSON.isDefaultToJSON = true;
var u = m;

// ../node_modules/@arcgis/core/geometry/Polyline.js
var c2;
function u2(t) {
  return !Array.isArray(t[0]);
}
var f2 = c2 = class extends n {
  constructor(...t) {
    super(...t), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(t, e2) {
    var _a, _b;
    let s, r2, i = null, a3 = null;
    return t && !Array.isArray(t) ? (i = t.paths ?? null, e2 || (t.spatialReference ? e2 = t.spatialReference : t.paths || (e2 = t)), s = t.hasZ, r2 = t.hasM) : i = t, i = i || [], e2 = e2 || f.WGS84, i.length && null != ((_a = i[0]) == null ? void 0 : _a[0]) && "number" == typeof i[0][0] && (i = [i]), a3 = (_b = i[0]) == null ? void 0 : _b[0], a3 && (void 0 === s && void 0 === r2 ? (s = a3.length > 2, r2 = false) : void 0 === s ? s = !r2 && a3.length > 3 : void 0 === r2 && (r2 = !s && a3.length > 3)), { paths: i, spatialReference: e2, hasZ: s, hasM: r2 };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: t } = this, e2 = h2(this);
    if (!e2) return null;
    const s = new w(e2);
    return s.spatialReference = t, s;
  }
  writePaths(t, s) {
    s.paths = a(this.paths);
  }
  addPath(t) {
    if (!t) return;
    const e2 = this.paths, s = e2.length;
    if (u2(t)) {
      const r2 = [];
      for (let e3 = 0, s2 = t.length; e3 < s2; e3++) r2[e3] = t[e3].toArray();
      e2[s] = r2;
    } else e2[s] = t.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t = new c2();
    return t.spatialReference = this.spatialReference, t.paths = a(this.paths), t.hasZ = this.hasZ, t.hasM = this.hasM, t;
  }
  getPoint(t, e2) {
    if (!this._validateInputs(t, e2)) return null;
    const s = this.paths[t][e2], r2 = this.hasZ, i = this.hasM;
    return r2 && !i ? new _(s[0], s[1], s[2], void 0, this.spatialReference) : i && !r2 ? new _(s[0], s[1], void 0, s[2], this.spatialReference) : r2 && i ? new _(s[0], s[1], s[2], s[3], this.spatialReference) : new _(s[0], s[1], this.spatialReference);
  }
  insertPoint(t, e2, s) {
    return this._validateInputs(t, e2, true) ? (h(this, s), Array.isArray(s) || (s = s.toArray()), this.paths[t].splice(e2, 0, s), this.notifyChange("paths"), this) : this;
  }
  removePath(t) {
    if (!this._validateInputs(t, null)) return null;
    const e2 = this.paths.splice(t, 1)[0], s = this.spatialReference, r2 = e2.map((t2) => new _(t2, s));
    return this.notifyChange("paths"), r2;
  }
  removePoint(t, e2) {
    if (!this._validateInputs(t, e2)) return null;
    const s = new _(this.paths[t].splice(e2, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), s;
  }
  setPoint(t, e2, s) {
    return this._validateInputs(t, e2) ? (h(this, s), Array.isArray(s) || (s = s.toArray()), this.paths[t][e2] = s, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t, e2, s = false) {
    if (null == t || t < 0 || t >= this.paths.length) return false;
    if (null != e2) {
      const r2 = this.paths[t];
      if (s && (e2 < 0 || e2 > r2.length)) return false;
      if (!s && (e2 < 0 || e2 >= r2.length)) return false;
    }
    return true;
  }
  toJSON(t) {
    return this.write({}, t);
  }
};
e([y({ readOnly: true })], f2.prototype, "cache", null), e([y({ readOnly: true })], f2.prototype, "extent", null), e([y({ type: [[[Number]]], json: { write: { isRequired: true } } })], f2.prototype, "paths", void 0), e([r("paths")], f2.prototype, "writePaths", null), f2 = c2 = e([a2("esri.geometry.Polyline")], f2), f2.prototype.toJSON.isDefaultToJSON = true;
var m2 = f2;

export {
  u,
  m2 as m
};
//# sourceMappingURL=chunk-RS5OZZZ5.js.map
