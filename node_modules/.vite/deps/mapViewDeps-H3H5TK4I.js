import {
  e as e11,
  i as i8
} from "./chunk-RC7SOLZI.js";
import {
  o as o10,
  y as y3
} from "./chunk-HOELAGXK.js";
import {
  f as f5
} from "./chunk-I7LOV2EA.js";
import {
  t as t10
} from "./chunk-YYPTXYRZ.js";
import {
  n as n4
} from "./chunk-MQ3HPI3E.js";
import {
  a as a4,
  a2 as a5,
  e as e10,
  n as n6,
  r as r5,
  r2 as r6,
  t as t9,
  t2 as t11,
  y as y4
} from "./chunk-7UHIQF2L.js";
import "./chunk-FVHY5NHZ.js";
import "./chunk-C7HZGCQT.js";
import {
  V
} from "./chunk-5LHDMDXL.js";
import {
  a as a3,
  c as c4,
  l as l5,
  m as m3
} from "./chunk-DWRS6H6A.js";
import "./chunk-IDGJX6LV.js";
import {
  T as T4,
  w as w3
} from "./chunk-RYYZIVJQ.js";
import "./chunk-IX2O3H2Q.js";
import {
  e as e9,
  h as h6,
  h2 as h7,
  i as i7,
  m as m4,
  n as n5,
  t2 as t8
} from "./chunk-ZGAEGZY4.js";
import {
  A as A3,
  E as E4,
  h3 as h5,
  i as i6,
  o as o9,
  s as s7,
  t as t7
} from "./chunk-55VZQ2O4.js";
import {
  e as e7,
  e2 as e8,
  o as o8
} from "./chunk-JYOYXNA4.js";
import {
  i as i5
} from "./chunk-34GIATYY.js";
import "./chunk-45NMBCKP.js";
import {
  t as t5
} from "./chunk-4WNCED5D.js";
import "./chunk-XJMUILUK.js";
import "./chunk-LVLFR7HJ.js";
import "./chunk-LMPNMUNH.js";
import "./chunk-N2OXWE6J.js";
import "./chunk-J4UNWSS7.js";
import {
  o as o7
} from "./chunk-4RKJDHFK.js";
import "./chunk-V4RHVJ2H.js";
import "./chunk-HDF4ZNLN.js";
import {
  L as L5
} from "./chunk-X7AJQ4XD.js";
import "./chunk-OXVX5F4E.js";
import {
  W as W2
} from "./chunk-V5SM2NNT.js";
import "./chunk-EEUTQFOP.js";
import {
  l as l4
} from "./chunk-T5HV76JZ.js";
import "./chunk-YCDX7TWD.js";
import "./chunk-HGR37N5M.js";
import "./chunk-LX3HI5TT.js";
import "./chunk-SLK2EUZ5.js";
import {
  M as M2,
  j,
  y as y2
} from "./chunk-QBIZASGH.js";
import "./chunk-TLURKUXV.js";
import {
  E as E3,
  c,
  i as i2,
  s as s4
} from "./chunk-235Z7ZG7.js";
import {
  ee,
  i as i3,
  t as t3
} from "./chunk-CWKNMWWX.js";
import "./chunk-JSBYWL75.js";
import {
  f as f4,
  u as u6
} from "./chunk-W366AY2Q.js";
import {
  c2,
  e2 as e4
} from "./chunk-4ZTHXCOS.js";
import "./chunk-CL2YKTVD.js";
import "./chunk-FNGV6RWU.js";
import "./chunk-2UJLW7H2.js";
import {
  t as t4
} from "./chunk-CRF5P7HT.js";
import "./chunk-Y55T56UT.js";
import {
  H,
  I as I3,
  L as L4,
  S,
  T as T3,
  Ut,
  W,
  X,
  b as b3,
  et,
  nt,
  st,
  tt,
  ut,
  wt,
  x as x2
} from "./chunk-TCGVPS3X.js";
import {
  i
} from "./chunk-A2WMIQD6.js";
import "./chunk-GRVB2MLZ.js";
import "./chunk-G44Z4LKI.js";
import "./chunk-UNI34X2Q.js";
import {
  t as t2
} from "./chunk-LXZ5X57H.js";
import {
  B,
  C,
  D,
  E as E2,
  F,
  G,
  I as I2,
  L as L3,
  N as N2,
  O as O2,
  P as P3,
  R as R2,
  T as T2,
  U as U2
} from "./chunk-POOHJZAR.js";
import {
  n as n3
} from "./chunk-MTDWQK7X.js";
import "./chunk-5T4GYCDT.js";
import "./chunk-F54TE5DA.js";
import "./chunk-ZPZCSP4J.js";
import "./chunk-5YPRHJQA.js";
import "./chunk-ZVC7ZICV.js";
import "./chunk-VBYAAZGS.js";
import "./chunk-OBN3TJ5S.js";
import {
  e as e12,
  w as w4
} from "./chunk-AAFC7EUR.js";
import "./chunk-SHY2ZONT.js";
import {
  e as e5
} from "./chunk-UF7MKJFM.js";
import "./chunk-4C2THXV6.js";
import {
  e as e6
} from "./chunk-XMJZJ562.js";
import "./chunk-OELB7RPX.js";
import {
  t as t6
} from "./chunk-AKR4324J.js";
import {
  s as s6
} from "./chunk-YH5YACEX.js";
import "./chunk-K7XS7LRW.js";
import "./chunk-GQ3ZCFNN.js";
import {
  a as a2,
  c as c3,
  i as i4,
  s as s5
} from "./chunk-QKCF7BZB.js";
import "./chunk-2U77OHLU.js";
import "./chunk-O45ZPWWN.js";
import {
  _
} from "./chunk-VXVUW2QY.js";
import "./chunk-H6PZORTK.js";
import {
  r as r4
} from "./chunk-TNRF7MOE.js";
import {
  M,
  f as f3,
  h as h3,
  l as l3
} from "./chunk-PNPG5IXD.js";
import "./chunk-CYGO6TZX.js";
import {
  h as h4
} from "./chunk-6V4RA3W6.js";
import {
  r as r3
} from "./chunk-YJXOPMOL.js";
import "./chunk-P3MZKJDB.js";
import "./chunk-JWA73VK6.js";
import "./chunk-UFNQVX5G.js";
import {
  y
} from "./chunk-GMJ4G37M.js";
import {
  o as o5
} from "./chunk-LGQJAMGK.js";
import "./chunk-PVAXLXWO.js";
import {
  A as A2,
  E,
  I,
  L as L2,
  N,
  O,
  P as P2,
  R,
  T,
  b as b2,
  f as f2,
  h as h2,
  o as o6,
  p,
  q,
  t,
  u as u5,
  v,
  w as w2,
  x
} from "./chunk-D6KE2FST.js";
import "./chunk-W3XB5XWO.js";
import "./chunk-LXDJBJSP.js";
import "./chunk-QUNQAVSE.js";
import "./chunk-VEOZVJAT.js";
import "./chunk-3D32E2TW.js";
import "./chunk-G5U2OA3R.js";
import "./chunk-JNGB7HKP.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import "./chunk-DZNQTDMC.js";
import "./chunk-EGMIKFPM.js";
import "./chunk-44DGTEO5.js";
import "./chunk-URNMKNS6.js";
import "./chunk-3QWMYL5A.js";
import "./chunk-ITGBXG45.js";
import "./chunk-LLJZCFHW.js";
import "./chunk-VIUFBDIY.js";
import "./chunk-TXIL3QUC.js";
import "./chunk-2ASAB4KA.js";
import "./chunk-IGNUVZ34.js";
import "./chunk-YUQFVZCH.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-T4EIRKFE.js";
import "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-JQIB7GFW.js";
import "./chunk-MNMU4ARP.js";
import "./chunk-IJ42YN7D.js";
import "./chunk-4AGGGL2W.js";
import "./chunk-FJPG3YI6.js";
import "./chunk-BJHLU2MM.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-CAC7FEOV.js";
import "./chunk-KK4UI5LV.js";
import {
  e as e3,
  u as u4
} from "./chunk-BL2UGYYZ.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import {
  P,
  d as d2
} from "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import "./chunk-3DBICPHD.js";
import {
  d
} from "./chunk-7R5XEKR3.js";
import {
  o as o3
} from "./chunk-ZK4LSXOH.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import {
  e as e2,
  h
} from "./chunk-6N5YXCNN.js";
import {
  n as n2,
  o as o4
} from "./chunk-MJ2NSPP7.js";
import {
  u as u3
} from "./chunk-6YSPJNLC.js";
import "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import "./chunk-F4OBDVPS.js";
import "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import {
  Pt,
  U
} from "./chunk-WC4SPMPL.js";
import {
  A,
  r
} from "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import "./chunk-GEH2VXFC.js";
import "./chunk-BJY5ADVY.js";
import {
  L,
  b,
  f,
  m as m2,
  o,
  o3 as o2,
  s as s3,
  u as u2,
  w
} from "./chunk-VMWKLHJD.js";
import {
  e,
  l as l2,
  r as r2,
  u
} from "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  a,
  l2 as l,
  n2 as n,
  s,
  s2
} from "./chunk-YNL57W4I.js";
import {
  has,
  m
} from "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var N3 = () => n.getLogger("esri.symbols.cim.cimAnalyzer");
function w5(e15) {
  const r12 = e15.markerPlacement;
  return r12 && r12.angleToLine ? i.MAP : i.SCREEN;
}
var R3 = class {
  constructor(e15) {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [], e15 && (this._resourceManager = e15);
  }
  analyzeSymbolReference(r12, t18, i13) {
    if (this._cimLayers = i13 ?? [], !r12) return this._cimLayers;
    if (this._reset(), r12.primitiveOverrides) {
      this._primitiveOverrides = r12.primitiveOverrides;
      for (const r13 of this._primitiveOverrides) {
        const t19 = r13.valueExpressionInfo;
        if (t19) this._setPoMap(r13.primitiveName, r13.propertyName, t19);
        else if (null != r13.value) {
          let t20 = r13.value;
          r13.propertyName.includes("Color") && (o5(t20) && (t20 = o6(t20)), t20 = f2(t20)), this._setPoMap(r13.primitiveName, r13.propertyName, t20);
        }
      }
    }
    return this._analyzeSymbol(r12.symbol, t18), this._cimLayers;
  }
  _reset() {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [];
  }
  _analyzeSymbol(e15, r12) {
    switch (e15 == null ? void 0 : e15.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this._analyzeMultiLayerSymbol(e15, r12);
    }
  }
  _analyzeMultiLayerSymbol(e15, r12) {
    const t18 = e15 == null ? void 0 : e15.symbolLayers;
    if (!t18) return;
    const i13 = e15.effects;
    let o15 = i.SCREEN;
    const a10 = q(e15) ?? 0;
    "CIMPointSymbol" === e15.type && "Map" === e15.angleAlignment && (o15 = i.MAP);
    const s14 = "CIMPolygonSymbol" === e15.type;
    let l13 = t18.length;
    for (; l13--; ) {
      const n14 = t18[l13];
      if (!n14 || false === n14.enable) continue;
      let c12;
      (i13 == null ? void 0 : i13.length) && (c12 = [...i13]);
      const m7 = n14.effects;
      (m7 == null ? void 0 : m7.length) && (i13 ? c12.push(...m7) : c12 = [...m7]);
      let f9 = null;
      if (c12) {
        f9 = [];
        for (const e16 of c12) {
          const r13 = y.findEffectOverrides(e16, this._primitiveOverrides);
          r13 && f9.push(r13);
        }
      }
      const y5 = [];
      switch (y.findApplicableOverrides(n14, this._primitiveOverrides, y5), n14.type) {
        case "CIMSolidFill":
          this._analyzeSolidFill(n14, f9);
          break;
        case "CIMPictureFill":
          this._analyzePictureFill(n14, f9);
          break;
        case "CIMHatchFill":
          this._analyzeHatchFill(n14, f9);
          break;
        case "CIMGradientFill":
          this._analyzeGradientFill(n14, f9);
          break;
        case "CIMSolidStroke":
          this._analyzeSolidStroke(n14, f9, s14, a10);
          break;
        case "CIMPictureStroke":
          this._analyzePictureStroke(n14, f9, s14, a10);
          break;
        case "CIMGradientStroke":
          this._analyzeGradientStroke(n14, f9, s14, a10);
          break;
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
        case "CIMVectorMarker": {
          "CIMLineSymbol" !== e15.type && "CIMPolygonSymbol" !== e15.type || (o15 = w5(n14));
          const t19 = [], i14 = n14.primitiveName;
          i14 && t19.push(i14);
          const l14 = s14 && b2(n14.markerPlacement);
          this._analyzeMarker(n14, f9, null, t19, o15, a10, r12, [], false, l14);
          break;
        }
        default:
          N3().error("Cannot analyze CIM layer", n14.type);
      }
    }
  }
  _analyzeSolidFill(e15, r12) {
    const { primitiveName: t18, type: i13 } = e15, o15 = f2(e15.color);
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: null, colorLocked: !!e15.colorLocked, color: this._getValueOrOverrideExpression(i13, t18, "Color", o15), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: r12, applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: false });
  }
  _analyzePictureFill(e15, r12) {
    const { primitiveName: t18, type: i13 } = e15, o15 = h2(e15), a10 = I(e15.height, t.CIMPictureFill.height);
    let s14 = I(e15.scaleX, 1);
    if ("width" in e15 && "number" == typeof e15.width) {
      const r13 = e15.width;
      let t19 = 1;
      const i14 = this._resourceManager.getResource(e15.url);
      null != i14 && (t19 = i14.width / i14.height), s14 /= t19 * (a10 / r13);
    }
    const l13 = { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(t18, i13) };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: l13, colorLocked: !!e15.colorLocked, effects: r12, color: this._getValueOrOverrideExpression(i13, t18, "TintColor", o15), height: this._getValueOrOverrideExpression(i13, t18, "Height", a10), scaleX: this._getValueOrOverrideExpression(i13, t18, "ScaleX", s14), angle: this._getValueOrOverrideExpression(i13, t18, "Rotation", I(e15.rotation)), offsetX: this._getValueOrOverrideExpression(i13, t18, "OffsetX", I(e15.offsetX)), offsetY: this._getValueOrOverrideExpression(i13, t18, "OffsetY", I(e15.offsetY)), applyRandomOffset: false, sampleAlphaOnly: false, hasUnresolvedReplacementColor: false });
  }
  _analyzeHatchFill(e15, r12) {
    var _a, _b, _c;
    const { primitiveName: t18, type: i13 } = e15, o15 = this._analyzeMaterialOverrides(t18, ["Rotation", "OffsetX", "OffsetY"]), a10 = R(o15);
    let s14 = [255, 255, 255, 1], l13 = false;
    if ((_a = e15.lineSymbol) == null ? void 0 : _a.symbolLayers) for (const n14 of e15.lineSymbol.symbolLayers) {
      if ("CIMSolidStroke" !== n14.type) continue;
      const e16 = n14.primitiveName ?? t18;
      l13 || !e16 || n14.colorLocked || null == ((_b = this._poMap[e16]) == null ? void 0 : _b.Color) && null == ((_c = this._poMap[e16]) == null ? void 0 : _c.StrokeColor) || (s14 = f2(n14.color), s14 = this._maybeGetValueOrOverrideExpression(e16, "StrokeColor") ?? this._getValueOrOverrideExpression(i13, e16, "Color", s14), l13 = true);
      const r13 = this._maybeGetValueOrOverrideExpression(e16, "StrokeWidth");
      if (r13) {
        let t19 = null, o16 = null;
        "number" == typeof r13 ? t19 = r13 : o16 = r13.valueExpressionInfo;
        let s15 = a10.find((e17) => "strokeWidth" === e17.propertyName);
        s15 ? s15.propertyName = "width" : (s15 = { type: "CIMPrimitiveOverride", primitiveName: e16, propertyName: "width", valueExpressionInfo: o16, value: t19, defaultValue: O(i13, "width") }, a10.push(s15));
      }
    }
    const c12 = { type: "sprite-rasterization-param", resource: e15, overrides: a10 };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: c12, colorLocked: !!e15.colorLocked, effects: r12, color: s14, height: this._getValueOrOverrideExpression(i13, t18, "Separation", I(e15.separation, t.CIMHatchFill.separation)), scaleX: 1, angle: this._getValueOrOverrideExpression(i13, t18, "Rotation", I(e15.rotation)), offsetX: this._getValueOrOverrideExpression(i13, t18, "OffsetX", I(e15.offsetX)), offsetY: this._getValueOrOverrideExpression(i13, t18, "OffsetY", I(e15.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: !l13 });
  }
  _analyzeGradientFill(e15, r12) {
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: null, colorLocked: !!e15.colorLocked, effects: r12, color: [128, 128, 128, 1], height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, applyRandomOffset: false, sampleAlphaOnly: false, hasUnresolvedReplacementColor: false });
  }
  _analyzeSolidStroke(e15, r12, t18, i13) {
    const { primitiveName: o15, type: a10 } = e15, s14 = f2(e15.color), l13 = I(e15.width, t.CIMSolidStroke.width), c12 = p(e15.capStyle, t.CIMSolidStroke.capstyle), p5 = p(e15.joinStyle, t.CIMSolidStroke.joinstyle), m7 = e15.miterLimit;
    let f9, y5, d5 = [];
    if (this._analyzePrimitiveOverrides(o15, r12, null, null) && (d5 = this._getPrimitiveMaterialOverrides(o15, a10)), r12 && Array.isArray(r12) && r12.length > 0) {
      const e16 = r12[r12.length - 1].effect;
      e16 && "CIMGeometricEffectDashes" === e16.type && "NoConstraint" === e16.lineDashEnding && null === e16.offsetAlongLine && (f9 = e16.dashTemplate, y5 = e16.scaleDash, (r12 = [...r12]).pop());
    }
    const u11 = void 0 !== f9 ? { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: f9, capStyle: c12 }, overrides: d5 } : null;
    this._cimLayers.push({ type: "line", spriteRasterizationParam: u11, isOutline: t18, colorLocked: !!e15.colorLocked, effects: r12, color: this._getValueOrOverrideExpression(a10, o15, "Color", s14), width: this._getValueOrOverrideExpression(a10, o15, "Width", l13), cap: this._getValueOrOverrideExpression(a10, o15, "CapStyle", c12), join: this._getValueOrOverrideExpression(a10, o15, "JoinStyle", p5), miterLimit: m7 && this._getValueOrOverrideExpression(a10, o15, "MiterLimit", m7), referenceWidth: i13, zOrder: G2(e15.name), dashTemplate: f9, scaleDash: y5, sampleAlphaOnly: true });
  }
  _analyzePictureStroke(e15, r12, t18, i13) {
    const { primitiveName: o15, type: a10 } = e15, s14 = h2(e15), l13 = I(e15.width, t.CIMPictureStroke.width), c12 = p(e15.capStyle, t.CIMPictureStroke.capstyle), p5 = p(e15.joinStyle, t.CIMPictureStroke.joinstyle), m7 = e15.miterLimit, f9 = { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(o15, a10) };
    this._cimLayers.push({ type: "line", spriteRasterizationParam: f9, isOutline: t18, colorLocked: !!e15.colorLocked, effects: r12, color: this._getValueOrOverrideExpression(a10, o15, "TintColor", s14), width: this._getValueOrOverrideExpression(a10, o15, "Width", l13), cap: this._getValueOrOverrideExpression(a10, o15, "CapStyle", c12), join: this._getValueOrOverrideExpression(a10, o15, "JoinStyle", p5), miterLimit: m7 && this._getValueOrOverrideExpression(a10, o15, "MiterLimit", m7), referenceWidth: i13, zOrder: G2(e15.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
  }
  _analyzeGradientStroke(e15, r12, t18, i13) {
    const { primitiveName: o15, type: a10 } = e15, s14 = I(e15.width, t.CIMSolidStroke.width), l13 = p(e15.capStyle, t.CIMGradientStroke.capstyle), c12 = p(e15.joinStyle, t.CIMGradientStroke.joinstyle), p5 = e15.miterLimit;
    this._cimLayers.push({ type: "line", spriteRasterizationParam: null, isOutline: t18, colorLocked: !!e15.colorLocked, effects: r12, color: [128, 128, 128, 1], width: this._getValueOrOverrideExpression(a10, o15, "Width", s14), cap: this._getValueOrOverrideExpression(a10, o15, "CapStyle", l13), join: this._getValueOrOverrideExpression(a10, o15, "JoinStyle", c12), miterLimit: p5 && this._getValueOrOverrideExpression(a10, o15, "MiterLimit", p5), referenceWidth: i13, zOrder: G2(e15.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
  }
  _analyzeMarker(e15, r12, t18, i13, o15, a10, s14, l13, c12 = false, p5 = false) {
    if (c12 || (c12 = !!e15.colorLocked), this._analyzeMarkerInsidePolygon(e15, r12, c12)) return;
    const m7 = I(e15.size, t.CIMVectorMarker.size), f9 = I(e15.rotation), y5 = I(e15.offsetX), h14 = I(e15.offsetY), { primitiveName: d5, type: u11 } = e15, v4 = this._getValueOrOverrideExpression(u11, d5, "Size", m7), _5 = this._getValueOrOverrideExpression(u11, d5, "Rotation", f9), g4 = this._getValueOrOverrideExpression(u11, d5, "OffsetX", y5), k2 = this._getValueOrOverrideExpression(u11, d5, "OffsetY", h14);
    switch (e15.type) {
      case "CIMPictureMarker":
        this._analyzePictureMarker(e15, r12, t18, i13, o15, a10, v4, _5, g4, k2, l13, c12, p5);
        break;
      case "CIMVectorMarker":
        this._analyzeVectorMarker(e15, r12, t18, i13, o15, a10, v4, _5, g4, k2, l13, s14, c12, p5);
    }
  }
  _analyzeMarkerInsidePolygon(e15, r12, t18) {
    const { markerPlacement: i13, type: o15 } = e15;
    if (!i13 || "CIMMarkerPlacementInsidePolygon" !== i13.type) return false;
    if ("CIMVectorMarker" === o15 || "CIMPictureMarker" === o15) {
      const t19 = e15.primitiveName;
      if (t19 && this._analyzePrimitiveOverrides([t19], r12, null, null)) return false;
      const a10 = i13.primitiveName;
      if (a10 && this._analyzePrimitiveOverrides([a10], r12, null, null)) return false;
      if ("CIMVectorMarker" === o15) {
        const { markerGraphics: r13 } = e15;
        if (r13) for (const e16 of r13) {
          const { symbol: r14 } = e16;
          if ("CIMPolygonSymbol" === (r14 == null ? void 0 : r14.type) && r14.symbolLayers) {
            const { symbolLayers: e17 } = r14;
            for (const r15 of e17) if ("CIMSolidStroke" === r15.type) return false;
          }
        }
      } else {
        const { animatedSymbolProperties: r13 } = e15;
        if (r13) return false;
      }
    }
    const s14 = Math.abs(i13.stepX), l13 = Math.abs(i13.stepY);
    if (0 === s14 || 0 === l13) return true;
    let n14, c12;
    if ("Random" === i13.gridType) {
      const e16 = e3(st), r13 = Math.max(Math.floor(e16 / s14), 1);
      n14 = l13 * Math.max(Math.floor(e16 / l13), 1);
      c12 = r13 * s14 / n14;
    } else i13.shiftOddRows ? (n14 = 2 * l13, c12 = s14 / l13 * 0.5) : (n14 = l13, c12 = s14 / l13);
    const p5 = h2(e15), m7 = "CIMCharacterMarker" === e15.type ? null : { type: "sprite-rasterization-param", resource: e15, overrides: [] };
    return this._cimLayers.push({ type: "fill", spriteRasterizationParam: m7, colorLocked: t18, effects: r12, color: p5, height: n14, scaleX: c12, angle: i13.gridAngle, offsetX: I(i13.offsetX), offsetY: I(i13.offsetY), applyRandomOffset: "Random" === i13.gridType, sampleAlphaOnly: "CIMPictureMarker" !== e15.type, hasUnresolvedReplacementColor: true }), true;
  }
  _analyzePictureMarker(e15, r12, i13, o15, a10, l13, n14, c12, p5, m7, f9, y5, h14) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { animatedSymbolProperties: d5, primitiveName: u11, type: _5 } = e15;
    let g4 = I(e15.scaleX, 1);
    const k2 = h2(e15);
    i13 || (i13 = this._createMarkerPlacementOverrideExpression(e15.markerPlacement));
    const M3 = this._createGIFAnimatedSymbolPropertiesOverrideExpression(d5), S2 = e15.anchorPoint ?? { x: 0, y: 0 };
    if ("width" in e15 && "number" == typeof e15.width) {
      const r13 = e15.width;
      let t18 = 1;
      const i14 = this._resourceManager.getResource(e15.url);
      null != i14 && (t18 = i14.width / i14.height);
      g4 /= t18 * (I(e15.size) / r13);
    }
    const C3 = [...o15];
    let b5;
    e15.primitiveName && C3.push(e15.primitiveName), d5 || M3 ? b5 = { type: "animated", url: e15.url, urlHash: "H" + l(e15.url), playAnimation: (_a = e15.animatedSymbolProperties) == null ? void 0 : _a.playAnimation, reverseAnimation: (_b = e15.animatedSymbolProperties) == null ? void 0 : _b.reverseAnimation, randomizeStartTime: (_c = e15.animatedSymbolProperties) == null ? void 0 : _c.randomizeStartTime, randomizeStartSeed: (_d = e15.animatedSymbolProperties) == null ? void 0 : _d.randomizeStartSeed, startTimeOffset: (_e = e15.animatedSymbolProperties) == null ? void 0 : _e.startTimeOffset, duration: (_f = e15.animatedSymbolProperties) == null ? void 0 : _f.duration, repeatType: (_g = e15.animatedSymbolProperties) == null ? void 0 : _g.repeatType, repeatDelay: (_h = e15.animatedSymbolProperties) == null ? void 0 : _h.repeatDelay } : (b5 = a(e15), b5.markerPlacement = null);
    const P5 = { type: "sprite-rasterization-param", resource: b5, overrides: this._getMaterialOverrides(C3, _5) };
    M3 && P5.overrides.push(...M3.overrides), this._cimLayers.push({ type: "marker", spriteRasterizationParam: P5, colorLocked: y5, effects: r12, scaleSymbolsProportionally: false, alignment: a10, size: n14, scaleX: this._getValueOrOverrideExpression(_5, u11, "ScaleX", g4), rotation: c12, offsetX: p5, offsetY: m7, transform: { type: "cim-marker-transform-param", params: f9 }, color: this._getValueOrOverrideExpression(_5, u11, "TintColor", k2), anchorPoint: { x: S2.x, y: S2.y }, isAbsoluteAnchorPoint: "Relative" !== e15.anchorPointUnits, outlineColor: [0, 0, 0, 0], outlineWidth: 0, frameHeight: 0, widthRatio: 1, rotateClockwise: !!e15.rotateClockwise, referenceSize: l13, sizeRatio: 1, isOutline: h14, markerPlacement: i13 });
  }
  _analyzeVectorMarker(e15, r12, t18, i13, o15, a10, s14, l13, n14, c12, p5, m7, f9, y5) {
    const h14 = e15.markerGraphics;
    if (!h14) return;
    const d5 = e15.frame;
    let u11 = 0;
    if (u11 = d5 ? d5.ymax - d5.ymin : a10, u11) {
      const r13 = { offsetX: n14, offsetY: c12, rotation: l13, size: s14, frameHeight: u11, rotateClockWise: !!e15.rotateClockwise };
      p5 = [...p5, r13];
    }
    t18 || (t18 = this._createMarkerPlacementOverrideExpression(e15.markerPlacement));
    for (const v4 of h14) if (v4) {
      const s15 = v4.symbol;
      if (!s15) continue;
      const l14 = v4.primitiveName;
      let n15;
      if (l14 && i13.push(l14), ("CIMPointSymbol" === s15.type || "CIMTextSymbol" === s15.type) && d5) {
        let r13 = 0, t19 = 0;
        const i14 = v4.geometry;
        "x" in i14 && "y" in i14 && (r13 += i14.x - 0.5 * (d5.xmin + d5.xmax), t19 += i14.y - 0.5 * (d5.ymin + d5.ymax));
        const o16 = e15.anchorPoint;
        o16 && ("Absolute" === e15.anchorPointUnits ? (r13 -= o16.x, t19 -= o16.y) : d5 && (r13 -= (d5.xmax - d5.xmin) * o16.x, t19 -= (d5.ymax - d5.ymin) * o16.y));
        const a11 = { offsetX: r13, offsetY: t19, rotation: 0, size: 0, frameHeight: 0, rotateClockWise: false };
        n15 = [...p5, a11];
      }
      switch (s15.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          m7 || T5(s15) ? this._analyzeMultiLayerGraphicNonSDF(e15, r12, t18, v4, i13, o15, a10, n15 ?? p5, u11, f9, y5) : this._analyzeMultiLayerGraphic(e15, r12, t18, v4, i13, o15, a10, n15 ?? p5, u11, f9, y5);
          break;
        case "CIMTextSymbol":
          this._analyzeTextGraphic(r12, t18, v4, i13, o15, a10, n15 ?? p5, f9);
      }
      l14 && i13.pop();
    }
  }
  _analyzeMultiLayerGraphic(e15, r12, t18, i13, o15, a10, s14, l13, n14, c12, p5) {
    const y5 = i13.symbol, d5 = y5.symbolLayers;
    if (!d5) return;
    let u11 = d5.length;
    if (F2(d5)) return void this._analyzeCompositeMarkerGraphic(e15, r12, t18, i13, d5, a10, s14, l13, n14, c12, p5);
    const v4 = this._resourceManager.geometryEngine, O3 = l4.applyEffects(y5.effects, i13.geometry, v4);
    if (O3) for (; u11--; ) {
      const y6 = d5[u11];
      if (!y6 || false === y6.enable) continue;
      const _5 = y6.primitiveName;
      switch (_5 && o15.push(_5), y6.type) {
        case "CIMSolidFill":
        case "CIMSolidStroke": {
          const o16 = l4.applyEffects(y6.effects, O3, v4), d6 = m3(o16);
          if (!d6) continue;
          const u12 = "Relative" !== e15.anchorPointUnits, [g4, k2, b5, P5] = a3(d6, e15.frame, e15.size, e15.anchorPoint, u12), x3 = "CIMSolidFill" === y6.type, z = { type: "sdf", geom: o16, asFill: x3 }, { path: L6 } = y6, E5 = x3 ? f2(L2(y6)) : null == L6 ? f2(N(y6)) : [0, 0, 0, 0], V2 = x3 ? [0, 0, 0, 0] : f2(N(y6)), N5 = T(y6) ?? 0;
          if (!x3 && !N5) break;
          const w6 = i13.primitiveName;
          let R4 = null;
          x3 && !y6.colorLocked && (R4 = this._maybeGetValueOrOverrideExpression(w6, "FillColor"));
          let A8 = null;
          x3 || y6.colorLocked || (A8 = this._maybeGetValueOrOverrideExpression(w6, "StrokeColor"));
          const G4 = R4 ?? this._getValueOrOverrideExpression(y6.type, _5, "Color", E5), X2 = A8 ?? this._getValueOrOverrideExpression(y6.type, _5, "Color", V2), F4 = this._maybeGetValueOrOverrideExpression(w6, "StrokeWidth") ?? this._getValueOrOverrideExpression(y6.type, _5, "Width", N5), T6 = L6 ? { type: "sprite-rasterization-param", resource: { type: "path", path: L6, asFill: x3 }, overrides: [] } : { type: "sprite-rasterization-param", resource: z, overrides: [] };
          this._cimLayers.push({ type: "marker", spriteRasterizationParam: T6, colorLocked: !!y6.colorLocked || !!c12, effects: r12, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: a10, anchorPoint: { x: k2, y: b5 }, isAbsoluteAnchorPoint: u12, size: n14, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l13 }, frameHeight: n14, widthRatio: P5, rotateClockwise: false, referenceSize: s14, sizeRatio: g4, color: G4, outlineColor: X2, outlineWidth: F4, isOutline: p5, markerPlacement: t18 });
          break;
        }
        case "CIMPictureMarker":
        case "CIMVectorMarker":
          y6.markerPlacement ? this._analyzeMultiLayerGraphicNonSDF(e15, r12, t18, i13, o15, a10, s14, l13, n14, !!y6.colorLocked || !!c12, p5) : this._analyzeMarker(y6, r12, t18, o15, a10, s14, false, l13, c12, p5);
          break;
        default:
          this._analyzeMultiLayerGraphicNonSDF(e15, r12, t18, i13, o15, a10, s14, l13, n14, !!y6.colorLocked || !!c12, p5);
      }
      _5 && o15.pop();
    }
  }
  _analyzeTextGraphic(e15, t18, i13, o15, a10, s14, l13, c12) {
    var _a;
    const m7 = [];
    y.findApplicableOverrides(i13, this._primitiveOverrides, m7);
    const f9 = i13.geometry;
    if (!("x" in f9) || !("y" in f9)) return;
    const y5 = i13.symbol, d5 = w2(y5), u11 = P2(y5.fontStyleName), v4 = u6(y5.fontFamilyName);
    y5.font = { family: v4, decoration: d5, ...u11 };
    const _5 = I(y5.height, t.CIMTextSymbol.height), g4 = I(y5.angle), k2 = I(y5.offsetX), L6 = I(y5.offsetY), E5 = f2(L2(y5));
    let I4 = f2(N(y5)), V2 = T(y5) ?? 0;
    V2 || (I4 = f2(L2(y5.haloSymbol)), V2 = I(y5.haloSize));
    let N5 = false;
    if ((_a = y5.symbol) == null ? void 0 : _a.symbolLayers) for (const r12 of y5.symbol.symbolLayers) {
      null != f2(L2(r12)) && (N5 = !!r12.colorLocked);
    }
    const w6 = i13.primitiveName;
    let R4 = null;
    N5 || (R4 = this._maybeGetValueOrOverrideExpression(w6, "FillColor"));
    const A8 = this._maybeGetValueOrOverrideExpression(w6, "TextSize"), G4 = this._maybeGetValueOrOverrideExpression(w6, "TextAngle"), X2 = this._maybeGetValueOrOverrideExpression(w6, "TextOffsetX"), F4 = this._maybeGetValueOrOverrideExpression(w6, "TextOffsetY");
    let T6 = null, Y2 = null, j3 = 0;
    if (y5.callout && "CIMBackgroundCallout" === y5.callout.type) {
      const e16 = y5.callout;
      if (e16.backgroundSymbol) {
        const r12 = e16.backgroundSymbol.symbolLayers;
        if (r12) for (const e17 of r12) "CIMSolidFill" === e17.type ? T6 = f2(e17.color) : "CIMSolidStroke" === e17.type && (Y2 = f2(e17.color), j3 = I(e17.width, t.CIMSolidStroke.width));
      }
    }
    const W3 = this._getValueOrOverrideExpression(y5.type, i13.primitiveName, "TextString", i13.textString ?? "");
    if (null == W3) return;
    const { fontStyleName: D2 } = y5, H2 = v4 + (D2 ? "-" + D2.toLowerCase() : "-regular"), U3 = this._getMaterialOverrides(o15, y5.type);
    U3.push(...this._getPrimitiveMaterialOverrides(i13.primitiveName, y5.type));
    const J = { type: "text-rasterization-param", resource: { type: "text", textString: i13.textString ?? "", font: y5.font, symbol: y5, primitiveName: i13.primitiveName }, overrides: U3 };
    this._cimLayers.push({ type: "text", lineWidth: y5.lineWidth, textRasterizationParam: J, colorLocked: !!c12 || !!N5, effects: e15, alignment: a10, anchorPoint: { x: 0, y: 0 }, isAbsoluteAnchorPoint: false, fontName: H2, decoration: d5, weight: u11.weight, style: u11.style, size: A8 ?? _5, angle: G4 ?? g4, offsetX: X2 ?? k2, offsetY: F4 ?? L6, transform: { type: "cim-marker-transform-param", params: l13 }, horizontalAlignment: x(y5.horizontalAlignment), verticalAlignment: A2(y5.verticalAlignment), text: W3, color: R4 ?? this._getValueOrOverrideExpression(y5.type, i13.primitiveName, "Color", E5), outlineColor: I4, outlineSize: V2, backgroundColor: T6, borderLineColor: Y2, borderLineWidth: j3, referenceSize: s14, sizeRatio: 1, markerPlacement: t18 });
  }
  _analyzeMultiLayerGraphicNonSDF(e15, r12, t18, i13, a10, s14, n14, c12, p5, m7, f9) {
    const y5 = A4(e15, i13), h14 = e15.primitiveName, d5 = this._analyzeMaterialOverrides(h14, ["Rotation", "OffsetX", "OffsetY"]), u11 = R(d5), [v4, O3, g4] = ee.getTextureAnchor(y5, this._resourceManager), k2 = this._getMaterialOverrides(a10, e15.type);
    k2.push(...u11);
    const M3 = { type: "sprite-rasterization-param", resource: { ...y5, avoidSDFRasterization: true }, overrides: k2 };
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: M3, colorLocked: m7, effects: r12, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: s14, anchorPoint: { x: v4, y: O3 }, isAbsoluteAnchorPoint: false, size: p5, rotation: 0, offsetX: 0, offsetY: 0, transform: { type: "cim-marker-transform-param", params: c12 }, color: [255, 255, 255, 1], outlineColor: [0, 0, 0, 0], outlineWidth: 0, scaleX: 1, frameHeight: p5, widthRatio: 1, rotateClockwise: !!e15.rotateClockwise, referenceSize: n14, sizeRatio: g4 / u4(e15.size), isOutline: f9, markerPlacement: t18 });
  }
  _createMarkerPlacementOverrideExpression(e15) {
    if (!e15) return null;
    const r12 = [];
    return y.findApplicableOverrides(e15, this._primitiveOverrides, r12), { type: "cim-marker-placement-param", placement: e15, overrides: Y(r12) };
  }
  _createGIFAnimatedSymbolPropertiesOverrideExpression(e15) {
    if (!e15) return null;
    const r12 = [];
    return y.findApplicableOverrides(e15, this._primitiveOverrides, r12), { type: "cim-gif-animation-params", animation: e15, overrides: Y(r12) };
  }
  _analyzeCompositeMarkerGraphic(e15, r12, t18, i13, o15, a10, s14, l13, c12, p5, y5) {
    const d5 = i13.geometry, u11 = o15[0], v4 = o15[1], _5 = m3(d5);
    if (!_5) return;
    const g4 = "Relative" !== e15.anchorPointUnits, [k2, M3, S2, C3] = a3(_5, e15.frame, e15.size, e15.anchorPoint, g4), { path: b5 } = v4, P5 = v4.primitiveName, x3 = u11.primitiveName, z = i13.primitiveName;
    let L6 = null;
    v4.colorLocked || p5 || (L6 = this._maybeGetValueOrOverrideExpression(z, "FillColor"));
    const E5 = L6 ?? this._getValueOrOverrideExpression(v4.type, P5, "Color", f2(v4.color));
    let I4 = null;
    u11.colorLocked || p5 || (I4 = this._maybeGetValueOrOverrideExpression(z, "StrokeColor"));
    const V2 = I4 ?? this._getValueOrOverrideExpression(u11.type, x3, "Color", f2(u11.color)), N5 = this._maybeGetValueOrOverrideExpression(z, "StrokeWidth") ?? this._getValueOrOverrideExpression(u11.type, x3, "Width", I(u11.width, t.CIMSolidStroke.width)), w6 = { type: "sprite-rasterization-param", resource: b5 ? { type: "path", path: b5, asFill: true } : { type: "sdf", geom: d5, asFill: true }, overrides: [] };
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: w6, colorLocked: p5, effects: r12, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: a10, anchorPoint: { x: M3, y: S2 }, isAbsoluteAnchorPoint: g4, size: c12, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l13 }, frameHeight: c12, widthRatio: C3, rotateClockwise: false, referenceSize: s14, sizeRatio: k2, color: E5, outlineColor: V2, outlineWidth: N5, isOutline: y5, markerPlacement: t18 });
  }
  _setPoMap(e15, r12, t18) {
    let i13;
    this._poMap[e15] ? i13 = this._poMap[e15] : (i13 = {}, this._poMap[e15] = i13), i13[r12] = t18;
  }
  _maybeGetValueOrOverrideExpression(e15, r12, t18) {
    return this._getValueOrOverrideExpression("", e15, r12, t18, false);
  }
  _getValueOrOverrideExpression(e15, r12, t18, i13, o15 = true) {
    if (o15 && !E(i13) && (i13 = O(e15, t18.toLowerCase())), null == r12) return i13;
    const a10 = this._poMap[r12];
    if (null == a10) return i13;
    const s14 = a10[t18];
    return "string" == typeof s14 || "number" == typeof s14 || Array.isArray(s14) ? s14 : s14 ? { valueExpressionInfo: s14, defaultValue: i13 } : i13;
  }
  _analyzePrimitiveOverrides(e15, r12, t18, i13) {
    if (null == e15) return false;
    "string" == typeof e15 && (e15 = [e15]);
    for (const o15 of this._primitiveOverrides) if (e15.includes(o15.primitiveName) && o15.valueExpressionInfo) return true;
    if (null != r12) {
      for (const o15 of r12) if ((o15 == null ? void 0 : o15.overrides.length) > 0) return true;
    }
    if (null != t18) {
      for (const o15 of t18) if ((o15 == null ? void 0 : o15.overrides.length) > 0) return true;
    }
    if (null != i13) {
      for (const o15 of i13) if ((o15 == null ? void 0 : o15.overrides.length) > 0) return true;
    }
    return false;
  }
  _getMaterialOverrides(e15, r12) {
    if (!e15) return [];
    const t18 = [];
    for (const i13 of e15) t18.push(...this._getPrimitiveMaterialOverrides(i13, r12));
    return t18;
  }
  _getPrimitiveMaterialOverrides(e15, r12) {
    if (!e15) return [];
    const t18 = R(this._primitiveOverrides.filter((r13) => r13.primitiveName === e15));
    return t18.forEach((e16) => e16.defaultValue = O(r12, e16.propertyName.toLowerCase())), t18;
  }
  _analyzeMaterialOverrides(e15, r12) {
    return this._primitiveOverrides.filter((t18) => t18.primitiveName !== e15 || !r12.includes(t18.propertyName));
  }
};
function A4(e15, r12) {
  return { type: e15.type, enable: true, name: e15.name, colorLocked: e15.colorLocked, primitiveName: e15.primitiveName, anchorPoint: e15.anchorPoint, anchorPointUnits: e15.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e15.rotateClockwise, rotation: 0, size: e15.size, billboardMode3D: e15.billboardMode3D, depth3D: e15.depth3D, frame: e15.frame, markerGraphics: [r12], scaleSymbolsProportionally: e15.scaleSymbolsProportionally, respectFrame: e15.respectFrame, clippingPath: e15.clippingPath };
}
function G2(e15) {
  if (e15 && 0 === e15.indexOf("Level_")) {
    const r12 = parseInt(e15.substr(6), 10);
    if (!isNaN(r12)) return r12;
  }
  return 0;
}
var F2 = (e15) => e15 && 2 === e15.length && e15[0].enable && e15[1].enable && "CIMSolidStroke" === e15[0].type && "CIMSolidFill" === e15[1].type && null == e15[0].path && null == e15[1].path && !e15[0].effects && !e15[1].effects;
function T5(e15) {
  const r12 = e15.symbolLayers;
  if (!r12 || 2 !== r12.length) return false;
  const t18 = r12.find((e16) => {
    var _a;
    return (_a = e16.effects) == null ? void 0 : _a.find((e17) => "CIMGeometricEffectDashes" === e17.type && null != e17.dashTemplate);
  }), i13 = r12.find((e16) => {
    var _a;
    return (_a = e16.effects) == null ? void 0 : _a.find((e17) => "CIMGeometricEffectAddControlPoints" === e17.type);
  });
  return !!t18 || !!i13;
}
function Y(e15) {
  return a(e15).map((e16) => ({ ...e16, propertyName: v(e16.propertyName) }));
}

// ../node_modules/@arcgis/core/views/2d/engine/ManagedCanvas.js
var l6 = class {
  constructor(s14) {
    this.events = new o3(), this._hasMajorPerformanceCaveat = false, this._lastRenderFrameCounter = 0, this._canvas = document.createElement("canvas"), this._canvas.setAttribute("style", "width: 100%; height:100%; display:block; willChange:transform");
    const r12 = { failIfMajorPerformanceCaveat: true, alpha: true, antialias: false, depth: true, stencil: true };
    s14.appendChild(this._canvas);
    let i13 = t6(this._canvas, r12);
    i13 || (i13 = t6(this._canvas, { ...r12, failIfMajorPerformanceCaveat: false }), this._hasMajorPerformanceCaveat = true), this._gl = i13, this._handles = o([o2(this._canvas, "webglcontextlost", (e15) => this.events.emit("webgl-context-lost", e15))]);
  }
  destroy() {
    var _a;
    (_a = this._canvas.parentNode) == null ? void 0 : _a.removeChild(this._canvas), this._canvas = null, this._handles.remove(), this._gl = null;
  }
  get gl() {
    return this._gl;
  }
  render(e15, t18) {
    if (this._hasMajorPerformanceCaveat || has("esri-force-performance-mode")) {
      if (++this._lastRenderFrameCounter >= has("esri-performance-mode-frames-between-render") && (t18(), this._lastRenderViewState = e15.state.clone(), this._lastRenderFrameCounter = 0), this._lastRenderViewState) {
        const [t19, a10, s14, r12, i13, o15] = this._computeViewTransform(this._lastRenderViewState, e15.state);
        this._canvas.style.transform = `matrix(${t19}, ${a10}, ${s14}, ${r12}, ${i13}, ${o15})`;
      }
    } else t18();
  }
  resize(e15) {
    const t18 = this._canvas, a10 = t18.style, { state: { size: s14 }, pixelRatio: r12 } = e15, i13 = s14[0], o15 = s14[1], n14 = Math.round(i13 * r12), h14 = Math.round(o15 * r12);
    t18.width === n14 && t18.height === h14 || (t18.width = n14, t18.height = h14), a10.width = i13 + "px", a10.height = o15 + "px";
  }
  _computeViewTransform(e15, t18) {
    const [a10, c12] = e15.center, [l13, m7] = t18.center, [d5, f9] = e15.toScreen([0, 0], l13, m7), [_5, v4] = e15.toScreen([0, 0], a10, c12), p5 = _5 - d5, g4 = v4 - f9, w6 = e15.scale / t18.scale, u11 = t18.rotation - e15.rotation, j3 = e5();
    return a2(j3), c3(j3, j3, [w6, w6]), s5(j3, j3, h(u11)), i4(j3, j3, [p5, g4]), j3;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js
var e13 = { background: { "background.frag": "#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}", "background.vert": "precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}" }, circle: { "circle.frag": "precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}", "circle.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, fill: { "fill.frag": "precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}", "fill.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, icon: { "icon.frag": "precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n}", "icon.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}" }, line: { "line.frag": "precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}", "line.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}" }, outline: { "outline.frag": "varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}", "outline.vert": "attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, text: { "text.frag": "uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}", "text.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}" }, util: { "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}", "util.glsl": "float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}" } };

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js
function o11(e15) {
  let o15 = e13;
  return e15.split("/").forEach((r12) => {
    o15 && (o15 = o15[r12]);
  }), o15;
}
var t12 = new e7(o11);
function n7(r12) {
  return t12.resolveIncludes(r12);
}

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js
var t13 = (e15) => n4({ PATTERN: e15.pattern });
var a6 = { shaders: (r12) => ({ vertexShader: t13(r12) + n7("background/background.vert"), fragmentShader: t13(r12) + n7("background/background.frag") }) };
var d3 = { shaders: (r12) => ({ vertexShader: n7("circle/circle.vert"), fragmentShader: n7("circle/circle.frag") }) };
var n8 = (e15) => n4({ PATTERN: e15.pattern });
var i9 = { shaders: (r12) => ({ vertexShader: n8(r12) + n7("fill/fill.vert"), fragmentShader: n8(r12) + n7("fill/fill.frag") }) };
var l7 = { shaders: (r12) => ({ vertexShader: n7("outline/outline.vert"), fragmentShader: n7("outline/outline.frag") }) };
var s8 = (e15) => n4({ SDF: e15.sdf });
var f6 = { shaders: (r12) => ({ vertexShader: s8(r12) + n7("icon/icon.vert"), fragmentShader: s8(r12) + n7("icon/icon.frag") }) };
var h8 = (e15) => n4({ PATTERN: e15.pattern, SDF: e15.sdf });
var o12 = { shaders: (r12) => ({ vertexShader: h8(r12) + n7("line/line.vert"), fragmentShader: h8(r12) + n7("line/line.frag") }) };
var g = { shaders: (r12) => ({ vertexShader: n7("text/text.vert"), fragmentShader: n7("text/text.frag") }) };

// ../node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterialManager.js
var p2 = class {
  constructor() {
    this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((e15) => e15.dispose()), this._programByKey.clear();
  }
  getMaterialProgram(e15, r12, t18) {
    const a10 = r12.key << 3 | this._getMaterialOptionsValue(r12.type, t18);
    if (this._programByKey.has(a10)) return this._programByKey.get(a10);
    const s14 = this._getProgramTemplate(r12.type), { shaders: n14 } = s14, { vertexShader: c12, fragmentShader: o15 } = n14(t18), p5 = r12.getShaderHeader(), u11 = r12.getShaderMain(), i13 = c12.replace("#pragma header", p5).replace("#pragma main", u11), g4 = e15.programCache.acquire(i13, o15, r12.getAttributeLocations());
    return this._programByKey.set(a10, g4), g4;
  }
  _getMaterialOptionsValue(r12, t18) {
    switch (r12) {
      case L5.BACKGROUND:
        return (t18.pattern ? 1 : 0) << 1;
      case L5.FILL:
        return (t18.pattern ? 1 : 0) << 1;
      case L5.OUTLINE:
        return 0;
      case L5.LINE: {
        const e15 = t18;
        return (e15.sdf ? 1 : 0) << 2 | (e15.pattern ? 1 : 0) << 1;
      }
      case L5.ICON:
        return (t18.sdf ? 1 : 0) << 1;
      case L5.CIRCLE:
      case L5.TEXT:
      default:
        return 0;
    }
  }
  _getProgramTemplate(p5) {
    switch (p5) {
      case L5.BACKGROUND:
        return a6;
      case L5.CIRCLE:
        return d3;
      case L5.FILL:
        return i9;
      case L5.ICON:
        return f6;
      case L5.LINE:
        return o12;
      case L5.OUTLINE:
        return l7;
      case L5.TEXT:
        return g;
      default:
        return null;
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/BitBlitRenderer.js
var _2 = class {
  constructor() {
    this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._vertexArrayObject = r2(this._vertexArrayObject);
  }
  render(r12, t18, e15, i13) {
    r12 && (this._initialized || this._initialize(r12), r12.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA), r12.bindVAO(this._vertexArrayObject), r12.useProgram(this._program), t18.setSamplingMode(e15), r12.bindTexture(t18, 0), this._program.setUniform1i("u_tex", 0), this._program.setUniform1f("u_opacity", i13), r12.drawArrays(E2.TRIANGLE_STRIP, 0, 4), r12.bindTexture(null, 0), r12.bindVAO());
  }
  _initialize(r12) {
    if (this._initialized) return true;
    const s14 = e8(r12, e10);
    if (!s14) return false;
    const o15 = new Int8Array(16);
    o15[0] = -1, o15[1] = -1, o15[2] = 0, o15[3] = 0, o15[4] = 1, o15[5] = -1, o15[6] = 1, o15[7] = 0, o15[8] = -1, o15[9] = 1, o15[10] = 0, o15[11] = 1, o15[12] = 1, o15[13] = 1, o15[14] = 1, o15[15] = 1;
    const _5 = e10.attributes, p5 = new o8(r12, _5, t8, { geometry: c.createVertex(r12, F.STATIC_DRAW, o15) });
    return this._program = s14, this._vertexArrayObject = p5, this._initialized = true, true;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/MaterialManager.js
var e14 = class {
  constructor(r12) {
    this._rctx = r12, this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((r12) => r12.dispose()), this._programByKey.clear();
  }
  getProgram(e15, t18 = []) {
    const a10 = e15.vsPath + "." + e15.fsPath + JSON.stringify(t18);
    if (this._programByKey.has(a10)) return this._programByKey.get(a10);
    const s14 = { ...t18.map((r12) => "string" == typeof r12 ? { name: r12, value: true } : r12).reduce((r12, e16) => ({ ...r12, [e16.name]: e16.value }), {}) }, { vsPath: o15, fsPath: h14, attributes: i13 } = e15, g4 = o10(o15, h14, i13, s14), m7 = this._rctx.programCache.acquire(g4.shaders.vertexShader, g4.shaders.fragmentShader, g4.attributes);
    if (!m7) throw new Error("Unable to get program for key: ${key}");
    return this._programByKey.set(a10, m7), m7;
  }
};

// ../node_modules/@arcgis/core/symbols/cim/Rasterizer.js
var c5 = 512;
var l8 = class {
  constructor(e15) {
    this._resourceManager = e15, this._cachedRasterizationCanvas = null;
  }
  dispose() {
    this._cachedRasterizationCanvas = null;
  }
  get _canvas() {
    return this._cachedRasterizationCanvas || (this._cachedRasterizationCanvas = document.createElement("canvas")), this._cachedRasterizationCanvas;
  }
  rasterizeJSONResource(e15) {
    switch (e15.type) {
      case "dash": {
        const r12 = e15.dashTemplate, a10 = e15.capStyle, [n14, s14, i13] = i8(r12, a10);
        return { size: [s14, i13], image: new Uint32Array(n14.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0 };
      }
      case "fill-style": {
        const [t18, a10, n14, s14] = e11(this._canvas, e15, et);
        return { size: [a10, n14], image: new Uint32Array(t18.buffer), sdf: false, simplePattern: true, anchorX: 0, anchorY: 0, rasterizationScale: s14 };
      }
      case "sdf":
        return h9(e15);
      case "CIMHatchFill":
      case "CIMVectorMarker":
      case "CIMPictureMarker":
        return this._rasterizeCIMJSONResource(e15);
    }
  }
  _rasterizeCIMJSONResource(r12) {
    var _a;
    switch (r12.type) {
      case "CIMHatchFill": {
        const t18 = ee.fromCIMHatchFill(r12, et);
        return this._rasterizeCIMVectorMarker(t18);
      }
      case "CIMPictureMarker": {
        const t18 = ee.fromCIMInsidePolygon(r12);
        return this._rasterizeCIMVectorMarker(t18);
      }
      case "CIMVectorMarker": {
        if ("CIMMarkerPlacementInsidePolygon" === ((_a = r12.markerPlacement) == null ? void 0 : _a.type)) {
          const t19 = ee.fromCIMInsidePolygon(r12);
          return this._rasterizeCIMVectorMarker(t19);
        }
        const t18 = l5(r12);
        return t18 && !r12.avoidSDFRasterization ? h9(t18) : this._rasterizeCIMVectorMarker(r12, false);
      }
    }
  }
  _rasterizeCIMVectorMarker(r12, t18 = true) {
    const n14 = t18 ? t3.fromExtent(r12.frame) : null, [s14, i13, o15, c12, l13] = ee.rasterize(this._canvas, r12, n14, this._resourceManager);
    return s14 ? { size: [i13, o15], image: new Uint32Array(s14.buffer), sdf: false, simplePattern: false, anchorX: c12, anchorY: l13 } : null;
  }
  rasterizeImageResource(e15, r12, t18, a10) {
    this._canvas.width = e15, this._canvas.height = r12;
    const n14 = this._canvas.getContext("2d", { willReadFrequently: true });
    t18 instanceof ImageData ? n14.putImageData(t18, 0, 0) : (t18.setAttribute("width", `${e15}px`), t18.setAttribute("height", `${r12}px`), n14.drawImage(t18, 0, 0, e15, r12));
    const s14 = n14.getImageData(0, 0, e15, r12), o15 = new Uint8Array(s14.data);
    if (a10) {
      for (const i13 of a10) if (i13 && i13.oldColor && 4 === i13.oldColor.length && i13.newColor && 4 === i13.newColor.length) {
        const [e16, r13, t19, a11] = i13.oldColor, [n15, s15, c12, l14] = i13.newColor;
        if (e16 === n15 && r13 === s15 && t19 === c12 && a11 === l14) continue;
        for (let i14 = 0; i14 < o15.length; i14 += 4) e16 === o15[i14] && r13 === o15[i14 + 1] && t19 === o15[i14 + 2] && a11 === o15[i14 + 3] && (o15[i14] = n15, o15[i14 + 1] = s15, o15[i14 + 2] = c12, o15[i14 + 3] = l14);
      }
    }
    let l13;
    for (let i13 = 0; i13 < o15.length; i13 += 4) l13 = o15[i13 + 3] / 255, o15[i13] = o15[i13] * l13, o15[i13 + 1] = o15[i13 + 1] * l13, o15[i13 + 2] = o15[i13 + 2] * l13;
    let h14 = o15, u11 = e15, f9 = r12;
    const m7 = c5;
    if (u11 >= m7 || f9 >= m7) {
      const t19 = u11 / f9;
      t19 > 1 ? (u11 = m7, f9 = Math.round(m7 / t19)) : (f9 = m7, u11 = Math.round(m7 * t19)), h14 = new Uint8Array(4 * u11 * f9);
      const a11 = new Uint8ClampedArray(h14.buffer);
      u5(o15, e15, r12, a11, u11, f9, false);
    }
    return { size: [u11, f9], image: new Uint32Array(h14.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0 };
  }
};
function h9(e15) {
  if (!e15) return null;
  const [r12, t18, a10] = c4(e15);
  return r12 ? { size: [t18, a10], image: new Uint32Array(r12.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0 } : null;
}

// ../node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t14 = class {
  constructor(t18, e15) {
    this._width = 0, this._height = 0, this._free = [], this._width = t18, this._height = e15, this._free.push(new t4(0, 0, t18, e15));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t18, e15) {
    if (t18 > this._width || e15 > this._height) return new t4();
    let i13 = null, s14 = -1;
    for (let h14 = 0; h14 < this._free.length; ++h14) {
      const r12 = this._free[h14];
      t18 <= r12.width && e15 <= r12.height && (null === i13 || r12.y <= i13.y && r12.x <= i13.x) && (i13 = r12, s14 = h14);
    }
    return null === i13 ? new t4() : (this._free.splice(s14, 1), i13.width < i13.height ? (i13.width > t18 && this._free.push(new t4(i13.x + t18, i13.y, i13.width - t18, e15)), i13.height > e15 && this._free.push(new t4(i13.x, i13.y + e15, i13.width, i13.height - e15))) : (i13.width > t18 && this._free.push(new t4(i13.x + t18, i13.y, i13.width - t18, i13.height)), i13.height > e15 && this._free.push(new t4(i13.x, i13.y + e15, t18, i13.height - e15))), new t4(i13.x, i13.y, t18, e15));
  }
  release(h14) {
    for (let t18 = 0; t18 < this._free.length; ++t18) {
      const e15 = this._free[t18];
      if (e15.y === h14.y && e15.height === h14.height && e15.x + e15.width === h14.x) e15.width += h14.width;
      else if (e15.x === h14.x && e15.width === h14.width && e15.y + e15.height === h14.y) e15.height += h14.height;
      else if (h14.y === e15.y && h14.height === e15.height && h14.x + h14.width === e15.x) e15.x = h14.x, e15.width += h14.width;
      else {
        if (h14.x !== e15.x || h14.width !== e15.width || h14.y + h14.height !== e15.y) continue;
        e15.y = h14.y, e15.height += h14.height;
      }
      this._free.splice(t18, 1), this.release(h14);
    }
    this._free.push(h14);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var n9 = 256;
var o13 = (t18) => Math.floor(t18 / 256);
function c6(t18) {
  const e15 = /* @__PURE__ */ new Set();
  for (const i13 of t18) e15.add(o13(i13));
  return e15;
}
function l9(e15, i13, h14) {
  return e15.has(i13) || e15.set(i13, h14().then(() => {
    e15.delete(i13);
  }).catch((h15) => {
    e15.delete(i13), f(h15);
  })), e15.get(i13);
}
var g2 = (t18) => ({ rect: new t4(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t18, sdf: true });
var p3 = class {
  constructor(t18, e15, h14) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t18, this.height = e15, this._glyphSource = h14, this._binPack = new t14(t18 - 4, e15 - 4), this._glyphData.push(new Uint8Array(t18 * e15)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t18 of this._textures) t18 && t18.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t18 = [117, 149, 181, 207, 207, 181, 149, 117], e15 = [], i13 = [];
    for (let r12 = 0; r12 < t18.length; r12++) {
      const h15 = t18[r12];
      for (let t19 = 0; t19 < 11; t19++) {
        const s15 = r12 >= 3 && r12 < 5 && t19 >= 3 && t19 < 8 ? 255 : 0;
        e15.push(h15), i13.push(s15);
      }
    }
    const h14 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e15) }, s14 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(i13) };
    this._recordGlyph(h14), this._recordGlyph(s14);
  }
  getTexture(t18, e15) {
    if (!this._textures[e15]) {
      const i13 = new e4();
      i13.pixelFormat = G.ALPHA, i13.wrapMode = D.CLAMP_TO_EDGE, i13.width = this.width, i13.height = this.height, this._textures[e15] = new c2(t18, i13, new Uint8Array(this.width * this.height));
    }
    return this._dirties[e15] && (this._textures[e15].setData(this._glyphData[e15]), this._dirties[e15] = false), this._textures[e15];
  }
  async getGlyphItems(t18, e15, i13) {
    const h14 = this._getGlyphCache(t18);
    return await this._fetchRanges(t18, e15, i13), e15.map((e16) => this._getMosaicItem(h14, t18, e16));
  }
  bind(t18, e15, i13, h14) {
    const s14 = this.getTexture(t18, i13);
    s14.setSamplingMode(e15), t18.bindTexture(s14, h14);
  }
  preloadASCIIGlyphCache(t18) {
    const e15 = this._preloadCache[t18];
    if (null != e15) return e15;
    const i13 = this._glyphSource.preloadASCIIRange(t18).then(() => {
      const e16 = this._getGlyphCache(t18);
      for (let i14 = 0; i14 < 256; i14++) this._getMosaicItem(e16, t18, i14);
    });
    return this._preloadCache[t18] = i13, i13;
  }
  _getGlyphCache(t18) {
    return this._glyphCache[t18] || (this._glyphCache[t18] = {}), this._glyphCache[t18];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t18, e15, i13) {
    const h14 = c6(e15), s14 = [];
    h14.forEach((e16) => {
      s14.push(this._fetchRange(t18, e16, i13));
    }), await Promise.all(s14);
  }
  async _fetchRange(t18, e15, i13) {
    if (e15 > n9) return;
    const h14 = t18 + e15;
    return l9(this._rangePromises, h14, () => this._glyphSource.getRange(t18, e15, i13));
  }
  _getMosaicItem(t18, e15, i13) {
    if (!t18[i13]) {
      const h14 = this._glyphSource.getGlyph(e15, i13);
      if (!(h14 == null ? void 0 : h14.metrics)) return g2(i13);
      const s14 = this._recordGlyph(h14), r12 = this._currentPage, a10 = h14.metrics;
      t18[i13] = { rect: s14, page: r12, metrics: a10, code: i13, sdf: true }, this._invalidate();
    }
    return t18[i13];
  }
  _recordGlyph(t18) {
    const h14 = t18.metrics;
    let s14;
    if (0 === h14.width) s14 = new t4(0, 0, 0, 0);
    else {
      const e15 = 3, r12 = h14.width + 2 * e15, a10 = h14.height + 2 * e15;
      s14 = this._binPack.allocate(r12, a10), s14.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t14(this.width - 4, this.height - 4), s14 = this._binPack.allocate(r12, a10));
      const n14 = this._glyphData[this._currentPage], o15 = t18.bitmap;
      let c12, l13;
      if (o15) for (let t19 = 0; t19 < a10; t19++) {
        c12 = r12 * t19, l13 = this.width * (s14.y + t19) + s14.x;
        for (let t20 = 0; t20 < r12; t20++) n14[l13 + t20] = o15[c12 + t20];
      }
      has("esri-glyph-debug") && this._showDebugPage(n14);
    }
    return s14;
  }
  _showDebugPage(t18) {
    const e15 = document.createElement("canvas"), i13 = e15.getContext("2d"), h14 = new ImageData(this.width, this.height), s14 = h14.data;
    e15.width = this.width, e15.height = this.height, e15.style.border = "1px solid black";
    for (let r12 = 0; r12 < t18.length; ++r12) s14[4 * r12] = t18[r12], s14[4 * r12 + 1] = 0, s14[4 * r12 + 2] = 0, s14[4 * r12 + 3] = 255;
    i13.putImageData(h14, 0, 0), document.body.appendChild(e15);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a7 = class {
  constructor(e15) {
    for (this._metrics = [], this._bitmaps = []; e15.next(); ) switch (e15.tag()) {
      case 1: {
        const t18 = e15.getMessage();
        for (; t18.next(); ) switch (t18.tag()) {
          case 3: {
            const e16 = t18.getMessage();
            let a10, s14, r12, n14, i13, c12, g4;
            for (; e16.next(); ) switch (e16.tag()) {
              case 1:
                a10 = e16.getUInt32();
                break;
              case 2:
                s14 = e16.getBytes();
                break;
              case 3:
                r12 = e16.getUInt32();
                break;
              case 4:
                n14 = e16.getUInt32();
                break;
              case 5:
                i13 = e16.getSInt32();
                break;
              case 6:
                c12 = e16.getSInt32();
                break;
              case 7:
                g4 = e16.getUInt32();
                break;
              default:
                e16.skip();
            }
            e16.release(), a10 && (this._metrics[a10] = { width: r12, height: n14, left: i13, top: c12, advance: g4 }, this._bitmaps[a10] = s14);
            break;
          }
          default:
            t18.skip();
        }
        t18.release();
        break;
      }
      default:
        e15.skip();
    }
  }
  getMetrics(e15) {
    return this._metrics[e15];
  }
  getBitmap(e15) {
    return this._bitmaps[e15];
  }
};
var s9 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e15) {
    return this._ranges[e15];
  }
  addRange(e15, t18) {
    this._ranges[e15] = t18;
  }
};
var r7 = class {
  constructor(e15) {
    this._glyphInfo = {}, this._baseURL = e15;
  }
  getRange(s14, r12, n14) {
    const i13 = this._getFontStack(s14);
    if (i13.getRange(r12)) return Promise.resolve();
    const c12 = 256 * r12, g4 = c12 + 255, o15 = this._baseURL.replace("{fontstack}", s14).replace("{range}", c12 + "-" + g4);
    return U(o15, { responseType: "array-buffer", ...n14 }).then((e15) => {
      i13.addRange(r12, new a7(new n3(new Uint8Array(e15.data), new DataView(e15.data))));
    });
  }
  async preloadASCIIRange(s14) {
    const r12 = this._getFontStack(s14), n14 = 0, i13 = 255, c12 = this._baseURL.replace("{fontstack}", s14).replace("{range}", n14 + "-" + i13), g4 = await U(c12, { responseType: "array-buffer" }), o15 = new a7(new n3(new Uint8Array(g4.data), new DataView(g4.data)));
    for (let e15 = n14; e15 <= i13; e15++) r12.getRange(e15) || r12.addRange(e15, o15);
  }
  getGlyph(e15, t18) {
    const a10 = this._getFontStack(e15);
    if (!a10) return;
    const s14 = Math.floor(t18 / 256), r12 = a10.getRange(s14);
    return r12 ? { metrics: r12.getMetrics(t18), bitmap: r12.getBitmap(t18) } : void 0;
  }
  _getFontStack(e15) {
    let t18 = this._glyphInfo[e15];
    return t18 || (t18 = this._glyphInfo[e15] = new s9()), t18;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var s10 = 1e20;
var r8 = class {
  constructor(t18, e15 = 2) {
    this._textureSize = t18, this._rasterizationScale = e15, this._canvasSize = this._textureSize * this._rasterizationScale, this._svg = null;
    const { _canvasSize: i13 } = this, s14 = document.createElement("canvas");
    s14.width = s14.height = i13, this._context = s14.getContext("2d", { willReadFrequently: false }), this._gridOuter = new Float64Array(i13 * i13), this._gridInner = new Float64Array(i13 * i13), this._f = new Float64Array(i13), this._d = new Float64Array(i13), this._z = new Float64Array(i13 + 1), this._v = new Int16Array(i13);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg && (document.body.removeChild(this._svg), this._svg = null);
  }
  draw(r12, n14, o15) {
    const { _canvasSize: h14, _textureSize: a10, _rasterizationScale: l13 } = this, d5 = a10 / 4;
    this._initSVG();
    const _5 = this.createSVGString(r12, n14);
    return new Promise((r13, n15) => {
      const c12 = new Image();
      c12.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(_5), c12.onload = () => {
        c12.onload = null, this._context.clearRect(0, 0, h14, h14), this._context.drawImage(c12, 0, 0, h14, h14);
        const e15 = this._context.getImageData(0, 0, h14, h14), i13 = new Uint8Array(a10 * a10 * 4);
        for (let t18 = 0; t18 < h14 * h14; t18++) {
          const i14 = e15.data[4 * t18 + 3] / 255;
          this._gridOuter[t18] = 1 === i14 ? 0 : 0 === i14 ? s10 : Math.max(0, 0.5 - i14) ** 2, this._gridInner[t18] = 1 === i14 ? s10 : 0 === i14 ? 0 : Math.max(0, i14 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, h14, h14), this._edt(this._gridInner, h14, h14);
        for (let s14 = 0; s14 < a10 * a10; s14++) {
          let e16 = 0;
          for (let t18 = 0; t18 < l13; t18++) {
            const i14 = Math.floor(s14 / a10) * l13 + t18;
            for (let t19 = 0; t19 < l13; t19++) {
              const r14 = i14 * h14 + (s14 % a10 * l13 + t19);
              e16 += this._gridOuter[r14] - this._gridInner[r14];
            }
          }
          e16 /= l13 * l13, e16 /= l13;
          o7(0.5 - e16 / (2 * d5), i13, 4 * s14);
        }
        r13(i13);
      };
      const g4 = o15 == null ? void 0 : o15.signal;
      g4 && m2(g4, () => n15(u2()));
    });
  }
  _initSVG() {
    if (!this._svg) {
      const t18 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t18.setAttribute("style", "position: absolute;"), t18.setAttribute("width", "0"), t18.setAttribute("height", "0"), t18.setAttribute("aria-hidden", "true"), t18.setAttribute("role", "presentation"), document.body.appendChild(t18), this._svg = t18;
    }
    return this._svg;
  }
  createSVGString(t18, e15) {
    const i13 = this._initSVG(), s14 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    s14.setAttribute("d", t18), i13.appendChild(s14);
    const r12 = s14.getBBox(), n14 = r12.width / r12.height, o15 = this._canvasSize / 2;
    let h14, a10, l13;
    if (n14 > 1) {
      h14 = o15 / r12.width;
      const t19 = o15 * (1 / n14);
      a10 = this._canvasSize / 4, l13 = o15 - t19 / 2;
    } else {
      h14 = o15 / r12.height;
      a10 = o15 - o15 * n14 / 2, l13 = this._canvasSize / 4;
    }
    const d5 = -r12.x * h14 + a10, _5 = -r12.y * h14 + l13;
    s14.setAttribute("style", `transform: matrix(${h14}, 0, 0, ${h14}, ${d5}, ${_5})`), s14.setAttribute("stroke-width", "" + 0.5 / h14);
    const c12 = `<svg style="fill:${e15 ? "red" : "none"}; stroke:${e15 ? "none" : "red"}" height="${this._canvasSize}" width="${this._canvasSize}" xmlns="http://www.w3.org/2000/svg">${i13.innerHTML}</svg>`;
    return i13.removeChild(s14), c12;
  }
  _edt(t18, e15, i13) {
    const s14 = this._f, r12 = this._d, n14 = this._v, o15 = this._z;
    for (let h14 = 0; h14 < e15; h14++) {
      for (let r13 = 0; r13 < i13; r13++) s14[r13] = t18[r13 * e15 + h14];
      this._edt1d(s14, r12, n14, o15, i13);
      for (let s15 = 0; s15 < i13; s15++) t18[s15 * e15 + h14] = r12[s15];
    }
    for (let h14 = 0; h14 < i13; h14++) {
      for (let i14 = 0; i14 < e15; i14++) s14[i14] = t18[h14 * e15 + i14];
      this._edt1d(s14, r12, n14, o15, e15);
      for (let i14 = 0; i14 < e15; i14++) t18[h14 * e15 + i14] = Math.sqrt(r12[i14]);
    }
  }
  _edt1d(t18, e15, i13, r12, n14) {
    i13[0] = 0, r12[0] = -s10, r12[1] = +s10;
    for (let o15 = 1, h14 = 0; o15 < n14; o15++) {
      let e16 = (t18[o15] + o15 * o15 - (t18[i13[h14]] + i13[h14] * i13[h14])) / (2 * o15 - 2 * i13[h14]);
      for (; e16 <= r12[h14]; ) h14--, e16 = (t18[o15] + o15 * o15 - (t18[i13[h14]] + i13[h14] * i13[h14])) / (2 * o15 - 2 * i13[h14]);
      h14++, i13[h14] = o15, r12[h14] = e16, r12[h14 + 1] = +s10;
    }
    for (let s14 = 0, o15 = 0; s14 < n14; s14++) {
      for (; r12[o15 + 1] < s14; ) o15++;
      e15[s14] = (s14 - i13[o15]) * (s14 - i13[o15]) + t18[i13[o15]];
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function c7(t18) {
  return t18 && "static" === t18.type;
}
var n10 = class _n {
  constructor(t18, e15, i13 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, this._pageWidth = t18, this._pageHeight = e15, i13 > 0 && (this._maxItemSize = i13), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t14(this._pageWidth, this._pageHeight);
    const s14 = Math.floor(this._pageWidth), r12 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s14 * r12) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t18) {
    return t18 >= this._mosaicPages.length ? -1 : this._mosaicPages[t18].size[0];
  }
  getHeight(t18) {
    return t18 >= this._mosaicPages.length ? -1 : this._mosaicPages[t18].size[1];
  }
  getPageTexture(t18) {
    return t18 < this._mosaicPages.length ? this._mosaicPages[t18].texture : null;
  }
  has(t18) {
    return this._mosaicRects.has(t18);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t18) {
    return this._mosaicRects.get(t18);
  }
  addSpriteItem(t18, i13, a10, r12, o15, h14, n14 = 1) {
    if (this._mosaicRects.has(t18)) return this._mosaicRects.get(t18);
    let g4, p5, m7;
    if (c7(a10)) [g4, p5, m7] = this._allocateImage(i13[0], i13[1]);
    else {
      g4 = new t4(0, 0, i13[0], i13[1]), p5 = this._mosaicPages.length;
      const t19 = void 0;
      this._mosaicPages.push({ mosaicsData: a10, size: [i13[0] + 2 * tt, i13[1] + 2 * tt], dirty: true, texture: t19 });
    }
    if (g4.width <= 0 || g4.height <= 0) return null;
    const d5 = { type: "sprite", rect: g4, width: i13[0], height: i13[1], sdf: o15, simplePattern: h14, rasterizationScale: n14, page: p5 };
    return this._mosaicRects.set(t18, d5), c7(a10) && (has("esri-mosaic-debug") && this._showDebugSprite(i13, a10.data), this._copy({ rect: g4, spriteSize: i13, spriteData: a10.data, page: p5, pageSize: m7, repeat: r12, sdf: o15 })), d5;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t18 = this._spriteCopyQueue.pop();
    t18 && this._copy(t18);
  }
  getMosaicItemPosition(t18) {
    const i13 = this.getSpriteItem(t18), s14 = i13 == null ? void 0 : i13.rect;
    if (!s14) return null;
    s14.width = i13.width, s14.height = i13.height;
    const a10 = i13.width, r12 = i13.height, o15 = tt, h14 = this._mosaicPages[i13.page].size;
    return { size: [i13.width, i13.height], tl: [(s14.x + o15) / h14[0], (s14.y + o15) / h14[1]], br: [(s14.x + o15 + a10) / h14[0], (s14.y + o15 + r12) / h14[1]], page: i13.page };
  }
  bind(t18, e15, i13 = 0, s14 = 0) {
    const a10 = this._mosaicPages[i13], r12 = a10.mosaicsData;
    let o15 = a10.texture;
    if (o15 || (o15 = p4(t18, a10.size), a10.texture = o15), o15.setSamplingMode(e15), c7(r12)) t18.bindTexture(o15, s14), a10.dirty && (o15.setData(new Uint8Array(r12.data.buffer)), o15.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i13));
    else {
      r12.data.loadFrame(o15), t18.bindTexture(o15, s14), o15.generateMipmap();
    }
    a10.dirty = false;
  }
  getTexture(t18, e15 = 0) {
    const i13 = this._mosaicPages[e15], s14 = i13.mosaicsData;
    let a10 = i13.texture;
    if (a10 || (a10 = p4(t18, i13.size), i13.texture = a10), c7(s14)) i13.dirty && (a10.setData(new Uint8Array(s14.data.buffer)), a10.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(e15));
    else {
      s14.data.loadFrame(a10), a10.generateMipmap();
    }
    return i13.dirty = false, a10;
  }
  dispose() {
    this._binPack = null;
    for (const t18 of this._mosaicPages) {
      const e15 = t18.texture;
      e15 && e15.dispose();
      const i13 = t18.mosaicsData;
      if (!c7(i13)) {
        i13.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t18, e15, i13, s14, a10, r12, o15, h14, c12, n14, g4) {
    let p5 = s14 * e15 + i13, m7 = h14 * r12 + o15;
    if (g4) {
      m7 -= r12;
      for (let o16 = -1; o16 <= n14; o16++, p5 = ((o16 + n14) % n14 + s14) * e15 + i13, m7 += r12) for (let e16 = -1; e16 <= c12; e16++) a10[m7 + e16] = t18[p5 + (e16 + c12) % c12];
    } else for (let d5 = 0; d5 < n14; d5++) {
      for (let e16 = 0; e16 < c12; e16++) a10[m7 + e16] = t18[p5 + e16];
      p5 += e15, m7 += r12;
    }
  }
  _copy(i13) {
    if (i13.page >= this._mosaicPages.length) return;
    const s14 = this._mosaicPages[i13.page], a10 = s14.mosaicsData;
    if (!c7(s14.mosaicsData)) throw new s2("mapview-invalid-resource", "unsuitable data type!");
    const r12 = i13.spriteData, o15 = a10.data;
    _n._copyBits(r12, i13.spriteSize[0], 0, 0, o15, i13.pageSize[0], i13.rect.x + tt, i13.rect.y + tt, i13.spriteSize[0], i13.spriteSize[1], i13.repeat), s14.dirty = true;
  }
  _allocateImage(t18, r12) {
    t18 += 2 * tt, r12 += 2 * tt;
    const o15 = Math.max(t18, r12);
    if (this._maxItemSize && this._maxItemSize < o15) {
      const e15 = 2 ** Math.ceil(e9(t18)), a10 = 2 ** Math.ceil(e9(r12)), o16 = new t4(0, 0, t18, r12);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e15 * a10) }, size: [e15, a10], dirty: true, texture: void 0 }), [o16, this._mosaicPages.length - 1, [e15, a10]];
    }
    const h14 = this._binPack.allocate(t18, r12);
    if (h14.width <= 0) {
      const e15 = this._mosaicPages[this._currentPage];
      return !e15.dirty && c7(e15.mosaicsData) && (e15.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t14(this._pageWidth, this._pageHeight), this._allocateImage(t18, r12);
    }
    return [h14, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t18, e15], i13) {
    const s14 = document.createElement("canvas");
    s14.width = t18, s14.height = e15, s14.setAttribute("style", `position: absolute; top: ${4 + 204 * g3++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a10 = s14.getContext("2d"), r12 = new ImageData(t18, e15);
    r12.data.set(new Uint8Array(i13.buffer)), a10.putImageData(r12, 0, 0), document.body.appendChild(s14);
  }
  _showDebugPage(t18) {
    const e15 = this._mosaicPages[t18], { size: [i13, s14], mosaicsData: a10 } = e15;
    if (!c7(a10)) return;
    const r12 = `mosaicDebugPage${t18}`, o15 = document.getElementById(r12) ?? document.createElement("canvas");
    o15.id = r12, o15.width = i13, o15.height = s14, o15.setAttribute("style", `position: absolute; top: ${4 + 204 * t18}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const h14 = o15.getContext("2d"), n14 = new ImageData(i13, s14);
    n14.data.set(new Uint8Array(a10.data.buffer)), h14.putImageData(n14, 0, 0), document.body.appendChild(o15);
  }
};
var g3 = 0;
function p4(t18, e15) {
  const i13 = new e4();
  return i13.width = e15[0], i13.height = e15[1], i13.wrapMode = D.CLAMP_TO_EDGE, new c2(t18, i13, null);
}

// ../node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var a8 = class {
  constructor(t18, a10, h14, e15) {
    this._animation = t18, this._frameData = null;
    const n14 = (t19) => {
      this._frameData = t19, a10.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = f5(this._animation, h14, e15, n14);
  }
  destroy() {
    this._playHandle.remove();
  }
  loadFrame(i13) {
    const a10 = this._frameData;
    if (null == a10) return;
    const h14 = "width" in a10 ? a10.width : a10.codedWidth, e15 = "height" in a10 ? a10.height : a10.codedHeight;
    i13.updateData(0, tt, tt, h14, e15, a10), this._frameData = null;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var C2 = "arial-unicode-ms-regular";
var P4 = () => n.getLogger("esri.views.2d.engine.webgl.TextureManager");
var b4 = (e15, t18, i13) => P4().error(new s2(e15, t18, i13));
var v2 = class _v {
  static fromMosaic(e15, t18) {
    return new _v(e15, t18.page, t18.sdf);
  }
  constructor(e15, t18, i13) {
    this.mosaicType = e15, this.page = t18, this.sdf = i13;
  }
};
var j2 = class {
  constructor(i13) {
    this._requestRender = i13, this._resourceManager = new i5(), this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new r8(nt), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new _({ concurrency: 10, process: async (e15, i14) => {
      s3(i14);
      try {
        return await U(e15, { responseType: "image", signal: i14 });
      } catch (r12) {
        if (!b(r12)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${e15}`, r12);
        throw r12;
      }
    } }), this._spriteMosaic = new n10(2048, 2048, 500), this._glyphSource = new r7(`${s.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new p3(1024, 1024, this._glyphSource), this._rasterizer = new l8(this.resourceManager);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null, this._resourceManager.destroy();
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  get resourceManager() {
    return this._resourceManager;
  }
  async rasterizeItem(e15, t18) {
    if (null == e15) return b4("mapview-null-resource", "Unable to rasterize null resource"), null;
    if ("cim-rasterization-info" !== e15.type) return b4("mapview-unexpected-resource", "Unable to rasterize resource"), null;
    const { resource: i13 } = e15;
    if ("text" === i13.type) {
      const e16 = await this._rasterizeText(i13, t18);
      for (const t19 of e16.glyphs) this._setTextureBinding(A3.GLYPH, t19);
      return e16;
    }
    const s14 = await this._rasterizeSprite(i13, t18);
    return s14 && this._setTextureBinding(A3.SPRITE, s14), s14;
  }
  getMosaicInfo(e15, t18, i13 = false) {
    const s14 = this._getTextureBindingInfo(e15, t18, i13);
    return s14 ? { size: s14.size, texture: { texture: s14.texture, unit: "sprite" === s14.type ? x2 : b3 } } : (b4("mapview-invalid-resource", `Unable to find resource for ${t18}`), { size: [0, 0], texture: { texture: null, unit: 0 } });
  }
  _getTextureBindingInfo(e15, t18, i13) {
    const s14 = this._bindingInfos[t18 - 1], r12 = s14.page, a10 = i13 ? L3.LINEAR_MIPMAP_LINEAR : L3.LINEAR;
    switch (s14.mosaicType) {
      case A3.SPRITE: {
        const t19 = [this.sprites.getWidth(r12), this.sprites.getHeight(r12)], i14 = this._spriteMosaic.getTexture(e15, r12);
        return i14.setSamplingMode(a10), { type: "sprite", texture: i14, size: t19 };
      }
      case A3.GLYPH: {
        const t19 = [this.glyphs.width, this.glyphs.height], i14 = this._glyphMosaic.getTexture(e15, r12);
        return this._glyphMosaic.bind(e15, a10, r12, b3), i14.setSamplingMode(a10), { type: "glyph", texture: i14, size: t19 };
      }
      default:
        return b4("mapview-texture-manager", `Cannot handle unknown type ${s14.mosaicType}`), null;
    }
  }
  _hashMosaic(e15, t18) {
    return 1 | e15 << 1 | (t18.sdf ? 1 : 0) << 2 | t18.page << 3;
  }
  _setTextureBinding(e15, t18) {
    const i13 = this._hashMosaic(e15, t18);
    if (!this._hashToBindingIndex.has(i13)) {
      const s14 = v2.fromMosaic(e15, t18), r12 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i13, r12), this._bindingInfos.push(s14);
    }
    t18.textureBinding = this._hashToBindingIndex.get(i13);
  }
  async _rasterizeText(e15, t18) {
    const { font: s14, textString: a10 } = e15, n14 = f4(s14), o15 = this._invalidFontsMap.has(n14), [c12, h14] = i3(a10), u11 = j(c12);
    try {
      const e16 = o15 ? C2 : n14;
      has("esri-2d-stabilize-glyphs") && await this._glyphMosaic.preloadASCIIGlyphCache(e16);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(e16, u11, t18), isRightToLeft: h14 };
    } catch (l13) {
      b4("mapview-invalid-resource", `Couldn't find font ${n14}. Falling back to Arial Unicode MS Regular`), this._invalidFontsMap.set(n14, true);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(C2, u11, t18), isRightToLeft: h14 };
    }
  }
  _hashSpriteResource(e15) {
    switch (e15.type) {
      case "path":
        return `path:${e15.path}.${e15.asFill ? 1 : 0}`;
      case "CIMPictureMarker":
        return `${e15.type}:${e15.url}:${e15.size}`;
      case "CIMPictureFill":
        return `${e15.type}:${e15.url}:${e15.height}`;
      case "CIMPictureStroke":
        return `${e15.type}:${e15.url}:${e15.width}`;
      case "dash":
        return `dash:${e15.capStyle}.${e15.dashTemplate.join("")}`;
      case "sdf":
        return `sdf:${JSON.stringify(e15.geom)}.${e15.asFill ? 1 : 0}`;
      case "fill-style":
        return `fill_style:${e15.style}`;
      case "animated":
        return JSON.stringify(M2(e15));
      case "CIMHatchFill":
      case "CIMVectorMarker":
        return JSON.stringify(e15);
    }
  }
  async _rasterizeSprite(e15, t18) {
    var _a;
    if (!e15) return null;
    const i13 = l(this._hashSpriteResource(e15));
    if (this._spriteMosaic.has(i13)) return this._spriteMosaic.getSpriteItem(i13);
    if ("url" in e15 && e15.url || "CIMPictureFill" === e15.type || "CIMPictureStroke" === e15.type || "CIMPictureMarker" === e15.type || "CIMVectorMarker" === e15.type) {
      const t19 = [];
      ee.fetchResources({ type: "CIMPointSymbol", symbolLayers: [e15] }, this._resourceManager, t19), t19.length > 0 && await Promise.all(t19);
    }
    switch (e15.type) {
      case "CIMPictureMarker":
        return "CIMMarkerPlacementInsidePolygon" === ((_a = e15.markerPlacement) == null ? void 0 : _a.type) ? this._rasterizeJSONResource(i13, e15) : this._handleAsyncResource(i13, e15, t18);
      case "animated":
      case "CIMPictureFill":
      case "CIMPictureStroke":
      case "path":
        return this._handleAsyncResource(i13, e15, t18);
      case "sdf":
      case "dash":
      case "fill-style":
      case "CIMVectorMarker":
      case "CIMHatchFill":
        return this._rasterizeJSONResource(i13, e15);
    }
  }
  _rasterizeJSONResource(e15, t18) {
    const i13 = this._rasterizer.rasterizeJSONResource(t18);
    if (i13) {
      const { size: s14, image: r12, sdf: a10, simplePattern: n14, rasterizationScale: o15 } = i13;
      return this._addItemToMosaic(e15, s14, { type: "static", data: r12 }, $(t18), a10, n14, o15);
    }
    return null;
  }
  async _handleAsyncResource(e15, t18, i13) {
    if (this._ongoingRasterizations.has(e15)) return this._ongoingRasterizations.get(e15);
    let s14;
    return s14 = "path" === t18.type ? this._handleSVG(t18, e15, i13) : this._handleImage(t18, e15, i13), this._ongoingRasterizations.set(e15, s14), s14.finally(() => this._ongoingRasterizations.delete(e15)), s14;
  }
  async _handleSVG(e15, t18, i13) {
    const s14 = [nt, nt], { asFill: r12 } = e15, a10 = await this._sdfConverter.draw(e15.path, r12, i13);
    return this._addItemToMosaic(t18, s14, { type: "static", data: new Uint32Array(a10.buffer) }, false, true, true);
  }
  async _handleGIFOrPNG(e15, t18, i13) {
    const s14 = e15.url, r12 = this.resourceManager.getResource(s14);
    if (null == r12) return null;
    const { width: a10, height: n14 } = r12;
    if (r12 instanceof HTMLImageElement) {
      if ("animated" === e15.type) return b4("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
      const i14 = "colorSubstitutions" in e15 ? e15.colorSubstitutions : void 0, { size: s15, sdf: o16, image: c13 } = this._rasterizer.rasterizeImageResource(a10, n14, r12, i14);
      return this._addItemToMosaic(t18, s15, { type: "static", data: c13 }, $(e15), o16, false);
    }
    let o15, c12, h14;
    "animated" === e15.type ? (o15 = false, c12 = { playAnimation: e15.playAnimation, reverseAnimation: e15.reverseAnimation, randomizeStartTime: e15.randomizeStartTime, randomizeStartSeed: e15.randomizeStartSeed, startTimeOffset: e15.startTimeOffset, duration: e15.duration, repeatType: e15.repeatType, repeatDelay: e15.repeatDelay }, h14 = e15.startGroup || 0) : (o15 = $(e15), c12 = {}, h14 = 0);
    const u11 = new a8(r12, this._requestRender, c12, h14);
    return this._addItemToMosaic(t18, [u11.width, u11.height], { type: "animated", data: u11 }, o15, false, false);
  }
  async _handleImage(e15, t18, i13) {
    const r12 = e15.url;
    if (A5(r12) || G3(r12)) return this._handleGIFOrPNG(e15, t18, i13);
    if ("animated" === e15.type) return b4("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
    try {
      let s14;
      const a10 = this.resourceManager.getResource(r12);
      if (null != a10 && a10 instanceof HTMLImageElement) s14 = a10;
      else {
        const { data: e16 } = await this._imageRequestQueue.push(r12, { ...i13 });
        s14 = e16;
      }
      if (y2(r12)) {
        if ("width" in e15 && "height" in e15) s14.width = u4(e15.width), s14.height = u4(e15.height);
        else if ("cim" in e15) {
          const t19 = e15;
          s14.width = u4(t19.width ?? t19.scaleX * t19.size), s14.height = u4(t19.size);
        }
      }
      if (!s14.width || !s14.height) return null;
      const n14 = s14.width, o15 = s14.height, h14 = "colorSubstitutions" in e15 ? e15.colorSubstitutions : void 0, { size: u11, sdf: l13, image: p5 } = this._rasterizer.rasterizeImageResource(n14, o15, s14, h14);
      return this._addItemToMosaic(t18, u11, { type: "static", data: p5 }, $(e15), l13, false);
    } catch (b5) {
      if (!b(b5)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${r12}. ${b5.message}`);
      throw b5;
    }
  }
  _addItemToMosaic(e15, t18, i13, s14, r12, a10, n14) {
    return this._spriteMosaic.addSpriteItem(e15, t18, i13, s14, r12, a10, n14);
  }
};
function $(e15) {
  switch (e15.type) {
    case "CIMVectorMarker":
    case "CIMPictureMarker":
      return B2(e15);
    default:
      return true;
  }
}
var k = (e15) => null != e15 && e15.startsWith("data:image/gif");
var A5 = (e15) => e15 && (e15.includes(".gif") || k(e15));
var F3 = (e15) => null != e15 && e15.startsWith("data:image/png");
var G3 = (e15) => e15 && (e15.includes(".png") || F3(e15));
var B2 = (e15) => e15 && "markerPlacement" in e15 && e15.markerPlacement && "CIMMarkerPlacementInsidePolygon" === e15.markerPlacement.type;

// ../node_modules/@arcgis/core/views/2d/engine/webgl/TextureUploadManager.js
var r9 = class {
  constructor(e15) {
    this._queue = [], this._refreshable = e15;
  }
  destroy() {
    this._queue = [];
  }
  enqueueTextureUpdate(o15, r12) {
    const n14 = L(), h14 = o15, i13 = Ut, a10 = Math.ceil(h14.height / i13);
    s3(r12);
    for (let e15 = 0; e15 < a10; e15++) {
      const t18 = e15 * i13, s14 = e15 === a10 - 1, u11 = s14 ? h14.height - i13 * e15 : i13;
      this._queue.push({ type: "chunk", request: o15, resolver: n14, chunk: e15, chunkOffset: t18, destHeight: u11, chunkIsLast: s14, options: r12 });
    }
    return w(r12, (e15) => n14.reject(e15)), n14.promise;
  }
  upload() {
    let e15 = 0;
    for (; this._queue.length; ) {
      const t18 = performance.now(), s14 = this._queue.shift();
      if (s14) {
        if (null != s14.options.signal && s14.options.signal.aborted) continue;
        switch (s14.type) {
          case "chunk":
            this._uploadChunk(s14);
            break;
          case "no-chunk":
            this._uploadNoChunk(s14);
        }
        const u11 = performance.now() - t18;
        if (e15 += u11, e15 + u11 >= ut) break;
      }
    }
    this._queue.length && this._refreshable.requestRender();
  }
  _uploadChunk(e15) {
    const { request: t18, resolver: s14, chunkOffset: o15, chunkIsLast: u11, destHeight: r12 } = e15, { data: n14, texture: h14, width: i13 } = t18;
    null != n14 && (h14.updateData(0, 0, o15, i13, r12, n14, o15), u11 && s14.resolve());
  }
  _uploadNoChunk(e15) {
    const { request: t18, resolver: s14 } = e15, { data: o15, texture: u11 } = t18;
    u11.setData(o15), s14.resolve();
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/WorldExtentClipRenderer.js
var f7 = r4(-0.5, -0.5);
var u7 = class {
  constructor() {
    this._centerNdc = n2(), this._pxToNdc = n2(), this._worldDimensionsPx = n2(), this._mat3 = e6(), this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._quad = r2(this._quad);
  }
  render(t18, i13, e15) {
    const { context: r12 } = t18, s14 = this._updateGeometry(t18, e15);
    if (null != i13) {
      const { r: t19, g: e16, b: s15, a: o15 } = i13;
      r12.setClearColor(o15 * t19 / 255, o15 * e16 / 255, o15 * s15 / 255, o15);
    } else r12.setClearColor(0, 0, 0, 0);
    if (r12.setStencilFunction(O2.ALWAYS, 0, 255), r12.setStencilWriteMask(255), !s14) return r12.setClearStencil(1), void r12.clear(r12.gl.STENCIL_BUFFER_BIT | r12.gl.COLOR_BUFFER_BIT);
    r12.setClearStencil(0), r12.clear(r12.gl.STENCIL_BUFFER_BIT | r12.gl.COLOR_BUFFER_BIT), this._initialized || this._initialize(r12), r12.setDepthWriteEnabled(false), r12.setDepthTestEnabled(false), r12.setColorMask(false, false, false, false), r12.setBlendingEnabled(false), r12.setStencilOp(I2.KEEP, I2.KEEP, I2.REPLACE), r12.setStencilFunction(O2.ALWAYS, 1, 255), r12.setStencilTestEnabled(true), r12.useProgram(this._program), this._program.setUniformMatrix3fv("u_worldExtent", this._mat3), this._quad.draw(), this._quad.unbind();
  }
  _initialize(t18) {
    if (this._initialized) return;
    const i13 = e8(t18, r5);
    i13 && (this._program = i13, this._quad = new h6(t18, [0, 0, 1, 0, 0, 1, 1, 1]), this._initialized = true);
  }
  _updateGeometry(t18, a10) {
    const { state: n14, pixelRatio: m7 } = t18, { size: c12, rotation: h14 } = n14, _5 = Math.round(c12[0] * m7), d5 = Math.round(c12[1] * m7);
    if (!n14.spatialReference.isWrappable) return false;
    const p5 = u3(h14), u11 = Math.abs(Math.cos(p5)), g4 = Math.abs(Math.sin(p5)), b5 = Math.round(_5 * u11 + d5 * g4), x3 = Math.round(m7 * n14.worldScreenWidth);
    if (b5 <= x3) return false;
    const E5 = _5 * g4 + d5 * u11, S2 = (a10.left - a10.right) * m7 / _5, C3 = (a10.bottom - a10.top) * m7 / d5;
    o4(this._worldDimensionsPx, x3, E5, 1), o4(this._pxToNdc, 2 / _5, -2 / d5, 1), o4(this._centerNdc, S2, C3, 1);
    const T6 = this._mat3;
    return l3(T6, this._centerNdc), f3(T6, T6, this._pxToNdc), 0 !== h14 && h3(T6, T6, p5), f3(T6, T6, this._worldDimensionsPx), M(T6, T6, f7), true;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/Effect.js
var t15 = class {
  constructor() {
    this.name = this.constructor.name;
  }
  createOptions(t18, r12) {
    return null;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/AnimationEffect.js
var i10 = class extends t15 {
  constructor() {
    super(...arguments), this.defines = [], this._desc = { vsPath: "fx/integrate", fsPath: "fx/integrate", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) };
  }
  dispose() {
    this._quad && this._quad.dispose();
  }
  bind() {
  }
  unbind() {
  }
  draw(r12, i13) {
    if (!(i13 == null ? void 0 : i13.size)) return;
    const { context: n14, renderingOptions: o15 } = r12;
    this._quad || (this._quad = new h6(n14, [0, 0, 1, 0, 0, 1, 1, 1]));
    const a10 = n14.getBoundFramebufferObject(), { x: s14, y: u11, width: m7, height: d5 } = n14.getViewport(), f9 = i13.getBlock(L4.Animation);
    if (null == f9) return;
    const l13 = i13.getUniforms(n14);
    n14.setViewport(0, 0, i13.size, i13.size);
    const c12 = l13.filterFlags, x3 = l13.animation, p5 = has("featurelayer-animation-enabled") ? o15.labelsAnimationTime : 1, _5 = f9.getFBO(n14, 1);
    n14.unbindTexture(_5.colorTexture), this._computeDelta(r12, _5, x3, c12, p5);
    const g4 = f9.getFBO(n14);
    n14.unbindTexture(g4.colorTexture), this._updateAnimationState(r12, _5, g4), n14.bindFramebuffer(a10), n14.setViewport(s14, u11, m7, d5);
  }
  _computeDelta(e15, t18, r12, i13, n14) {
    const { context: o15, painter: a10, displayLevel: s14 } = e15, u11 = a10.materialManager.getProgram(this._desc, ["delta"]);
    if (o15.bindFramebuffer(t18), o15.setColorMask(true, true, true, true), o15.setClearColor(0, 0, 0, 0), o15.clear(o15.gl.COLOR_BUFFER_BIT), o15.useProgram(u11), !("type" in i13.texture) || !("type" in r12.texture)) throw new Error("InternalError: Expected to find texture");
    o15.bindTexture(i13.texture, i13.unit), o15.bindTexture(r12.texture, r12.unit), u11.setUniform1i("u_maskTexture", i13.unit), u11.setUniform1i("u_sourceTexture", r12.unit), u11.setUniform1f("u_timeDelta", e15.deltaTime), u11.setUniform1f("u_animationTime", n14), u11.setUniform1f("u_zoomLevel", Math.round(10 * s14)), this._quad.draw();
  }
  _updateAnimationState(e15, t18, r12) {
    const { context: i13, painter: n14 } = e15, o15 = n14.materialManager.getProgram(this._desc, ["update"]);
    i13.bindTexture(t18.colorTexture, 1), i13.useProgram(o15), o15.setUniform1i("u_sourceTexture", 1), i13.bindFramebuffer(r12), i13.setColorMask(true, true, true, true), i13.setClearColor(0, 0, 0, 0), i13.clear(i13.gl.COLOR_BUFFER_BIT), this._quad.draw();
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BlendPrograms.js
var r10 = (e15) => e15.replace("-", "_").toUpperCase();
var t16 = (e15) => `#define ${r10(e15)}
`;
function n11(r12) {
  return { attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]), shaders: { vertexShader: t16(r12) + n5("blend/blend.vert"), fragmentShader: t16(r12) + n5("blend/blend.frag") } };
}

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var c8 = () => n.getLogger("esri.views.2d.engine.webgl.effects.blendEffects.BlendEffect");
var m5 = class {
  constructor() {
    this._size = [0, 0];
  }
  dispose(e15) {
    this._backBufferTexture = r2(this._backBufferTexture), this._quad = r2(this._quad);
  }
  draw(r12, t18, i13, a10, d5) {
    const { context: u11, drawPhase: f9 } = r12;
    if (this._setupShader(u11), a10 && "normal" !== a10 && f9 !== E4.LABEL) return void this._drawBlended(r12, t18, i13, a10, d5);
    const m7 = n11("normal"), h14 = u11.programCache.acquire(m7.shaders.vertexShader, m7.shaders.fragmentShader, m7.attributes);
    if (!h14) return void c8().error(new s2("mapview-BlendEffect", 'Error creating shader program for blend mode "normal"'));
    u11.useProgram(h14), t18.setSamplingMode(i13), u11.bindTexture(t18, 0), h14.setUniform1i("u_layerTexture", 0), h14.setUniform1f("u_opacity", d5), u11.setBlendingEnabled(true), u11.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA);
    const l13 = this._quad;
    l13.draw(), l13.unbind(), h14.dispose();
  }
  _drawBlended(r12, t18, s14, i13, a10) {
    const { context: d5, state: u11, pixelRatio: f9, inFadeTransition: m7 } = r12, { size: h14 } = u11, l13 = d5.getBoundFramebufferObject();
    let _5, p5;
    null != l13 ? (_5 = l13.width, p5 = l13.height) : (_5 = Math.round(f9 * h14[0]), p5 = Math.round(f9 * h14[1])), this._createOrResizeTexture(r12, _5, p5);
    const b5 = this._backBufferTexture;
    l13.copyToTexture(0, 0, _5, p5, 0, 0, b5), d5.setStencilTestEnabled(false), d5.setStencilWriteMask(0), d5.setBlendingEnabled(true), d5.setDepthTestEnabled(false), d5.setDepthWriteEnabled(false);
    const g4 = n11(i13), x3 = d5.programCache.acquire(g4.shaders.vertexShader, g4.shaders.fragmentShader, g4.attributes);
    if (!x3) return void c8().error(new s2("mapview-BlendEffect", `Error creating shader program for blend mode ${i13}`));
    d5.useProgram(x3), b5.setSamplingMode(s14), d5.bindTexture(b5, 0), x3.setUniform1i("u_backbufferTexture", 0), t18.setSamplingMode(s14), d5.bindTexture(t18, 1), x3.setUniform1i("u_layerTexture", 1), x3.setUniform1f("u_opacity", a10), x3.setUniform1f("u_inFadeOpacity", m7 ? 1 : 0), d5.setBlendFunction(R2.ONE, R2.ZERO);
    const T6 = this._quad;
    T6.draw(), T6.unbind(), x3.dispose(), d5.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA);
  }
  _setupShader(e15) {
    this._quad || (this._quad = new h6(e15, [-1, -1, 1, -1, -1, 1, 1, 1]));
  }
  _createOrResizeTexture(e15, r12, t18) {
    const { context: s14 } = e15;
    if (null === this._backBufferTexture || r12 !== this._size[0] || t18 !== this._size[1]) {
      if (this._backBufferTexture) this._backBufferTexture.resize(r12, t18);
      else {
        const e16 = new e4();
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.width = r12, e16.height = t18, this._backBufferTexture = new c2(s14, e16);
      }
      this._size[0] = r12, this._size[1] = t18;
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/FeatureEffect.js
var s11 = class extends t15 {
  constructor(e15) {
    super(), this.name = this.constructor.name, this.defines = [e15];
  }
  dispose() {
  }
  bind({ context: e15, painter: t18 }) {
    this._prev = e15.getBoundFramebufferObject();
    const s14 = t18.getFbos().effect0;
    e15.bindFramebuffer(s14), e15.setColorMask(true, true, true, true), e15.setClearColor(0, 0, 0, 0), e15.clear(e15.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  draw(e15, s14) {
    const { context: r12, painter: o15 } = e15, n14 = o15.getPostProcessingEffects(s14), c12 = r12.getBoundFramebufferObject();
    for (const { postProcessingEffect: t18, effect: f9 } of n14) t18.draw(e15, c12, f9);
    r12.bindFramebuffer(this._prev), r12.setStencilTestEnabled(false), o15.blitTexture(r12, c12.colorTexture, L3.NEAREST), r12.setStencilTestEnabled(true);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightRenderer.js
var c9 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.quadGeometry.dispose(), this._resources.quadVAO.dispose(), this._resources.highlightProgram.dispose(), this._resources.blurProgram.dispose(), this._resources = null);
  }
  preBlur(e15, i13) {
    e15.bindTexture(i13, H), e15.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [1, 0, 1 / this._width, 0]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", t7), e15.bindVAO(this._resources.quadVAO), e15.drawArrays(E2.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  finalBlur(e15, s14) {
    e15.bindTexture(s14, H), e15.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [0, 1, 0, 1 / this._height]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", i6), e15.bindVAO(this._resources.quadVAO), e15.drawArrays(E2.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  renderHighlight(e15, s14, i13) {
    e15.bindTexture(s14, H), e15.useProgram(this._resources.highlightProgram), i13.applyHighlightOptions(e15, this._resources.highlightProgram), e15.bindVAO(this._resources.quadVAO), e15.setBlendingEnabled(true), e15.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), e15.drawArrays(E2.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  _initialize(s14, i13, a10) {
    this._width = i13, this._height = a10;
    const m7 = c.createVertex(s14, F.STATIC_DRAW, new Int8Array([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]).buffer), c12 = new o8(s14, /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]), { geometry: [new t2("a_position", 2, C.BYTE, 0, 4), new t2("a_texcoord", 2, C.UNSIGNED_BYTE, 2, 4)] }, { geometry: m7 }), f9 = e8(s14, t9), b5 = e8(s14, r6);
    s14.useProgram(f9), f9.setUniform1i("u_texture", H), f9.setUniform1i("u_shade", I3), f9.setUniform1f("u_sigma", o9), s14.useProgram(b5), b5.setUniform1i("u_texture", H), b5.setUniform1f("u_sigma", o9), this._resources = { quadGeometry: m7, quadVAO: c12, highlightProgram: f9, blurProgram: b5 };
  }
  setup(r12, e15, s14) {
    this._resources ? (this._width = e15, this._height = s14) : this._initialize(r12, e15, s14);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightSurfaces.js
function i11(i13, h14, u11) {
  const l13 = new e4(h14, u11);
  return l13.wrapMode = D.CLAMP_TO_EDGE, new E3(i13, l13, new i2(B.STENCIL_INDEX8, h14, u11));
}
var h10 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.sharedBlur1Fbo.dispose(), this._resources.sharedBlur2Fbo.dispose(), this._resources = null);
  }
  _initialize(r12, e15, s14) {
    this._width = e15, this._height = s14;
    const t18 = i11(r12, e15, s14), o15 = i11(r12, e15, s14);
    this._resources = { sharedBlur1Fbo: t18, sharedBlur2Fbo: o15 };
  }
  setup(r12, e15, s14) {
    !this._resources || this._width === e15 && this._height === s14 || this.dispose(), this._resources || this._initialize(r12, e15, s14);
  }
  get sharedBlur1Tex() {
    return this._resources.sharedBlur1Fbo.colorTexture;
  }
  get sharedBlur1Fbo() {
    return this._resources.sharedBlur1Fbo;
  }
  get sharedBlur2Tex() {
    return this._resources.sharedBlur2Fbo.colorTexture;
  }
  get sharedBlur2Fbo() {
    return this._resources.sharedBlur2Fbo;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/HighlightEffect.js
var h11 = 4;
var d4 = 4 / h11;
var l10 = class extends t15 {
  constructor() {
    super(...arguments), this.defines = ["highlight"], this._hlRenderer = new c9(), this._width = void 0, this._height = void 0, this._boundFBO = null, this._hlSurfaces = new h10(), this._adjustedWidth = void 0, this._adjustedHeight = void 0, this._blitRenderer = new _2();
  }
  dispose() {
    var _a, _b;
    (_a = this._hlSurfaces) == null ? void 0 : _a.dispose(), (_b = this._hlRenderer) == null ? void 0 : _b.dispose(), this._boundFBO = null;
  }
  bind(e15) {
    const { context: t18, painter: s14 } = e15, { width: r12, height: i13 } = t18.getViewport(), h14 = s14.getFbos().effect0;
    this.setup(e15, r12, i13), t18.bindFramebuffer(h14), t18.setColorMask(true, true, true, true), t18.setClearColor(0, 0, 0, 0), t18.clear(t18.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  setup({ context: e15 }, t18, s14) {
    this._width = t18, this._height = s14;
    const r12 = t18 % h11, i13 = s14 % h11;
    t18 += r12 < h11 / 2 ? -r12 : h11 - r12, s14 += i13 < h11 / 2 ? -i13 : h11 - i13, this._adjustedWidth = t18, this._adjustedHeight = s14, this._boundFBO = e15.getBoundFramebufferObject();
    const l13 = Math.round(t18 * d4), o15 = Math.round(s14 * d4);
    this._hlRenderer.setup(e15, l13, o15), this._hlSurfaces.setup(e15, l13, o15);
  }
  draw(e15) {
    const { context: t18, passOptions: s14 } = e15, r12 = s14.activeGradient, h14 = t18.getBoundFramebufferObject();
    t18.setViewport(0, 0, this._adjustedWidth * d4, this._adjustedHeight * d4), t18.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t18.setStencilTestEnabled(false), t18.setClearColor(0, 0, 0, 0), t18.clear(t18.gl.COLOR_BUFFER_BIT), this._blitRenderer.render(t18, h14.colorTexture, L3.NEAREST, 1), t18.setStencilTestEnabled(false), t18.setBlendingEnabled(false), t18.setColorMask(false, false, false, true), t18.bindFramebuffer(this._hlSurfaces.sharedBlur2Fbo), t18.setClearColor(0, 0, 0, 0), t18.clear(t18.gl.COLOR_BUFFER_BIT), this._hlRenderer.preBlur(t18, this._hlSurfaces.sharedBlur1Tex), t18.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t18.setClearColor(0, 0, 0, 0), t18.clear(t18.gl.COLOR_BUFFER_BIT), this._hlRenderer.finalBlur(t18, this._hlSurfaces.sharedBlur2Tex), t18.bindFramebuffer(this._boundFBO), t18.setBlendingEnabled(true), t18.setColorMask(true, true, true, true), t18.setViewport(0, 0, this._width, this._height), this._hlRenderer.renderHighlight(t18, this._hlSurfaces.sharedBlur1Tex, r12), this._boundFBO = null;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffect.js
var c10 = class extends t15 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["hittest"];
  }
  dispose() {
    null != this._fbo && this._fbo.dispose();
  }
  createOptions({ pixelRatio: t18 }, r12) {
    if (!r12.length) return null;
    const n14 = r12.shift(), l13 = n14.x, c12 = n14.y;
    this._outstanding = n14;
    const a10 = has("esri-mobile");
    return { type: "hittest", distance: (a10 ? S : T3) * t18, smallSymbolDistance: (a10 ? S : W) * t18, smallSymbolSizeThreshold: X, position: [l13, c12] };
  }
  bind(e15) {
    const { context: s14, attributeView: i13 } = e15;
    if (!i13.size) return;
    const o15 = i13.getBlock(L4.GPGPU);
    if (null == o15) return;
    const r12 = o15.getFBO(s14);
    s14.setViewport(0, 0, i13.size, i13.size), s14.bindFramebuffer(r12), s14.setColorMask(true, true, true, true), s14.setClearColor(0, 0, 0, 0), s14.clear(s14.gl.COLOR_BUFFER_BIT | s14.gl.DEPTH_BUFFER_BIT);
  }
  unbind() {
  }
  draw(t18) {
    if (null == this._outstanding) return;
    const e15 = this._outstanding;
    this._outstanding = null, this._resolve(t18, e15.resolvers);
  }
  async _resolve(e15, s14) {
    const { context: i13, attributeView: o15 } = e15, r12 = o15.getBlock(L4.GPGPU);
    if (null == r12) return void s14.forEach((t18) => t18.resolve([]));
    const c12 = r12.getFBO(i13), a10 = new Uint8Array(c12.width * c12.height * 4);
    try {
      await c12.readPixelsAsync(0, 0, c12.width, c12.height, G.RGBA, U2.UNSIGNED_BYTE, a10);
    } catch (u11) {
      return void s14.forEach((t18) => t18.resolve([]));
    }
    const h14 = [];
    for (let t18 = 0; t18 < a10.length; t18 += 4) {
      const e16 = t18 / 4;
      a10[t18] && h14.push(e16);
    }
    s14.forEach((t18) => t18.resolve(h14));
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Bloom.js
var a9 = 5;
var u8 = [1, 0];
var l11 = [0, 1];
var m6 = [1, 0.8, 0.6, 0.4, 0.2];
var _3 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var h12 = class {
  constructor() {
    this._intensityFBO = null, this._compositeFBO = null, this._mipsFBOs = new Array(a9), this._nMips = a9, this._kernelSizeArray = [3, 5, 7, 9, 11], this._size = [0, 0], this._programDesc = { luminosityHighPass: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/luminosityHighPass", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    if (this._quad = r2(this._quad), this._intensityFBO = r2(this._intensityFBO), this._compositeFBO = r2(this._compositeFBO), this._mipsFBOs) {
      for (let t18 = 0; t18 < this._nMips; t18++) this._mipsFBOs[t18] && (this._mipsFBOs[t18].horizontal.dispose(), this._mipsFBOs[t18].vertical.dispose());
      this._mipsFBOs = null;
    }
  }
  draw(t18, i13, r12) {
    const { width: o15, height: n14 } = i13, { context: h14, painter: p5 } = t18, { materialManager: c12 } = p5, d5 = h14.gl, f9 = this._programDesc, { strength: b5, radius: F4, threshold: O3 } = r12;
    this._quad || (this._quad = new h6(h14, [-1, -1, 1, -1, -1, 1, 1, 1])), this._createOrResizeResources(t18, o15, n14), h14.setStencilTestEnabled(false), h14.setBlendingEnabled(true), h14.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), h14.setStencilWriteMask(0);
    const B3 = this._quad;
    B3.bind(), h14.bindFramebuffer(this._intensityFBO);
    const g4 = c12.getProgram(f9.luminosityHighPass);
    h14.useProgram(g4), h14.bindTexture(i13.colorTexture, 0), g4.setUniform1i("u_texture", 0), g4.setUniform3fv("u_defaultColor", [0, 0, 0]), g4.setUniform1f("u_defaultOpacity", 0), g4.setUniform1f("u_luminosityThreshold", O3), g4.setUniform1f("u_smoothWidth", 0.01);
    const T6 = [Math.round(o15 / 2), Math.round(n14 / 2)];
    h14.setViewport(0, 0, T6[0], T6[1]), h14.setClearColor(0, 0, 0, 0), h14.clear(d5.COLOR_BUFFER_BIT), B3.draw(), h14.setBlendingEnabled(false);
    let x3 = this._intensityFBO.colorTexture;
    for (let e15 = 0; e15 < this._nMips; e15++) {
      const t19 = c12.getProgram(f9.gaussianBlur, [{ name: "radius", value: this._kernelSizeArray[e15] }]);
      h14.useProgram(t19), h14.bindTexture(x3, e15 + 1), t19.setUniform1i("u_colorTexture", e15 + 1), t19.setUniform2fv("u_texSize", T6), t19.setUniform2fv("u_direction", u8), h14.setViewport(0, 0, T6[0], T6[1]);
      const s14 = this._mipsFBOs[e15];
      h14.bindFramebuffer(s14.horizontal), B3.draw(), x3 = s14.horizontal.colorTexture, h14.bindFramebuffer(s14.vertical), h14.bindTexture(x3, e15 + 1), t19.setUniform2fv("u_direction", l11), B3.draw(), x3 = s14.vertical.colorTexture, T6[0] = Math.round(T6[0] / 2), T6[1] = Math.round(T6[1] / 2);
    }
    h14.setViewport(0, 0, o15, n14);
    const w6 = c12.getProgram(f9.composite, [{ name: "nummips", value: a9 }]);
    h14.bindFramebuffer(this._compositeFBO), h14.useProgram(w6), w6.setUniform1f("u_bloomStrength", b5), w6.setUniform1f("u_bloomRadius", F4), w6.setUniform1fv("u_bloomFactors", m6), w6.setUniform3fv("u_bloomTintColors", _3), h14.bindTexture(this._mipsFBOs[0].vertical.colorTexture, 1), w6.setUniform1i("u_blurTexture1", 1), h14.bindTexture(this._mipsFBOs[1].vertical.colorTexture, 2), w6.setUniform1i("u_blurTexture2", 2), h14.bindTexture(this._mipsFBOs[2].vertical.colorTexture, 3), w6.setUniform1i("u_blurTexture3", 3), h14.bindTexture(this._mipsFBOs[3].vertical.colorTexture, 4), w6.setUniform1i("u_blurTexture4", 4), h14.bindTexture(this._mipsFBOs[4].vertical.colorTexture, 5), w6.setUniform1i("u_blurTexture5", 5), B3.draw(), h14.bindFramebuffer(i13), h14.setBlendingEnabled(true);
    const M3 = c12.getProgram(f9.blit);
    h14.useProgram(M3), h14.bindTexture(this._compositeFBO.colorTexture, 6), M3.setUniform1i("u_texture", 6), h14.setBlendFunction(R2.ONE, R2.ONE), B3.draw(), B3.unbind(), h14.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), h14.setStencilTestEnabled(true);
  }
  _createOrResizeResources(t18, e15, s14) {
    const { context: a10 } = t18;
    if (this._compositeFBO && this._size[0] === e15 && this._size[1] === s14) return;
    this._size[0] = e15, this._size[1] = s14;
    const u11 = [Math.round(e15 / 2), Math.round(s14 / 2)];
    if (this._compositeFBO) this._compositeFBO.resize(e15, s14);
    else {
      const t19 = new e4(e15, s14);
      t19.internalFormat = G.RGBA, t19.wrapMode = D.CLAMP_TO_EDGE, this._compositeFBO = new E3(a10, t19);
    }
    if (this._intensityFBO) this._intensityFBO.resize(u11[0], u11[1]);
    else {
      const t19 = new e4(u11[0], u11[1]);
      t19.internalFormat = G.RGBA, t19.wrapMode = D.CLAMP_TO_EDGE, this._intensityFBO = new E3(a10, t19);
    }
    for (let l13 = 0; l13 < this._nMips; l13++) {
      if (this._mipsFBOs[l13]) this._mipsFBOs[l13].horizontal.resize(u11[0], u11[1]), this._mipsFBOs[l13].vertical.resize(u11[0], u11[1]);
      else {
        const t19 = new e4(u11[0], u11[1]);
        t19.internalFormat = G.RGBA, t19.wrapMode = D.CLAMP_TO_EDGE, this._mipsFBOs[l13] = { horizontal: new E3(a10, t19), vertical: new E3(a10, t19) };
      }
      u11[0] = Math.round(u11[0] / 2), u11[1] = Math.round(u11[1] / 2);
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Blur.js
var n12 = [1, 0];
var o14 = [0, 1];
var u9 = class {
  constructor() {
    this._blurFBO = null, this._size = [0, 0], this._programDesc = { gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, radialBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/radial-blur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._blurFBO && (this._blurFBO.dispose(), this._blurFBO = null);
  }
  draw(t18, s14, r12) {
    const { context: i13 } = t18, { type: a10, radius: n14 } = r12;
    if (0 === n14) return;
    this._createOrResizeResources(t18), this._quad || (this._quad = new h6(i13, [-1, -1, 1, -1, -1, 1, 1, 1]));
    const o15 = this._quad;
    o15.bind(), "blur" === a10 ? this._gaussianBlur(t18, s14, n14) : this._radialBlur(t18, s14), o15.unbind();
  }
  _gaussianBlur(e15, s14, r12) {
    const { context: i13, state: a10, painter: u11, pixelRatio: l13 } = e15, { size: d5 } = a10, { materialManager: b5 } = u11, c12 = this._programDesc, _5 = this._quad, p5 = [Math.round(l13 * d5[0]), Math.round(l13 * d5[1])], h14 = this._blurFBO, m7 = b5.getProgram(c12.gaussianBlur, [{ name: "radius", value: Math.ceil(r12) }]);
    i13.useProgram(m7), i13.setBlendingEnabled(false), i13.bindFramebuffer(h14), i13.bindTexture(s14.colorTexture, 4), m7.setUniform1i("u_colorTexture", 4), m7.setUniform2fv("u_texSize", p5), m7.setUniform2fv("u_direction", n12), m7.setUniform1f("u_sigma", r12), _5.draw(), i13.bindFramebuffer(s14), i13.setStencilWriteMask(0), i13.setStencilTestEnabled(false), i13.setDepthWriteEnabled(false), i13.setDepthTestEnabled(false), i13.bindTexture(h14 == null ? void 0 : h14.colorTexture, 5), m7.setUniform1i("u_colorTexture", 5), m7.setUniform2fv("u_direction", o14), _5.draw(), i13.setBlendingEnabled(true), i13.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), i13.setStencilTestEnabled(true);
  }
  _radialBlur(e15, s14) {
    const { context: r12, painter: i13 } = e15, { materialManager: a10 } = i13, n14 = this._programDesc, o15 = this._quad, u11 = this._blurFBO;
    r12.bindFramebuffer(u11);
    const l13 = a10.getProgram(n14.radialBlur);
    r12.useProgram(l13), r12.setBlendingEnabled(false), r12.bindTexture(s14.colorTexture, 4), l13.setUniform1i("u_colorTexture", 4), o15.draw(), r12.bindFramebuffer(s14), r12.setStencilWriteMask(0), r12.setStencilTestEnabled(false), r12.setDepthWriteEnabled(false), r12.setDepthTestEnabled(false), r12.setBlendingEnabled(true);
    const d5 = a10.getProgram(n14.blit);
    r12.useProgram(d5), r12.bindTexture(u11 == null ? void 0 : u11.colorTexture, 5), d5.setUniform1i("u_texture", 5), r12.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), o15.draw();
  }
  _createOrResizeResources(e15) {
    const { context: t18, state: n14, pixelRatio: o15 } = e15, { size: u11 } = n14, l13 = Math.round(o15 * u11[0]), d5 = Math.round(o15 * u11[1]);
    if (!this._blurFBO || this._size[0] !== l13 || this._size[1] !== d5) if (this._size[0] = l13, this._size[1] = d5, this._blurFBO) this._blurFBO.resize(l13, d5);
    else {
      const e16 = new e4(l13, d5);
      e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, this._blurFBO = new E3(t18, e16);
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Colorize.js
var n13 = class {
  constructor() {
    this._layerFBOTexture = null, this._size = [0, 0], this._programDesc = { vsPath: "post-processing/pp", fsPath: "post-processing/filterEffect", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) };
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  draw(e15, t18, s14) {
    const { width: i13, height: o15 } = t18;
    this._createOrResizeResources(e15, i13, o15);
    const { context: a10, painter: n14 } = e15, { materialManager: c12 } = n14, l13 = this._programDesc, u11 = this._quad, _5 = s14.colorMatrix;
    u11.bind();
    const h14 = this._layerFBOTexture;
    a10.bindFramebuffer(t18), t18.copyToTexture(0, 0, i13, o15, 0, 0, h14), a10.setBlendingEnabled(false), a10.setStencilTestEnabled(false);
    const m7 = c12.getProgram(l13);
    a10.useProgram(m7), a10.bindTexture(h14, 2), m7.setUniformMatrix4fv("u_coefficients", _5), m7.setUniform1i("u_colorTexture", 2), u11.draw(), a10.setBlendingEnabled(true), a10.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), a10.setStencilTestEnabled(true), u11.unbind();
  }
  _createOrResizeResources(e15, r12, n14) {
    const { context: c12 } = e15;
    if (!this._layerFBOTexture || this._size[0] !== r12 || this._size[1] !== n14) {
      if (this._size[0] = r12, this._size[1] = n14, this._layerFBOTexture) this._layerFBOTexture.resize(r12, n14);
      else {
        const e16 = new e4();
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.width = r12, e16.height = n14, this._layerFBOTexture = new c2(c12, e16);
      }
      this._quad || (this._quad = new h6(c12, [-1, -1, 1, -1, -1, 1, 1, 1]));
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/DropShadow.js
var u10 = [1, 0];
var h13 = [0, 1];
var _4 = class {
  constructor() {
    this._layerFBOTexture = null, this._horizontalBlurFBO = null, this._verticalBlurFBO = null, this._size = [0, 0], this._quad = null, this._programDesc = { blur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/drop-shadow/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture), this._horizontalBlurFBO = r2(this._horizontalBlurFBO), this._verticalBlurFBO = r2(this._verticalBlurFBO);
  }
  draw(e15, i13, o15) {
    const { context: a10, state: n14, painter: l13 } = e15, { materialManager: _5 } = l13, c12 = this._programDesc, p5 = i13.width, m7 = i13.height, f9 = [Math.round(p5), Math.round(m7)], { blurRadius: B3, offsetX: d5, offsetY: b5, color: O3 } = o15, F4 = [u4(d5), u4(b5)];
    this._createOrResizeResources(e15, p5, m7, f9);
    const w6 = this._horizontalBlurFBO, T6 = this._verticalBlurFBO;
    a10.setStencilWriteMask(0), a10.setStencilTestEnabled(false), a10.setDepthWriteEnabled(false), a10.setDepthTestEnabled(false);
    const x3 = this._layerFBOTexture;
    i13.copyToTexture(0, 0, p5, m7, 0, 0, x3), this._quad || (this._quad = new h6(a10, [-1, -1, 1, -1, -1, 1, 1, 1])), a10.setViewport(0, 0, f9[0], f9[1]);
    const g4 = this._quad;
    g4.bind(), a10.setBlendingEnabled(false);
    const z = _5.getProgram(c12.blur, [{ name: "radius", value: Math.ceil(B3) }]);
    a10.useProgram(z), a10.bindFramebuffer(w6), a10.bindTexture(i13.colorTexture, 4), z.setUniform1i("u_colorTexture", 4), z.setUniform2fv("u_texSize", f9), z.setUniform2fv("u_direction", u10), z.setUniform1f("u_sigma", B3), g4.draw(), a10.bindFramebuffer(T6), a10.bindTexture(w6 == null ? void 0 : w6.colorTexture, 5), z.setUniform1i("u_colorTexture", 5), z.setUniform2fv("u_direction", h13), g4.draw(), a10.bindFramebuffer(i13), a10.setViewport(0, 0, p5, m7);
    const M3 = _5.getProgram(c12.composite);
    a10.useProgram(M3), a10.bindTexture(T6 == null ? void 0 : T6.colorTexture, 2), M3.setUniform1i("u_blurTexture", 2), a10.bindTexture(x3, 3), M3.setUniform1i("u_layerFBOTexture", 3), M3.setUniform4fv("u_shadowColor", [O3[3] * (O3[0] / 255), O3[3] * (O3[1] / 255), O3[3] * (O3[2] / 255), O3[3]]), M3.setUniformMatrix3fv("u_displayViewMat3", n14.displayMat3), M3.setUniform2fv("u_shadowOffset", F4), g4.draw(), a10.setBlendingEnabled(true), a10.setStencilTestEnabled(true), a10.setBlendFunction(R2.ONE, R2.ONE_MINUS_SRC_ALPHA), g4.unbind();
  }
  _createOrResizeResources(e15, t18, r12, s14) {
    const { context: u11 } = e15;
    if (!this._horizontalBlurFBO || this._size[0] !== t18 || this._size[1] !== r12) {
      if (this._size[0] = t18, this._size[1] = r12, this._horizontalBlurFBO) this._horizontalBlurFBO.resize(s14[0], s14[1]);
      else {
        const e16 = new e4(s14[0], s14[1]);
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, this._horizontalBlurFBO = new E3(u11, e16);
      }
      if (this._verticalBlurFBO) this._verticalBlurFBO.resize(s14[0], s14[1]);
      else {
        const e16 = new e4(s14[0], s14[1]);
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, this._verticalBlurFBO = new E3(u11, e16);
      }
      if (this._layerFBOTexture) this._layerFBOTexture.resize(t18, r12);
      else {
        const e16 = new e4();
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.width = t18, e16.height = r12, this._layerFBOTexture = new c2(u11, e16);
      }
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Opacity.js
var l12 = class {
  constructor() {
    this._size = [0, 0], this._layerFBOTexture = null;
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  draw(e15, r12, s14) {
    const { width: i13, height: o15 } = r12;
    this._createOrResizeResources(e15, i13, o15);
    const { context: l13, painter: a10 } = e15, { amount: n14 } = s14, h14 = l13.gl, u11 = this._layerFBOTexture;
    l13.bindFramebuffer(r12), r12.copyToTexture(0, 0, i13, o15, 0, 0, u11), l13.setBlendingEnabled(true), l13.setStencilTestEnabled(false), l13.setDepthTestEnabled(false), l13.setClearColor(0, 0, 0, 0), l13.clear(h14.COLOR_BUFFER_BIT), a10.blitTexture(l13, u11, L3.NEAREST, n14);
  }
  _createOrResizeResources(e15, l13, a10) {
    const { context: n14 } = e15;
    if (!this._layerFBOTexture || this._size[0] !== l13 || this._size[1] !== a10) if (this._size[0] = l13, this._size[1] = a10, this._layerFBOTexture) this._layerFBOTexture.resize(l13, a10);
    else {
      const e16 = new e4();
      e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.samplingMode = L3.NEAREST, e16.width = l13, e16.height = a10, this._layerFBOTexture = new c2(n14, e16);
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/EffectManager.js
function c11(o15) {
  switch (o15) {
    case "bloom":
    case "blur":
    case "opacity":
    case "drop-shadow":
      return o15;
    default:
      return "colorize";
  }
}
var f8 = { colorize: () => new n13(), blur: () => new u9(), bloom: () => new h12(), opacity: () => new l12(), "drop-shadow": () => new _4() };
var i12 = class {
  constructor() {
    this._effectMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._effectMap.forEach((o15) => o15.dispose()), this._effectMap.clear();
  }
  getPostProcessingEffects(o15) {
    if (!o15 || 0 === o15.length) return [];
    const e15 = [];
    for (const t18 of o15) {
      const o16 = c11(t18.type);
      let s14 = this._effectMap.get(o16);
      s14 || (s14 = f8[o16](), this._effectMap.set(o16, s14)), e15.push({ postProcessingEffect: s14, effect: t18 });
    }
    return e15;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/painter/RenderPass.js
var t17 = class {
  constructor(e15, t18) {
    this.brushes = e15, this.name = t18.name, this.drawPhase = t18.drawPhase || E4.MAP, this._targetFn = t18.target, this.effects = t18.effects || [], this.enableDefaultDraw = t18.enableDefaultDraw ?? (() => true), this.forceDrawByDisplayOrder = !!t18.forceDrawByDisplayOrder;
  }
  render(e15) {
    var _a;
    const { context: r12, profiler: t18 } = e15, s14 = this._targetFn(), a10 = this.drawPhase & e15.drawPhase;
    if (t18.recordPassStart(this.name), a10) {
      this.enableDefaultDraw() && this._doRender(e15, s14), t18.recordPassEnd();
      for (const t19 of this.effects) {
        if (!t19.enable()) continue;
        const a11 = t19.apply, n14 = (_a = t19.args) == null ? void 0 : _a.call(t19), i13 = r12.getViewport(), o15 = r12.getBoundFramebufferObject(), d5 = e15.passOptions;
        this._bindEffect(e15, a11, n14), this._doRender(e15, s14, a11.defines), this._drawAndUnbindEffect(e15, a11, i13, o15, d5, n14);
      }
    }
  }
  _doRender(e15, r12, t18) {
    if (null == r12) return;
    const { profiler: s14, context: a10 } = e15;
    for (const n14 of this.brushes) {
      if (s14.recordBrushStart(n14.name), null != n14.brushEffect) {
        const s15 = a10.getViewport(), i13 = a10.getBoundFramebufferObject(), o15 = e15.passOptions;
        this._bindEffect(e15, n14.brushEffect), this._drawWithBrush(n14, e15, r12, t18), this._drawAndUnbindEffect(e15, n14.brushEffect, s15, i13, o15);
      } else this._drawWithBrush(n14, e15, r12, t18);
      s14.recordBrushEnd();
    }
  }
  _drawWithBrush(r12, t18, s14, a10) {
    m(s14) ? (r12.prepareState(t18, a10), r12.drawMany(t18, s14, a10)) : s14.visible && (r12.prepareState(t18, a10), r12.draw(t18, s14, a10));
  }
  _bindEffect(e15, r12, t18) {
    const { profiler: s14 } = e15;
    s14.recordPassStart(this.name + "." + r12.name), r12.bind(e15, t18);
    const a10 = r12.createOptions(e15, t18);
    e15.passOptions = a10;
  }
  _drawAndUnbindEffect(e15, r12, t18, s14, a10, n14) {
    const { profiler: i13, context: o15 } = e15;
    e15.passOptions = a10, i13.recordBrushStart(r12.name), r12.draw(e15, n14), r12.unbind(e15, n14), o15.bindFramebuffer(s14);
    const { x: d5, y: f9, width: h14, height: c12 } = t18;
    o15.setViewport(d5, f9, h14, c12), i13.recordBrushEnd(), i13.recordPassEnd();
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TechniqueProgramCache.js
var r11 = class {
  constructor() {
    this._programCache = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const r12 of this._programCache.values()) r12.destroy();
    this._programCache.clear();
  }
  getProgram(r12, e15, t18, a10, o15) {
    const s14 = r12.getShaderKey(e15, t18, a10, o15);
    let c12 = this._programCache.get(s14);
    return c12 || (c12 = r12.getProgram(e15, t18, a10, o15), this._programCache.set(s14, c12)), c12;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/Painter.js
var A6 = class {
  constructor(e15, t18) {
    this.context = e15, this._currentPipelineStateNeedsUpdate = false, this._blitRenderer = new _2(), this._worldExtentRenderer = new u7(), this._brushCache = /* @__PURE__ */ new Map(), this._lastWidth = null, this._lastHeight = null, this._vtlMaterialManager = new p2(), this._blendEffect = new m5(), this._stencilBuf = null, this._prevBeforeLayerFBOStack = [], this._fboPool = [], this.effects = { highlight: new l10(), hittest: new c10(), integrate: new i10(), insideEffect: new s11("inside"), outsideEffect: new s11("outside") }, this._programCache = new r11(), this._shaderState = { shader: null, uniforms: null, defines: null, optionalAttributes: null, useComputeBuffer: false }, this.materialManager = new e14(e15), this.textureManager = new j2(t18), this.textureUploadManager = new r9(t18), this._effectsManager = new i12(), this._quadMesh = new h6(e15, [0, 0, 1, 0, 0, 1, 1, 1]);
  }
  dispose() {
    if (this._programCache.destroy(), this.materialManager.dispose(), this.textureManager.dispose(), this.textureUploadManager.destroy(), this._blitRenderer = r2(this._blitRenderer), this._worldExtentRenderer = r2(this._worldExtentRenderer), this._quadMesh.dispose(), this._brushCache && (this._brushCache.forEach((e15) => e15.dispose()), this._brushCache.clear(), this._brushCache = null), this._fbos) {
      let e15;
      for (e15 in this._fbos) this._fbos[e15] && this._fbos[e15].dispose();
    }
    for (const e15 of this._fboPool) e15.dispose();
    if (this._fboPool.length = 0, this.effects) {
      let e15;
      for (e15 in this.effects) this.effects[e15] && this.effects[e15].dispose();
    }
    this._effectsManager.dispose(), this._blendEffect.dispose(this.context), this._vtlMaterialManager = r2(this._vtlMaterialManager);
  }
  clearShaderCache() {
    this._programCache.destroy(), this._programCache = new r11();
  }
  get blitRenderer() {
    return this._blitRenderer;
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  getFbos() {
    if (!this._fbos) throw new Error("InternalError: Painter FBOs not initialized");
    return this._fbos;
  }
  acquireFbo(e15, t18) {
    let s14;
    if (this._fboPool.length > 0) s14 = this._fboPool.pop();
    else {
      const r12 = new e4(e15, t18);
      r12.samplingMode = L3.NEAREST, r12.wrapMode = D.CLAMP_TO_EDGE, s14 = new E3(this.context, r12, this._stencilBuf);
    }
    return s14.width === e15 && s14.height === t18 || s14.resize(e15, t18), s14;
  }
  releaseFbo(e15) {
    this._fboPool.push(e15);
  }
  getSharedStencilBuffer() {
    return this._stencilBuf;
  }
  beforeRenderPhases(e15, t18, s14) {
    const { context: r12 } = e15;
    this._worldExtentRenderer.render(e15, t18, s14);
    const { width: i13, height: n14 } = r12.getViewport();
    if (this.updateFBOs(i13, n14), this._prevFBO = r12.getBoundFramebufferObject(), r12.bindFramebuffer(this.getFbos().output), r12.setColorMask(true, true, true, true), null != t18) {
      const { r: e16, g: s15, b: i14, a: n15 } = t18;
      r12.setClearColor(n15 * e16 / 255, n15 * s15 / 255, n15 * i14 / 255, n15);
    } else r12.setClearColor(0, 0, 0, 0);
    r12.setDepthWriteEnabled(true), r12.setClearDepth(1), r12.clear(r12.gl.COLOR_BUFFER_BIT | r12.gl.DEPTH_BUFFER_BIT), r12.setDepthWriteEnabled(false);
  }
  afterRenderPhases(e15) {
    const { context: t18 } = e15;
    t18.bindFramebuffer(this._prevFBO), t18.setStencilFunction(O2.EQUAL, 1, 255), t18.setStencilTestEnabled(true), t18.setDepthTestEnabled(false), this.blitTexture(t18, this.getFbos().output.colorTexture, L3.NEAREST);
  }
  beforeRenderLayer(e15, t18, s14) {
    const { context: r12, blendMode: i13, effects: n14, drawPhase: a10, requireFBO: o15 } = e15;
    if (o15 || N4(a10, i13, n14, s14)) {
      const e16 = r12.getBoundFramebufferObject();
      this._prevBeforeLayerFBOStack.push(e16);
      const { width: t19, height: s15 } = r12.getViewport(), i14 = this.acquireFbo(t19, s15);
      r12.bindFramebuffer(i14), r12.setColorMask(true, true, true, true), r12.setClearColor(0, 0, 0, 0), r12.setDepthWriteEnabled(true), r12.setClearDepth(1), r12.clear(r12.gl.COLOR_BUFFER_BIT | r12.gl.DEPTH_BUFFER_BIT), r12.setDepthWriteEnabled(false);
    }
    r12.setDepthWriteEnabled(false), r12.setDepthTestEnabled(false), r12.setStencilTestEnabled(true), r12.setClearStencil(t18), r12.setStencilWriteMask(255), r12.clear(r12.gl.STENCIL_BUFFER_BIT);
  }
  afterRenderLayer(e15, t18) {
    const { context: s14, blendMode: r12, effects: n14, requireFBO: a10, drawPhase: o15 } = e15;
    if (a10 || N4(o15, r12, n14, t18)) {
      const a11 = s14.getBoundFramebufferObject();
      null != n14 && n14.length > 0 && o15 === E4.MAP && (s14.setColorMask(true, true, true, true), this._applyEffects(e15, n14, a11)), s14.bindFramebuffer(this._prevBeforeLayerFBOStack.pop()), s14.setStencilTestEnabled(false), s14.setStencilWriteMask(0), s14.setBlendingEnabled(true), s14.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA), s14.setColorMask(true, true, true, true);
      const l13 = null == r12 || o15 === E4.HIGHLIGHT ? "normal" : r12;
      this._blendEffect.draw(e15, a11.colorTexture, L3.NEAREST, l13, t18), this.releaseFbo(a11);
    }
  }
  renderObject(e15, s14, r12, i13) {
    const n14 = h7[r12];
    if (!n14) return;
    let a10 = this._brushCache.get(n14);
    void 0 === a10 && (a10 = new n14(), this._brushCache.set(n14, a10)), a10.prepareState(e15), a10.draw(e15, s14, i13);
  }
  renderObjects(e15, s14, r12, i13) {
    const n14 = h7[r12];
    if (!n14) return;
    let a10 = this._brushCache.get(n14);
    void 0 === a10 && (a10 = new n14(), this._brushCache.set(n14, a10)), a10.drawMany(e15, s14, i13);
  }
  registerRenderPass(e15) {
    const t18 = e15.brushes.map((e16) => (this._brushCache.has(e16) || this._brushCache.set(e16, new e16()), this._brushCache.get(e16)));
    return new t17(t18, e15);
  }
  blitTexture(e15, t18, s14, r12 = 1) {
    e15.setBlendingEnabled(true), e15.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA), e15.setColorMask(true, true, true, true), this._blitRenderer.render(e15, t18, s14, r12), this._currentPipelineStateNeedsUpdate = true;
  }
  getPostProcessingEffects(e15) {
    return this._effectsManager.getPostProcessingEffects(e15);
  }
  updateFBOs(e15, t18) {
    if (e15 !== this._lastWidth || t18 !== this._lastHeight) {
      if (this._lastWidth = e15, this._lastHeight = t18, this._fbos) {
        let s15;
        for (s15 in this._fbos) this._fbos[s15].resize(e15, t18);
        return;
      }
      const s14 = new e4(e15, t18);
      s14.samplingMode = L3.NEAREST, s14.wrapMode = D.CLAMP_TO_EDGE;
      const r12 = new i2(B.DEPTH_STENCIL, e15, t18);
      this._stencilBuf = new s4(this.context, r12), this._fbos = { output: new E3(this.context, s14, this._stencilBuf), effect0: new E3(this.context, s14, this._stencilBuf) };
    }
  }
  _applyEffects(e15, t18, s14) {
    const { context: r12 } = e15, i13 = this._effectsManager.getPostProcessingEffects(t18);
    for (const { postProcessingEffect: n14, effect: a10 } of i13) r12.bindFramebuffer(s14), n14.draw(e15, s14, a10);
    this._currentPipelineStateNeedsUpdate = true;
  }
  setShader(e15) {
    this._shaderState.shader = e15.shader, this._shaderState.uniforms = e15.uniforms, this._shaderState.defines = e15.defines, this._shaderState.optionalAttributes = e15.optionalAttributes, this._shaderState.useComputeBuffer = e15.useComputeBuffer ?? false;
  }
  setPipelineState(e15) {
    e15 !== this._currentPipelineState && (this._currentPipelineState = e15, this._currentPipelineStateNeedsUpdate = true);
  }
  submitDraw(e15, t18) {
    const { shader: s14, uniforms: r12, defines: i13, optionalAttributes: n14 } = this._shaderState, a10 = e15.context, o15 = t18.getAttributePrecisionPackFactors(), l13 = this._programCache.getProgram(s14, o15, r12, i13 ?? {}, n14 ?? {});
    return l13.setUniforms(r12), l13.bind(a10), this.updatePipelineState(a10), this.setStencilRef(a10, t18), t18.draw(e15, s14.locationInfo), l13.cleanupTemporaryTextures(), { vertexShader: l13.vertexShader, fragmentShader: l13.fragmentShader };
  }
  submitDrawQuad(e15) {
    const { shader: t18, uniforms: s14, defines: r12, optionalAttributes: i13 } = this._shaderState, n14 = this._programCache.getProgram(t18, {}, s14, r12 ?? {}, i13 ?? {});
    n14.setUniforms(s14), n14.bind(e15), this.updatePipelineState(e15), this._quadMesh.draw(), e15.bindVAO(null), n14.cleanupTemporaryTextures();
  }
  submitDrawMesh(e15, t18, s14) {
    const { shader: r12, uniforms: i13, defines: n14, optionalAttributes: a10 } = this._shaderState, o15 = this._programCache.getProgram(r12, {}, i13, n14 ?? {}, a10 ?? {});
    if (o15.setUniforms(i13), o15.bind(e15), this.updatePipelineState(e15), s14) for (const l13 of s14) t18.bind(e15, l13), t18.draw(e15);
    else for (let l13 = 0; l13 < t18.parts.length; l13++) t18.bind(e15, l13), t18.draw(e15);
    t18.unbind(e15), o15.cleanupTemporaryTextures();
  }
  updatePipelineState(e15) {
    this._currentPipelineStateNeedsUpdate && (this._currentPipelineStateNeedsUpdate = false, this._updatePipelineState(e15));
  }
  _updatePipelineState(e15) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { color: t18, depth: s14, stencil: r12 } = this._currentPipelineState;
    if (t18) {
      const { blendMode: s15, write: r13 } = t18;
      switch (e15.setColorMask(...r13), e15.setBlendingEnabled(true), e15.setBlendEquation(T2.ADD), s15) {
        case "composite":
          e15.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA);
          break;
        case "additive":
          e15.setBlendFunctionSeparate(R2.ONE, R2.ONE, R2.ONE, R2.ONE);
          break;
        case "custom": {
          const { blendParameters: s16 } = t18, { dstAlpha: r14, dstRGB: i13, srcAlpha: n14, srcRGB: a10 } = s16;
          e15.setBlendFunctionSeparate(a10, i13, n14, r14);
          break;
        }
        case "delete":
          e15.setBlendEquation(T2.REVERSE_SUBTRACT), e15.setBlendFunctionSeparate(R2.ONE, R2.ONE_MINUS_SRC_ALPHA, R2.ONE, R2.ONE_MINUS_SRC_ALPHA);
      }
    }
    if (s14) {
      const { test: t19, write: r13 } = s14;
      r13 ? (e15.setDepthWriteEnabled(true), e15.setDepthRange(r13.zNear, r13.zFar)) : e15.setDepthWriteEnabled(false), t19 ? (e15.setDepthTestEnabled(true), e15.setDepthFunction(t19)) : e15.setDepthTestEnabled(false);
    } else e15.setDepthTestEnabled(false), e15.setDepthWriteEnabled(false);
    if (r12) {
      const { test: t19, write: s15 } = r12;
      if (t19) {
        const { compare: s16, mask: r13, op: i13, ref: n14 } = t19;
        e15.setStencilTestEnabled(true), "function" != typeof n14 && e15.setStencilFunctionSeparate(N2.FRONT_AND_BACK, s16, n14, r13), e15.setStencilOpSeparate(N2.FRONT_AND_BACK, i13.fail, i13.zFail, i13.zPass);
      } else e15.setStencilTestEnabled(false);
      if (s15) {
        const { mask: t20 } = s15;
        e15.setStencilWriteMask(t20);
      } else e15.setStencilWriteMask(0);
    } else e15.setStencilTestEnabled(false), e15.setStencilWriteMask(0);
  }
  setStencilRef(e15, t18) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { stencil: s14 } = this._currentPipelineState;
    if (s14) {
      const { test: r12 } = s14;
      if (r12) {
        const { compare: s15, mask: i13, ref: n14 } = r12;
        if ("function" == typeof n14) {
          const r13 = t18.getStencilReference();
          if (null === r13) throw new Error("InternalError: Stencil reference expected for target but not defined");
          e15.setStencilFunctionSeparate(N2.FRONT_AND_BACK, s15, r13, i13);
        }
      }
    }
  }
};
function N4(e15, t18, s14, r12) {
  return e15 !== E4.LABEL_ALPHA && e15 !== E4.LABEL && e15 !== E4.HIGHLIGHT && (1 !== r12 || null != t18 && "normal" !== t18 || null != s14 && s14.length > 0);
}

// ../node_modules/@arcgis/core/views/2d/engine/webgl/TileReshuffleManager.js
var s12 = class {
  constructor() {
    this._candidateTiles = [];
  }
  schedule(s14) {
    this._candidateTiles.includes(s14) || this._candidateTiles.push(s14);
  }
  reshuffle(s14) {
    const e15 = [];
    for (const i13 of this._candidateTiles) s14 > 0 ? (i13.reshuffle(), s14--) : e15.push(i13);
    this._candidateTiles = e15;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/Stage.js
var v3 = 2e3;
var q2 = class extends h5 {
  constructor(t18, i13) {
    super(), this.meshWriterRegistry = new W2(), this._trash = /* @__PURE__ */ new Set(), this._renderRemainingTime = 0, this._lastFrameRenderTime = 0, this._renderRequested = r3(false), this.stage = this, this._stationary = true, this._reshuffleManager = new s12(), this._canvas = new l6(t18), this.context = new y3(this._canvas.gl, i13.contextOptions ?? {}), this.painter = new A6(this.context, this), this._cimAnalyzer = new R3(this.painter.textureManager.resourceManager), has("esri-2d-profiler") && (this._debugOutput = document.createElement("div"), this._debugOutput.setAttribute("style", "margin: 24px 64px; position: absolute; color: red;"), t18.appendChild(this._debugOutput));
    const a10 = () => this._highlightGradient;
    this._renderParameters = { drawPhase: 0, state: this.state, pixelRatio: window.devicePixelRatio, stationary: false, globalOpacity: 1, blendMode: null, deltaTime: -1, time: 0, inFadeTransition: false, effects: null, context: this.context, painter: this.painter, timeline: i13.timeline || new e12(), renderingOptions: i13.renderingOptions, requestRender: () => this.requestRender(), allowDelayedRender: false, requireFBO: false, profiler: new n6(this.context, this._debugOutput), dataUploadCounter: 0, get highlightGradient() {
      return a10();
    }, reshuffleManager: this._reshuffleManager, backgroundColor: i13.backgroundColor }, this._taskHandle = A({ render: (e15) => this.renderFrame(e15) }), this._taskHandle.pause(), this._lostWebGLContextHandle = this._canvas.events.on("webgl-context-lost", (t19) => this.emit("webgl-error", { error: new s2("webgl-context-lost", t19.statusMessage) })), this._bufferPool = new i7(), T4();
  }
  destroy() {
    var _a, _b;
    w3(this.context), this.removeAllChildren(), this._emptyTrash(), this._taskHandle = l2(this._taskHandle), this._lostWebGLContextHandle = l2(this._lostWebGLContextHandle), this._canvas.destroy(), (_b = (_a = this._debugOutput) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(this._debugOutput), this._bufferPool.destroy(), this.painter.dispose(), this.context.dispose(), this._canvas = null;
  }
  get textureManager() {
    return this.painter.textureManager;
  }
  get backgroundColor() {
    return this._renderParameters.backgroundColor;
  }
  set backgroundColor(e15) {
    this._renderParameters.backgroundColor = e15, this.requestRender();
  }
  get bufferPool() {
    return this._bufferPool;
  }
  get cimAnalyzer() {
    return this._cimAnalyzer;
  }
  get renderingOptions() {
    return this._renderingOptions;
  }
  set renderingOptions(e15) {
    this._renderingOptions = e15, this.requestRender();
  }
  get renderRequested() {
    return this._renderRequested.value;
  }
  get state() {
    return this._state;
  }
  set state(e15) {
    this._state = e15, this.requestRender();
  }
  get stationary() {
    return this._stationary;
  }
  set stationary(e15) {
    this._stationary !== e15 && (this._stationary = e15, this.requestRender());
  }
  trashDisplayObject(e15) {
    this._trash.add(e15), this.requestRender();
  }
  untrashDisplayObject(e15) {
    return this._trash.delete(e15);
  }
  requestRender() {
    this._renderRemainingTime = v3, this.renderRequested || (this._renderRequested.value = true, this._taskHandle.resume());
  }
  renderFrame(e15) {
    const t18 = this._lastFrameRenderTime ? e15.time - this._lastFrameRenderTime : 0;
    this._renderRemainingTime -= t18, this._renderRemainingTime <= 0 && this._taskHandle.pause(), this._lastFrameRenderTime = e15.time, this._renderRequested.value = false, this._renderParameters.state = this._state, this._renderParameters.stationary = this.stationary, this._renderParameters.pixelRatio = window.devicePixelRatio, this._renderParameters.globalOpacity = 1, this._renderParameters.time = e15.time, this._renderParameters.deltaTime = e15.deltaTime, this._renderParameters.effects = null, this.processRender(this._renderParameters), this._emptyTrash();
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  renderChildren(e15) {
    for (const t18 of this.children) t18.beforeRender(e15);
    this._reshuffleManager.reshuffle(wt), this._canvas.render(e15, () => this._renderChildren(this.children, e15));
    for (const t18 of this.children) t18.afterRender(e15);
  }
  _renderChildren(e15, t18) {
    const r12 = this.context;
    this.painter.textureUploadManager.upload(), r12.resetInfo(), t18.profiler.recordStart("drawLayers"), t18.dataUploadCounter = 0, this.painter.beforeRenderPhases(t18, t18.backgroundColor, this.state.padding), t18.drawPhase = E4.MAP;
    for (const s14 of e15) s14.processRender(t18);
    if (this.children.some((e16) => e16.hasHighlight)) {
      t18.drawPhase = E4.HIGHLIGHT;
      for (const r13 of e15) r13.processRender(t18);
    }
    if (this.children.some((e16) => e16.hasLabels)) {
      t18.drawPhase = E4.LABEL;
      for (const r13 of e15) r13.processRender(t18);
    }
    if (has("esri-tiles-debug")) {
      t18.drawPhase = E4.DEBUG;
      for (const r13 of e15) r13.processRender(t18);
    }
    this.painter.afterRenderPhases(t18), t18.profiler.recordEnd("drawLayers"), r12.logInfo();
  }
  doRender(e15) {
    const t18 = this.context, { state: r12, pixelRatio: s14 } = e15;
    this._canvas.resize(e15), t18.setViewport(0, 0, s14 * r12.size[0], s14 * r12.size[1]), t18.setDepthWriteEnabled(true), t18.setStencilWriteMask(255), this.renderChildren(e15);
  }
  async takeScreenshot(e15, t18, r12, s14) {
    const i13 = Math.round(this.state.size[0] * e15.resolutionScale), n14 = Math.round(this.state.size[1] * e15.resolutionScale), a10 = e15.resolutionScale, o15 = this.context, h14 = this._state.clone();
    if (null != s14) {
      const e16 = h14.viewpoint;
      h14.viewpoint.rotation = s14, h14.viewpoint = e16;
    }
    const d5 = { ...this._renderParameters, drawPhase: null, globalOpacity: 1, stationary: true, state: h14, pixelRatio: a10, time: performance.now(), deltaTime: 0, blendMode: null, effects: null, inFadeTransition: false, backgroundColor: r12 }, l13 = new e4(i13, n14);
    l13.wrapMode = D.CLAMP_TO_EDGE, l13.internalFormat = P3.RGBA8, l13.isImmutable = true;
    const m7 = new E3(o15, l13, new i2(B.DEPTH_STENCIL, i13, n14)), c12 = o15.getBoundFramebufferObject(), u11 = o15.getViewport();
    o15.bindFramebuffer(m7), o15.setViewport(0, 0, i13, n14), this._renderChildren(t18 ?? this.children, d5);
    const p5 = this._readbackScreenshot(m7, { ...e15.cropArea, y: n14 - (e15.cropArea.y + e15.cropArea.height) });
    o15.bindFramebuffer(c12), o15.setViewport(u11.x, u11.y, u11.width, u11.height), this.requestRender();
    const f9 = await p5;
    let g4;
    return 1 === e15.outputScale ? g4 = f9 : (g4 = new ImageData(Math.round(f9.width * e15.outputScale), Math.round(f9.height * e15.outputScale)), w4(f9, g4, true)), m7.dispose(), g4;
  }
  async _readbackScreenshot(e15, t18) {
    const r12 = s6(t18.width, t18.height, document.createElement("canvas"));
    return await e15.readPixelsAsync(t18.x, t18.y, t18.width, t18.height, G.RGBA, U2.UNSIGNED_BYTE, new Uint8Array(r12.data.buffer)), r12;
  }
  _emptyTrash() {
    for (; this._trash.size > 0; ) {
      const e15 = Array.from(this._trash);
      this._trash.clear();
      for (const t18 of e15) t18.processDetach();
    }
  }
};

// ../node_modules/@arcgis/core/views/magnifier/resources.js
async function s13(s14) {
  const r12 = import("./mask-svg-BRDQGMMD.js"), i13 = import("./overlay-svg-Q3OKYXTH.js"), o15 = t5((await r12).default, { signal: s14 }), e15 = t5((await i13).default, { signal: s14 }), m7 = { mask: await o15, overlay: await e15 };
  return s3(s14), m7;
}

// ../node_modules/@arcgis/core/views/2d/magnifier/MagnifierView2D.js
var A7 = class extends s7 {
  constructor() {
    super(), this._handles = new r(), this._resourcePixelRatio = 1, this.updatingHandles = new h4(), this.visible = false;
  }
  destroy() {
    this._handles = u(this._handles), this._disposeRenderResources(), this._resourcesTask = e(this._resourcesTask);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(e15) {
    this._backgroundColor = e15, this.requestRender();
  }
  get magnifier() {
    return this._magnifier;
  }
  set magnifier(e15) {
    this._magnifier = e15, this._handles.removeAll(), this._handles.add([d2(() => e15.version, () => {
      this.visible = e15.visible && null != e15.position && e15.size > 0, this.requestRender();
    }, P), d2(() => [e15.maskUrl, e15.overlayUrl], () => this._reloadResources()), d2(() => e15.size, () => {
      this._disposeRenderResources(), this.requestRender();
    })]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  doRender(e15) {
    const r12 = e15.context;
    if (!this._resourcesTask) return void this._reloadResources();
    if (e15.drawPhase !== E4.MAP || !this._canRender()) return;
    this._updateResources(e15);
    const s14 = this._magnifier;
    if (null == s14.position) return;
    const i13 = e15.pixelRatio, o15 = s14.size * i13, a10 = 1 / s14.factor, n14 = Math.ceil(a10 * o15);
    this._readbackTexture.resize(n14, n14);
    const { size: l13 } = e15.state, h14 = i13 * l13[0], m7 = i13 * l13[1], u11 = 0.5 * n14, c12 = 0.5 * n14, d5 = e2(i13 * s14.position.x, u11, h14 - u11 - 1), p5 = e2(m7 - i13 * s14.position.y, c12, m7 - c12 - 1);
    r12.setBlendingEnabled(true);
    const f9 = d5 - u11, g4 = p5 - c12, x3 = this._readbackTexture;
    r12.bindTexture(x3, 0), r12.gl.copyTexImage2D(x3.descriptor.target, 0, x3.descriptor.pixelFormat, f9, g4, n14, n14, 0);
    const T6 = this.backgroundColor, y5 = T6 ? [T6.a * T6.r / 255, T6.a * T6.g / 255, T6.a * T6.b / 255, T6.a] : [1, 1, 1, 1], k2 = (d5 + s14.offset.x * i13) / h14 * 2 - 1, R4 = (p5 - s14.offset.y * i13) / m7 * 2 - 1, v4 = o15 / h14 * 2, j3 = o15 / m7 * 2, w6 = this._program;
    r12.bindVAO(this._vertexArrayObject), r12.bindTexture(this._overlayTexture, 6), r12.bindTexture(this._maskTexture, 7), r12.useProgram(w6), w6.setUniform4fv("u_background", y5), w6.setUniform1i("u_readbackTexture", 0), w6.setUniform1i("u_overlayTexture", 6), w6.setUniform1i("u_maskTexture", 7), w6.setUniform4f("u_drawPos", k2, R4, v4, j3), w6.setUniform1i("u_maskEnabled", s14.maskEnabled ? 1 : 0), w6.setUniform1i("u_overlayEnabled", s14.overlayEnabled ? 1 : 0), r12.setStencilTestEnabled(false), r12.setColorMask(true, true, true, true), r12.drawArrays(E2.TRIANGLE_STRIP, 0, 4), r12.bindVAO();
  }
  _canRender() {
    return this._mask && this._overlay && null != this._magnifier;
  }
  _reloadResources() {
    this._resourcesTask && this._resourcesTask.abort();
    const s14 = null != this._magnifier ? this._magnifier.maskUrl : null, t18 = null != this._magnifier ? this._magnifier.overlayUrl : null;
    this._resourcesTask = d(async (r12) => {
      const i13 = null == s14 || null == t18 ? s13(r12) : null, o15 = null != s14 ? U(s14, { responseType: "image", signal: r12 }).then((e15) => e15.data) : i13.then((e15) => e15.mask), a10 = null != t18 ? U(t18, { responseType: "image", signal: r12 }).then((e15) => e15.data) : i13.then((e15) => e15.overlay), [n14, l13] = await Promise.all([o15, a10]);
      this._mask = n14, this._overlay = l13, this._disposeRenderResources(), this.requestRender();
    }), this.updatingHandles.addPromise(this._resourcesTask.promise);
  }
  _disposeRenderResources() {
    this._readbackTexture = r2(this._readbackTexture), this._overlayTexture = r2(this._overlayTexture), this._maskTexture = r2(this._maskTexture), this._vertexArrayObject = r2(this._vertexArrayObject), this._program = r2(this._program);
  }
  _updateResources(e15) {
    if (e15.pixelRatio !== this._resourcePixelRatio && this._disposeRenderResources(), this._readbackTexture) return;
    const r12 = e15.context;
    this._resourcePixelRatio = e15.pixelRatio;
    const s14 = Math.ceil(this._magnifier.size * e15.pixelRatio);
    this._program = t11(r12);
    const t18 = new Uint16Array([0, 1, 0, 0, 1, 1, 1, 0]), i13 = a5.attributes;
    this._vertexArrayObject = new o8(r12, i13, m4, { geometry: c.createVertex(r12, F.STATIC_DRAW, t18) }), this._overlay.width = s14, this._overlay.height = s14;
    const o15 = new e4();
    o15.internalFormat = G.RGBA, o15.wrapMode = D.CLAMP_TO_EDGE, o15.samplingMode = L3.NEAREST, o15.flipped = true, o15.preMultiplyAlpha = !Pt(this._overlay.src) || !e15.context.driverTest.svgPremultipliesAlpha.result, this._overlayTexture = new c2(r12, o15, this._overlay), this._mask.width = s14, this._mask.height = s14, o15.pixelFormat = o15.internalFormat = G.ALPHA, this._maskTexture = new c2(r12, o15, this._mask);
    const a10 = 1 / this._magnifier.factor;
    o15.pixelFormat = o15.internalFormat = G.RGBA, o15.width = o15.height = Math.ceil(a10 * s14), o15.samplingMode = L3.LINEAR, o15.flipped = false, this._readbackTexture = new c2(r12, o15);
  }
};
export {
  t10 as GraphicContainer,
  V as GraphicsView2D,
  a4 as LabelManager,
  A7 as MagnifierView2D,
  y4 as MapViewNavigation,
  q2 as Stage
};
//# sourceMappingURL=mapViewDeps-H3H5TK4I.js.map
