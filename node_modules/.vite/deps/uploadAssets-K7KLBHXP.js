import {
  a as a2,
  c,
  d,
  l,
  n as n3,
  p,
  r as r4,
  t as t2,
  u as u2
} from "./chunk-6VBJAAUX.js";
import {
  A as A2,
  N,
  h,
  i as i2,
  o
} from "./chunk-4CS2XXGQ.js";
import {
  i,
  s as s2,
  u
} from "./chunk-RMOPI4S6.js";
import {
  g
} from "./chunk-OHUWK5XV.js";
import {
  r as r3
} from "./chunk-ZK2DM5OJ.js";
import "./chunk-PNUUOKAJ.js";
import {
  U,
  V,
  Wt
} from "./chunk-WC4SPMPL.js";
import "./chunk-TJUEGVVG.js";
import {
  n as n2,
  r as r2,
  t
} from "./chunk-FXNOKZ3B.js";
import {
  r
} from "./chunk-GEH2VXFC.js";
import "./chunk-BJY5ADVY.js";
import {
  A,
  a,
  e,
  s
} from "./chunk-VMWKLHJD.js";
import "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  n2 as n
} from "./chunk-YNL57W4I.js";
import {
  has
} from "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/layers/graphics/sources/support/uploadProgressWeights.js
var e2 = { upload: { createFromFiles: 0.8, loadMesh: 0.2 }, uploadAssetBlobs: { prepareAssetItems: 0.9, uploadAssetItems: 0.1 }, uploadConvertibleSource: { uploadEditSource: 0.5, serviceAssetsToGlb: 0.5 }, uploadLocalMesh: { meshToAssetBlob: 0.5, uploadAssetBlobs: 0.5 } };

// ../node_modules/@arcgis/core/support/progressUtils.js
function i3(s3, t3 = (s4) => {
}, e3) {
  return new n4(s3, t3, e3);
}
var n4 = class {
  constructor(s3, t3 = (s4) => {
  }, e3) {
    if (this.onProgress = t3, this.taskName = e3, this._progressMap = /* @__PURE__ */ new Map(), this._startTime = void 0, this._timingsMap = /* @__PURE__ */ new Map(), "number" == typeof s3) {
      this._weights = {};
      for (let t4 = 0; t4 < s3; t4++) {
        const e4 = t4, r5 = 1 / s3;
        this._weights[e4] = r5, this._progressMap.set(e4, 0);
      }
    } else this._weights = s3;
    this.emitProgress();
  }
  emitProgress() {
    let s3 = 0;
    for (const [t3, e3] of this._progressMap.entries()) {
      s3 += e3 * this._weights[t3];
    }
    if (1 === s3 && has("enable-feature:esri-3dofl-upload-timings")) {
      const s4 = Math.round(performance.now() - (this._startTime ?? 0)) / 1e3;
      console.log(`${this.taskName} done in ${s4} sec`);
      for (const [t3, e3] of this._timingsMap) {
        const r5 = Math.round(e3.end - e3.start) / 1e3, o2 = Math.round(r5 / s4 * 100);
        console.log(this.taskName ?? "Task", { stepKey: t3, stepTime: r5, relativeTime: o2 });
      }
    }
    this.onProgress(s3);
  }
  setProgress(s3, e3) {
    if (this._progressMap.set(s3, e3), has("enable-feature:esri-3dofl-upload-timings")) {
      const r5 = performance.now();
      this._startTime ?? (this._startTime = r5);
      const o2 = r(this._timingsMap, s3, () => ({ start: r5, end: 0 }));
      1 === e3 && (o2.end = r5);
    }
    this.emitProgress();
  }
  simulate(s3, t3) {
    return a3((t4) => this.setProgress(s3, t4), t3);
  }
  makeOnProgress(s3) {
    return (t3) => this.setProgress(s3, t3);
  }
};
function a3(t3 = (s3) => {
}, e3 = l2) {
  const r5 = performance.now();
  t3(0);
  const o2 = setInterval(() => {
    const s3 = performance.now() - r5, o3 = 1 - Math.exp(-s3 / e3);
    t3(o3);
  }, g2);
  return e(() => {
    clearInterval(o2), t3(1);
  });
}
function h2(s3, t3 = c2) {
  return r2(t(s3 * f / t3));
}
function m(s3, t3 = p2) {
  return r2(t(s3 * f / t3));
}
var c2 = 10;
var p2 = 10;
var f = 8e-6;
var g2 = n2(50);
var l2 = n2(1e3);

// ../node_modules/@arcgis/core/layers/graphics/sources/support/uploads.js
var n5 = 1e6;
var i4 = 20 * n5;
var p3 = 2e9;
var l3 = 3;
async function m2({ data: m3, name: f2, description: d2 }, u3, h3) {
  let w = null;
  try {
    const y = V(u3, "uploads"), j = V(y, "info"), { data: g3 } = await U(j, { query: { f: "json" }, responseType: "json" });
    s(h3);
    const q2 = g(u3), z2 = g3.maxUploadFileSize * n5, T = q2 ? p3 : z2, U2 = q2 ? Math.min(i4, z2) : i4;
    if (m3.size > T) throw new Error("Data too large");
    const A3 = V(y, "register"), { data: E } = await U(A3, { query: { f: "json", itemName: c3(f2), description: d2 }, responseType: "json", method: "post" });
    if (s(h3), !E.success) throw new Error("Registration failed");
    const { itemID: P } = E.item;
    w = V(y, P);
    const D = V(w, "uploadPart"), I2 = Math.ceil(m3.size / U2), M2 = new Array();
    for (let e3 = 0; e3 < I2; ++e3) M2.push(m3.slice(e3 * U2, Math.min((e3 + 1) * U2, m3.size)));
    const v2 = M2.slice().reverse(), x = new Array(), F = i3(I2, h3 == null ? void 0 : h3.onProgress, "uploadItem"), _2 = async () => {
      for (; 0 !== v2.length; ) {
        const t3 = M2.length - v2.length, r5 = v2.pop(), s3 = new FormData(), n6 = F.simulate(t3, h2(r5.size));
        try {
          s3.append("f", "json"), s3.append("file", r5), s3.append("partId", `${t3}`);
          const { data: a4 } = await U(D, { timeout: 0, body: s3, responseType: "json", method: "post" });
          if (s(h3), !a4.success) throw new Error("Part upload failed");
        } finally {
          n6.remove();
        }
      }
    };
    for (let e3 = 0; e3 < l3 && 0 !== v2.length; ++e3) x.push(_2());
    await Promise.all(x);
    const b = V(w, "commit"), { data: C2 } = await U(b, { query: { f: "json", parts: M2.map((e3, o2) => o2).join(",") }, responseType: "json", method: "post" });
    if (s(h3), !C2.success) throw new Error("Commit failed");
    return C2.item;
  } catch (y) {
    if (null != w) {
      const o2 = V(w, "delete");
      await U(o2, { query: { f: "json" }, responseType: "json", method: "post" });
    }
    throw y;
  }
}
function c3(e3) {
  return e3.replaceAll("/", "_").replaceAll("\\", "_");
}

// ../node_modules/@arcgis/core/layers/graphics/sources/support/uploadAssets.js
async function O(s3, e3, t3) {
  var _a;
  const r5 = s3.length;
  if (!r5) return (_a = t3 == null ? void 0 : t3.onProgress) == null ? void 0 : _a.call(t3, 1), [];
  const o2 = i3(r5, t3 == null ? void 0 : t3.onProgress, "uploadAssets");
  return Promise.all(s3.map((s4, r6) => v(s4, e3, { ...t3, onProgress: o2.makeOnProgress(r6) })));
}
async function v(s3, { layer: e3, ongoingUploads: t3 }, r5) {
  var _a;
  const o2 = t3.get(s3);
  if (o2) return o2;
  if (!Z(e3)) throw new r4();
  if (I(s3, e3)) return (_a = r5 == null ? void 0 : r5.onProgress) == null ? void 0 : _a.call(r5, 1), s3;
  const n6 = k(s3, e3, r5);
  t3.set(s3, n6);
  try {
    await n6;
  } finally {
    t3.delete(s3);
  }
  return s3;
}
function I(s3, e3) {
  const { parsedUrl: t3 } = e3;
  return null != t3 && s3.metadata.externalSources.some((s4) => h(s4, t3));
}
async function k(s3, e3, r5) {
  const { metadata: o2 } = s3, { displaySource: n6 } = o2, a4 = H(n6 == null ? void 0 : n6.source, e3), i5 = !!a4, c4 = o2.externalSources.length > 0, u3 = i5 ? B(a4, e3, r5) : c4 ? R(s3, e3, r5) : C(s3, e3, r5), l4 = await u3;
  return s(r5), s3.addExternalSources([l4]), s3;
}
async function B(s3, e3, t3) {
  return { source: await G(s3, e3, t3), original: true };
}
async function R(s3, e3, t3) {
  const r5 = _(e3), { externalSources: o2 } = s3.metadata, n6 = q(o2, e3);
  if (!n6) throw new n3();
  const a4 = i3(e2.uploadConvertibleSource, t3 == null ? void 0 : t3.onProgress, "uploadConvertibleSource"), i5 = await G(n6, e3, { onProgress: a4.makeOnProgress("uploadEditSource") });
  s3.addExternalSources([{ source: i5, original: true }]);
  const c4 = n6.reduce((s4, { asset: e4 }) => e4 instanceof File ? s4 + e4.size : s4, 0), u3 = a4.simulate("serviceAssetsToGlb", m(c4));
  try {
    return { source: await V2(i5, e3, r5) };
  } finally {
    u3.remove();
  }
}
async function C(s3, e3, t3) {
  const r5 = i3(e2.uploadLocalMesh, t3 == null ? void 0 : t3.onProgress, "uploadLocalMesh"), o2 = L(s3, e3, { ...t3, onProgress: r5.makeOnProgress("meshToAssetBlob") });
  return { source: await J([o2], e3, { ...t3, onProgress: r5.makeOnProgress("uploadAssetBlobs") }), extent: s3.extent.clone(), original: true };
}
async function L(s3, e3, r5) {
  const o2 = _(e3), n6 = await s3.load(r5), a4 = await n6.toBinaryGLTF({ origin: n6.origin, signal: r5 == null ? void 0 : r5.signal, ignoreLocalTransform: true });
  return s(r5), { blob: new Blob([a4], { type: "model/gltf-binary" }), assetName: `${r3()}.glb`, assetType: o2 };
}
function q(s3, e3) {
  for (const t3 of s3) {
    const s4 = H(t3.source, e3);
    if (s4) return s4;
  }
  return null;
}
function H(s3, e3) {
  if (!s3) return null;
  const { infoFor3D: { supportedFormats: t3, editFormats: r5 } } = e3, o2 = A2(s3), n6 = new Array();
  let a4 = false;
  for (let i5 = 0; i5 < o2.length; ++i5) {
    const s4 = $(o2[i5], t3);
    if (!s4) return null;
    r5.includes(s4.assetType) && (a4 = true), n6.push(s4);
  }
  return a4 ? n6 : null;
}
function $(s3, e3) {
  const t3 = N(s3, e3);
  return t3 ? { asset: s3, assetType: t3 } : null;
}
async function G(s3, e3, t3) {
  return J(s3.map((s4) => M(s4, t3)), e3, t3);
}
async function J(s3, e3, r5) {
  const o2 = i3(e2.uploadAssetBlobs, r5 == null ? void 0 : r5.onProgress, "uploadAssetBlobs"), n6 = await z(s3, e3, { ...r5, onProgress: o2.makeOnProgress("prepareAssetItems") });
  s(r5);
  const a4 = n6.map(({ item: s4 }) => s4), { uploadResults: i5 } = await K(a4, e3, { ...r5, onProgress: o2.makeOnProgress("uploadAssetItems") });
  return s(r5), s3.map((s4, t3) => Q(n6[t3], i5[t3], e3));
}
async function M(s3, e3) {
  const { asset: r5, assetType: o2 } = s3;
  if (r5 instanceof File) return { blob: r5, assetName: r5.name, assetType: o2 };
  const n6 = await r5.toBlob(e3);
  return s(e3), { blob: n6, assetName: r5.assetName, assetType: o2 };
}
async function W(s3, e3, r5) {
  const { blob: n6, assetType: a4, assetName: c4 } = s3;
  let u3 = null;
  try {
    const s4 = await m2({ data: n6, name: c4 }, e3.url, r5);
    s(r5), u3 = { assetType: a4, assetUploadId: s4.itemID };
  } catch (l4) {
    a(l4), ss().warnOnce(`Service ${e3.url} does not support the REST Uploads API.`);
  }
  if (!u3) {
    const s4 = await Wt(n6);
    if (s(r5), !s4.isBase64) throw new u2();
    u3 = { assetType: a4, assetData: s4.data };
  }
  if (!u3) throw new p();
  return { item: u3, assetName: c4 };
}
function z(s3, e3, r5) {
  const o2 = i3(s3.length, r5 == null ? void 0 : r5.onProgress, "prepareAssetItems");
  return Promise.all(s3.map(async (s4, n6) => {
    const a4 = W(await s4, e3, { ...r5, onProgress: o2.makeOnProgress(n6) });
    return s(r5), a4;
  }));
}
async function K(e3, r5, o2) {
  const n6 = a3(o2 == null ? void 0 : o2.onProgress);
  try {
    const n7 = await U(V(r5.parsedUrl.path, "uploadAssets"), { timeout: 0, query: { f: "json", assets: JSON.stringify(e3) }, method: "post", responseType: "json" });
    if (s(o2), n7.data.uploadResults.length !== e3.length) throw new a2(e3.length, n7.data.uploadResults.length);
    return n7.data;
  } finally {
    n6.remove();
  }
}
function Q(s3, e3, t3) {
  const { success: r5 } = e3;
  if (!r5) {
    const { error: t4 } = e3;
    throw new d(s3.assetName, t4);
  }
  const { assetHash: o2 } = e3, { assetName: n6, item: { assetType: a4 } } = s3, { infoFor3D: { supportedFormats: i5 } } = t3, c4 = s2(a4, i5);
  if (!c4) throw new c(a4);
  return new i2(n6, c4, [new o(`${t3.parsedUrl.path}/assets/${o2}`, o2)]);
}
async function V2(s3, e3, t3) {
  var _a;
  const r5 = s3.map(({ assetName: s4, parts: e4 }) => ({ assetName: s4, assetHash: e4[0].partHash })), o2 = (_a = e3.capabilities) == null ? void 0 : _a.operations.supportsAsyncConvert3D, n6 = { f: "json", assets: JSON.stringify(r5), transportType: "esriTransportTypeUrl", targetFormat: t3, async: o2 }, i5 = V(e3.parsedUrl.path, "convert3D");
  let c4;
  try {
    c4 = (await (o2 ? Y : X)(i5, { query: n6, responseType: "json", timeout: 0 })).data;
  } catch (l4) {
    throw new l();
  }
  const { supportedFormats: u3 } = e3.infoFor3D;
  return c4.assets.map((s4) => {
    const e4 = u(s4.contentType, u3);
    if (!e4) throw new c(e4);
    return new i2(s4.assetName, s4.contentType, [new o(s4.assetURL, s4.assetHash)]);
  });
}
function X(e3, t3) {
  return U(e3, t3);
}
async function Y(e3, t3) {
  const o2 = (await U(e3, t3)).data.statusUrl;
  for (; ; ) {
    const e4 = (await U(o2, { query: { f: "json" }, responseType: "json" })).data;
    switch (e4.status) {
      case "Completed":
        return U(e4.resultUrl, { query: { f: "json" }, responseType: "json" });
      case "CompletedWithErrors":
        throw new Error(e4.status);
      case "Failed ImportChanges":
      case "InProgress":
      case "Pending":
      case "ExportAttachments":
      case "ExportChanges":
      case "ExportingData":
      case "ExportingSnapshot":
      case "ImportAttachments":
      case "ProvisioningReplica":
      case "UnRegisteringReplica":
        break;
      default:
        throw new Error();
    }
    await A(es);
  }
}
function Z(s3) {
  return !!s3.infoFor3D && !!s3.url;
}
function _(s3) {
  const { infoFor3D: e3 } = s3, t3 = u("model/gltf-binary", e3.supportedFormats) ?? i("glb", e3.supportedFormats);
  if (!t3) throw new t2();
  return t3;
}
function ss() {
  return n.getLogger("esri.layers.graphics.sources.support.uploadAssets");
}
var es = n2(1e3);
export {
  O as uploadAssets
};
//# sourceMappingURL=uploadAssets-K7KLBHXP.js.map
