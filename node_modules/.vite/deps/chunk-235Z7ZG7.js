import {
  a,
  c,
  c2,
  e,
  u,
  u2
} from "./chunk-4ZTHXCOS.js";
import {
  A,
  B,
  C,
  F,
  G,
  H,
  M,
  U,
  V,
  X,
  n as n2,
  t
} from "./chunk-POOHJZAR.js";
import {
  o
} from "./chunk-JQIB7GFW.js";
import {
  r
} from "./chunk-5AEITAWU.js";
import {
  n2 as n
} from "./chunk-YNL57W4I.js";
import {
  f,
  i,
  m
} from "./chunk-2PA5UPTB.js";

// ../node_modules/@arcgis/core/views/webgl/BufferObject.js
var f2 = () => n.getLogger("esri.views.webgl.BufferObject");
var c3 = class _c {
  static createIndex(t3, e4, i5) {
    return new _c(t3, A.ELEMENT_ARRAY_BUFFER, e4, i5);
  }
  static createVertex(t3, e4, i5) {
    return new _c(t3, A.ARRAY_BUFFER, e4, i5);
  }
  static createUniform(t3, e4, i5) {
    return new _c(t3, A.UNIFORM_BUFFER, e4, i5);
  }
  static createPixelPack(t3, e4 = F.STREAM_READ, i5) {
    const s4 = new _c(t3, A.PIXEL_PACK_BUFFER, e4);
    return i5 && s4.setSize(i5), s4;
  }
  static createPixelUnpack(t3, e4 = F.STREAM_DRAW, i5) {
    return new _c(t3, A.PIXEL_UNPACK_BUFFER, e4, i5);
  }
  static createTransformFeedback(t3, e4 = F.STATIC_DRAW, i5) {
    const s4 = new _c(t3, A.TRANSFORM_FEEDBACK_BUFFER, e4);
    return s4.setSize(i5), s4;
  }
  constructor(t3, e4, i5, s4) {
    this._context = t3, this.bufferType = e4, this.usage = i5, this._glName = null, this._size = -1, this._indexType = void 0, t3.instanceCounter.increment(V.BufferObject, this), this._glName = this._context.gl.createBuffer(), u(this._context.gl), s4 && this.setData(s4);
  }
  get glName() {
    return this._glName;
  }
  get size() {
    return this._size;
  }
  get indexType() {
    return this._indexType;
  }
  get usedMemory() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER ? this._indexType === C.UNSIGNED_INT ? 4 * this._size : 2 * this._size : this._size;
  }
  get _isVAOAware() {
    return this.bufferType === A.ELEMENT_ARRAY_BUFFER || this.bufferType === A.ARRAY_BUFFER;
  }
  dispose() {
    var _a;
    if ((_a = this._context) == null ? void 0 : _a.gl) {
      if (this._glName) {
        this._context.gl.deleteBuffer(this._glName), this._glName = null;
      }
      this._context.instanceCounter.decrement(V.BufferObject, this), this._context = null;
    } else this._glName && f2().warn("Leaked WebGL buffer object");
  }
  setSize(t3, e4 = null) {
    if (this.bufferType === A.ELEMENT_ARRAY_BUFFER && null != e4) switch (this._indexType = e4, e4) {
      case C.UNSIGNED_SHORT:
        t3 *= 2;
        break;
      case C.UNSIGNED_INT:
        t3 *= 4;
    }
    this._setBufferData(t3);
  }
  setData(t3) {
    if (!t3) return;
    let e4 = t3.byteLength;
    this.bufferType === A.ELEMENT_ARRAY_BUFFER && (i(t3) && (e4 /= 2, this._indexType = C.UNSIGNED_SHORT), f(t3) && (e4 /= 4, this._indexType = C.UNSIGNED_INT)), this._setBufferData(e4, t3);
  }
  _setBufferData(t3, e4 = null) {
    this._size = t3;
    const i5 = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const s4 = this._context.gl;
    null != e4 ? s4.bufferData(this.bufferType, e4, this.usage) : s4.bufferData(this.bufferType, t3, this.usage), u(s4), this._isVAOAware && this._context.bindVAO(i5);
  }
  setSubData(t3, e4, i5, s4) {
    if (!t3) return;
    const n4 = this._context.getBoundVAO();
    this._isVAOAware && this._context.bindVAO(null), this._context.bindBuffer(this);
    const { gl: _2 } = this._context;
    _2.bufferSubData(this.bufferType, e4 * t3.BYTES_PER_ELEMENT, t3, i5, s4 - i5), u(_2), this._isVAOAware && this._context.bindVAO(n4);
  }
  getSubData(t3, e4 = 0, i5, s4) {
    if (i5 < 0 || s4 < 0) return;
    const r4 = o2(t3) ? t3.BYTES_PER_ELEMENT : 1;
    if (r4 * ((i5 ?? 0) + (s4 ?? 0)) > t3.byteLength) return;
    e4 + r4 * (s4 ?? 0) > this.usedMemory && f2().warn("Potential problem getting subdata: requested data exceeds buffer size!");
    const _2 = this._context.gl;
    this.bufferType === A.TRANSFORM_FEEDBACK_BUFFER ? (this._context.bindBuffer(this, A.TRANSFORM_FEEDBACK_BUFFER), _2.getBufferSubData(A.TRANSFORM_FEEDBACK_BUFFER, e4, t3, i5, s4), this._context.unbindBuffer(A.TRANSFORM_FEEDBACK_BUFFER)) : (this._context.bindBuffer(this, A.COPY_READ_BUFFER), _2.getBufferSubData(A.COPY_READ_BUFFER, e4, t3, i5, s4), this._context.unbindBuffer(A.COPY_READ_BUFFER));
  }
  async getSubDataAsync(t3, e4 = 0, i5, s4) {
    await this._context.clientWaitAsync(), this.getSubData(t3, e4, i5, s4);
  }
};
function o2(e4) {
  return m(e4);
}

// ../node_modules/@arcgis/core/views/webgl/RenderbufferDescriptor.js
var i2 = class {
  constructor(t3, i5, h4 = i5) {
    this.internalFormat = t3, this.width = i5, this.height = h4, this.multisampled = false, this.samples = 1;
  }
};
function h(i5) {
  return i5.width <= 0 || i5.height <= 0 || null == i5.internalFormat ? 0 : i5.width * i5.height * u2(i5.internalFormat);
}

// ../node_modules/@arcgis/core/views/webgl/Renderbuffer.js
var s = class {
  constructor(r4, s4) {
    this._context = r4, this._descriptor = s4, this.type = e.RenderBuffer, this._context.instanceCounter.increment(V.Renderbuffer, this);
    const i5 = this._context.gl;
    this.glName = i5.createRenderbuffer(), this._context.bindRenderbuffer(this);
    const { width: n4, height: o5, internalFormat: h4, multisampled: d2 } = s4;
    d2 ? i5.renderbufferStorageMultisample(i5.RENDERBUFFER, this.samples, h4, n4, o5) : i5.renderbufferStorage(i5.RENDERBUFFER, h4, n4, o5), this._context.bindRenderbuffer(null);
  }
  get descriptor() {
    return this._descriptor;
  }
  get samples() {
    const e4 = this._descriptor.samples, t3 = this._context.parameters.maxSamples;
    return e4 ? Math.min(e4, t3) : t3;
  }
  get usedMemory() {
    return h(this._descriptor);
  }
  resize(e4, t3) {
    const r4 = this._descriptor;
    if (r4.width === e4 && r4.height === t3) return;
    r4.width = e4, r4.height = t3;
    const s4 = this._context.gl;
    this._context.bindRenderbuffer(this), r4.multisampled ? s4.renderbufferStorageMultisample(s4.RENDERBUFFER, this.samples, r4.internalFormat, r4.width, r4.height) : s4.renderbufferStorage(s4.RENDERBUFFER, r4.internalFormat, r4.width, r4.height), this._context.bindRenderbuffer(null);
  }
  dispose() {
    this._context && (this._context.gl.deleteRenderbuffer(this.glName), this._context.instanceCounter.decrement(V.Renderbuffer, this), this._context = null);
  }
};

// ../node_modules/@arcgis/core/views/webgl/FramebufferObject.js
var p = () => n.getLogger("esri.views.webgl.FramebufferObject");
var E = class _E {
  constructor(t3, e4, i5 = null) {
    this._context = t3, this._glName = null, this._colorAttachments = /* @__PURE__ */ new Map(), this._depthStencilBuffer = null, this._depthStencilTexture = null, this._initialized = false, t3.instanceCounter.increment(V.FramebufferObject, this);
    const r4 = x(e4) ? e4 : new c2(this._context, e4);
    if (this._colorAttachments.set(X.COLOR_ATTACHMENT0, r4), this._validateTextureDescriptor(r4.descriptor), this._validateColorAttachmentPoint(X.COLOR_ATTACHMENT0), null != i5) if (b(i5)) this._depthStencilTexture = x(i5) ? i5 : new c2(this._context, i5), this._validateTextureDescriptor(this._depthStencilTexture.descriptor);
    else {
      const t4 = g(i5) ? i5 : new s(this._context, i5);
      this._depthStencilBuffer = t4, this._validateRenderBufferDescriptor(t4.descriptor);
    }
  }
  dispose() {
    var _a, _b;
    if (0 === this._colorAttachments.size && !this._glName) return;
    const t3 = this._context.getBoundFramebufferObject();
    if (this._colorAttachments.forEach((t4, e4) => {
      var _a2;
      return (_a2 = this.detachColorTexture(e4)) == null ? void 0 : _a2.dispose();
    }), (_a = this.detachDepthStencilBuffer()) == null ? void 0 : _a.dispose(), (_b = this.detachDepthStencilTexture()) == null ? void 0 : _b.dispose(), this._glName) {
      this._context.gl.deleteFramebuffer(this._glName), this._glName = null;
    }
    this._context.bindFramebuffer(t3), this._context.instanceCounter.decrement(V.FramebufferObject, this);
  }
  get glName() {
    return this._glName;
  }
  get colorTexture() {
    return this._colorAttachments.get(X.COLOR_ATTACHMENT0);
  }
  get depthStencil() {
    return this._depthStencilTexture || this._depthStencilBuffer;
  }
  get depthStencilTexture() {
    return this._depthStencilTexture;
  }
  get width() {
    var _a;
    const t3 = this._colorAttachments.get(X.COLOR_ATTACHMENT0);
    return ((_a = t3 == null ? void 0 : t3.descriptor) == null ? void 0 : _a.width) ?? 0;
  }
  get height() {
    var _a;
    const t3 = this._colorAttachments.get(X.COLOR_ATTACHMENT0);
    return ((_a = t3 == null ? void 0 : t3.descriptor) == null ? void 0 : _a.height) ?? 0;
  }
  get usedMemory() {
    var _a;
    return [...this._colorAttachments].reduce((t3, [e4, i5]) => t3 + i5.usedMemory, ((_a = this.depthStencil) == null ? void 0 : _a.usedMemory) ?? 0);
  }
  getColorTexture(t3) {
    const e4 = this._colorAttachments.get(t3);
    return e4 && x(e4) ? e4 : null;
  }
  get colorAttachments() {
    return [...this._colorAttachments.keys()];
  }
  attachColorTexture(t3, e4 = X.COLOR_ATTACHMENT0) {
    var _a;
    if (!t3) return;
    this._validateColorAttachmentPoint(e4);
    const i5 = t3.descriptor;
    this._validateTextureDescriptor(i5), (_a = this.detachColorTexture(e4)) == null ? void 0 : _a.dispose(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t3.glName, e4)), this._colorAttachments.set(e4, t3);
  }
  detachColorTexture(t3 = X.COLOR_ATTACHMENT0) {
    const e4 = this._colorAttachments.get(t3);
    if (e4) {
      if (this._initialized) {
        const e5 = this._context.getBoundFramebufferObject();
        this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3), this._context.bindFramebuffer(e5);
      }
      return this._colorAttachments.delete(t3), e4;
    }
  }
  setColorTextureTarget(t3, e4 = X.COLOR_ATTACHMENT0) {
    const i5 = this._colorAttachments.get(e4);
    i5 && this._framebufferTexture2D(i5.glName, e4, t3);
  }
  attachDepthStencil(t3) {
    if (t3) switch (t3.type) {
      case e.Texture:
        return this._attachDepthStencilTexture(t3);
      case e.RenderBuffer:
        return this._attachDepthStencilBuffer(t3);
    }
  }
  _attachDepthStencilTexture(t3) {
    var _a;
    if (null == t3) return;
    const e4 = t3.descriptor;
    e4.pixelFormat !== G.DEPTH_STENCIL && e4.pixelFormat !== G.DEPTH24_STENCIL8 && console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"), e4.dataType !== U.UNSIGNED_INT_24_8 && console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"), this._validateTextureDescriptor(e4), this._disposeDepthStencilAttachments(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t3.glName, t)), (_a = this._depthStencilTexture) == null ? void 0 : _a.dispose(), this._depthStencilTexture = t3;
  }
  detachDepthStencilTexture() {
    const t3 = this._depthStencilTexture;
    if (t3 && this._initialized) {
      const t4 = this._context.getBoundFramebufferObject();
      this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t), this._context.bindFramebuffer(t4);
    }
    return this._depthStencilTexture = null, t3;
  }
  _attachDepthStencilBuffer(t3) {
    if (null == t3) return;
    const e4 = t3.descriptor;
    if (this._validateRenderBufferDescriptor(e4), this._disposeDepthStencilAttachments(), this._initialized) {
      this._context.bindFramebuffer(this);
      const i5 = this._context.gl, r4 = this._getGLAttachmentPoint(e4);
      i5.framebufferRenderbuffer(n2.FRAMEBUFFER, r4, i5.RENDERBUFFER, t3.glName);
    }
    this._depthStencilBuffer = t3;
  }
  detachDepthStencilBuffer() {
    const t3 = this._depthStencilBuffer;
    if (t3 && this._initialized) {
      const e4 = this._context.getBoundFramebufferObject();
      this._context.bindFramebuffer(this);
      const i5 = this._context.gl, r4 = this._getGLAttachmentPoint(t3.descriptor);
      i5.framebufferRenderbuffer(n2.FRAMEBUFFER, r4, i5.RENDERBUFFER, null), this._context.bindFramebuffer(e4);
    }
    return this._depthStencilBuffer = null, t3;
  }
  copyToTexture(t3, e4, i5, r4, s4, h4, n4) {
    (t3 < 0 || e4 < 0 || s4 < 0 || h4 < 0) && console.error("Offsets cannot be negative!"), (i5 <= 0 || r4 <= 0) && console.error("Copy width and height must be greater than zero!");
    const o5 = n4.descriptor;
    n4.descriptor.target !== M.TEXTURE_2D && console.error("Texture target must be TEXTURE_2D!"), (null == (o5 == null ? void 0 : o5.width) || null == (o5 == null ? void 0 : o5.height) || t3 + i5 > this.width || e4 + r4 > this.height || s4 + i5 > o5.width || h4 + r4 > o5.height) && console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");
    const c5 = this._context, a4 = c5.bindTexture(n4, c2.TEXTURE_UNIT_FOR_UPDATES);
    c5.setActiveTexture(c2.TEXTURE_UNIT_FOR_UPDATES), c5.bindFramebuffer(this), c5.gl.copyTexSubImage2D(M.TEXTURE_2D, 0, s4, h4, t3, e4, i5, r4), c5.bindTexture(a4, c2.TEXTURE_UNIT_FOR_UPDATES);
  }
  readPixels(t3, e4, i5, r4, s4, h4, n4) {
    (i5 <= 0 || r4 <= 0) && console.error("Copy width and height must be greater than zero!"), n4 || console.error("Target memory is not initialized!"), this._context.bindFramebuffer(this), this._context.gl.readPixels(t3, e4, i5, r4, s4, h4, n4);
  }
  async readPixelsAsync(t3, e4, r4, s4, h4, n4, o5) {
    const { gl: c5 } = this._context, a4 = c3.createPixelPack(this._context, F.STREAM_READ, o5.byteLength);
    this._context.bindBuffer(a4), this._context.bindFramebuffer(this), c5.readPixels(t3, e4, r4, s4, h4, n4, 0), this._context.unbindBuffer(A.PIXEL_PACK_BUFFER), await a4.getSubDataAsync(o5), a4.dispose();
  }
  resize(t3, e4) {
    var _a, _b;
    if (this.width === t3 && this.height === e4) return;
    const i5 = { width: t3, height: e4 };
    A2(i5, this._context.parameters.maxTextureSize), this._colorAttachments.forEach((t4) => t4.resize(i5.width, i5.height)), (_a = this._depthStencilTexture) == null ? void 0 : _a.resize(i5.width, i5.height), this._initialized && (A2(i5, this._context.parameters.maxRenderbufferSize), (_b = this._depthStencilBuffer) == null ? void 0 : _b.resize(i5.width, i5.height), this._context.getBoundFramebufferObject() === this && this._context.bindFramebuffer(null), this._initialized = false);
  }
  initializeAndBind(t3 = n2.FRAMEBUFFER) {
    const e4 = this._context.gl;
    if (this._initialized) return void e4.bindFramebuffer(t3, this.glName);
    this._glName && e4.deleteFramebuffer(this._glName);
    const i5 = e4.createFramebuffer();
    if (e4.bindFramebuffer(t3, i5), this._colorAttachments.forEach((e5, i6) => this._framebufferTexture2D(e5.glName, i6, S(e5), t3)), this._depthStencilBuffer) {
      const i6 = this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);
      e4.framebufferRenderbuffer(t3, i6, e4.RENDERBUFFER, this._depthStencilBuffer.glName);
    } else this._depthStencilTexture && this._framebufferTexture2D(this._depthStencilTexture.glName, e4.DEPTH_STENCIL_ATTACHMENT, S(this._depthStencilTexture), t3);
    if (a()) {
      e4.checkFramebufferStatus(t3) !== e4.FRAMEBUFFER_COMPLETE && console.error("Framebuffer is incomplete!");
    }
    this._glName = i5, this._initialized = true;
  }
  _framebufferTexture2D(t3, e4 = X.COLOR_ATTACHMENT0, i5 = M.TEXTURE_2D, r4 = n2.FRAMEBUFFER, s4 = 0) {
    this._context.gl.framebufferTexture2D(r4, e4, i5, t3, s4);
  }
  _disposeDepthStencilAttachments() {
    const t3 = this._context.gl;
    if (this._depthStencilBuffer) {
      if (this._initialized) {
        this._context.bindFramebuffer(this);
        const e4 = this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);
        t3.framebufferRenderbuffer(n2.FRAMEBUFFER, e4, t3.RENDERBUFFER, null);
      }
      this._depthStencilBuffer = r(this._depthStencilBuffer);
    }
    this._depthStencilTexture && (this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t3.DEPTH_STENCIL_ATTACHMENT)), this._depthStencilTexture = r(this._depthStencilTexture));
  }
  _validateTextureDescriptor(t3) {
    t3.target !== M.TEXTURE_2D && t3.target !== M.TEXTURE_CUBE_MAP && console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"), A2(t3, this._context.parameters.maxTextureSize), this._validateBufferDimensions(t3);
  }
  _validateRenderBufferDescriptor(t3) {
    A2(t3, this._context.parameters.maxRenderbufferSize), this._validateBufferDimensions(t3);
  }
  _validateBufferDimensions(t3) {
    t3.width <= 0 && (t3.width = this.width), t3.height <= 0 && (t3.height = this.height), this.width > 0 && this.height > 0 && (this.width === t3.width && this.height === t3.height || console.error("Attachment size must match framebuffer size!"));
  }
  _getGLAttachmentPoint(t3) {
    switch (t3.internalFormat) {
      case B.DEPTH_COMPONENT16:
      case B.DEPTH_COMPONENT24:
      case B.DEPTH_COMPONENT32F:
        return this._context.gl.DEPTH_ATTACHMENT;
      case B.DEPTH24_STENCIL8:
      case B.DEPTH32F_STENCIL8:
      case B.DEPTH_STENCIL:
        return this._context.gl.DEPTH_STENCIL_ATTACHMENT;
      case B.STENCIL_INDEX8:
        return this._context.gl.STENCIL_ATTACHMENT;
    }
  }
  _validateColorAttachmentPoint(e4) {
    if (-1 === _E._MAX_COLOR_ATTACHMENTS) {
      const { gl: t3 } = this._context;
      _E._MAX_COLOR_ATTACHMENTS = t3.getParameter(t3.MAX_COLOR_ATTACHMENTS);
    }
    const i5 = e4 - X.COLOR_ATTACHMENT0;
    i5 + 1 > _E._MAX_COLOR_ATTACHMENTS && n.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject", `illegal attachment point for color attachment: ${i5 + 1}. Implementation supports up to ${_E._MAX_COLOR_ATTACHMENTS} color attachments`);
  }
};
function x(t3) {
  return null != t3 && "type" in t3 && t3.type === e.Texture;
}
function g(t3) {
  return null != t3 && "type" in t3 && t3.type === e.RenderBuffer;
}
function b(t3) {
  return x(t3) || null != t3 && "pixelFormat" in t3;
}
function A2(t3, e4) {
  const i5 = Math.max(t3.width, t3.height);
  if (i5 > e4) {
    p().warn(`Resizing FBO attachment size ${t3.width}x${t3.height} to device limit ${e4}`);
    const r4 = e4 / i5;
    return t3.width = Math.round(t3.width * r4), t3.height = Math.round(t3.height * r4), false;
  }
  return true;
}
function S(t3) {
  return t3.descriptor.target === M.TEXTURE_CUBE_MAP ? M.TEXTURE_CUBE_MAP_POSITIVE_X : M.TEXTURE_2D;
}
E._MAX_COLOR_ATTACHMENTS = -1;

// ../node_modules/@arcgis/core/chunks/builtins.js
var r2;
var t2 = { exports: {} };
void 0 !== (r2 = ["precision", "highp", "mediump", "lowp", "attribute", "const", "uniform", "varying", "break", "continue", "do", "for", "while", "if", "else", "in", "out", "inout", "float", "int", "void", "bool", "true", "false", "discard", "return", "mat2", "mat3", "mat4", "vec2", "vec3", "vec4", "ivec2", "ivec3", "ivec4", "bvec2", "bvec3", "bvec4", "sampler1D", "sampler2D", "sampler3D", "samplerCube", "sampler1DShadow", "sampler2DShadow", "struct", "asm", "class", "union", "enum", "typedef", "template", "this", "packed", "goto", "switch", "default", "inline", "noinline", "volatile", "public", "static", "extern", "external", "interface", "long", "short", "double", "half", "fixed", "unsigned", "input", "output", "hvec2", "hvec3", "hvec4", "dvec2", "dvec3", "dvec4", "fvec2", "fvec3", "fvec4", "sampler2DRect", "sampler3DRect", "sampler2DRectShadow", "sizeof", "cast", "namespace", "using"]) && (t2.exports = r2);
var o3 = o(t2.exports);
var l;
var a2 = { exports: {} };
l = a2, function(e4) {
  var r4 = ["<<=", ">>=", "++", "--", "<<", ">>", "<=", ">=", "==", "!=", "&&", "||", "+=", "-=", "*=", "/=", "%=", "&=", "^^", "^=", "|=", "(", ")", "[", "]", ".", "!", "~", "*", "/", "%", "+", "-", "<", ">", "&", "^", "|", "?", ":", "=", ",", ";", "{", "}"];
  void 0 !== r4 && (l.exports = r4);
}();
var g2 = o(a2.exports);
var i3 = { exports: {} };
!function(e4) {
  !function(r4) {
    var t3 = /* @__PURE__ */ function() {
      return ["abs", "acos", "all", "any", "asin", "atan", "ceil", "clamp", "cos", "cross", "dFdx", "dFdy", "degrees", "distance", "dot", "equal", "exp", "exp2", "faceforward", "floor", "fract", "gl_BackColor", "gl_BackLightModelProduct", "gl_BackLightProduct", "gl_BackMaterial", "gl_BackSecondaryColor", "gl_ClipPlane", "gl_ClipVertex", "gl_Color", "gl_DepthRange", "gl_DepthRangeParameters", "gl_EyePlaneQ", "gl_EyePlaneR", "gl_EyePlaneS", "gl_EyePlaneT", "gl_Fog", "gl_FogCoord", "gl_FogFragCoord", "gl_FogParameters", "gl_FragColor", "gl_FragCoord", "gl_FragData", "gl_FragDepth", "gl_FragDepthEXT", "gl_FrontColor", "gl_FrontFacing", "gl_FrontLightModelProduct", "gl_FrontLightProduct", "gl_FrontMaterial", "gl_FrontSecondaryColor", "gl_LightModel", "gl_LightModelParameters", "gl_LightModelProducts", "gl_LightProducts", "gl_LightSource", "gl_LightSourceParameters", "gl_MaterialParameters", "gl_MaxClipPlanes", "gl_MaxCombinedTextureImageUnits", "gl_MaxDrawBuffers", "gl_MaxFragmentUniformComponents", "gl_MaxLights", "gl_MaxTextureCoords", "gl_MaxTextureImageUnits", "gl_MaxTextureUnits", "gl_MaxVaryingFloats", "gl_MaxVertexAttribs", "gl_MaxVertexTextureImageUnits", "gl_MaxVertexUniformComponents", "gl_ModelViewMatrix", "gl_ModelViewMatrixInverse", "gl_ModelViewMatrixInverseTranspose", "gl_ModelViewMatrixTranspose", "gl_ModelViewProjectionMatrix", "gl_ModelViewProjectionMatrixInverse", "gl_ModelViewProjectionMatrixInverseTranspose", "gl_ModelViewProjectionMatrixTranspose", "gl_MultiTexCoord0", "gl_MultiTexCoord1", "gl_MultiTexCoord2", "gl_MultiTexCoord3", "gl_MultiTexCoord4", "gl_MultiTexCoord5", "gl_MultiTexCoord6", "gl_MultiTexCoord7", "gl_Normal", "gl_NormalMatrix", "gl_NormalScale", "gl_ObjectPlaneQ", "gl_ObjectPlaneR", "gl_ObjectPlaneS", "gl_ObjectPlaneT", "gl_Point", "gl_PointCoord", "gl_PointParameters", "gl_PointSize", "gl_Position", "gl_ProjectionMatrix", "gl_ProjectionMatrixInverse", "gl_ProjectionMatrixInverseTranspose", "gl_ProjectionMatrixTranspose", "gl_SecondaryColor", "gl_TexCoord", "gl_TextureEnvColor", "gl_TextureMatrix", "gl_TextureMatrixInverse", "gl_TextureMatrixInverseTranspose", "gl_TextureMatrixTranspose", "gl_Vertex", "greaterThan", "greaterThanEqual", "inversesqrt", "length", "lessThan", "lessThanEqual", "log", "log2", "matrixCompMult", "max", "min", "mix", "mod", "normalize", "not", "notEqual", "pow", "radians", "reflect", "refract", "sign", "sin", "smoothstep", "sqrt", "step", "tan", "texture2D", "texture2DLod", "texture2DProj", "texture2DProjLod", "textureCube", "textureCubeLod", "texture2DLodEXT", "texture2DProjLodEXT", "textureCubeLodEXT", "texture2DGradEXT", "texture2DProjGradEXT", "textureCubeGradEXT", "textureSize", "texelFetch"];
    }();
    void 0 !== t3 && (e4.exports = t3);
  }();
}(i3);
var n3 = o(i3.exports);

// ../node_modules/@arcgis/core/views/webgl/reservedWordsGLSL3.js
var e2 = ["layout", "centroid", "smooth", "case", "mat2x2", "mat2x3", "mat2x4", "mat3x2", "mat3x3", "mat3x4", "mat4x2", "mat4x3", "mat4x4", "uint", "uvec2", "uvec3", "uvec4", "samplerCubeShadow", "sampler2DArray", "sampler2DArrayShadow", "isampler2D", "isampler3D", "isamplerCube", "isampler2DArray", "usampler2D", "usampler3D", "usamplerCube", "usampler2DArray", "coherent", "restrict", "readonly", "writeonly", "resource", "atomic_uint", "noperspective", "patch", "sample", "subroutine", "common", "partition", "active", "filter", "image1D", "image2D", "image3D", "imageCube", "iimage1D", "iimage2D", "iimage3D", "iimageCube", "uimage1D", "uimage2D", "uimage3D", "uimageCube", "image1DArray", "image2DArray", "iimage1DArray", "iimage2DArray", "uimage1DArray", "uimage2DArray", "image1DShadow", "image2DShadow", "image1DArrayShadow", "image2DArrayShadow", "imageBuffer", "iimageBuffer", "uimageBuffer", "sampler1DArray", "sampler1DArrayShadow", "isampler1D", "isampler1DArray", "usampler1D", "usampler1DArray", "isampler2DRect", "usampler2DRect", "samplerBuffer", "isamplerBuffer", "usamplerBuffer", "sampler2DMS", "isampler2DMS", "usampler2DMS", "sampler2DMSArray", "isampler2DMSArray", "usampler2DMSArray", "trunc", "round", "roundEven", "isnan", "isinf", "floatBitsToInt", "floatBitsToUint", "intBitsToFloat", "uintBitsToFloat", "packSnorm2x16", "unpackSnorm2x16", "packUnorm2x16", "unpackUnorm2x16", "packHalf2x16", "unpackHalf2x16", "outerProduct", "transpose", "determinant", "inverse", "texture", "textureSize", "textureProj", "textureLod", "textureOffset", "texelFetch", "texelFetchOffset", "textureProjOffset", "textureLodOffset", "textureProjLod", "textureProjLodOffset", "textureGrad", "textureGradOffset", "textureProjGrad", "textureProjGradOffset"];

// ../node_modules/@arcgis/core/views/webgl/testUtils.js
var e3 = { enableCache: false };

// ../node_modules/@arcgis/core/views/webgl/ShaderTranspiler.js
var i4 = 999;
var s2 = 9999;
var c4 = 0;
var p2 = 1;
var u3 = 2;
var f3 = 3;
var d = 4;
var l2 = 5;
var h2 = 6;
var y = 7;
var w = 8;
var g3 = 9;
var m2 = 10;
var k = 11;
var b2 = ["block-comment", "line-comment", "preprocessor", "operator", "integer", "float", "ident", "builtin", "keyword", "whitespace", "eof", "integer"];
function E2() {
  var t3, e4, a4, E3 = 0, _2 = 0, v2 = i4, j2 = [], A4 = [], x3 = 1, D2 = 0, R2 = 0, T2 = false, S3 = false, G3 = "";
  return function(t4) {
    return A4 = [], null !== t4 ? F3(t4.replace ? t4.replace(/\r\n/g, "\n") : t4) : L2();
  };
  function X3(t4) {
    t4.length && A4.push({ type: b2[v2], data: t4, position: R2, line: x3, column: D2 });
  }
  function F3(e5) {
    var r4;
    for (E3 = 0, a4 = (G3 += e5).length; t3 = G3[E3], E3 < a4; ) {
      switch (r4 = E3, v2) {
        case c4:
          E3 = V2();
          break;
        case p2:
          E3 = P();
          break;
        case u3:
          E3 = M2();
          break;
        case f3:
          E3 = O();
          break;
        case d:
          E3 = $();
          break;
        case k:
          E3 = W();
          break;
        case l2:
          E3 = z();
          break;
        case s2:
          E3 = I();
          break;
        case g3:
          E3 = H3();
          break;
        case i4:
          E3 = C3();
      }
      if (r4 !== E3) if ("\n" === G3[r4]) D2 = 0, ++x3;
      else ++D2;
    }
    return _2 += E3, G3 = G3.slice(E3), A4;
  }
  function L2(t4) {
    return j2.length && X3(j2.join("")), v2 = m2, X3("(eof)"), A4;
  }
  function C3() {
    return j2 = j2.length ? [] : j2, "/" === e4 && "*" === t3 ? (R2 = _2 + E3 - 1, v2 = c4, e4 = t3, E3 + 1) : "/" === e4 && "/" === t3 ? (R2 = _2 + E3 - 1, v2 = p2, e4 = t3, E3 + 1) : "#" === t3 ? (v2 = u3, R2 = _2 + E3, E3) : /\s/.test(t3) ? (v2 = g3, R2 = _2 + E3, E3) : (T2 = /\d/.test(t3), S3 = /[^\w_]/.test(t3), R2 = _2 + E3, v2 = T2 ? d : S3 ? f3 : s2, E3);
  }
  function H3() {
    return /[^\s]/g.test(t3) ? (X3(j2.join("")), v2 = i4, E3) : (j2.push(t3), e4 = t3, E3 + 1);
  }
  function M2() {
    return "\r" !== t3 && "\n" !== t3 || "\\" === e4 ? (j2.push(t3), e4 = t3, E3 + 1) : (X3(j2.join("")), v2 = i4, E3);
  }
  function P() {
    return M2();
  }
  function V2() {
    return "/" === t3 && "*" === e4 ? (j2.push(t3), X3(j2.join("")), v2 = i4, E3 + 1) : (j2.push(t3), e4 = t3, E3 + 1);
  }
  function O() {
    if ("." === e4 && /\d/.test(t3)) return v2 = l2, E3;
    if ("/" === e4 && "*" === t3) return v2 = c4, E3;
    if ("/" === e4 && "/" === t3) return v2 = p2, E3;
    if ("." === t3 && j2.length) {
      for (; N(j2); ) ;
      return v2 = l2, E3;
    }
    if (";" === t3 || ")" === t3 || "(" === t3) {
      if (j2.length) for (; N(j2); ) ;
      return X3(t3), v2 = i4, E3 + 1;
    }
    var a5 = 2 === j2.length && "=" !== t3;
    if (/[\w_\d\s]/.test(t3) || a5) {
      for (; N(j2); ) ;
      return v2 = i4, E3;
    }
    return j2.push(t3), e4 = t3, E3 + 1;
  }
  function N(t4) {
    for (var e5, a5, n4 = 0; ; ) {
      if (e5 = g2.indexOf(t4.slice(0, t4.length + n4).join("")), a5 = g2[e5], -1 === e5) {
        if (n4-- + t4.length > 0) continue;
        a5 = t4.slice(0, 1).join("");
      }
      return X3(a5), R2 += a5.length, (j2 = j2.slice(a5.length)).length;
    }
  }
  function W() {
    return /[^a-fA-F0-9]/.test(t3) ? (X3(j2.join("")), v2 = i4, E3) : (j2.push(t3), e4 = t3, E3 + 1);
  }
  function $() {
    return "." === t3 || /[eE]/.test(t3) ? (j2.push(t3), v2 = l2, e4 = t3, E3 + 1) : "x" === t3 && 1 === j2.length && "0" === j2[0] ? (v2 = k, j2.push(t3), e4 = t3, E3 + 1) : /[^\d]/.test(t3) ? (X3(j2.join("")), v2 = i4, E3) : (j2.push(t3), e4 = t3, E3 + 1);
  }
  function z() {
    return "f" === t3 && (j2.push(t3), e4 = t3, E3 += 1), /[eE]/.test(t3) || "-" === t3 && /[eE]/.test(e4) ? (j2.push(t3), e4 = t3, E3 + 1) : /[^\d]/.test(t3) ? (X3(j2.join("")), v2 = i4, E3) : (j2.push(t3), e4 = t3, E3 + 1);
  }
  function I() {
    if (/[^\d\w_]/.test(t3)) {
      var a5 = j2.join("");
      return v2 = o3.indexOf(a5) > -1 ? w : n3.indexOf(a5) > -1 ? y : h2, X3(j2.join("")), v2 = i4, E3;
    }
    return j2.push(t3), e4 = t3, E3 + 1;
  }
}
function _(t3) {
  var e4 = E2(), a4 = [];
  return a4 = (a4 = a4.concat(e4(t3))).concat(e4(null));
}
function v(t3) {
  return _(t3);
}
function j(t3) {
  return t3.map((t4) => "eof" !== t4.type ? t4.data : "").join("");
}
var A3 = /* @__PURE__ */ new Set(["GL_OES_standard_derivatives", "GL_EXT_frag_depth", "GL_EXT_draw_buffers", "GL_EXT_shader_texture_lod"]);
function x2(t3, e4 = "100", a4 = "300 es") {
  const r4 = /^\s*#version\s+([0-9]+(\s+[a-zA-Z]+)?)\s*/;
  for (const n4 of t3) if ("preprocessor" === n4.type) {
    const t4 = r4.exec(n4.data);
    if (t4) {
      const r5 = t4[1].replaceAll(/\s{2,}/g, " ");
      if (r5 === a4) return r5;
      if (r5 === e4) return n4.data = "#version " + a4, e4;
      throw new Error("unknown glsl version: " + r5);
    }
  }
  return t3.splice(0, 0, { type: "preprocessor", data: "#version " + a4 }, { type: "whitespace", data: "\n" }), null;
}
function D(t3, e4) {
  for (let a4 = e4 - 1; a4 >= 0; a4--) {
    const e5 = t3[a4];
    if ("whitespace" !== e5.type && "block-comment" !== e5.type) {
      if ("keyword" !== e5.type) break;
      if ("attribute" === e5.data || "in" === e5.data) return true;
    }
  }
  return false;
}
function R(t3, e4, a4, r4) {
  r4 = r4 || a4;
  for (const n4 of t3) if ("ident" === n4.type && n4.data === a4) {
    r4 in e4 ? e4[r4]++ : e4[r4] = 0;
    return R(t3, e4, r4 + "_" + e4[r4], r4);
  }
  return a4;
}
function T(t3, e4, a4 = "afterVersion") {
  function r4(t4, e5) {
    for (let a5 = e5; a5 < t4.length; a5++) {
      const e6 = t4[a5];
      if ("operator" === e6.type && ";" === e6.data) return a5;
    }
    return null;
  }
  function n4(t4) {
    let e5 = -1, n5 = 0, o6 = -1;
    for (let i6 = 0; i6 < t4.length; i6++) {
      const s5 = t4[i6];
      if ("preprocessor" === s5.type && (/#(if|ifdef|ifndef)\s+.+/.test(s5.data) ? ++n5 : /#endif\s*.*/.test(s5.data) && --n5), "afterVersion" !== a4 && "afterPrecision" !== a4 || "preprocessor" === s5.type && s5.data.startsWith("#version") && (o6 = Math.max(o6, i6)), "afterPrecision" === a4 && "keyword" === s5.type && "precision" === s5.data) {
        const e6 = r4(t4, i6);
        if (null === e6) throw new Error("precision statement not followed by any semicolons!");
        o6 = Math.max(o6, e6);
      }
      e5 < o6 && 0 === n5 && (e5 = i6);
    }
    return e5 + 1;
  }
  const o5 = { data: "\n", type: "whitespace" }, i5 = (e5) => e5 < t3.length && /[^\r\n]$/.test(t3[e5].data);
  let s4 = n4(t3);
  i5(s4 - 1) && t3.splice(s4++, 0, o5);
  for (const c5 of e4) t3.splice(s4++, 0, c5);
  i5(s4 - 1) && i5(s4) && t3.splice(s4, 0, o5);
}
function S2(t3, e4, a4, r4 = "lowp") {
  T(t3, [{ type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: r4 }, { type: "whitespace", data: " " }, { type: "keyword", data: a4 }, { type: "whitespace", data: " " }, { type: "ident", data: e4 }, { type: "operator", data: ";" }], "afterPrecision");
}
function G2(t3, e4, a4, r4, n4 = "lowp") {
  T(t3, [{ type: "keyword", data: "layout" }, { type: "operator", data: "(" }, { type: "keyword", data: "location" }, { type: "whitespace", data: " " }, { type: "operator", data: "=" }, { type: "whitespace", data: " " }, { type: "integer", data: r4.toString() }, { type: "operator", data: ")" }, { type: "whitespace", data: " " }, { type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: n4 }, { type: "whitespace", data: " " }, { type: "keyword", data: a4 }, { type: "whitespace", data: " " }, { type: "ident", data: e4 }, { type: "operator", data: ";" }], "afterPrecision");
}
function X2(t3, e4) {
  let a4, r4, n4 = -1;
  for (let o5 = e4; o5 < t3.length; o5++) {
    const e5 = t3[o5];
    if ("operator" === e5.type && ("[" === e5.data && (a4 = o5), "]" === e5.data)) {
      r4 = o5;
      break;
    }
    "integer" === e5.type && (n4 = parseInt(e5.data, 10));
  }
  return a4 && r4 && t3.splice(a4, r4 - a4 + 1), n4;
}
function F2(a4, r4) {
  if (a4.startsWith("#version 300")) return a4;
  const n4 = C2(a4);
  if (null != n4) return n4;
  const o5 = v(a4);
  if ("300 es" === x2(o5, "100", "300 es")) return a4;
  let i5 = null, s4 = null;
  const c5 = {}, p3 = {};
  for (let u4 = 0; u4 < o5.length; ++u4) {
    const a5 = o5[u4];
    switch (a5.type) {
      case "keyword":
        r4 === H.VERTEX_SHADER && "attribute" === a5.data ? a5.data = "in" : "varying" === a5.data && (a5.data = r4 === H.VERTEX_SHADER ? "out" : "in");
        break;
      case "builtin":
        if (/^texture(2D|Cube)(Proj)?(Lod|Grad)?(EXT)?$/.test(a5.data.trim()) && (a5.data = a5.data.replaceAll(/(2D|Cube|EXT)/g, "")), r4 === H.FRAGMENT_SHADER && "gl_FragColor" === a5.data && (i5 || (i5 = R(o5, c5, "fragColor"), S2(o5, i5, "vec4")), a5.data = i5), r4 === H.FRAGMENT_SHADER && "gl_FragData" === a5.data) {
          const t3 = X2(o5, u4 + 1), e4 = R(o5, c5, "fragData");
          G2(o5, e4, "vec4", t3, "mediump"), a5.data = e4;
        } else r4 === H.FRAGMENT_SHADER && "gl_FragDepthEXT" === a5.data && (s4 || (s4 = R(o5, c5, "gl_FragDepth")), a5.data = s4);
        break;
      case "ident":
        if (e2.includes(a5.data)) {
          if (r4 === H.VERTEX_SHADER && D(o5, u4)) throw new Error("attribute in vertex shader uses a name that is a reserved word in glsl 300 es");
          a5.data in p3 || (p3[a5.data] = R(o5, c5, a5.data)), a5.data = p3[a5.data];
        }
    }
  }
  for (let t3 = o5.length - 1; t3 >= 0; --t3) {
    const e4 = o5[t3];
    if ("preprocessor" === e4.type) {
      const a5 = e4.data.match(/#extension\s+(.*):/);
      if ((a5 == null ? void 0 : a5[1]) && A3.has(a5[1].trim())) {
        const e5 = o5[t3 + 1];
        o5.splice(t3, e5 && "whitespace" === e5.type ? 2 : 1);
      }
      const r5 = e4.data.match(/#ifdef\s+(.*)/);
      (r5 == null ? void 0 : r5[1]) && A3.has(r5[1].trim()) && (e4.data = "#if 1");
      const n5 = e4.data.match(/#ifndef\s+(.*)/);
      (n5 == null ? void 0 : n5[1]) && A3.has(n5[1].trim()) && (e4.data = "#if 0");
    }
  }
  return H2(a4, j(o5));
}
var L = /* @__PURE__ */ new Map();
function C2(t3) {
  return e3.enableCache ? L.get(t3) : null;
}
function H2(t3, e4) {
  return e3.enableCache && L.set(t3, e4), e4;
}

// ../node_modules/@arcgis/core/views/webgl/Program.js
var o4 = 4294967295;
var r3 = class {
  constructor(r4, a4, h4, m4, c5 = /* @__PURE__ */ new Map(), _2 = []) {
    var _a;
    this._context = r4, this._locations = m4, this._uniformBlockBindings = c5, this._transformFeedbackVaryings = _2, this._refCount = 1, this._compiled = false, this._linesOfCode = 0, this._nameToUniformLocation = /* @__PURE__ */ new Map(), this._nameToUniform1 = /* @__PURE__ */ new Map(), this._nameToUniform1v = /* @__PURE__ */ new Map(), this._nameToUniform2 = /* @__PURE__ */ new Map(), this._nameToUniform3 = /* @__PURE__ */ new Map(), this._nameToUniform4 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix3 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix4 = /* @__PURE__ */ new Map(), r4 || console.error("RenderingContext isn't initialized!"), 0 === a4.length && console.error("Shaders source should not be empty!"), a4 = F2(a4, H.VERTEX_SHADER), h4 = F2(h4, H.FRAGMENT_SHADER), this._vShader = s3(this._context, H.VERTEX_SHADER, a4), this._fShader = s3(this._context, H.FRAGMENT_SHADER, h4), f4.enabled && (this._linesOfCode = a4.match(/\n/g).length + h4.match(/\n/g).length + 2, this._context.instanceCounter.increment(V.LinesOfCode, this._vShader, this._linesOfCode)), this._vShader && this._fShader || console.error("Error loading shaders!"), this._context.instanceCounter.increment(V.Shader, this), c() && (this.vertexShader = a4, this.fragmentShader = h4), this.usedMemory = a4.length + h4.length;
    const l3 = this._context.gl, g4 = l3.createProgram();
    l3.attachShader(g4, this._vShader), l3.attachShader(g4, this._fShader), this._locations.forEach((t3, e4) => l3.bindAttribLocation(g4, t3, e4)), ((_a = this._transformFeedbackVaryings) == null ? void 0 : _a.length) && l3.transformFeedbackVaryings(g4, this._transformFeedbackVaryings, l3.SEPARATE_ATTRIBS), l3.linkProgram(g4), c() && !l3.getProgramParameter(g4, l3.LINK_STATUS) && console.error(`Could not link shader
validated: ${l3.getProgramParameter(g4, l3.VALIDATE_STATUS)}, gl error ${l3.getError()}, vertex: ${l3.getShaderParameter(this._vShader, l3.COMPILE_STATUS)}, fragment: ${l3.getShaderParameter(this._fShader, l3.COMPILE_STATUS)}, info log: ${l3.getProgramInfoLog(g4)}, vertex source: ${this.vertexShader}, fragment source: ${this.fragmentShader}`);
    for (const [t3, e4] of this._uniformBlockBindings) {
      const n4 = l3.getUniformBlockIndex(g4, t3);
      n4 < o4 && l3.uniformBlockBinding(g4, n4, e4);
    }
    this._glName = g4, this._context.instanceCounter.increment(V.Program, this);
  }
  get glName() {
    return this._glName;
  }
  get hasGLName() {
    return null != this._glName;
  }
  get hasTransformFeedbackVaryings() {
    var _a;
    return !!((_a = this._transformFeedbackVaryings) == null ? void 0 : _a.length);
  }
  get compiled() {
    if (this._compiled) return true;
    const t3 = this._context.gl.getExtension("KHR_parallel_shader_compile");
    return null == t3 || null == this.glName ? (this._compiled = true, true) : (this._compiled = !!this._context.gl.getProgramParameter(this.glName, t3.COMPLETION_STATUS_KHR), this._compiled);
  }
  dispose() {
    if (--this._refCount > 0) return;
    const t3 = this._context.gl, e4 = this._context.instanceCounter;
    this._nameToUniformLocation.forEach((t4) => t4 && e4.decrement(V.Uniform, t4)), this._nameToUniformLocation.clear(), this._vShader && (this._linesOfCode > 0 && (e4.decrement(V.LinesOfCode, this._vShader, this._linesOfCode), this._linesOfCode = 0), t3.deleteShader(this._vShader), this._vShader = null, e4.decrement(V.Shader, this)), this._fShader && (t3.deleteShader(this._fShader), this._fShader = null), this._glName && (t3.deleteProgram(this._glName), this._glName = null, e4.decrement(V.Program, this));
  }
  ref() {
    ++this._refCount;
  }
  _getUniformLocation(t3) {
    const e4 = this._nameToUniformLocation.get(t3);
    if (void 0 !== e4) return e4;
    if (this.glName) {
      const e5 = this._context.gl.getUniformLocation(this.glName, t3);
      return this._nameToUniformLocation.set(t3, e5), e5 && this._context.instanceCounter.increment(V.Uniform, e5), e5;
    }
    return null;
  }
  hasUniform(t3) {
    return null != this._getUniformLocation(t3);
  }
  setUniform1i(t3, e4) {
    const n4 = this._nameToUniform1.get(t3);
    void 0 !== n4 && e4 === n4 || (this._context.gl.uniform1i(this._getUniformLocation(t3), e4), this._nameToUniform1.set(t3, e4));
  }
  setUniform1iv(t3, e4) {
    m3(this._nameToUniform1v, t3, e4) && this._context.gl.uniform1iv(this._getUniformLocation(t3), e4);
  }
  setUniform2iv(t3, e4) {
    m3(this._nameToUniform2, t3, e4) && this._context.gl.uniform2iv(this._getUniformLocation(t3), e4);
  }
  setUniform3iv(t3, e4) {
    m3(this._nameToUniform3, t3, e4) && this._context.gl.uniform3iv(this._getUniformLocation(t3), e4);
  }
  setUniform4iv(t3, e4) {
    m3(this._nameToUniform4, t3, e4) && this._context.gl.uniform4iv(this._getUniformLocation(t3), e4);
  }
  setUniform1f(t3, e4) {
    const n4 = this._nameToUniform1.get(t3);
    void 0 !== n4 && e4 === n4 || (this._context.gl.uniform1f(this._getUniformLocation(t3), e4), this._nameToUniform1.set(t3, e4));
  }
  setUniform1fv(t3, e4) {
    m3(this._nameToUniform1v, t3, e4) && this._context.gl.uniform1fv(this._getUniformLocation(t3), e4);
  }
  setUniform2f(t3, e4, n4) {
    const i5 = this._nameToUniform2.get(t3);
    void 0 === i5 ? (this._context.gl.uniform2f(this._getUniformLocation(t3), e4, n4), this._nameToUniform2.set(t3, [e4, n4])) : e4 === i5[0] && n4 === i5[1] || (this._context.gl.uniform2f(this._getUniformLocation(t3), e4, n4), i5[0] = e4, i5[1] = n4);
  }
  setUniform2fv(t3, e4) {
    m3(this._nameToUniform2, t3, e4) && this._context.gl.uniform2fv(this._getUniformLocation(t3), e4);
  }
  setUniform3f(t3, e4, n4, i5) {
    const o5 = this._nameToUniform3.get(t3);
    void 0 === o5 ? (this._context.gl.uniform3f(this._getUniformLocation(t3), e4, n4, i5), this._nameToUniform3.set(t3, [e4, n4, i5])) : e4 === o5[0] && n4 === o5[1] && i5 === o5[2] || (this._context.gl.uniform3f(this._getUniformLocation(t3), e4, n4, i5), o5[0] = e4, o5[1] = n4, o5[2] = i5);
  }
  setUniform3fv(t3, e4) {
    const n4 = this._getUniformLocation(t3);
    null != n4 && m3(this._nameToUniform3, t3, e4) && this._context.gl.uniform3fv(n4, e4);
  }
  setUniform4f(t3, e4, n4, i5, o5) {
    const r4 = this._nameToUniform4.get(t3);
    void 0 === r4 ? (this._context.gl.uniform4f(this._getUniformLocation(t3), e4, n4, i5, o5), this._nameToUniform4.set(t3, [e4, n4, i5, o5])) : void 0 !== r4 && e4 === r4[0] && n4 === r4[1] && i5 === r4[2] && o5 === r4[3] || (this._context.gl.uniform4f(this._getUniformLocation(t3), e4, n4, i5, o5), r4[0] = e4, r4[1] = n4, r4[2] = i5, r4[3] = o5);
  }
  setUniform4fv(t3, e4) {
    const n4 = this._getUniformLocation(t3);
    null != n4 && m3(this._nameToUniform4, t3, e4) && this._context.gl.uniform4fv(n4, e4);
  }
  setUniformMatrix3fv(t3, e4, n4 = false) {
    const i5 = this._getUniformLocation(t3);
    null != i5 && m3(this._nameToUniformMatrix3, t3, e4) && this._context.gl.uniformMatrix3fv(i5, n4, e4);
  }
  setUniformMatrix4fv(t3, e4, n4 = false) {
    const i5 = this._getUniformLocation(t3);
    null != i5 && m3(this._nameToUniformMatrix4, t3, e4) && this._context.gl.uniformMatrix4fv(i5, n4, e4);
  }
  stop() {
  }
};
function s3(n4, i5, o5) {
  const r4 = n4.gl, s4 = r4.createShader(i5);
  return r4.shaderSource(s4, o5), r4.compileShader(s4), c() && !r4.getShaderParameter(s4, r4.COMPILE_STATUS) && (console.error("Compile error in ".concat(i5 === H.VERTEX_SHADER ? "vertex" : "fragment", " shader")), console.error(r4.getShaderInfoLog(s4)), console.error(a3(o5))), s4;
}
function a3(t3) {
  let e4 = 2;
  return t3.replaceAll("\n", () => "\n" + h3(e4++) + ":");
}
function h3(t3) {
  return t3 >= 1e3 ? t3.toString() : ("  " + t3).slice(-3);
}
function m3(t3, e4, n4) {
  const i5 = t3.get(e4);
  if (!i5) return t3.set(e4, Array.from(n4)), true;
  const o5 = n4.length;
  if (i5.length !== o5) return t3.set(e4, Array.from(n4)), true;
  for (let r4 = 0; r4 < o5; ++r4) {
    const t4 = n4[r4];
    if (i5[r4] !== t4) {
      for (i5[r4] = t4; r4 < o5; ++r4) i5[r4] = n4[r4];
      return true;
    }
  }
  return false;
}
var f4 = { enabled: false };

export {
  c3 as c,
  i2 as i,
  s,
  E,
  r3 as r
};
//# sourceMappingURL=chunk-235Z7ZG7.js.map
