import {
  r as r2
} from "./chunk-235Z7ZG7.js";
import {
  E
} from "./chunk-4ZTHXCOS.js";
import {
  V
} from "./chunk-POOHJZAR.js";
import {
  r
} from "./chunk-5AEITAWU.js";
import {
  n2 as n
} from "./chunk-YNL57W4I.js";
import {
  p
} from "./chunk-2PA5UPTB.js";

// ../node_modules/@arcgis/core/views/webgl/ShaderCompiler.js
var e = class {
  constructor(e3) {
    this._readFile = e3;
  }
  resolveIncludes(e3) {
    return this._resolve(e3);
  }
  _resolve(e3, t = /* @__PURE__ */ new Map()) {
    if (t.has(e3)) return t.get(e3);
    const r3 = this._read(e3);
    if (!r3) throw new Error(`cannot find shader file ${e3}`);
    const s = /^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;
    let n3 = s.exec(r3);
    const l = [];
    for (; null != n3; ) l.push({ path: n3[1], start: n3.index, length: n3[0].length }), n3 = s.exec(r3);
    let a = 0, h = "";
    return l.forEach((e4) => {
      h += r3.slice(a, e4.start), h += t.has(e4.path) ? "" : this._resolve(e4.path, t), a = e4.start + e4.length;
    }), h += r3.slice(a), t.set(e3, h), h;
  }
  _read(e3) {
    return this._readFile(e3);
  }
};

// ../node_modules/@arcgis/core/views/webgl/VertexArrayObject.js
var n2 = () => n.getLogger("esri.views.webgl.VertexArrayObject");
var o = class {
  constructor(e3, t, i, r3, s = null) {
    this._context = e3, this._locations = t, this._layout = i, this._buffers = r3, this._indexBuffer = s, this._glName = null, this._initialized = false;
  }
  get glName() {
    return this._glName;
  }
  get context() {
    return this._context;
  }
  get vertexBuffers() {
    return this._buffers;
  }
  get indexBuffer() {
    return this._indexBuffer;
  }
  get byteSize() {
    return Object.keys(this._buffers).reduce((e3, t) => e3 + this._buffers[t].usedMemory, null != this._indexBuffer ? this._indexBuffer.usedMemory : 0);
  }
  get layout() {
    return this._layout;
  }
  get locations() {
    return this._locations;
  }
  get usedMemory() {
    return this.byteSize + (Object.keys(this._buffers).length + (this._indexBuffer ? 1 : 0)) * p;
  }
  dispose() {
    var _a;
    if (this._context) {
      this._context.getBoundVAO() === this && this._context.bindVAO(null);
      for (const e3 in this._buffers) (_a = this._buffers[e3]) == null ? void 0 : _a.dispose(), delete this._buffers[e3];
      this._indexBuffer = r(this._indexBuffer), this.disposeVAOOnly();
    } else (this._glName || Object.getOwnPropertyNames(this._buffers).length > 0) && n2().warn("Leaked WebGL VAO");
  }
  disposeVAOOnly() {
    this._glName && (this._context.gl.deleteVertexArray(this._glName), this._glName = null, this._context.instanceCounter.decrement(V.VertexArrayObject, this)), this._context = null;
  }
  initialize() {
    if (this._initialized) return;
    const { gl: e3 } = this._context, t = e3.createVertexArray();
    e3.bindVertexArray(t), this._bindLayout(), e3.bindVertexArray(null), this._glName = t, this._context.instanceCounter.increment(V.VertexArrayObject, this), this._initialized = true;
  }
  bind() {
    this.initialize(), this._context.gl.bindVertexArray(this.glName);
  }
  _bindLayout() {
    const { _buffers: e3, _layout: t, _indexBuffer: i } = this;
    e3 || n2().error("Vertex buffer dictionary is empty!");
    const r3 = this._context.gl;
    for (const o2 in e3) {
      const i2 = e3[o2];
      i2 || n2().error("Vertex buffer is uninitialized!");
      const r4 = t[o2];
      r4 || n2().error("Vertex element descriptor is empty!"), E(this._context, this._locations, i2, r4);
    }
    null != i && r3.bindBuffer(r3.ELEMENT_ARRAY_BUFFER, i.glName);
  }
  unbind() {
    this.initialize(), this._context.gl.bindVertexArray(null);
  }
};

// ../node_modules/@arcgis/core/views/webgl/ProgramTemplate.js
function e2(e3, t, a = "") {
  return new r2(e3, a + t.shaders.vertexShader, a + t.shaders.fragmentShader, t.attributes);
}

export {
  e,
  o,
  e2
};
//# sourceMappingURL=chunk-JYOYXNA4.js.map
