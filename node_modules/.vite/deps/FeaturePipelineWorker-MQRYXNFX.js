import {
  W as W2,
  r
} from "./chunk-V5SM2NNT.js";
import "./chunk-EEUTQFOP.js";
import "./chunk-T5HV76JZ.js";
import {
  M as M2,
  a as a3,
  b as b3,
  i as i2,
  n as n5,
  n2 as n6,
  p,
  p2,
  s as s7,
  t2 as t3
} from "./chunk-YCDX7TWD.js";
import {
  o as o5
} from "./chunk-TNYUXGW7.js";
import {
  t as t4
} from "./chunk-HGR37N5M.js";
import {
  d2 as d5
} from "./chunk-LX3HI5TT.js";
import "./chunk-SLK2EUZ5.js";
import "./chunk-QBIZASGH.js";
import "./chunk-TLURKUXV.js";
import "./chunk-235Z7ZG7.js";
import "./chunk-CWKNMWWX.js";
import "./chunk-JSBYWL75.js";
import "./chunk-W366AY2Q.js";
import {
  $ as $2
} from "./chunk-XDQZOUPG.js";
import "./chunk-4ZTHXCOS.js";
import "./chunk-CL2YKTVD.js";
import "./chunk-FNGV6RWU.js";
import "./chunk-2UJLW7H2.js";
import "./chunk-CRF5P7HT.js";
import "./chunk-Y55T56UT.js";
import {
  a as a2
} from "./chunk-TCGVPS3X.js";
import "./chunk-A2WMIQD6.js";
import "./chunk-GRVB2MLZ.js";
import {
  r as r2
} from "./chunk-WZTFY7IX.js";
import "./chunk-UNI34X2Q.js";
import "./chunk-LXZ5X57H.js";
import "./chunk-POOHJZAR.js";
import {
  S as S2,
  c as c3,
  d as d4
} from "./chunk-5EVRQBNQ.js";
import "./chunk-TTOHDCA7.js";
import {
  b as b2,
  h
} from "./chunk-F6WID7U3.js";
import {
  n as n4
} from "./chunk-MTDWQK7X.js";
import "./chunk-BGYJXU44.js";
import "./chunk-KENYLMTJ.js";
import "./chunk-6RHMAIR4.js";
import "./chunk-DYYENG3B.js";
import {
  $,
  o as o4
} from "./chunk-VR7WVNO3.js";
import {
  j as j2,
  x
} from "./chunk-5T4GYCDT.js";
import "./chunk-P6AJLPW7.js";
import {
  K,
  N,
  Nt,
  O,
  at,
  ct,
  et,
  ft,
  gt,
  nt,
  pt,
  rt,
  w as w2
} from "./chunk-F54TE5DA.js";
import "./chunk-ZPZCSP4J.js";
import {
  e as e4,
  s as s4
} from "./chunk-5YPRHJQA.js";
import {
  e as e3
} from "./chunk-ZVC7ZICV.js";
import "./chunk-VBYAAZGS.js";
import "./chunk-C5TCSNRO.js";
import "./chunk-MGJTYDNO.js";
import "./chunk-PFCHMQMS.js";
import "./chunk-QSCURXVW.js";
import "./chunk-DDQ2RCGU.js";
import "./chunk-OBN3TJ5S.js";
import {
  n as n7
} from "./chunk-UOAQBYAK.js";
import {
  i as i3
} from "./chunk-K7XS7LRW.js";
import "./chunk-VVQOSOJY.js";
import {
  h as h2
} from "./chunk-WI6OODG3.js";
import "./chunk-GQ3ZCFNN.js";
import "./chunk-QKCF7BZB.js";
import {
  e as e5
} from "./chunk-2U77OHLU.js";
import "./chunk-O45ZPWWN.js";
import {
  _
} from "./chunk-VXVUW2QY.js";
import "./chunk-H6PZORTK.js";
import "./chunk-TNRF7MOE.js";
import "./chunk-CYGO6TZX.js";
import "./chunk-6V4RA3W6.js";
import "./chunk-YJXOPMOL.js";
import "./chunk-P3MZKJDB.js";
import "./chunk-JWA73VK6.js";
import "./chunk-UFNQVX5G.js";
import {
  z
} from "./chunk-JFTJTGUT.js";
import "./chunk-4N73DVTU.js";
import "./chunk-PVAXLXWO.js";
import "./chunk-D6KE2FST.js";
import {
  d as d3,
  s as s6,
  y as y2
} from "./chunk-W3XB5XWO.js";
import "./chunk-QG2IIIZW.js";
import {
  Z
} from "./chunk-LXDJBJSP.js";
import "./chunk-OPCT64AO.js";
import "./chunk-VEOZVJAT.js";
import "./chunk-3D32E2TW.js";
import "./chunk-OIFKYPGO.js";
import {
  s as s5
} from "./chunk-JNGB7HKP.js";
import "./chunk-NREDFKHH.js";
import "./chunk-DCOKV3EO.js";
import "./chunk-DZNQTDMC.js";
import "./chunk-URNMKNS6.js";
import "./chunk-3QWMYL5A.js";
import "./chunk-MB5H6D2S.js";
import "./chunk-LVH66MEH.js";
import "./chunk-4FW6GTBF.js";
import "./chunk-E5ZJCKHO.js";
import {
  O as O2,
  c as c4
} from "./chunk-JJIIUFER.js";
import "./chunk-ITGBXG45.js";
import {
  b
} from "./chunk-LLJZCFHW.js";
import "./chunk-VIUFBDIY.js";
import "./chunk-TXIL3QUC.js";
import "./chunk-2ASAB4KA.js";
import {
  c as c2
} from "./chunk-IGNUVZ34.js";
import "./chunk-YUQFVZCH.js";
import "./chunk-TQBRYTUC.js";
import "./chunk-T4EIRKFE.js";
import {
  g
} from "./chunk-OHUWK5XV.js";
import "./chunk-PHVKM5OH.js";
import "./chunk-KQ5GHUVQ.js";
import "./chunk-RTULPMO3.js";
import "./chunk-AJ6PR43V.js";
import "./chunk-6LV4OO46.js";
import "./chunk-JQIB7GFW.js";
import "./chunk-IJ42YN7D.js";
import "./chunk-4AGGGL2W.js";
import "./chunk-FJPG3YI6.js";
import {
  i
} from "./chunk-BJHLU2MM.js";
import "./chunk-Z32PAECZ.js";
import "./chunk-TW7VY7XV.js";
import "./chunk-CAC7FEOV.js";
import {
  n as n3
} from "./chunk-KK4UI5LV.js";
import {
  u as u3
} from "./chunk-BL2UGYYZ.js";
import "./chunk-Q4D7WYWB.js";
import "./chunk-NYWHVRZC.js";
import "./chunk-ZH4RVBER.js";
import "./chunk-UGXIDNPX.js";
import "./chunk-FADA7L64.js";
import "./chunk-YTTIKQNA.js";
import "./chunk-PNUUOKAJ.js";
import {
  d as d2
} from "./chunk-7PMYO342.js";
import "./chunk-4K4GIBGP.js";
import "./chunk-WMMHQ2SA.js";
import "./chunk-AZ7WOCBW.js";
import "./chunk-3DBICPHD.js";
import "./chunk-7R5XEKR3.js";
import {
  o as o2
} from "./chunk-ZK4LSXOH.js";
import "./chunk-XFBTC3BA.js";
import "./chunk-XFU3BDEI.js";
import "./chunk-IZXTMJPP.js";
import "./chunk-5MMVRBZL.js";
import "./chunk-RS5OZZZ5.js";
import {
  j
} from "./chunk-VRHSV3YE.js";
import "./chunk-OVORXUCO.js";
import "./chunk-WLUQPLAY.js";
import "./chunk-BTSZKQPH.js";
import "./chunk-AL3F322A.js";
import {
  M,
  e as e2
} from "./chunk-6N5YXCNN.js";
import "./chunk-MJ2NSPP7.js";
import "./chunk-6YSPJNLC.js";
import {
  w
} from "./chunk-66KCMKB5.js";
import "./chunk-ZART2Y5J.js";
import {
  f as f2
} from "./chunk-F4OBDVPS.js";
import {
  W2 as W,
  o as o3,
  s as s3
} from "./chunk-X3IFQMC4.js";
import "./chunk-4ZEH5SNV.js";
import "./chunk-Z6R2SP3D.js";
import "./chunk-K4UOG562.js";
import {
  U
} from "./chunk-WC4SPMPL.js";
import {
  S,
  y
} from "./chunk-TJUEGVVG.js";
import "./chunk-FXNOKZ3B.js";
import {
  a3 as a,
  t2
} from "./chunk-GEH2VXFC.js";
import {
  e
} from "./chunk-BJY5ADVY.js";
import {
  L,
  c2 as c,
  d,
  f,
  m,
  o,
  s as s2
} from "./chunk-VMWKLHJD.js";
import {
  n as n2,
  u as u2
} from "./chunk-5AEITAWU.js";
import "./chunk-G36SOMYZ.js";
import {
  n2 as n,
  s2 as s,
  u
} from "./chunk-YNL57W4I.js";
import {
  has,
  t
} from "./chunk-2PA5UPTB.js";
import "./chunk-XZXEUADC.js";

// ../node_modules/@arcgis/core/views/2d/layers/features/PipelineConnectionHandlers.js
var t5 = class {
  constructor(e13) {
    this._client = e13, this.layerView = this._client.createInvokeProxy(""), this.container = this._client.createInvokeProxy("container"), this._eventLog = this._client.createInvokeProxy("eventLog");
  }
  onEvent(t17) {
    O2(this._eventLog.onEvent(t17));
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MultiTileMeshData.js
var i4 = 1;
var n8 = 2;
var h3 = 4;
var o6 = 8;
var c5 = 16;
var a4 = 32;
var l = 64;
var f3 = 128;
function u4(e13) {
  switch (e13) {
    case i4:
    case o6:
    case a4:
      return -1;
    case n8:
    case l:
      return 0;
    case h3:
    case c5:
    case f3:
      return 1;
  }
}
function m2(e13) {
  switch (e13) {
    case i4:
    case n8:
    case h3:
      return -1;
    case o6:
    case c5:
      return 0;
    case a4:
    case l:
    case f3:
      return 1;
  }
}
var _2 = i4 | o6 | a4;
var d6 = h3 | c5 | f3;
var p3 = i4 | n8 | h3;
var y3 = a4 | l | f3;
var g2 = class {
  constructor(e13, s18, r9, i12 = 0) {
    this.tileKey = e13, this._bufferingEnabled = s18, this._sizeHint = i12, this._meshes = { self: new n5(this.id, this._sizeHint), neighbors: new Array() }, this._currentRecordOverlaps = 0, this._currentEntityOverlaps = 0, this._copyBufferedDataIntoSelf = r9 && this._bufferingEnabled && 0 === e13.level;
  }
  get id() {
    return this.tileKey.id;
  }
  vertexCount() {
    return this._meshes.self.vertexCount();
  }
  indexCount() {
    return this._meshes.self.indexCount();
  }
  indexEnsureSize(e13) {
    this._meshes.self.indexEnsureSize(e13);
  }
  entityStart(e13, s18 = e13) {
    this._currentEntityOverlaps = 0, this._meshes.self.entityStart(e13, s18);
  }
  entityRecordCount() {
    return this._meshes.self.entityRecordCount();
  }
  entityEnd() {
    if (this._meshes.self.entityEnd(), this._bufferingEnabled) {
      if (this._copyBufferedDataIntoSelf) return;
      for (let e13 = 0; e13 < 8; e13++) {
        const s18 = 1 << e13;
        !!(this._currentEntityOverlaps & s18) && this._meshes.neighbors[e13].entityEnd();
      }
    }
  }
  recordStart(e13, s18, t17) {
    this._currentRecordOverlaps = 0, this._meshes.self.recordStart(e13, s18, t17);
  }
  recordEnd(e13 = 0) {
    const s18 = this._meshes.self.recordEnd(this._currentRecordOverlaps);
    return s18 && 0 !== this._currentRecordOverlaps ? (this._copyIntoNeighbors(), this._currentEntityOverlaps |= this._currentRecordOverlaps, true) : s18;
  }
  recordBounds(e13, s18, t17, r9) {
    this._bufferingEnabled && this._addOverlap(e13, s18, t17, r9);
  }
  recordCount() {
    return this._meshes.self.recordCount();
  }
  metricStart(e13) {
    this._meshes.self.metricStart(e13);
  }
  metricBoxWrite(e13) {
    this._meshes.self.metricBoxWrite(e13);
  }
  metricEnd() {
    this._meshes.self.metricEnd();
  }
  vertexWrite(e13) {
    this._meshes.self.vertexWrite(e13);
  }
  vertexWriteF32(e13) {
    this._meshes.self.vertexWriteF32(e13);
  }
  vertexWriteRegion(e13) {
    this._meshes.self.vertexWriteRegion(e13);
  }
  indexWrite(e13) {
    this._meshes.self.indexWrite(e13);
  }
  serialize(s18) {
    const t17 = { message: [], transferList: [] }, i12 = this._meshes.self.serialize();
    return t17.message.push({ tileId: this.tileKey.id, ...i12.message }), t17.transferList.push(...i12.transferList), this._meshes.neighbors.forEach((i13, n17) => {
      const h6 = i13.serialize(), o16 = 1 << n17, c10 = u4(o16), a12 = m2(o16), l9 = o5(new e5(this.tileKey), c10, a12, s18);
      t17.message.push({ tileId: l9.id, ...h6.message }), t17.transferList.push(...h6.transferList);
    }), t17;
  }
  _addOverlap(e13, t17, r9, i12) {
    const n17 = Math.min(a2 / 2, r9), h6 = Math.min(a2 / 2, i12), o16 = 255 ^ ((e13 < 0 + n17 ? d6 : e13 >= a2 - n17 ? _2 : d6 | _2) | (t17 < 0 + h6 ? y3 : t17 >= a2 - h6 ? p3 : y3 | p3));
    this._currentRecordOverlaps |= o16;
  }
  _copyIntoNeighbors() {
    for (let e13 = 0; e13 < 8; e13++) {
      const r9 = 1 << e13;
      if (!!(this._currentRecordOverlaps & r9)) {
        if (this._copyBufferedDataIntoSelf) {
          const e14 = -u4(r9) * a2, t17 = -m2(r9) * a2;
          if (0 !== t17) continue;
          this._meshes.self.copyLast(e14, t17);
          continue;
        }
        if (!this._meshes.neighbors[e13]) {
          const s18 = Math.floor(this._sizeHint / 16);
          this._meshes.neighbors[e13] = new n5(r9, s18);
        }
        const i12 = this._meshes.neighbors[e13], n17 = -u4(r9) * a2, h6 = -m2(r9) * a2;
        i12.copyLastFrom(this._meshes.self, n17, h6);
      }
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/MeshFactory.js
var s8 = class {
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var t6 = class _t {
  constructor() {
    this._defaultResult = null, this._backgroundFillResult = null;
  }
  static async from(e13, s18) {
    const l9 = new _t();
    return l9.setDefault(await e13.createMeshWriters(s18.meshes)), l9;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(t17) {
    this._defaultResult = t17;
  }
  getBackgroundFill() {
    return this._backgroundFillResult;
  }
  setBackgroundFill(t17) {
    this._backgroundFillResult = t17;
  }
  match(t17, e13) {
    const s18 = this.doMatch(t17, e13) || this.getDefault();
    if (s18 && s18.length > 0) {
      const t18 = this.getBackgroundFill();
      if (t18) return [...t18, ...s18];
    }
    return s18;
  }
  getSortKey(t17, e13) {
    return 0;
  }
  doMatch(t17, e13) {
    return null;
  }
  async fetchResources(t17, e13) {
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/util/DictionaryMatcher.js
var e6 = class _e extends t6 {
  static async fromDictionaryRenderer(t17, s18) {
    return new _e(t17, s18);
  }
  constructor(t17, e13) {
    super(), this._context = t17, this._schema = e13, this._hashToGroup = /* @__PURE__ */ new Map();
  }
  get fieldMap() {
    return this._schema.fieldMap;
  }
  async fetchResources(t17, e13) {
    const s18 = e13.getCursor(), r9 = [];
    for (; s18.next(); ) r9.push(this._updateMeshWriterGroup(t17, s18));
    await Promise.all(r9);
  }
  match(t17, e13) {
    const s18 = t17.getAttributeHash();
    return this._hashToGroup.get(s18);
  }
  async _updateMeshWriterGroup(t17, e13) {
    const s18 = e13.readLegacyFeatureForDisplay(), r9 = e13.getAttributeHash();
    if (this._hashToGroup.has(r9)) return;
    this._hashToGroup.set(r9, null);
    const a12 = await t17.fetchDictionaryResourceImmediate({ type: "dictionary-request", feature: s18 });
    if (!a12) return;
    const h6 = await this._context.createMeshWriters(a12.meshes);
    this._hashToGroup.set(r9, h6);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/util/IntervalMatcher.js
var e7 = class _e extends t6 {
  constructor(t17, e13) {
    super(), this._intervals = [], this._isMaxInclusive = e13, this._field = t17;
  }
  static async fromIntervalSchema(t17, s18) {
    const i12 = await t17.storage.createComputedField(s18), r9 = new _e(i12, s18.isMaxInclusive);
    await Promise.all(s18.intervals.map(async (e13) => {
      const s19 = await t17.createMeshWriters(e13.meshes);
      r9.add(e13, s19);
    }));
    const a12 = await t17.createMeshWriters(s18.defaultSymbol);
    r9.setDefault(a12);
    const n17 = await t17.createMeshWriters(s18.backgroundFill);
    return r9.setBackgroundFill(n17), r9;
  }
  add(t17, e13) {
    this._intervals.push({ interval: t17, result: e13 }), this._intervals.sort((t18, e14) => t18.interval.min - e14.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  doMatch(t17, e13) {
    var _a;
    const s18 = (_a = this._field) == null ? void 0 : _a.read(t17, e13);
    if (null == s18 || isNaN(s18) || s18 === 1 / 0 || s18 === -1 / 0) return null;
    for (let i12 = 0; i12 < this._intervals.length; i12++) {
      const { interval: t18, result: e14 } = this._intervals[i12], r9 = s18 >= t18.min, a12 = this._isMaxInclusive ? s18 <= t18.max : s18 < t18.max;
      if (r9 && a12) return e14;
    }
    return null;
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/util/LabelMatcher.js
var a5 = class _a extends t6 {
  static async fromLabelSchema(e13, s18) {
    const r9 = s18.classes.map(async (a12) => {
      const s19 = await e13.createMeshWriters(a12.meshes);
      return { minScale: a12.minScale, maxScale: a12.maxScale, meshes: s19, expression: null, where: await e13.storage.createWhereClause(a12.where) };
    }), t17 = await Promise.all(r9);
    return new _a(t17);
  }
  constructor(e13) {
    super(), this._labels = e13;
  }
  match(e13, a12) {
    if (!this._labels.length) return null;
    const s18 = this._getLabels(a12.$view.scale), r9 = [];
    for (const t17 of s18) t17.where && !t17.where(e13) || r9.push(...t17.meshes);
    return r9;
  }
  _getLabels(e13) {
    return this._labels.filter((a12) => this._validForTileScale(a12, e13));
  }
  _validForTileScale(e13, a12) {
    const s18 = a12 - a12 / 4, r9 = a12 + a12 / 2;
    return (!e13.minScale || e13.minScale >= s18) && (!e13.maxScale || e13.maxScale <= r9);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/util/MapMatcher.js
var t7 = class _t extends t6 {
  constructor(e13, t17) {
    super(), this._defaultSymbolSortKey = 0, this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fields = e13, this._separator = t17 || "";
  }
  static async fromMatcherSchema(e13, l9) {
    const s18 = l9.expression ? [e13.storage.createComputedField({ expression: l9.expression })] : [l9.field ? e13.storage.createComputedField({ field: l9.field }) : null, l9.field2 ? e13.storage.createComputedField({ field: l9.field2 }) : null, l9.field3 ? e13.storage.createComputedField({ field: l9.field3 }) : null], r9 = (await Promise.all(s18)).filter((e14) => !!e14), i12 = new _t(r9, l9.fieldDelimiter), a12 = await e13.createMeshWriters(l9.defaultSymbol);
    i12.setDefault(a12);
    const u8 = await e13.createMeshWriters(l9.backgroundFill);
    return i12.setBackgroundFill(u8), await Promise.all(l9.map.map(async (t17, l10) => {
      const s19 = await e13.createMeshWriters(t17.symbol);
      "<Null>" === t17.value ? i12.setNullResult(s19) : i12.add(t17.value, s19, l10 + 1);
    })), i12;
  }
  setNullResult(e13) {
    this._nullResult = e13;
  }
  getSortKey(e13, t17) {
    const l9 = this._getValueFromFields(e13, t17);
    if (null == l9 || "" === l9 || "<Null>" === l9) return 0;
    const s18 = this._resultsMap.get(l9.toString());
    return s18 ? s18.sortKey : this._defaultSymbolSortKey;
  }
  add(e13, t17, l9) {
    this._resultsMap.set(e13.toString(), { meshWriters: t17, sortKey: l9 }), this._defaultSymbolSortKey = Math.max(this._defaultSymbolSortKey, l9 + 1);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  doMatch(e13, t17) {
    var _a;
    const l9 = this._getValueFromFields(e13, t17);
    if (null !== this._nullResult && (null == l9 || "" === l9 || "<Null>" === l9)) return this._nullResult;
    if (null == l9) return null;
    const s18 = l9.toString();
    return (_a = this._resultsMap.get(s18)) == null ? void 0 : _a.meshWriters;
  }
  _getValueFromFields(e13, t17) {
    const l9 = [];
    for (const s18 of this._fields) {
      const r9 = s18.read(e13, t17);
      null == r9 || "" === r9 ? l9.push("<Null>") : l9.push(r9);
    }
    return l9.join(this._separator);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/util/createMatcher.js
async function c6(c10, u8) {
  switch (u8.type) {
    case "simple":
    case "heatmap":
    case "dot-density":
    case "pie-chart":
      return t6.from(c10, u8);
    case "interval":
      return e7.fromIntervalSchema(c10, u8);
    case "dictionary":
      return e6.fromDictionaryRenderer(c10, u8);
    case "label":
      return a5.fromLabelSchema(c10, u8);
    case "map":
      return t7.fromMatcherSchema(c10, u8);
    case "subtype":
      return n9.fromSubtypes(c10, u8);
    case "cluster":
      return o7.fromClusterSchema(c10, u8);
    default:
      throw new Error("Impl");
  }
}
var n9 = class _n extends t6 {
  constructor(e13, t17) {
    super(), this._subMatchers = e13, this._subtypeField = t17;
  }
  static async fromSubtypes(e13, t17) {
    const r9 = /* @__PURE__ */ new Map(), s18 = [];
    for (const a12 in t17.renderers) {
      const n17 = parseInt(a12, 10), o16 = c6(e13, t17.renderers[a12]).then((e14) => r9.set(n17, e14));
      s18.push(o16);
    }
    return await Promise.all(s18), new _n(r9, t17.subtypeField);
  }
  match(e13, t17) {
    const r9 = e13.readAttribute(this._subtypeField), s18 = this._subMatchers.get(r9);
    return s18 ? s18.match(e13, t17) : null;
  }
};
var o7 = class _o extends t6 {
  static async fromClusterSchema(e13, t17) {
    const [r9, s18] = await Promise.all([c6(e13, t17.feature), c6(e13, t17.cluster)]);
    return new _o(r9, s18);
  }
  constructor(e13, t17) {
    super(), this._featureMatcher = e13, this._clusterMatcher = t17;
  }
  match(e13, t17) {
    return 1 === e13.readAttribute("cluster_count") ? this._featureMatcher.match(e13, t17) : this._clusterMatcher.match(e13, t17);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/FeatureMeshFactory.js
var s9 = class _s extends s8 {
  static async create(e13, o16) {
    const r9 = await c6(e13, o16.symbology), c10 = o16.labels ? await c6(e13, o16.labels) : null;
    return new _s(r9, c10);
  }
  constructor(e13, t17) {
    super(), this._symbology = e13, this._labels = t17;
  }
  destroy() {
  }
  async enqueueMatcherRequests(e13, t17) {
    var _a;
    await Promise.all([this._symbology.fetchResources(e13, t17), (_a = this._labels) == null ? void 0 : _a.fetchResources(e13, t17)]);
  }
  enqueueWriterRequests(e13, t17, s18) {
    const o16 = this._symbology.match(t17, s18);
    if (o16) {
      for (const r9 of o16) r9.enqueueRequest(e13, t17, s18);
      if (this._labels) {
        const o17 = this._labels.match(t17, s18);
        if (!o17) return;
        for (const r9 of o17) r9.enqueueRequest(e13, t17, s18);
      }
    }
  }
  write(e13, t17, s18, o16, r9) {
    const c10 = this._symbology.match(s18, o16);
    if (!c10) return;
    for (const i12 of c10) i12.write(e13, t17, s18, o16, r9);
    if (e13.entityRecordCount() >= 1 && this._labels) {
      const i12 = this._labels.match(s18, o16);
      if (!i12) return;
      for (const a12 of i12) a12.setReferences(c10), a12.write(e13, t17, s18, o16, r9);
    }
  }
  getSortKey(e13, t17) {
    return this._symbology.getSortKey(e13, t17);
  }
};

// ../node_modules/@arcgis/core/views/2d/engine/webgl/util/MatcherContext.js
var s10 = class {
  constructor(s18, r9, t17, e13) {
    this.storage = s18, this.proxy = r9, this.viewParams = t17, this.registry = e13;
  }
  async createMeshWriters(s18) {
    const r9 = s18.map((s19) => this.registry.createMeshWriter(this.storage, this.proxy, this.viewParams, s19));
    return Promise.all(r9);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/ProcessorTileMessageQueue.js
var e8 = class {
  constructor(e13) {
    this._outstandingMessages = [], this._queue = new _({ concurrency: e13.concurrency, process: (s18) => e13.process(s18) });
  }
  async push(s18) {
    if (s18.end) return await Promise.all(this._outstandingMessages), await this._queue.push(s18), void (this._outstandingMessages = []);
    const e13 = this._queue.push(s18);
    return this._outstandingMessages.push(e13), e13;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/aggregation/ComputedAggregateField.js
var s11 = class _s {
  static async create(i12, e13) {
    var _a;
    if ("count" === e13.statisticType) {
      const i13 = new r(1);
      return new _s(e13.name, e13.alias, e13.type, e13.statisticType, i13);
    }
    const a12 = await i12.createComputedField({ expression: (_a = e13.onStatisticExpression) == null ? void 0 : _a.expression, field: e13.onStatisticField });
    return new _s(e13.name, e13.alias, e13.type, e13.statisticType, a12);
  }
  constructor(t17, s18, i12, e13, a12) {
    this.name = t17, this.alias = s18, this.type = i12, this.statisticType = e13, this.computed = a12;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/processor/AProcessorStrategy.js
var t8 = class {
  constructor(t17) {
    this.subscription = t17, this.handledChunks = /* @__PURE__ */ new Set();
  }
  destroy() {
  }
};
var e9 = class {
  constructor(t17, e13) {
    this._source = t17, this._attributeStore = e13, this._sendStates = /* @__PURE__ */ new Map();
  }
  destroy() {
  }
  get enablePixelBuffering() {
    return true;
  }
  onSubscribe(t17) {
    const e13 = this.createState(t17);
    this._sendStates.set(t17.key.id, e13), this.updateChunks();
  }
  onUnsubscribe(t17) {
    var _a;
    (_a = this._sendStates.get(t17.key.id)) == null ? void 0 : _a.destroy(), this._sendStates.delete(t17.key.id);
  }
  invalidate() {
    const t17 = Array.from(this._sendStates.values());
    this._sendStates.clear();
    for (const e13 of t17) e13.destroy(), this.onSubscribe(e13.subscription);
  }
  invalidateAttributeData() {
  }
  getFeatureObjectIdsForAggregate(t17) {
    throw new Error("InternalError: AggregateId lookup not supported");
  }
  getDisplayIds(t17) {
    return this.displayMap(t17, (t18) => t18, (t18) => t18);
  }
  getDisplayAndObjectIds(t17) {
    return this.displayMap(t17, (t18) => t18, (t18, e13, s18) => [t18, s18]);
  }
  afterUpdateChunks() {
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/processor/AAggregateStrategy.js
var i5 = class extends e9 {
  constructor(t17, r9, s18, o16) {
    super(t17, r9), this.spatialReference = s18, this.aggregateFields = o16, this.events = new o2(), this.featureAdapter = o4;
  }
  get aggregateQueryEngine() {
    return this._aggregateQueryEngine || (this._aggregateQueryEngine = new $({ featureStore: this, fieldsIndex: this._metadata.fieldsIndex, geometryType: this._metadata.geometryType, objectIdField: this._metadata.objectIdField, spatialReference: this.spatialReference })), this._aggregateQueryEngine;
  }
  removeChunks(e13) {
  }
  forEach(e13) {
    return this.forEachAggregateWorldSpace(e13);
  }
  forEachInBounds(e13, t17) {
  }
  forEachBounds(e13, a12) {
    const s18 = i();
    for (const t17 of e13) {
      const e14 = gt(s18, t17.geometry, false, false);
      e14 && a12(e14);
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceMessage.js
var e10 = class {
  constructor(e13, i12, t17, s18, r9) {
    this.subscription = e13, this.reader = i12, this.clear = t17, this.end = s18, this.debugInfo = r9, this.type = "append";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e13, i12, t17) {
    return { type: "append", clear: this.clear, id: this.id, append: e13, end: this.end, debugInfo: this.debugInfo, subscriptionVesrion: this.subscription.version, version: i12, attributeEpoch: t17 };
  }
};
var i6 = class {
  constructor(e13, i12, t17, s18, r9) {
    this.subscription = e13, this.reader = i12, this.remove = t17, this.end = s18, this.debugInfo = r9, this.type = "update";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e13, i12, t17) {
    return { type: "update", id: this.id, modify: e13, debugInfo: this.debugInfo, remove: this.remove, version: i12, subscriptionVesrion: this.subscription.version, end: this.end, attributeEpoch: t17 };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderJSON.js
var u5 = class _u extends M2 {
  static fromFeatures(t17, r9) {
    const { objectIdField: s18, geometryType: i12 } = r9, n17 = et([], t17, i12, false, false, s18);
    for (let e13 = 0; e13 < n17.length; e13++) n17[e13].displayId = t17[e13].displayId;
    return _u.fromOptimizedFeatures(n17, r9);
  }
  static fromFeatureSet(e13, r9) {
    const s18 = ct(e13, r9.objectIdField);
    return _u.fromOptimizedFeatureSet(s18, r9);
  }
  static fromOptimizedFeatureSet(e13, t17) {
    const r9 = _u.fromOptimizedFeatures(e13.features, t17);
    return r9._exceededTransferLimit = e13.exceededTransferLimit, r9._transform = e13.transform, r9._fieldsIndex = new Z(e13.fields), r9;
  }
  static fromOptimizedFeatures(e13, t17, r9) {
    const s18 = new _u(e13, t17);
    return s18._fieldsIndex = t17.fieldsIndex, s18._transform = r9, s18;
  }
  static empty(e13) {
    return new _u([], e13);
  }
  constructor(e13, t17) {
    super(t17), this._exceededTransferLimit = false, this._featureIndex = -1, this._fieldsIndex = null, this._geometryType = t17.geometryType, this._features = e13;
  }
  get fields() {
    return this._fieldsIndex;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasFeatures() {
    return !!this._features.length;
  }
  get hasNext() {
    return this._featureIndex + 1 < this._features.length;
  }
  get exceededTransferLimit() {
    return this._exceededTransferLimit;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get _current() {
    return this._features[this._featureIndex];
  }
  removeIds(e13) {
    const t17 = new Set(e13);
    this._features = this._features.filter((e14) => !(null != e14.objectId && t17.has(e14.objectId)));
  }
  getSize() {
    return this._features.length;
  }
  getCursor() {
    return this.copy();
  }
  getInTransform() {
    return this._transform;
  }
  getAttributeHash() {
    let e13 = "";
    for (const t17 in this._current.attributes) e13 += this._current.attributes[t17];
    return e13;
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e13) {
    this._featureIndex = e13;
  }
  getObjectId() {
    var _a;
    return (_a = this._current) == null ? void 0 : _a.objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(e13) {
    this._current.displayId = e13;
  }
  copy() {
    const e13 = new _u(this._features, this.metadata);
    return this.copyInto(e13), e13;
  }
  next() {
    for (; ++this._featureIndex < this._features.length && !this._getExists(); ) ;
    return this._featureIndex < this._features.length;
  }
  readGeometryArea() {
    return s4(this._current) ? Nt(this._current.geometry, 2) : 0;
  }
  _readX() {
    return s4(this._current) ? this._current.geometry.coords[0] : 0;
  }
  _readY() {
    return s4(this._current) ? this._current.geometry.coords[1] : 0;
  }
  _readGeometry() {
    return s4(this._current) ? this._current.geometry ?? null : null;
  }
  _readServerCentroid() {
    return this._current.centroid;
  }
  _readAttribute(e13, t17) {
    var _a;
    if (!this._fieldsIndex) {
      const t18 = this._current.attributes[e13];
      if (void 0 !== t18) return t18;
      const r10 = e13.toLowerCase();
      for (const e14 in this._current.attributes) if (e14.toLowerCase() === r10) return this._current.attributes[e14];
      return;
    }
    const r9 = this._fieldsIndex.get(e13);
    if (!r9) return;
    let s18 = this._current.attributes[r9.name];
    return null == s18 ? s18 : ("esriFieldTypeTimestampOffset" === ((_a = this.fields.get(e13)) == null ? void 0 : _a.type) && (s18 = this.parseTimestampOffset(s18)), t17 && this.fields.isDateField(e13) ? new Date(s18) : s18);
  }
  _readAttributes() {
    return this._current.attributes;
  }
  copyInto(e13) {
    super.copyInto(e13), e13._featureIndex = this._featureIndex, e13._transform = this._transform, e13._fieldsIndex = this._fieldsIndex;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/processor/BinningStrategy.js
var m3 = class extends t8 {
  constructor(e13, t17) {
    super(e13), this.bins = /* @__PURE__ */ new Map(), this.featureCache = /* @__PURE__ */ new Map(), this.done = false, this._store = t17;
  }
  reset() {
    this.destroy(), this.done = false;
  }
  destroy() {
    const e13 = this.subscription.tile.key.level;
    for (const t17 of this.featureCache.keys()) this._store.releaseDisplayIdForObjectId(`${t17}.${e13}`);
    this.bins.clear(), this.featureCache.clear(), this.handledChunks.clear();
  }
  get tile() {
    return this.subscription.tile;
  }
  *featuresWorldSpace() {
    for (const t17 of this.featureCache.values()) {
      const s18 = t17.clone();
      s18.geometry && pt(s18.geometry, s18.geometry, false, false, this.subscription.tile.transform), yield s18;
    }
  }
};
var g3 = class _g extends i5 {
  static async create(e13, t17, s18, a12, o16) {
    const n17 = new p({ spatialReference: t17 }), l9 = await Promise.all(e13.fields.map(async (e14) => s11.create(n17, e14))), u8 = e13.featureFilter ? await p2.create({ geometryType: s18.metadata.geometryType, hasM: false, hasZ: false, timeInfo: s18.metadata.timeInfo, fieldsIndex: s18.metadata.fieldsIndex, spatialReference: t17, filterJSON: e13.featureFilter }) : null;
    return "geohash" === e13.index.type && await x(t17, f2.WGS84), new _g(e13, u8, o16, l9, t17, s18, a12);
  }
  constructor(e13, t17, s18, r9, i12, a12, o16) {
    super(a12, o16, i12, r9), this._schema = e13, this._featureFilter = t17, this._timeZone = s18, this._metadata = new i2({ geometryType: "esriGeometryPolygon", objectIdField: "aggregateId", fields: e13.fields, globalIdField: null, spatialReference: a12.metadata.spatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, typeIdField: null, types: null });
  }
  createState(e13) {
    return new m3(e13, this._attributeStore);
  }
  async *applyLocalEdit(e13) {
    for (const t17 of this._sendStates.values()) {
      t17.reset();
      const e14 = new e10(t17.subscription, u5.empty(this._source.metadata), true, false, {});
      yield e14;
    }
  }
  displayMap(e13, t17, s18) {
    const r9 = new Map(e13.map((e14) => [t17(e14), e14])), i12 = [];
    for (const a12 of this._sendStates.values()) for (const e14 of a12.featuresWorldSpace()) {
      const { objectId: t18, displayId: a13 } = e14, o16 = r9.get(t18);
      if (null != o16) {
        const e15 = s18(a13, o16, t18);
        i12.push(e15), r9.delete(t18);
      }
    }
    return i12;
  }
  getDisplayFeatures(e13) {
    const s18 = new Set(e13), r9 = /* @__PURE__ */ new Set(), i12 = [];
    for (const a12 of this._sendStates.values()) for (const e14 of a12.featuresWorldSpace()) s18.has(e14.displayId) && !r9.has(e14.objectId) && (e14.geometry && i12.push({ ...nt(e14, this._metadata.geometryType, false, false), displayId: e14.displayId }), r9.add(e14.objectId));
    return { features: [], aggregates: i12 };
  }
  getFeatureObjectIdsForAggregate(e13) {
    for (const t17 of this._sendStates.values()) for (const s18 of t17.bins.values()) if (s18.id === e13) return Array.from(s18.containedObjectIds);
    return [];
  }
  async *updateChunks() {
    if (this._source.chunks().length) for (const e13 of this._sendStates.values()) yield* this._update(e13, this._source);
  }
  forEachAggregateWorldSpace(e13) {
    for (const t17 of this._sendStates.values()) for (const s18 of t17.featuresWorldSpace()) e13(s18);
  }
  _createIndexOptions(e13) {
    switch (this._schema.index.type) {
      case "geohash":
        return { type: "geohash", fields: this.aggregateFields, featureFilter: this._featureFilter, geohashLevel: this._schema.index.fixBinLevel, spatialReference: this.spatialReference, timeZone: this._timeZone, scale: e13.scale };
      case "grid": {
        const t17 = this._schema.index.fixedBinLevel, s18 = null != t17 ? e13.tileInfoView.getLODInfoAt(t17).scale : e13.scale;
        return { type: "grid", fields: this.aggregateFields, cellSize: this._schema.index.size, featureFilter: this._featureFilter, spatialReference: this.spatialReference, timeZone: this._timeZone, scale: s18 };
      }
    }
  }
  async *_update(e13, t17) {
    const { handledChunks: r9, subscription: i12, bins: a12, featureCache: o16 } = e13, n17 = i12.tile;
    if (e13.done) return;
    for (const s18 of t17.chunks()) {
      if (r9.has(s18.chunkId)) continue;
      r9.add(s18.chunkId);
      const t18 = s18.queryInfo;
      if ("tileId" in t18) {
        const e14 = new e5(t18.tileId);
        if (e14.level !== n17.level || e14.world !== n17.key.world) continue;
      }
      s18.getAggregateIndex(this._createIndexOptions(e13.tile)).putBounded(a12, e13.tile.extent, e13.tile.resolution);
    }
    const c10 = [], d9 = i12.tile.transform, u8 = i12.tile.key.level;
    for (const l9 of a12.values()) {
      let e14 = o16.get(l9.id);
      if (e14) e14.attributes = l9.getAttributes();
      else {
        const t18 = l9.getGeometry(this.spatialReference, d9);
        e14 = new e4(t18, l9.getAttributes(), null), t18 || (e14.centroid = l9.getGeometricCentroid(this.spatialReference, d9)), e14.objectId = l9.id, e14.displayId = this._attributeStore.createDisplayIdForObjectId(`${e14.objectId}.${u8}`), o16.set(l9.id, e14);
      }
      c10.push(e14);
    }
    this.events.emit("changed"), e13.done = !t17.updateTracking.updating;
    const h6 = u5.fromOptimizedFeatures(c10, this._metadata, d9), m9 = h6.getCursor(), g5 = e13.subscription.tile.createArcadeEvaluationOptions(this._timeZone);
    for (; m9.next(); ) this._attributeStore.setAttributeData(m9.getDisplayId(), m9, g5);
    const y8 = new i6(e13.subscription, h6, [], e13.done, {});
    yield y8;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateCell.js
var t9 = class {
  constructor(t17) {
    this._statistics = t17;
  }
  get statistics() {
    return this._statistics;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/aggregation/AccumulatedStatistics.js
var e11 = Math.PI / 180;
var s12 = class _s {
  static create(t17) {
    return new _s(t17.map((t18) => i7(t18)));
  }
  constructor(t17) {
    this._statistics = t17;
  }
  values() {
    return this._statistics.values();
  }
  insert(t17, e13) {
    for (const s18 of this._statistics) s18.insert(t17, e13);
  }
  merge(t17) {
    for (let e13 = 0; e13 < this._statistics.length; e13++) {
      const s18 = this._statistics[e13], i12 = t17._statistics[e13];
      if (s18.field.name !== i12.field.name) throw new Error("InternalError: Tried to merge incompatible statistics");
      s18.merge(i12);
    }
  }
  clone() {
    return new _s(this._statistics.map((t17) => t17.clone()));
  }
};
function i7(t17) {
  switch (t17.statisticType) {
    case "min":
      return new r3(t17);
    case "max":
      return new u6(t17);
    case "avg":
      return new c7(t17);
    case "avg_angle":
      return new h4(t17);
    case "sum":
    case "count":
      return new a6(t17);
    case "mode":
      return new o8(t17);
  }
}
var n10 = class {
  constructor(t17) {
    this.field = t17;
  }
  insert(e13, s18) {
    if (!this.field.computed) return;
    const i12 = this.field.computed.read(e13, s18);
    n6(i12) || this._insertValue(i12);
  }
};
var r3 = class _r extends n10 {
  constructor() {
    super(...arguments), this.type = "min", this.value = Number.MAX_VALUE;
  }
  _insertValue(t17) {
    this.value = Math.min(this.value, t17);
  }
  merge(t17) {
    this.value = Math.min(this.value, t17.value);
  }
  clone() {
    const t17 = new _r(this.field);
    return t17.value = this.value, t17;
  }
};
var u6 = class _u extends n10 {
  constructor() {
    super(...arguments), this.type = "max", this.value = Number.MIN_VALUE;
  }
  _insertValue(t17) {
    this.value = Math.max(this.value, t17);
  }
  merge(t17) {
    this.value = Math.max(this.value, t17.value);
  }
  clone() {
    const t17 = new _u(this.field);
    return t17.value = this.value, t17;
  }
};
var a6 = class _a extends n10 {
  constructor() {
    super(...arguments), this.type = "sum", this.value = 0;
  }
  _insertValue(t17) {
    this.value += t17;
  }
  merge(t17) {
    this.value += t17.value;
  }
  clone() {
    const t17 = new _a(this.field);
    return t17.value = this.value, t17;
  }
};
var c7 = class _c extends n10 {
  constructor() {
    super(...arguments), this.type = "avg", this._total = 0, this._count = 0;
  }
  get value() {
    return this._total / this._count;
  }
  _insertValue(t17) {
    this._total += t17, this._count += 1;
  }
  merge(t17) {
    this._total += t17._total, this._count += t17._count;
  }
  clone() {
    const t17 = new _c(this.field);
    return t17._total = this._total, t17._count = this._count, t17;
  }
};
var h4 = class _h extends n10 {
  constructor() {
    super(...arguments), this.type = "avg_angle", this._x = 0, this._y = 0, this._count = 0;
  }
  get value() {
    const t17 = this._x / this._count, e13 = this._y / this._count, s18 = 180 / Math.PI;
    return Math.atan2(e13, t17) * s18;
  }
  _insertValue(t17) {
    this._x = this._x + Math.cos(t17 * e11), this._y = this._y + Math.sin(t17 * e11), this._count += 1;
  }
  merge(t17) {
    this._x += t17._x, this._y += t17._y, this._count += t17._count;
  }
  clone() {
    const t17 = new _h(this.field);
    return t17._x = this._x, t17._y = this._y, t17._count = this._count, t17;
  }
};
var o8 = class _o extends n10 {
  constructor() {
    super(...arguments), this._frequencies = /* @__PURE__ */ new Map();
  }
  get value() {
    let t17, e13 = 0;
    for (const [s18, i12] of this._frequencies.entries()) i12 > e13 && (e13 = i12, t17 = s18);
    return t17;
  }
  _insertValue(t17) {
    const e13 = this._frequencies.get(t17);
    null != e13 ? this._frequencies.set(t17, e13 + 1) : this._frequencies.set(t17, 1);
  }
  merge(t17) {
    for (const [e13, s18] of t17._frequencies.entries()) {
      const t18 = this._frequencies.get(e13);
      null != t18 ? this._frequencies.set(e13, t18 + s18) : this._frequencies.set(e13, s18);
    }
  }
  clone() {
    const t17 = new _o(this.field);
    return t17._frequencies = new Map(this._frequencies), t17;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridCell.js
var l2 = class _l extends t9 {
  static createId(t17, e13) {
    return `${t17}.${e13}`;
  }
  static create(t17, e13, r9, i12) {
    return new _l(t17, e13, s12.create(r9), i12);
  }
  constructor(t17, e13, r9, i12) {
    super(r9), this.gridX = t17, this.gridY = e13, this._worldUnitsPerCell = i12, this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._objectIds = /* @__PURE__ */ new Set();
  }
  get id() {
    return _l.createId(this.gridX, this.gridY);
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  get firstObjectId() {
    return this._objectIds.values().next().value;
  }
  get centroidXWorld() {
    return this._xWorldTotal / this._count;
  }
  get centroidYWorld() {
    return this._yWorldTotal / this._count;
  }
  clone() {
    const t17 = new _l(this.gridX, this.gridY, this._statistics.clone(), this._worldUnitsPerCell);
    return t17._count = this._count, t17._xWorldTotal = this._xWorldTotal, t17._yWorldTotal = this._yWorldTotal, t17._firstFeatureAttributes = this._firstFeatureAttributes, t17._objectIds = new Set(this._objectIds), t17;
  }
  insert(t17, e13, r9, i12) {
    0 === this._count ? this._firstFeatureAttributes = t17.readAttributes() : this._firstFeatureAttributes = null, this._count += 1, this._xWorldTotal += r9, this._yWorldTotal += i12, this._statistics.insert(t17, e13), this._objectIds.add(t17.getObjectId());
  }
  merge(t17) {
    if (0 !== t17._count) {
      this._count += t17._count, this._firstFeatureAttributes = t17._firstFeatureAttributes, this._xWorldTotal += t17._xWorldTotal, this._yWorldTotal += t17._yWorldTotal, this._statistics.merge(t17._statistics);
      for (const e13 of t17._objectIds.values()) this._objectIds.add(e13);
    }
  }
  getCentroidX(e13) {
    return null == e13 ? this.centroidXWorld : N(e13, this.centroidXWorld);
  }
  getCentroidY(t17) {
    return null == t17 ? this.centroidYWorld : w2(t17, this.centroidYWorld);
  }
  getGeometry(t17, e13) {
    const s18 = this.gridX * this._worldUnitsPerCell, o16 = this.gridY * this._worldUnitsPerCell, l9 = new e3([4], [s18, o16, s18 + this._worldUnitsPerCell, o16, s18 + this._worldUnitsPerCell, o16 + this._worldUnitsPerCell, s18, o16 + this._worldUnitsPerCell]);
    if (null != e13) {
      const t18 = new e3();
      return at(t18, l9, false, false, "esriGeometryPolygon", e13);
    }
    return l9;
  }
  getCentroid(t17) {
    const e13 = new e3([], [this.centroidXWorld, this.centroidYWorld]);
    if (null != t17) {
      const s18 = new e3();
      return at(s18, e13, false, false, "esriGeometryPoint", t17);
    }
    return e13;
  }
  getGeometricCentroid(t17, e13) {
    const s18 = this.gridX * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, o16 = this.gridY * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, l9 = new e3([], [s18, o16]);
    if (null != e13) {
      const t18 = new e3();
      return at(t18, l9, false, false, "esriGeometryPoint", e13);
    }
    return l9;
  }
  getAttributes() {
    const t17 = { aggregateId: this.id };
    for (const e13 of this._statistics.values()) t17[e13.field.name] = e13.value;
    return null != this._firstFeatureAttributes ? { ...t17, ...this._firstFeatureAttributes } : t17;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateSpatialIndex.js
var t10 = class {
  constructor(e13) {
    this._options = e13;
  }
  insert(e13, t17) {
    const r9 = e13.getCursor(), o16 = { $view: { scale: this._options.scale, timeZone: this._options.timeZone } };
    for (; r9.next(); ) this._insertFeature(r9, o16, t17);
  }
  _insertFeature(t17, r9, o16) {
    const { featureFilter: i12 } = this._options;
    if (null !== i12 && !i12.check(t17)) return;
    let s18 = 0, n17 = 0;
    if ("esriGeometryPoint" === t17.geometryType) s18 = t17.readXWorldSpace(), n17 = t17.readYWorldSpace();
    else {
      if (o16) {
        const r11 = t17.readCentroidForDisplay();
        if (null == r11) return;
        const [o17, i13] = r11.coords;
        if (o17 < 0 || o17 > a2 || i13 < 0 || i13 > a2) return;
      }
      const r10 = t17.readCentroidWorldSpace();
      if (null == r10) return;
      s18 = r10.coords[0], n17 = r10.coords[1];
    }
    this._insert(t17, s18, n17, r9);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridSpatialIndex.js
var l3 = 96;
function o9(i12, s18) {
  return W(i12) * o3 * l3 / s18;
}
var n11 = class extends t10 {
  constructor(t17) {
    super(t17), this._cells = /* @__PURE__ */ new Map(), this._pixelsPerMapUnit = o9(t17.spatialReference, t17.scale);
  }
  put(t17) {
    for (const e13 of this._cells.values()) {
      const i12 = t17.get(e13.id);
      i12 ? i12.merge(e13) : t17.set(e13.id, e13.clone());
    }
  }
  putBounded(t17, e13, i12) {
    const s18 = [e13.xmin, e13.ymin, e13.xmax, e13.ymax], [l9, o16, n17, r9] = s18, c10 = Math.floor(l9 * this._pixelsPerMapUnit / this._options.cellSize), p7 = Math.floor(o16 * this._pixelsPerMapUnit / this._options.cellSize), a12 = Math.ceil(n17 * this._pixelsPerMapUnit / this._options.cellSize), h6 = Math.ceil(r9 * this._pixelsPerMapUnit / this._options.cellSize);
    for (let _5 = p7; _5 <= h6; _5++) for (let e14 = c10; e14 <= a12; e14++) {
      const i13 = `${e14}.${_5}`, s19 = this._cells.get(i13);
      if (!s19) continue;
      const l10 = t17.get(s19.id);
      l10 ? s19 && !t17.has(s19.id) && l10.merge(s19) : t17.set(s19.id, s19.clone());
    }
  }
  _insert(t17, e13, i12, s18) {
    const l9 = e13 * this._pixelsPerMapUnit, o16 = i12 * this._pixelsPerMapUnit, n17 = Math.floor(l9 / this._options.cellSize), r9 = Math.floor(o16 / this._options.cellSize);
    this._getCellOrCreate(n17, r9).insert(t17, s18, e13, i12);
  }
  _getCellOrCreate(t17, e13) {
    const i12 = l2.createId(t17, e13);
    let l9 = this._cells.get(i12);
    if (!l9) {
      const o16 = 1 * this._options.cellSize / this._pixelsPerMapUnit;
      l9 = l2.create(t17, e13, this._options.fields, o16), this._cells.set(i12, l9);
    }
    return l9;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/processor/support/WithDisplayId.js
var s13 = class {
  constructor(s18, t17) {
    this.inner = s18, this.displayId = t17;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/processor/ClusterStrategy.js
var _3 = 128;
var m4 = class extends t8 {
  constructor(e13) {
    super(e13), this.didSend = false, this.done = false;
  }
};
var y4 = class {
  constructor(e13, t17, s18, i12, r9) {
    this._level = e13, this._scale = t17, this._indexOptions = s18, this._clusterRadius = i12, this._store = r9, this._cells = /* @__PURE__ */ new Map(), this._handledChunks = /* @__PURE__ */ new Set(), this._statistics = /* @__PURE__ */ new Map(), this._clusters = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._clearClusters();
  }
  _clearClusters() {
    for (const e13 of this._clusters.values()) this._store.releaseDisplayIdForObjectId(e13.inner.id);
    this._clusters.clear();
  }
  *aggregatesWorldSpace() {
    for (const e13 of this._clusters.values()) {
      const s18 = e13.inner.getCentroid(null), i12 = new e4(s18, e13.inner.getAttributes(), null);
      i12.objectId = e13.inner.id, i12.displayId = e13.displayId, yield i12;
    }
  }
  clusters() {
    return this._clusters.values();
  }
  updateChunks(e13, t17) {
    let s18 = false;
    for (const a12 of e13) {
      const e14 = a12.queryInfo;
      if ("tileId" in e14) {
        if (new e5(e14.tileId).level !== this._level) continue;
      }
      if (!this._handledChunks.has(a12.normalizedChunkId)) {
        this._handledChunks.add(a12.normalizedChunkId), s18 = true;
        a12.getAggregateIndex({ ...this._indexOptions, scale: this._scale }).put(this._cells);
      }
    }
    const i12 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 }, r9 = o9(this._indexOptions.spatialReference, this._scale), n17 = this._indexOptions.cellSize;
    for (const { subscription: a12 } of t17) {
      const e14 = a12.tile.bounds, t18 = Math.floor(e14[0] * r9 / n17), s19 = Math.floor(e14[1] * r9 / n17), l9 = Math.ceil(e14[2] * r9 / n17), o16 = Math.ceil(e14[3] * r9 / n17);
      i12.xMin = Math.min(i12.xMin, t18), i12.yMin = Math.min(i12.yMin, s19), i12.xMax = Math.max(i12.xMax, l9), i12.yMax = Math.max(i12.yMax, o16);
    }
    return null != this._lastCellBounds && i12.xMin === this._lastCellBounds.xMin && i12.yMin === this._lastCellBounds.yMin && i12.yMin === this._lastCellBounds.yMin && i12.yMax === this._lastCellBounds.yMax || (s18 = true, this._lastCellBounds = i12), s18 && this._clusterCells(i12), s18;
  }
  async updateStatistics(e13) {
    let t17 = false;
    for (const s18 of this._clusters.values()) s18.inner.count > 1 && (t17 = this._updateAggregateStatistics(this._statistics, s18.inner) || t17);
    if (t17) {
      const t18 = Array.from(this._statistics.entries()).map(([e14, t19]) => ({ fieldName: e14, minValue: t19.minValue, maxValue: t19.maxValue }));
      await e13.container.updateStatistics(this._level, t18);
    }
  }
  createAggregateFeatures(e13, r9) {
    const n17 = e13.subscription, a12 = [], l9 = n17.tile.transform;
    for (const o16 of this._clusters.values()) {
      let e14 = o16.inner.getCentroidX(l9);
      const r10 = o16.inner.getCentroidY(l9), d9 = n17.tile.lod, c10 = d9.wrap ? d9.worldSize[0] : null, u8 = 1 === o16.inner.count ? o16.inner.firstObjectId : o16.inner.id, h6 = o16.displayId;
      if (null != c10) if (1 === c10) {
        const n18 = new e3([], [e14, r10]), l10 = new e4(n18, o16.inner.getAttributes(), null);
        l10.geometry.coords[0] -= a2, l10.objectId = u8, l10.displayId = h6, a12.push(l10);
        const d10 = new e3([], [e14, r10]), c11 = new e4(d10, o16.inner.getAttributes(), null);
        c11.geometry.coords[0] += a2, c11.objectId = u8, c11.displayId = h6, a12.push(c11);
      } else e14 > a2 + a2 / 2 ? e14 -= c10 * a2 : e14 < -a2 / 2 && (e14 += c10 * a2);
      if (e14 < a2 + _3 && e14 >= -_3 && r10 < a2 + _3 && r10 >= -_3) {
        const i12 = new e3([], [e14, r10]), n18 = new e4(i12, o16.inner.getAttributes(), null);
        n18.objectId = u8, n18.displayId = h6, a12.push(n18);
      }
    }
    return u5.fromOptimizedFeatures(a12, r9, n17.tile.transform);
  }
  _clusterCells(e13) {
    let t17 = Array.from(this._cells.values());
    t17 = t17.sort((e14, t18) => t18.count - e14.count);
    const s18 = [];
    for (const n17 of this._clusters.values()) s18.push(n17.inner.id);
    this._clusters.clear();
    const i12 = this._clusterRadius * (1 / o9(this._indexOptions.spatialReference, this._scale)), r9 = 1 + this._clusterRadius / this._indexOptions.cellSize, l9 = /* @__PURE__ */ new Set();
    for (const a12 of t17) {
      if (l9.has(a12.id)) continue;
      if (a12.gridX < e13.xMin || a12.gridX > e13.xMax || a12.gridY < e13.yMin || a12.gridY > e13.yMax) continue;
      const t18 = this._store.createDisplayIdForObjectId(a12.id), s19 = new s13(a12.clone(), t18);
      l9.add(a12.id), this._clusters.set(a12.id, s19);
      const o16 = a12.centroidXWorld, c10 = a12.centroidYWorld;
      for (let e14 = a12.gridY - r9; e14 <= a12.gridY + r9; e14++) for (let t19 = a12.gridX - r9; t19 <= a12.gridX + r9; t19++) {
        if (e14 === a12.gridY && t19 === a12.gridX) continue;
        const r10 = this._cells.get(l2.createId(t19, e14));
        if (!r10 || l9.has(r10.id)) continue;
        const d9 = Math.abs(r10.centroidXWorld - o16), u8 = Math.abs(r10.centroidYWorld - c10);
        d9 < i12 && u8 < i12 && (s19.inner.merge(r10), l9.add(r10.id));
      }
    }
    for (const n17 of s18) this._store.releaseDisplayIdForObjectId(n17);
  }
  _updateAggregateStatistics(e13, t17) {
    let s18 = false;
    for (const i12 of t17.statistics.values()) {
      if ("esriFieldTypeString" === i12.field.type) continue;
      const t18 = i12.value, r9 = i12.field, n17 = e13.get(r9.name);
      if (n17) {
        const { minValue: e14, maxValue: i13 } = n17, r10 = Math.min(n17.minValue, t18), a12 = Math.max(n17.maxValue, t18);
        e14 === r10 && i13 === a12 || (n17.minValue = r10, n17.maxValue = a12, s18 = true);
      } else e13.set(r9.name, { minValue: t18, maxValue: t18 }), s18 = true;
    }
    return s18;
  }
};
var S3 = class _S extends i5 {
  static async create(e13, t17, s18, i12, n17, a12) {
    const l9 = new p({ spatialReference: s18 }), o16 = { type: "grid", fields: await Promise.all(t17.fields.map(async (e14) => s11.create(l9, e14))), spatialReference: s18, featureFilter: t17.featureFilter ? await p2.create({ geometryType: i12.metadata.geometryType, hasM: false, hasZ: false, timeInfo: i12.metadata.timeInfo, fieldsIndex: i12.metadata.fieldsIndex, spatialReference: s18, filterJSON: t17.featureFilter }) : null, cellSize: t17.clusterRadius / 4, timeZone: a12 };
    return new _S(e13, t17.clusterRadius, o16, t17.fields, i12, n17);
  }
  constructor(e13, t17, s18, i12, r9, n17) {
    super(r9, n17, s18.spatialReference, s18.fields), this._connection = e13, this._clusterRadius = t17, this._indexOptions = s18, this._cellsPerScale = /* @__PURE__ */ new Map(), this._metadata = new i2({ geometryType: "esriGeometryPoint", objectIdField: "aggregateId", fields: [...i12, ...this._source.metadata.fieldsIndex.fields, { name: "aggregateId", alias: "aggregateId", type: "esriFieldTypeOID" }], globalIdField: null, spatialReference: r9.metadata.spatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, typeIdField: null, types: null });
  }
  get enablePixelBuffering() {
    return false;
  }
  invalidate() {
    super.invalidate();
    for (const e13 of this._cellsPerScale.values()) e13.destroy();
    this._cellsPerScale.clear();
  }
  onSubscribe(e13) {
    super.onSubscribe(e13), this._requiredLevel = e13.tile.level, this._requiredScale = e13.tile.scale;
  }
  createState(e13) {
    return new m4(e13);
  }
  async *applyLocalEdit(e13) {
    for (const t17 of this._cellsPerScale.values()) t17.destroy();
    this._cellsPerScale.clear();
    for (const t17 of this._sendStates.values()) t17.done = false;
  }
  displayMap(e13, t17, s18) {
    const i12 = new Map(e13.map((e14) => [t17(e14), e14])), r9 = [], n17 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const a12 of n17.clusters()) {
      const e14 = i12.get(a12.inner.id);
      if (null == e14) {
        if (1 === a12.inner.count) {
          const e15 = i12.get(a12.inner.firstObjectId);
          if (null != e15) {
            const t18 = s18(a12.displayId, e15, a12.inner.firstObjectId);
            r9.push(t18), i12.delete(a12.inner.firstObjectId);
          }
        }
      } else {
        const t18 = s18(a12.displayId, e14, a12.inner.id);
        r9.push(t18), i12.delete(a12.inner.id);
      }
    }
    return r9;
  }
  getDisplayFeatures(t17) {
    const s18 = new Set(t17), i12 = /* @__PURE__ */ new Set(), r9 = [], n17 = [], a12 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const l9 of a12.aggregatesWorldSpace()) if (s18.has(l9.displayId) && !i12.has(l9.displayId)) {
      const t18 = nt(l9, this._metadata.geometryType, false, false);
      if (i12.add(l9.displayId), 1 === t18.attributes.cluster_count) {
        r9.push({ ...t18, displayId: l9.displayId });
        continue;
      }
      n17.push({ ...t18, displayId: l9.displayId });
    }
    return { features: r9, aggregates: n17 };
  }
  getFeatureObjectIdsForAggregate(e13) {
    const t17 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s18 of t17.clusters()) if (s18.inner.id === e13) return Array.from(s18.inner.containedObjectIds);
    return [];
  }
  async *updateChunks() {
    const e13 = this._source.chunks();
    if (!e13.length) return;
    const t17 = this._getClusterState(this._requiredLevel, this._requiredScale), s18 = Array.from(this._sendStates.values()).filter((e14) => e14.subscription.tile.level === this._requiredLevel);
    if (t17.updateChunks(e13, s18) || !this._source.updateTracking.updating) for (const n17 of s18) n17.subscription.tile.level === this._requiredLevel && (n17.didSend = false, n17.done = false);
    const i12 = Array.from(this._sendStates.values()).filter((e14) => e14.done).map((e14) => e14.subscription.tile.key), r9 = new Set(i12);
    for (const n17 of this._sendStates.values()) {
      if (this._source.updateTracking.updating) {
        if (i12.some((e14) => e14.containsChild(n17.subscription.tile.key))) continue;
        if (n17.subscription.tile.key.getChildKeys().every((e14) => r9.has(e14))) continue;
      }
      n17.didSend || n17.subscription.tile.level !== this._requiredLevel || (n17.didSend = true, yield* this._update(n17, t17, this._source));
    }
    await t17.updateStatistics(this._connection);
  }
  forEachAggregateWorldSpace(e13) {
    if (null == this._requiredLevel || null == this._requiredScale) return;
    const t17 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s18 of t17.aggregatesWorldSpace()) e13(s18);
  }
  _getClusterState(e13, t17) {
    if (null == e13 || null == t17) throw new Error("InternalError: Level and scale must be defined");
    let s18 = this._cellsPerScale.get(t17);
    return s18 || (s18 = new y4(e13, t17, this._indexOptions, this._clusterRadius, this._attributeStore), this._cellsPerScale.set(t17, s18)), s18;
  }
  async *_update(e13, t17, s18) {
    if (e13.done) return;
    const i12 = t17.createAggregateFeatures(e13, this._metadata);
    this.events.emit("changed"), e13.done = !s18.updateTracking.updating;
    const r9 = i12.getCursor(), n17 = e13.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);
    for (; r9.next(); ) this._attributeStore.setAttributeData(r9.getDisplayId(), r9, n17);
    const a12 = new e10(e13.subscription, i12, true, e13.done, {});
    yield a12;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/FeatureSpatialIndex.js
var t11 = class _t {
  static fromReader(o16) {
    const e13 = [], r9 = o16.copy(), a12 = i();
    for (; r9.next(); ) {
      r9.getBounds(a12) && e13.push(r9.getIndex());
    }
    const i12 = i3(9, (n17) => (r9.setIndex(n17), { minX: r9.getBoundsXMin(), minY: r9.getBoundsYMin(), maxX: r9.getBoundsXMax(), maxY: r9.getBoundsYMax() }));
    return i12.load(e13), new _t(i12);
  }
  constructor(n17) {
    this._index = n17;
  }
  search(n17) {
    const s18 = { minX: n17[0], minY: n17[1], maxX: n17[2], maxY: n17[3] };
    return this._index.search(s18);
  }
};

// ../node_modules/@arcgis/core/geohash/geohashUtils.js
var m5 = new Float64Array(2);
var p4 = new Float64Array(2);
var j3 = 64;
function S4(t17, e13, f7, l9) {
  const a12 = [t17.xmin, t17.ymin, t17.xmax, t17.ymax], u8 = j.fromExtent(w.fromBounds(a12, l9)), h6 = j2(u8, l9, f2.WGS84, { densificationStep: e13 * j3 });
  if (!h6) return null;
  const m9 = K(new e3(), h6, false, false), p7 = m9.coords.filter((t18, o16) => !(o16 % 2)), g5 = m9.coords.filter((t18, o16) => o16 % 2), y8 = Math.min(...p7), d9 = Math.min(...g5), x2 = Math.max(...p7), M3 = Math.max(...g5), S6 = A(y8, d9, f7, f2.WGS84), G = A(x2, M3, f7, f2.WGS84);
  return S6 && G ? { bounds: a12, geohashBounds: { xLL: S6[0], yLL: S6[1], xTR: G[0], yTR: G[1] }, level: f7 } : null;
}
function A(o16, r9, s18, i12) {
  if (i12.isWebMercator) {
    const n17 = M(o16 / s3.radius), i13 = n17 - 360 * Math.floor((n17 + 180) / 360), c10 = [0, 0];
    return Y(c10, 0, M(Math.PI / 2 - 2 * Math.atan(Math.exp(-r9 / s3.radius))), i13, s18), c10;
  }
  const f7 = j2({ x: o16, y: r9 }, i12, f2.WGS84);
  if (!f7) return null;
  const l9 = [0, 0];
  return Y(l9, 0, f7.y, f7.x, s18), l9;
}
function R(t17, o16) {
  let r9 = -90, n17 = 90, e13 = -180, s18 = 180;
  for (let i12 = 0; i12 < o16; i12++) {
    const o17 = Math.ceil((i12 + 1) / 2), c10 = Math.floor((i12 + 1) / 2), f7 = 1 - i12 % 2, l9 = 30 - (3 * o17 + 2 * c10), a12 = 30 - (2 * o17 + 3 * c10), u8 = 3 * f7 + 2 * (1 - f7), h6 = 2 * f7 + 3 * (1 - f7), m9 = 3 * f7 + 7 * (1 - f7) << a12, p7 = (7 * f7 + 3 * (1 - f7) << l9 & t17.geohashX) >> l9, g5 = (m9 & t17.geohashY) >> a12;
    for (let t18 = u8 - 1; t18 >= 0; t18--) {
      const o18 = (e13 + s18) / 2, r10 = p7 & 1 << t18 ? 1 : 0;
      e13 = (1 - r10) * e13 + r10 * o18, s18 = (1 - r10) * o18 + r10 * s18;
    }
    for (let t18 = h6 - 1; t18 >= 0; t18--) {
      const o18 = (r9 + n17) / 2, e14 = g5 & 1 << t18 ? 1 : 0;
      r9 = (1 - e14) * r9 + e14 * o18, n17 = (1 - e14) * o18 + e14 * n17;
    }
  }
  return [e13, r9, s18, n17];
}
function Y(t17, o16, r9, n17, e13) {
  e13 % 2 && (e13 += 1);
  let s18 = 0, i12 = 0, c10 = -90, f7 = 90, l9 = -180, a12 = 180;
  for (let u8 = 0; u8 < e13 / 2; u8++) {
    for (let t18 = 0; t18 < 5; t18++) {
      const o17 = (l9 + a12) / 2, r10 = n17 > o17 ? 1 : 0;
      s18 |= r10 << 29 - (t18 + 5 * u8), l9 = (1 - r10) * l9 + r10 * o17, a12 = (1 - r10) * o17 + r10 * a12;
    }
    for (let t18 = 0; t18 < 5; t18++) {
      const o17 = (c10 + f7) / 2, n18 = r9 > o17 ? 1 : 0;
      i12 |= n18 << 29 - (t18 + 5 * u8), c10 = (1 - n18) * c10 + n18 * o17, f7 = (1 - n18) * o17 + n18 * f7;
    }
  }
  t17[2 * o16] = s18, t17[2 * o16 + 1] = i12;
}

// ../node_modules/@arcgis/core/geohash/GeohashCell.js
var l4 = class _l extends t9 {
  static create(t17, e13, o16, s18) {
    const r9 = s12.create(t17), i12 = new Array(32);
    for (let h6 = 0; h6 < i12.length; h6++) i12[h6] = null;
    return new _l(r9, e13, o16, s18, i12);
  }
  constructor(t17, e13, o16, s18, r9) {
    super(t17), this.xNode = e13, this.yNode = o16, this.depth = s18, this.children = r9, this._objectIds = /* @__PURE__ */ new Set(), this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._xGeohashTotal = 0, this._yGeohashTotal = 0, this.next = null;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  clone() {
    const t17 = new _l(this._statistics.clone(), this.xNode, this.yNode, this.depth, this.children);
    return t17._count = this._count, t17._xWorldTotal = this._xWorldTotal, t17._yWorldTotal = this._yWorldTotal, t17._xGeohashTotal = this._xGeohashTotal, t17._yGeohashTotal = this._yGeohashTotal, t17.next = this.next, t17._objectIds = new Set(this._objectIds), t17;
  }
  insert(t17, e13, o16, s18, r9, i12) {
    this._count += 1, this._xWorldTotal += e13, this._yWorldTotal += o16, this._xGeohashTotal += s18, this._yGeohashTotal += r9, this._statistics.insert(t17, i12), this._objectIds.add(t17.getObjectId());
  }
  merge(t17) {
    if (0 !== t17._count) {
      this._count += t17._count, this._xWorldTotal += t17._xWorldTotal, this._yWorldTotal += t17._yWorldTotal, this._xGeohashTotal += t17._xWorldTotal, this._yGeohashTotal += t17._yWorldTotal, this._statistics.merge(t17._statistics);
      for (const e13 of t17._objectIds.values()) this._objectIds.add(e13);
    }
  }
  getCentroid(t17) {
    throw new Error("getCentroid not supported for GeohashNode");
  }
  getGeometry(t17, r9) {
    const a12 = this._getLngLatBounds(), [n17, l9, d9, c10] = a12, _5 = j2({ rings: [[[n17, l9], [n17, c10], [d9, c10], [d9, l9], [n17, l9]]] }, f2.WGS84, t17), u8 = K(new e3(), _5, false, false);
    if (null != r9) {
      return at(new e3(), u8, false, false, "esriGeometryPolygon", r9, false, false);
    }
    return u8;
  }
  getGeometricCentroid(t17, o16) {
    const a12 = this._getLngLatBounds(), [n17, l9, d9, c10] = a12, _5 = j2({ x: (n17 + d9) / 2, y: (l9 + c10) / 2 }, f2.WGS84, t17), u8 = O(new e3(), _5);
    if (null != o16) {
      return at(new e3(), u8, false, false, "esriGeometryPoint", o16, false, false);
    }
    return u8;
  }
  getAttributes() {
    const t17 = { aggregateId: this.id };
    for (const e13 of this._statistics.values()) t17[e13.field.name] = e13.value;
    return t17.aggregateCount = this._count, t17;
  }
  find(t17, e13, o16, s18, r9, i12) {
    if (s18 >= o16) return this;
    const h6 = 1 - s18 % 2, a12 = 3 * h6 + 2 * (1 - h6), n17 = 2 * h6 + 3 * (1 - h6), l9 = 30 - r9 - a12, d9 = 30 - i12 - n17, c10 = ((t17 & 7 * h6 + 3 * (1 - h6) << l9) >> l9) + ((e13 & 3 * h6 + 7 * (1 - h6) << d9) >> d9) * (8 * h6 + 4 * (1 - h6)), _5 = this.children[c10];
    return null == _5 ? null : _5.find(t17, e13, o16, s18 + 1, r9 + a12, i12 + n17);
  }
  _getLngLatBounds() {
    const e13 = this.depth, o16 = Math.ceil(e13 / 2), s18 = Math.floor(e13 / 2), r9 = 30 - (3 * o16 + 2 * s18), i12 = 30 - (2 * o16 + 3 * s18), h6 = this.xNode << r9, a12 = this.yNode << i12;
    return R({ geohashX: h6, geohashY: a12 }, this.depth);
  }
};

// ../node_modules/@arcgis/core/geohash/GeohashTree.js
var e12 = class {
  constructor(e13) {
    this._fields = e13, this._size = 0, this._depth = 0, this._root = l4.create(this._fields, 0, 0, 0);
  }
  destroy() {
  }
  get size() {
    return this._size;
  }
  get depth() {
    return this._depth;
  }
  find(t17, e13, s18) {
    return this._root.find(t17, e13, s18, 0, 0, 0);
  }
  insert(e13, s18, i12, n17, o16, h6, r9) {
    let l9 = this._root, d9 = 0, c10 = 0, a12 = 0;
    for (; null !== l9; ) {
      if (l9.insert(e13, s18, i12, n17, o16, r9), d9 >= h6) return;
      const f7 = Math.ceil((d9 + 1) / 2), u8 = Math.floor((d9 + 1) / 2), x2 = 1 - d9 % 2, _5 = 30 - (3 * f7 + 2 * u8), p7 = 30 - (2 * f7 + 3 * u8), M3 = (n17 & 7 * x2 + 3 * (1 - x2) << _5) >> _5, m9 = (o16 & 3 * x2 + 7 * (1 - x2) << p7) >> p7, g5 = M3 + m9 * (8 * x2 + 4 * (1 - x2));
      c10 = c10 << 3 * x2 + 2 * (1 - x2) | M3, a12 = a12 << 2 * x2 + 3 * (1 - x2) | m9, null == l9.children[g5] && (l9.children[g5] = l4.create(this._fields, c10, a12, d9 + 1), this._depth = Math.max(this._depth, d9 + 1), this._size += 1), d9 += 1, l9 = l9.children[g5];
    }
  }
  putBins(t17, e13) {
    for (const s18 of this.getNodes(e13)) {
      const e14 = t17.get(s18.id);
      e14 ? e14.merge(s18) : t17.set(s18.id, s18.clone());
    }
  }
  getNodes(t17) {
    const e13 = [], { geohashBounds: s18, level: i12 } = t17;
    let n17 = this._root;
    for (; null !== n17; ) {
      const t18 = n17.depth, o16 = n17.xNode, h6 = n17.yNode;
      if (t18 >= i12) {
        e13.push(n17), n17 = n17.next;
        continue;
      }
      const r9 = Math.ceil((t18 + 1) / 2), l9 = Math.floor((t18 + 1) / 2), d9 = 1 - t18 % 2, c10 = 30 - (3 * r9 + 2 * l9), a12 = 30 - (2 * r9 + 3 * l9), f7 = ~((1 << c10) - 1), u8 = ~((1 << a12) - 1), x2 = (s18.xLL & f7) >> c10, _5 = (s18.yLL & u8) >> a12, p7 = (s18.xTR & f7) >> c10, M3 = (s18.yTR & u8) >> a12, m9 = o16 << 3 * d9 + 2 * (1 - d9), g5 = h6 << 2 * d9 + 3 * (1 - d9), y8 = m9 + 8 * d9 + 4 * (1 - d9), z2 = g5 + 4 * d9 + 8 * (1 - d9), L2 = Math.max(m9, x2), N2 = Math.max(g5, _5), B = Math.min(y8, p7), R2 = Math.min(z2, M3);
      let T = null, j4 = null;
      for (let e14 = N2; e14 <= R2; e14++) for (let t19 = L2; t19 <= B; t19++) {
        const s19 = t19 - m9 + (e14 - g5) * (8 * d9 + 4 * (1 - d9)), i13 = n17.children[s19];
        i13 && (T || (T = i13, T.next = n17.next), j4 && (j4.next = i13), j4 = i13, i13.next = n17.next);
      }
      n17 = T || n17.next;
    }
    return e13;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/aggregation/GeohashSpatialIndex.js
var r4 = class extends t10 {
  constructor(t17) {
    super(t17), this._tree = new e12(this._options.fields);
  }
  put(e13) {
    throw new Error("Geohash tree does not support put");
  }
  putBounded(e13, s18, o16) {
    const { geohashLevel: r9, spatialReference: h6 } = this._options, i12 = S4(s18, o16, r9, h6);
    null != i12 && this._tree.putBins(e13, i12);
  }
  _insert(e13, t17, o16, r9) {
    const { geohashLevel: h6, spatialReference: i12 } = this._options, n17 = A(t17, o16, h6, i12);
    n17 && this._tree.insert(e13, t17, o16, n17[0], n17[1], h6, r9);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderIndirect.js
var a7 = class _a extends M2 {
  static from(e13, r9) {
    return new _a(e13.copy(), r9);
  }
  constructor(e13, r9) {
    super(e13.metadata), this._currentIndex = -1, this._displayTranslationX = 0, this._displayTranslationY = 0, this._displayScaleX = 1, this._displayScaleY = 1, this._reader = e13, this._indices = r9, this._isPoint = "esriGeometryPoint" === e13.geometryType;
  }
  setTransformForDisplay(e13) {
    const r9 = this._reader.getInTransform();
    if (null == r9) {
      const [r10, t18] = e13.scale, [s19, a13] = e13.translate;
      return this._displayTranslationX = -s19 / r10, this._displayScaleX = 1 / r10, this._displayTranslationY = a13 / t18, this._displayScaleY = 1 / -t18, void (this._displayTransform = e13);
    }
    const [t17, s18] = r9.scale, [a12, i12] = r9.translate, [d9, n17] = e13.scale, [o16, l9] = e13.translate;
    if (this._displayScaleX = t17 / d9, this._displayTranslationX = (a12 - o16) / d9, this._displayScaleY = s18 / n17, this._displayTranslationY = (-i12 + l9) / n17, !this._isPoint && r9) throw new Error("InternalError: Relative transformations not supported for non-point features");
    this._displayTransform = e13;
  }
  getInTransform() {
    return this._reader.getInTransform();
  }
  get fields() {
    return this._reader.fields;
  }
  get hasNext() {
    return this._currentIndex + 1 < this._indices.length;
  }
  getSize() {
    return this._indices.length;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const e13 = new _a(this._reader.copy(), this._indices);
    return e13._currentIndex = this._currentIndex, e13._displayTransform = this._displayTransform, e13._displayTranslationX = this._displayTranslationX, e13._displayTranslationY = this._displayTranslationY, e13._displayScaleX = this._displayScaleX, e13._displayScaleY = this._displayScaleY, e13;
  }
  get contextTimeZone() {
    return this._reader.contextTimeZone;
  }
  set contextTimeZone(e13) {
    this._reader.contextTimeZone = e13;
  }
  _nextIndex() {
    return ++this._currentIndex < this._indices.length && (this._reader.setIndex(this._indices[this._currentIndex]), true);
  }
  next() {
    for (; this._nextIndex() && !this._reader._getExists(); ) ;
    return this._currentIndex < this._indices.length;
  }
  readXForDisplay() {
    return this._reader.readXForDisplay() * this._displayScaleX + this._displayTranslationX;
  }
  readYForDisplay() {
    return this._reader.readYForDisplay() * this._displayScaleY + this._displayTranslationY;
  }
  readGeometryForDisplay() {
    const r9 = this._reader.readGeometryForDisplay();
    if (!this._displayTransform) return r9;
    const s18 = new e3();
    return at(s18, r9, this.hasZ, this.hasM, this.geometryType, this._displayTransform), s18.deltaDecode();
  }
  readCentroidForDisplay() {
    var _a2;
    const e13 = (_a2 = this._reader.readCentroidForDisplay()) == null ? void 0 : _a2.clone();
    if (e13) {
      const [r9, t17] = e13.coords;
      e13.coords[0] = r9 * this._displayScaleX + this._displayTranslationX, e13.coords[1] = t17 * this._displayScaleY + this._displayTranslationY;
    }
    return e13;
  }
  get geometryType() {
    return this._reader.geometryType;
  }
  get hasFeatures() {
    return this._reader.hasFeatures;
  }
  get exceededTransferLimit() {
    return this._reader.exceededTransferLimit;
  }
  get hasZ() {
    return this._reader.hasZ;
  }
  get hasM() {
    return this._reader.hasM;
  }
  readAttribute(e13, r9 = false) {
    return this._reader.readAttribute(e13, r9);
  }
  readAttributes() {
    return this._reader.readAttributes();
  }
  joinAttributes(e13) {
    return this._reader.joinAttributes(e13);
  }
  getBounds(e13) {
    return this._reader.getBounds(e13);
  }
  getAttributeHash() {
    return this._reader.getAttributeHash();
  }
  getObjectId() {
    return this._reader.getObjectId();
  }
  getDisplayId() {
    return this._reader.getDisplayId();
  }
  setDisplayId(e13) {
    return this._reader.setDisplayId(e13);
  }
  setIndex(e13) {
    return this._reader.setIndex(e13);
  }
  getIndex() {
    return this._reader.getIndex();
  }
  readXWorldSpace() {
    return this._reader.readXWorldSpace();
  }
  readYWorldSpace() {
    return this._reader.readYWorldSpace();
  }
  _readX() {
    return this._reader.readXForDisplay();
  }
  _readY() {
    return this._reader.readYForDisplay();
  }
  _readServerCentroid() {
    return this._reader._readServerCentroid();
  }
  readLegacyFeatureForDisplay() {
    const e13 = this.readCentroidForDisplay();
    return { attributes: this.readAttributes(), geometry: this.readLegacyGeometryForDisplay(), centroid: (e13 && { x: e13.coords[0], y: e13.coords[1] }) ?? null };
  }
  readLegacyGeometryForDisplay() {
    const e13 = this.readGeometryForDisplay();
    return rt(e13, this.geometryType, false, false);
  }
  readGeometryArea() {
    return this._reader.readGeometryArea();
  }
  readGeometryWorldSpace() {
    return this._reader.readGeometryWorldSpace();
  }
  _readGeometry() {
    return this._reader._readGeometry();
  }
  _readAttribute(e13, r9) {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  _readAttributes() {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  readArcadeFeature() {
    return this._reader.readArcadeFeature();
  }
  geometry() {
    return this._reader.geometry();
  }
  field(e13) {
    return this._reader.field(e13);
  }
  hasField(e13) {
    return this._reader.hasField(e13);
  }
  setField(e13, r9) {
    return this._reader.setField(e13, r9);
  }
  keys() {
    return this._reader.keys();
  }
  castToText(e13 = false) {
    return this._reader.castToText(e13);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/ASourceChunk.js
var i8 = class {
  size() {
    return this.reader.getSize();
  }
  get fields() {
    return this.reader.fields;
  }
  invalidate() {
    this._aggregateIndex = null, this._aggregateIndexHash = null, this._spatialIndex = null;
  }
  queryFeaturesInBounds(e13) {
    const t17 = this._getSpatialIndex().search(e13);
    return a7.from(this.reader, t17);
  }
  getAggregateIndex(e13) {
    const r9 = JSON.stringify(e13);
    if (r9 !== this._aggregateIndexHash) {
      switch (this._aggregateIndexHash = r9, e13.type) {
        case "grid":
          this._aggregateIndex = new n11(e13);
          break;
        case "geohash":
          this._aggregateIndex = new r4(e13);
      }
      this._aggregateIndex.insert(this.reader, this.isTiled);
    }
    return this._aggregateIndex;
  }
  _getSpatialIndex() {
    return this._spatialIndex || (this._spatialIndex = t11.fromReader(this.reader)), this._spatialIndex;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/OverrideChunk.js
var r5 = class extends i8 {
  constructor(e13, t17) {
    super(), this.metadata = e13, this.removed = /* @__PURE__ */ new Set(), this.overriddenIds = /* @__PURE__ */ new Set(), this._features = [], this.chunkId = t17, this.normalizedChunkId = t17;
  }
  get reader() {
    return u5.fromOptimizedFeatures(this._features, this.metadata);
  }
  get queryInfo() {
    return {};
  }
  get first() {
    return false;
  }
  get end() {
    return false;
  }
  get isTiled() {
    return false;
  }
  applyOverrides(e13) {
    super.invalidate();
    const { reader: t17, removed: r9 } = e13, s18 = [], d9 = /* @__PURE__ */ new Set(), o16 = t17.getCursor(), i12 = new Set(r9);
    for (this.overriddenIds.clear(); o16.next(); ) {
      const e14 = o16.readOptimizedFeatureWorldSpace(), t18 = e14.objectId;
      s18.push(e14), d9.add(t18), this.overriddenIds.add(t18), this.removed.delete(t18);
    }
    for (const n17 of this._features) {
      const e14 = n17.objectId;
      i12.has(e14) || d9.has(e14) || (s18.push(n17), this.overriddenIds.add(e14));
    }
    this._features = s18;
    for (const n17 of d9.values()) this.removed.delete(n17);
    for (const n17 of r9) this.removed.add(n17), this.overriddenIds.add(n17);
  }
  removeOverrides(e13) {
    this.invalidate();
    const t17 = e13.reader.getCursor(), r9 = /* @__PURE__ */ new Set();
    for (; t17.next(); ) {
      const e14 = t17.getObjectId();
      this.overriddenIds.has(e14) && (r9.add(e14), this.overriddenIds.delete(e14));
    }
    this._features = this._features.filter((e14) => !r9.has(e14.objectId));
  }
  getTileReader(e13) {
    if (!this._features.length) return null;
    const t17 = this.queryFeaturesInBounds(e13.bounds);
    return t17.setTransformForDisplay(e13.transform), t17;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/processor/FeatureUpdateStrategy.js
var n12 = class extends t8 {
};
var o10 = class extends e9 {
  constructor(e13, t17, s18) {
    super(e13, t17), this._timeZone = s18, this.handledChunks = /* @__PURE__ */ new Set(), this.handledChunksForIdCreation = /* @__PURE__ */ new Set(), this.handledChunksForAttributeData = /* @__PURE__ */ new Set(), this._streamLayerDeferredObjectIdsToRemove = [];
  }
  destroy() {
    super.destroy();
    for (const e13 of this._source.chunks()) this._cleanupChunkIds(e13);
  }
  invalidateAttributeData() {
    this.handledChunksForAttributeData.clear();
  }
  onSubscribe(e13) {
    super.onSubscribe(e13), this._evalOptions = e13.tile.createArcadeEvaluationOptions(this._timeZone);
  }
  createState(e13) {
    return new n12(e13);
  }
  get aggregateQueryEngine() {
    return null;
  }
  displayMap(e13, t17, s18) {
    const r9 = new Map(e13.map((e14) => [t17(e14), e14])), a12 = [];
    for (const n17 of this._source.chunks()) {
      const e14 = n17.reader.getCursor();
      for (; e14.next(); ) {
        const t18 = e14.getObjectId(), n18 = e14.getDisplayId(), o16 = r9.get(t18);
        if (null != o16) {
          const e15 = s18(n18, o16, t18);
          a12.push(e15), r9.delete(t18);
        }
      }
    }
    return a12;
  }
  getDisplayFeatures(e13) {
    const t17 = new Set(e13), s18 = /* @__PURE__ */ new Set(), r9 = [];
    for (const a12 of this._source.chunks()) {
      const e14 = a12.reader.getCursor();
      for (; e14.next(); ) {
        const a13 = e14.getObjectId(), n17 = e14.getDisplayId();
        t17.has(n17) && !s18.has(a13) && (r9.push({ ...e14.readLegacyFeatureWorldSpace(), displayId: n17 }), s18.add(a13));
      }
    }
    return { features: r9, aggregates: [] };
  }
  async *applyLocalEdit(e13) {
    const t17 = [], r9 = e13.reader.getCursor();
    for (; r9.next(); ) {
      const e14 = r9.getObjectId();
      t17.push(e14);
      const s18 = this._attributeStore.createDisplayIdForObjectId(e14);
      r9.setDisplayId(s18), this._attributeStore.setAttributeData(s18, r9, this._evalOptions);
    }
    const n17 = this.getDisplayIds(t17), o16 = this.getDisplayIds(e13.removed), d9 = new r5(this._source.metadata, "localEdit");
    d9.applyOverrides(e13), this.handledChunks.add(d9.chunkId), this.handledChunksForAttributeData.add(d9.chunkId), this.handledChunksForIdCreation.add(d9.chunkId);
    for (const a12 of this._sendStates.values()) a12.handledChunks.add(d9.chunkId), yield new i6(a12.subscription, null, n17, false, d9.queryInfo);
    for (const a12 of this._sendStates.values()) {
      const e14 = d9.getTileReader(a12.subscription.tile);
      yield new i6(a12.subscription, e14, o16, false, d9.queryInfo);
    }
    for (const s18 of e13.removed) this._attributeStore.releaseDisplayIdForObjectId(s18);
  }
  async *updateChunks() {
    if (this._source.chunks().length) {
      await this._updateAttributeData();
      for (const e13 of this._sendStates.values()) yield* this._update(e13);
    }
  }
  removeChunks(e13) {
    for (const t17 of e13) this.handledChunks.delete(t17.chunkId), this.handledChunksForAttributeData.delete(t17.chunkId), this._cleanupChunkIds(t17);
  }
  afterUpdateChunks() {
    for (const e13 of this._streamLayerDeferredObjectIdsToRemove) this._attributeStore.releaseDisplayIdForObjectId(e13);
    this._streamLayerDeferredObjectIdsToRemove = [];
  }
  _cleanupChunkIds(e13) {
    if (this.handledChunksForIdCreation.has(e13.chunkId)) {
      const t17 = e13.reader.getCursor();
      for (; t17.next(); ) {
        const e14 = t17.getObjectId();
        this._source.isStream ? this._streamLayerDeferredObjectIdsToRemove.push(e14) : this._attributeStore.releaseDisplayIdForObjectId(e14);
      }
      this.handledChunksForIdCreation.delete(e13.chunkId);
    }
  }
  async _updateAttributeData() {
    for (const e13 of this._source.chunks()) {
      const { chunkId: t17, reader: s18 } = e13;
      if (!this.handledChunksForIdCreation.has(t17)) {
        this.handledChunksForIdCreation.add(t17);
        const e14 = s18.getCursor();
        for (; e14.next(); ) {
          const t18 = this._attributeStore.createDisplayIdForObjectId(e14.getObjectId());
          e14.setDisplayId(t18);
        }
      }
    }
    for (const e13 of this._source.chunks()) if (!this.handledChunksForAttributeData.has(e13.chunkId)) {
      this.handledChunksForAttributeData.add(e13.chunkId);
      const t17 = e13.reader.getCursor();
      for (; t17.next(); ) {
        const e14 = t17.getDisplayId();
        this._attributeStore.setAttributeData(e14, t17, this._evalOptions);
      }
    }
  }
  *_update(e13) {
    const { subscription: t17, handledChunks: s18 } = e13;
    for (const a12 of this._source.chunks()) {
      const { chunkId: n17 } = a12;
      if (s18.has(n17)) continue;
      s18.add(n17);
      const o16 = a12.getTileReader(t17.tile);
      o16 && (yield new e10(e13.subscription, o16, false, a12.end, a12.queryInfo));
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/Processor.js
var f4 = class {
  constructor(e13, t17) {
    this._connection = e13, this._source = t17, this._version = 1, this._registry = new W2(), this._proxy = new s7({ fetch: (e14, t18) => this._connection.layerView.fetch(e14, t18), fetchDictionary: (e14, t18) => this._connection.layerView.fetchDictionary(e14, t18) }), this._attributeStore = new b3({ isLocal: false, update: (e14) => O2(this._connection.container.updateAttributeView(e14)) });
  }
  destroy() {
    var _a;
    this._proxy.destroy(), (_a = this._strategy) == null ? void 0 : _a.destroy(), this._attributeStore.destroy();
  }
  get aggregateQueryEngine() {
    var _a;
    return (_a = this._strategy) == null ? void 0 : _a.aggregateQueryEngine;
  }
  getDisplayFeatures(e13) {
    return this._strategy ? this._strategy.getDisplayFeatures(e13) : { features: [], aggregates: [] };
  }
  getFeatureObjectIdsForAggregate(e13) {
    return this._strategy ? this._strategy.getFeatureObjectIdsForAggregate(e13) : [];
  }
  onSubscribe(e13) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.onSubscribe(e13);
  }
  onUnsubscribe(e13) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.onUnsubscribe(e13);
  }
  async update(e13, s18, r9, a12, n17) {
    var _a, _b, _c, _d, _e;
    const h6 = e13.processor, u8 = u((_a = this._schema) == null ? void 0 : _a.storage, h6.storage), g5 = u((_b = this._schema) == null ? void 0 : _b.mesh.properties, h6.mesh.properties), d9 = u((_c = this._schema) == null ? void 0 : _c.mesh.factory, h6.mesh.factory), y8 = u((_d = this._schema) == null ? void 0 : _d.mesh.strategy, h6.mesh.strategy), _5 = g5 || d9 || y8;
    if (!(u8 || _5) && !a12) return;
    has("esri-2d-update-debug") && console.debug(`Version[${this._version}] SymbolProcessor.update`, { changes: d3(this._schema, h6), schema: h6 }), this._schema = h6;
    const l9 = f2.fromJSON(this._source.service.outSpatialReference), f7 = new p({ fields: this._source.metadata.fieldsIndex, spatialReference: l9 });
    if (await this._attributeStore.update(h6.storage, f7, this._source.metadata, l9, s18), (_e = this._strategy) == null ? void 0 : _e.invalidateAttributeData(), !a12 && !_5) return;
    (y8 || g5) && await this._updateStrategy(h6.mesh.strategy, l9, n17, h6.mesh.properties.timeZone), this._updateSortKey(f7, "sortKey" in h6.mesh.properties ? h6.mesh.properties.sortKey : null);
    const b4 = new s10(f7, this._proxy, r9, this._registry);
    return (d9 || "dictionary" === h6.mesh.factory.symbology.type) && (this._factory = await s9.create(b4, h6.mesh.factory)), this._invalidate(), this._version = s18, this._connection.container.updateRenderState(this._version);
  }
  async applyLocalEdit(e13) {
    if (!this._strategy) return;
    const t17 = this._strategy.applyLocalEdit(e13);
    for await (const r9 of t17) try {
      await this._process(r9);
    } catch (s18) {
    }
  }
  async updateChunks() {
    var _a;
    await this._doUpdateChunks(), (_a = this._strategy) == null ? void 0 : _a.afterUpdateChunks();
  }
  async removeChunks(e13) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.removeChunks(e13), this._attributeStore.incrementDisplayIdGeneration();
  }
  updateHighlight({ highlights: e13 }) {
    if (!this._strategy) return void this._attributeStore.setHighlight(e13.map(({ objectId: e14, highlightFlags: t18 }) => ({ objectId: e14, highlightFlags: t18, displayId: -1 })), e13);
    const t17 = this._strategy.displayMap(e13, ({ objectId: e14 }) => e14, (e14, { highlightFlags: t18 }, s18) => ({ objectId: s18, displayId: e14, highlightFlags: t18 }));
    this._attributeStore.setHighlight(t17, e13);
  }
  async _doUpdateChunks() {
    if (!this._strategy) return;
    const e13 = this._strategy.updateChunks(), t17 = [], r9 = /* @__PURE__ */ new Map();
    for await (const a12 of e13) {
      let e14 = r9.get(a12.id);
      null == e14 && (e14 = new e8({ concurrency: 16, process: (e15) => this._process(e15) }), r9.set(a12.id, e14));
      const i12 = e14.push(a12).catch((e15) => f(e15));
      t17.push(i12);
    }
    try {
      await Promise.all(t17);
    } catch (i12) {
    }
    has("esri-2d-update-debug") && console.log("SendUpdates"), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.log("SendUpdates.await");
  }
  async _updateStrategy(e13, t17, s18, r9) {
    var _a;
    switch ((_a = this._strategy) == null ? void 0 : _a.destroy(), e13.type) {
      case "feature":
        this._strategy = new o10(this._source, this._attributeStore, r9);
        break;
      case "binning":
        this._strategy = await g3.create(e13, t17, this._source, this._attributeStore, r9);
        break;
      case "cluster":
        this._strategy = await S3.create(this._connection, e13, t17, this._source, this._attributeStore, r9);
    }
    for (const i12 of s18) this._strategy.onSubscribe(i12);
  }
  async _updateSortKey(t17, s18) {
    var _a;
    if (this._sortInfo = u2((_a = this._sortInfo) == null ? void 0 : _a.computed), null != s18) {
      const e13 = s18.byRenderer ? null : await t17.createComputedField(s18);
      this._sortInfo = { ...s18, computed: e13 };
    }
  }
  _invalidate() {
    this._strategy && this._strategy.invalidate();
  }
  async _process(e13) {
    var _a, _b, _c;
    const t17 = e13.subscription;
    if (has("esri-2d-update-debug")) {
      const s19 = t17.tile;
      console.debug(`Version[${this._version}] Tile[${s19.key.id}, end=${e13.end}] Processor._process`);
    }
    await this._fetchResources(e13), s2(t17.signal);
    const s18 = await this._write(e13, t17.tile.createArcadeEvaluationOptions((_a = this._schema) == null ? void 0 : _a.mesh.properties.timeZone)), i12 = t17.tile.tileInfoView.tileInfo.isWrappable, { message: a12, transferList: o16 } = s18.serialize(i12), n17 = { objectIdMap: null, inner: e13.createMessage(a12, this._version, this._attributeStore.epoch) };
    if ((_b = this._schema) == null ? void 0 : _b.mesh.properties.returnMeshObjectId) {
      n17.objectIdMap = {};
      const t18 = (_c = e13.reader) == null ? void 0 : _c.getCursor();
      if (t18) for (; t18.next(); ) n17.objectIdMap[t18.getDisplayId()] = t18.getObjectId();
    }
    if (s2(t17.signal), await this._connection.container.onMessage(n17, { signal: t17.signal, transferList: o16 }), this._attributeStore.sendUpdates(), has("esri-2d-update-debug")) {
      const s19 = t17.tile;
      console.debug(`Version[${this._version}] Tile[${s19.key.id}, end=${e13.end}] Processor._process.await`);
    }
  }
  async _fetchResources(e13) {
    await this._fetchMatcherResources(e13), await this._fetchWriterResources(e13);
  }
  async _fetchMatcherResources(e13) {
    if (e13.reader) return this._factory.enqueueMatcherRequests(this._proxy, e13.reader);
  }
  async _fetchWriterResources(e13) {
    if (!e13.reader) return;
    const t17 = e13.reader.getCursor(), s18 = e13.subscription.tile.createArcadeEvaluationOptions(this._schema.mesh.properties.timeZone);
    for (; t17.next(); ) this._factory.enqueueWriterRequests(this._proxy, t17, s18);
    await this._proxy.fetchEnqueuedResources();
  }
  async _write(e13, t17) {
    var _a;
    const s18 = e13.subscription.tile, r9 = (_a = e13.reader) == null ? void 0 : _a.getCursor(), i12 = (r9 == null ? void 0 : r9.getSize()) ?? 0, a12 = s18.tileInfoView.tileInfo.isWrappable, o16 = new g2(s18.key, this._strategy.enablePixelBuffering, a12, i12);
    if (!r9) return o16;
    const c10 = s18.createArcadeEvaluationOptions(this._schema.mesh.properties.timeZone);
    for (; r9.next(); ) {
      const e14 = this._getSortKeyValue(r9, t17);
      o16.entityStart(r9.getDisplayId(), e14), this._factory.write(o16, this._proxy, r9, c10, s18.level), o16.entityEnd();
    }
    return o16;
  }
  _getSortKeyValue(e13, t17) {
    if (!this._sortInfo) return 0;
    const { computed: s18, order: r9, byRenderer: i12 } = this._sortInfo, a12 = i12 ? this._factory.getSortKey(e13, t17) : s18 == null ? void 0 : s18.read(e13, t17);
    return null == a12 || isNaN(a12) ? 0 : a12 * ("asc" === r9 ? -1 : 1);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreStatistics.js
var t12 = class _t {
  static from(e13) {
    let n17 = 0, r9 = 0, o16 = 0;
    return e13.forEach((t17) => {
      const e14 = t17._readGeometry();
      e14 && (r9 += e14.isPoint ? 1 : e14.lengths.reduce((t18, e15) => t18 + e15, 0), o16 += e14.isPoint ? 1 : e14.lengths.length, n17 += 1);
    }), new _t(n17, r9, o16);
  }
  constructor(t17, e13, n17) {
    this.featureCount = t17, this.vertexCount = e13, this.ringCount = n17;
  }
  toJSON() {
    return { featureCount: this.featureCount, ringCount: this.featureCount, vertexCount: this.featureCount };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceQueryInfo.js
var o11 = 4;
function s14(t17, i12, o16) {
  const s18 = t17.orderByFields ?? o16.objectIdField + " ASC", n17 = t17.source, u8 = { returnCentroid: !(null !== n17 && "object" == typeof n17 && "path" in n17 && g(n17.path)) && "esriGeometryPolygon" === o16.geometryType, returnGeometry: true, timeReferenceUnknownClient: o16.timeReferenceUnknownClient ?? void 0, outSpatialReference: f2.fromJSON(t17.outSpatialReference), orderByFields: [s18], where: i12.mutable.dataFilter.definitionExpression ?? "1=1", outFields: i12.mutable.availableFields };
  if ("feature" === i12.type) {
    const { gdbVersion: t18, historicMoment: r9, timeExtent: a12 } = i12.mutable.dataFilter;
    return { ...u8, gdbVersion: t18, historicMoment: r9 ? new Date(r9) : null, timeExtent: a12 ? c2.fromJSON(a12) : null, outFields: i12.mutable.availableFields };
  }
  return u8;
}
var n13 = class _n {
  static fromSchema(e13, t17, r9) {
    const a12 = "feature" === t17.type ? t17.mutable.dataFilter.queryScaleRanges : [];
    return new _n(s14(e13, t17, r9), a12, r9.subtypeField, t17.mutable.dataFilter.customParameters, r9.geometryType, e13.queryMetadata);
  }
  constructor(e13, t17, r9, a12, i12, o16) {
    this._queryParams = e13, this._queryScaleRanges = t17, this._subtypeField = r9, this._customParameters = a12, this._geometryType = i12, this._queryMetadata = o16;
  }
  get pageSize() {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support paged queries");
    const e13 = this._queryMetadata.supportsMaxRecordCountFactor ? o11 : null, t17 = (this._queryMetadata.maxRecordCount ?? 8e3) * (e13 ?? 1);
    return Math.min(8e3, t17);
  }
  updateHistoricMoment(e13) {
    this._queryParams.historicMoment = e13;
  }
  updateFields(e13) {
    this._queryParams.outFields = e13;
  }
  createPatchFieldsQuery(e13, t17) {
    if (!t17.getSize()) return null;
    const r9 = e13.clone();
    if ("*" === this._queryParams.outFields[0]) {
      if ("*" === (r9.outFields ?? [])[0]) return null;
      r9.outFields = this._queryParams.outFields;
    } else {
      const e14 = new Set(this._queryParams.outFields), a12 = [];
      for (const r10 of e14) t17.hasField(r10) || a12.push(r10);
      if (0 === a12.length) return null;
      r9.outFields = a12;
    }
    return r9.returnGeometry = false, r9.returnCentroid = false, r9.quantizationParameters = null, r9.cacheHint = true, { inner: r9, customParameters: this._customParameters };
  }
  createQuery(e13 = {}) {
    if (!this._queryParams) throw new Error("InternalError: queryInfo should be defined");
    return { inner: new b({ ...this._queryParams, ...e13 }), customParameters: this._customParameters };
  }
  createTileQuery(e13, r9) {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support tile queries");
    const a12 = this.createQuery(r9), i12 = a12.inner;
    if (this._queryScaleRanges.length) {
      const r10 = this._queryScaleRanges.filter((t17) => (!t17.minScale || t17.minScale >= e13.maxScale) && (!t17.maxScale || t17.maxScale <= e13.minScale)).map((e14) => e14.subtypeCode);
      if (r10.length) {
        const e14 = `${this._subtypeField} IN (${r10})`;
        i12.where = n3(i12.where, e14);
      }
    }
    if (i12.quantizationParameters = r9.quantizationParameters ?? e13.getQuantizationParameters(), i12.resultType = "tile", i12.geometry = e13.extent, this._queryMetadata.supportsQuantization ? "esriGeometryPolyline" === this._geometryType && (i12.maxAllowableOffset = e13.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== this._geometryType && "esriGeometryPolygon" !== this._geometryType || (i12.maxAllowableOffset = e13.resolution, "esriGeometryPolyline" === this._geometryType && (i12.maxAllowableOffset *= has("feature-polyline-generalization-factor"))), i12.defaultSpatialReferenceEnabled = this._queryMetadata.supportsDefaultSpatialReference, i12.compactGeometryEnabled = this._queryMetadata.supportsCompactGeometry, this._queryMetadata.supportsMaxRecordCountFactor && (i12.maxRecordCountFactor = o11), has("esri-tiles-debug")) {
      const t17 = e13.id.replaceAll("/", ".");
      a12.customParameters = a12.customParameters ? { ...a12.customParameters, tileId: t17 } : { tileId: t17 };
    }
    return a12;
  }
  createPagedTileQuery(e13, t17) {
    const r9 = this.pageSize;
    return this.createTileQuery(e13, { start: r9 * t17, num: r9, returnExceededLimitFeatures: true });
  }
  createPagedQuery(e13) {
    const t17 = this.pageSize;
    return this.createQuery({ start: t17 * e13, num: t17, returnExceededLimitFeatures: true, maxRecordCountFactor: o11 });
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/StreamMessenger.js
var a8 = 2500;
var o12 = class extends S {
  constructor(e13) {
    super(), this._connection = e13, this._enabledEventTypes = /* @__PURE__ */ new Set(), this._updateInfo = { websocket: 0, client: 0 }, this._lastTime = performance.now(), this._queuedCommands = [], this.addHandles([d2(() => {
      var _a;
      return ((_a = this._strategy) == null ? void 0 : _a.connectionStatus) ?? "disconnected";
    }, (e14) => {
      this._layerView.setProperty({ propertyName: "pipelineConnectionStatus", value: e14 });
    }, { initial: true }), d2(() => {
      var _a;
      return ((_a = this._strategy) == null ? void 0 : _a.errorString) || null;
    }, (e14) => this._layerView.setProperty({ propertyName: "pipelineErrorString", value: e14 }), { initial: true })]);
  }
  destroy() {
    this._strategy = null, this.removeAllHandles();
  }
  get _layerView() {
    return this._connection.layerView;
  }
  set strategy(e13) {
    null == this._strategy && this._resetUpdateInfo(performance.now());
    const t17 = "event-handles";
    this.removeHandles(t17), null != e13 && (this.addHandles([e13.events.on("data-received", (e14) => this._onFeature(e14)), e13.events.on("message-received", (e14) => this._onWebSocketMessage(e14)), e13.events.on("features-updated", (e14) => this._onUpdate(e14)), e13.events.on("tick", () => this._onTick())], t17), this._queuedCommands.forEach((t18) => t18(e13)), this._queuedCommands = []), this._strategy = e13;
  }
  updateCustomParameters(e13) {
    null != e13 && this._callOrEnqueue((t17) => t17.updateCustomParameters(e13));
  }
  sendMessageToSocket(e13) {
    this._callOrEnqueue((t17) => t17.sendMessageToSocket(e13));
  }
  sendMessageToClient(e13) {
    this._callOrEnqueue((t17) => t17.sendMessageToClient(e13));
  }
  enableEvent(e13, t17) {
    t17 ? this._enabledEventTypes.add(e13) : this._enabledEventTypes.delete(e13);
  }
  disconnect() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.disconnect();
  }
  connect() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.connect();
  }
  clear() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.clear();
  }
  _onWebSocketMessage(e13) {
    this._enabledEventTypes.has("message-received") && this._layerView.emitEvent({ name: "message-received", event: e13 });
  }
  _onFeature(e13) {
    this._updateInfo.websocket++, this._enabledEventTypes.has("data-received") && this._layerView.emitEvent({ name: "data-received", event: { attributes: e13.attributes, centroid: e13.centroid, geometry: e13.geometry } });
  }
  _onUpdate(e13) {
    this._updateInfo.client += e13;
  }
  _onTick() {
    const e13 = performance.now(), t17 = e13 - this._lastTime;
    if (t17 > a8) {
      const s18 = Math.round(this._updateInfo.client / (t17 / 1e3)), n17 = Math.round(this._updateInfo.websocket / (t17 / 1e3));
      this._resetUpdateInfo(e13), this._layerView.emitEvent({ name: "update-rate", event: { client: s18, websocket: n17 } });
    }
  }
  _resetUpdateInfo(e13) {
    this._lastTime = e13, this._updateInfo.client = 0, this._updateInfo.websocket = 0;
  }
  _callOrEnqueue(e13) {
    null != this._strategy ? e13(this._strategy) : this._queuedCommands.push(e13);
  }
};
e([y()], o12.prototype, "_strategy", void 0), o12 = e([a("esri.views.2d.layers.features.sources.StreamMessenger")], o12);

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ALoadStrategy.js
var r6 = class {
  constructor(r9) {
    this._store = r9, this._controller = new AbortController();
  }
  destroy() {
    this._controller.abort();
  }
  get _options() {
    return { signal: this._controller.signal };
  }
  unsafeSetQueryHistoricMoment(r9) {
    throw new Error("InternalError: LoadStrategy does not support query info");
  }
  async queryOverride(r9) {
    throw new Error("InternalError: LoadStrategy does not support fetching");
  }
  async queryByObjectId(r9) {
    throw new Error("InternalError: LoadStrategy does not support fetching");
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n14 = 268435455;
var o13 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
};
function a9(a12, i12, c10 = false) {
  var _a;
  const f7 = 1, d9 = 3, u8 = 9, g5 = 12, l9 = 13, p7 = 15, h6 = a12.asUnsafe(), b4 = h6.pos(), w3 = new o13();
  let m9 = 0, y8 = 0;
  const k = 1, x2 = 2, I2 = 4, L2 = 3;
  let A2 = null, F = null, C = null, S6 = false;
  const j4 = [];
  for (; h6.next(); ) switch (h6.tag()) {
    case f7:
      A2 = h6.getString();
      break;
    case d9:
      F = h6.getString();
      break;
    case g5:
      C = h6.processMessage(h);
      break;
    case u8:
      if (w3.exceededTransferLimit = h6.getBool(), w3.exceededTransferLimit) {
        w3.offsets.geometry = c10 ? new Float64Array(8e3) : new Int32Array(8e3), w3.centroid = c10 ? new Float64Array(16e3) : new Int32Array(16e3);
        for (let e13 = 0; e13 < w3.centroid.length; e13++) w3.centroid[e13] = n14;
      }
      break;
    case l9: {
      const e13 = h6.processMessage(b2);
      e13.index = m9++, j4.push(e13);
      break;
    }
    case p7: {
      const e13 = h6.getLength(), t17 = h6.pos() + e13;
      if (!w3.exceededTransferLimit) {
        const e14 = w3.offsets.geometry, t18 = w3.centroid;
        e14.push(0), t18.push(n14), t18.push(n14);
      }
      !S6 && w3.exceededTransferLimit && (S6 = true, w3.offsets.attributes = c10 ? new Float64Array(8e3 * m9) : new Uint32Array(8e3 * m9));
      let s18 = y8 * m9;
      for (; h6.pos() < t17 && h6.next(); ) switch (h6.tag()) {
        case k: {
          if (S6) w3.offsets.attributes[s18++] = h6.pos();
          else {
            w3.offsets.attributes.push(h6.pos());
          }
          const e14 = h6.getLength();
          h6.skipLen(e14);
          break;
        }
        case x2:
          if (i12) {
            const e14 = h6.getLength(), t18 = h6.pos() + e14;
            for (; h6.pos() < t18 && h6.next(); ) switch (h6.tag()) {
              case L2: {
                h6.getUInt32();
                const e15 = h6.getSInt64(), t19 = h6.getSInt64();
                w3.centroid[2 * y8] = e15, w3.centroid[2 * y8 + 1] = t19;
                break;
              }
              default:
                h6.skip();
            }
          } else {
            w3.offsets.geometry[y8] = h6.pos();
            const e14 = h6.getLength();
            w3.vertexCount += e14, h6.skipLen(e14);
          }
          break;
        case I2: {
          const e14 = h6.getLength(), t18 = h6.pos() + e14;
          for (; h6.pos() < t18 && h6.next(); ) switch (h6.tag()) {
            case L2: {
              h6.getUInt32();
              const e15 = h6.getSInt64(), t19 = h6.getSInt64();
              w3.centroid[2 * y8] = e15, w3.centroid[2 * y8 + 1] = t19;
              break;
            }
            default:
              h6.skip();
          }
          break;
        }
        default:
          h6.skip();
      }
      y8++, w3.hasFeatures = true;
      break;
    }
    default:
      h6.skip();
  }
  const U2 = A2 || F;
  if (!U2) throw new s("FeatureSet has no objectId or globalId field name");
  return w3.fields = new Z(j4), w3.featureCount = y8, w3.fieldCount = m9, w3.objectIdFieldIndex = (_a = w3.fields.get(U2)) == null ? void 0 : _a.index, w3.transform = C, w3.displayIds = new Uint32Array(w3.featureCount), w3.groupIds = new Uint16Array(w3.featureCount), h6.move(b4), w3;
}

// ../node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var o14 = true;
var d7 = 268435455;
var u7 = 128;
var c8 = 128e3;
var g4 = { small: { delta: new Int32Array(u7), decoded: new Int32Array(u7) }, large: { delta: new Int32Array(c8), decoded: new Int32Array(c8) } };
function _4(e13) {
  return e13 <= g4.small.delta.length ? g4.small : (e13 <= g4.large.delta.length || (g4.large.delta = new Int32Array(Math.round(1.25 * e13)), g4.large.decoded = new Int32Array(Math.round(1.25 * e13))), g4.large);
}
function f5(r9) {
  try {
    const e13 = 2, t17 = new n4(new Uint8Array(r9), new DataView(r9));
    for (; t17.next(); ) {
      if (t17.tag() === e13) return l5(t17.getMessage());
      t17.skip();
    }
  } catch (n17) {
    const r10 = new s("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: n17 });
    n.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r10);
  }
  return null;
}
function l5(e13) {
  const t17 = 1;
  for (; e13.next(); ) {
    if (e13.tag() === t17) return e13.getMessage();
    e13.skip();
  }
  return null;
}
function I(e13) {
  const t17 = 1, r9 = 2, s18 = 3, n17 = 4, a12 = 5, i12 = 6, h6 = 7, o16 = 8, d9 = 9, u8 = e13.getLength(), c10 = e13.pos() + u8;
  for (; e13.pos() < c10 && e13.next(); ) switch (e13.tag()) {
    case t17:
      return e13.getString();
    case r9:
      return e13.getFloat();
    case s18:
      return e13.getDouble();
    case n17:
      return e13.getSInt32();
    case a12:
      return e13.getUInt32();
    case i12:
      return e13.getInt64();
    case h6:
      return e13.getUInt64();
    case o16:
      return e13.getSInt64();
    case d9:
      return e13.getBool();
    default:
      return e13.skip(), null;
  }
  return null;
}
function p5(e13, t17, r9, s18, n17, a12) {
  return 0.5 * Math.abs(e13 * s18 + r9 * a12 + n17 * t17 - e13 * a12 - r9 * t17 - n17 * s18);
}
function y5(e13, t17, r9, s18) {
  return 0 === e13 * s18 - r9 * t17 && e13 * r9 + t17 * s18 > 0;
}
var m6 = class _m extends M2 {
  static fromBuffer(e13, t17, r9 = false) {
    const s18 = t17.geometryType, n17 = f5(e13), a12 = a9(n17, "esriGeometryPoint" === s18, r9);
    return new _m(n17, a12, t17);
  }
  constructor(e13, t17, r9) {
    super(r9), this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0, centroid: void 0, legacyFeature: void 0, optFeature: void 0 }, this._parseCaches = new Array(), this._geometryType = r9.geometryType, this._reader = e13, this._header = t17, this._hasNext = t17.hasFeatures, this._isPoints = "esriGeometryPoint" === r9.geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getInTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e13) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0, this._featureIndex = e13;
  }
  getAttributeHash() {
    let e13 = "";
    for (const t17 of this._header.fields.fields) e13 += this._readAttributeAtIndex(t17.index) + ".";
    return e13;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e13) {
    this._header.displayIds[this._featureIndex] = e13;
  }
  readGeometryArea() {
    return this._cache.area || this._readGeometry(true), this._cache.area;
  }
  copy() {
    const e13 = this._reader.clone(), t17 = new _m(e13, this._header, this.metadata);
    return this.copyInto(t17), t17;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0; ++this._featureIndex < this._size && !this._getExists(); ) ;
    return this._featureIndex < this._size;
  }
  _readX() {
    return this._header.centroid[2 * this._featureIndex];
  }
  _readY() {
    return this._header.centroid[2 * this._featureIndex + 1];
  }
  _readServerCentroid() {
    const e13 = this._header.centroid[2 * this._featureIndex], t17 = this._header.centroid[2 * this._featureIndex + 1];
    return e13 === d7 ? null : new e3([], [e13, t17]);
  }
  _readGeometry(e13 = false) {
    if (void 0 === this._cache.geometry) {
      let r9 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === d7) return null;
        const e14 = this._header.centroid[2 * this._featureIndex], t17 = this._header.centroid[2 * this._featureIndex + 1];
        r9 = new e3([], [e14, t17]);
      } else {
        const s18 = this._header.offsets.geometry[this._featureIndex], n17 = this._reader;
        if (0 === s18) return null;
        n17.move(s18);
        try {
          r9 = e13 ? this._parseGeometryForDisplay(n17) : this._parseGeometry(n17);
        } catch (t17) {
          return null;
        }
      }
      return 0 === (r9 == null ? void 0 : r9.coords.length) && (r9 = null), this._cache.geometry = r9, r9;
    }
    return this._cache.geometry;
  }
  _readAttribute(e13, t17) {
    var _a;
    const r9 = this._header.fields.get(e13);
    if (null == r9) return;
    let s18 = this._readAttributeAtIndex(r9.index);
    "esriFieldTypeTimestampOffset" === ((_a = this.fields.get(e13)) == null ? void 0 : _a.type) && (s18 = this.parseTimestampOffset(s18));
    const n17 = this._header.fields.isDateField(r9.name);
    return t17 ? null == s18 ? s18 : n17 ? new Date(s18) : s18 : s18;
  }
  _readAttributes() {
    const e13 = {};
    for (const t17 of this._header.fields.fields) e13[t17.name] = this._readAttributeAtIndex(t17.index);
    return e13;
  }
  copyInto(e13) {
    super.copyInto(e13), e13._featureIndex = this._featureIndex, e13._featureOffset = this._featureOffset, e13._hasNext = this._hasNext, e13._parseCaches = this._parseCaches;
  }
  _readAttributeAtIndex(e13) {
    let t17 = this._parseCaches[e13];
    if (t17 || (t17 = new a3(this.getSize()), this._parseCaches[e13] = t17), t17.has(this._featureIndex)) return t17.get(this._featureIndex);
    const r9 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e13], s18 = this._reader;
    s18.move(r9);
    const n17 = I(s18);
    return t17.set(this._featureIndex, n17), n17;
  }
  _readGeometryDeltaDecoded(e13 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t17 = this._readGeometry(e13);
      if (!t17) return this._cache.unquantGeometry = void 0, null;
      if (!this.getInTransform()) return this._cache.unquantGeometry = t17, t17;
      const r9 = _4(t17.coords.length).decoded, s18 = t17.clone(r9), n17 = s18.coords;
      let a12 = 0;
      for (const e14 of s18.lengths) {
        for (let t18 = 1; t18 < e14; t18++) {
          const e15 = 2 * (a12 + t18), r10 = 2 * (a12 + t18 - 1);
          n17[e15] += n17[r10], n17[e15 + 1] += n17[r10 + 1];
        }
        a12 += e14;
      }
      return this._cache.unquantGeometry = s18, s18;
    }
    return this._cache.unquantGeometry;
  }
  _parseGeometry(e13) {
    const t17 = 2, r9 = 3, s18 = e13.asUnsafe(), a12 = s18.getLength(), i12 = s18.pos() + a12, h6 = [], o16 = [];
    for (; s18.pos() < i12 && s18.next(); ) switch (s18.tag()) {
      case t17: {
        const e14 = s18.getUInt32(), t18 = s18.pos() + e14;
        for (; s18.pos() < t18; ) o16.push(s18.getUInt32());
        break;
      }
      case r9: {
        const e14 = s18.getUInt32(), t18 = s18.pos() + e14;
        for (h6.push(s18.getSInt64()), h6.push(s18.getSInt64()), this.hasZ && s18.getSInt64(), this.hasM && s18.getSInt64(); s18.pos() < t18; ) h6.push(s18.getSInt64()), h6.push(s18.getSInt64()), this.hasZ && s18.getSInt64(), this.hasM && s18.getSInt64();
        break;
      }
      default:
        s18.skip();
    }
    return new e3(o16, h6);
  }
  _parseGeometryForDisplay(e13) {
    const t17 = 2, s18 = 3, a12 = e13.asUnsafe(), i12 = a12.getLength(), h6 = a12.pos() + i12, d9 = [], u8 = [];
    let c10 = 0, g5 = 0, f7 = null, l9 = 0;
    const I2 = "esriGeometryPolygon" === this.geometryType;
    for (; a12.pos() < h6 && a12.next(); ) switch (a12.tag()) {
      case t17: {
        const e14 = a12.getUInt32(), t18 = a12.pos() + e14;
        for (; a12.pos() < t18; ) {
          const e15 = a12.getUInt32();
          d9.push(e15), c10 += e15;
        }
        f7 = _4(2 * c10).delta;
        break;
      }
      case s18: {
        a12.getUInt32();
        const e14 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
        n2(f7);
        for (const t18 of d9) if (g5 + e14 * t18 > f7.length) for (let e15 = 0; e15 < t18; e15++) a12.getSInt32(), a12.getSInt32(), this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32();
        else if (I2 && o14) {
          const e15 = this.getAreaSimplificationThreshold(t18, this._header.vertexCount);
          let r9 = 2, s19 = 1;
          const n17 = false;
          let i13 = a12.getSInt32(), h7 = a12.getSInt32();
          f7[g5++] = i13, f7[g5++] = h7, this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32();
          let o16 = a12.getSInt32(), d10 = a12.getSInt32();
          for (this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32(); r9 < t18; ) {
            let t19 = a12.getSInt32(), n18 = a12.getSInt32();
            this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32();
            const u9 = i13 + o16, c11 = h7 + d10;
            p5(i13, h7, u9, c11, u9 + t19, c11 + n18) >= e15 ? (l9 += -0.5 * (u9 - i13) * (c11 + h7), s19 > 1 && y5(f7[g5 - 2], f7[g5 - 1], o16, d10) ? (f7[g5 - 2] += o16, f7[g5 - 1] += d10) : (f7[g5++] = o16, f7[g5++] = d10, s19++), i13 = u9, h7 = c11) : (t19 += o16, n18 += d10), o16 = t19, d10 = n18, r9++;
          }
          s19 < 3 || n17 ? g5 -= 2 * s19 : (l9 += -0.5 * (i13 + o16 - i13) * (h7 + d10 + h7), y5(f7[g5 - 2], f7[g5 - 1], o16, d10) ? (f7[g5 - 2] += o16, f7[g5 - 1] += d10, u8.push(s19)) : (f7[g5++] = o16, f7[g5++] = d10, u8.push(++s19)));
        } else {
          let e15 = 0, r9 = a12.getSInt32(), s19 = a12.getSInt32();
          this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32(), f7[g5++] = r9, f7[g5++] = s19, e15 += 1;
          for (let n17 = 1; n17 < t18; n17++) {
            const t19 = a12.getSInt32(), i13 = a12.getSInt32(), h7 = r9 + t19, o16 = s19 + i13;
            l9 += -0.5 * (h7 - r9) * (o16 + s19), this.hasZ && a12.getSInt32(), this.hasM && a12.getSInt32(), n17 > 2 && y5(f7[g5 - 2], f7[g5 - 1], t19, i13) ? (f7[g5 - 2] += t19, f7[g5 - 1] += i13) : (f7[g5++] = t19, f7[g5++] = i13, e15 += 1), r9 = h7, s19 = o16;
          }
          u8.push(e15);
        }
        break;
      }
      default:
        a12.skip();
    }
    return this._cache.area = l9, u8.length ? new e3(u8, f7) : null != f7 ? this._createQuantizedExtrudedGeometry(f7[0], f7[1]) : null;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/queryAdapters.js
var c9 = class {
  constructor(t17, e13) {
    this.service = t17, this._metadata = e13;
  }
  destroy() {
  }
};
function m7(t17, e13) {
  switch (t17.type) {
    case "memory":
      return new l6(t17, e13);
    case "ogc":
      return new y6(t17, e13);
    case "feature-service":
      return t17.queryMetadata.supportsFormatPBF && has("featurelayer-pbf") ? new d8(t17, e13) : new f6(t17, e13);
  }
}
async function p6(e13) {
  const r9 = new c4();
  return await r9.open(e13, {}), r9;
}
var l6 = class extends c9 {
  constructor(t17, e13) {
    super(t17, e13), this._portsOpen = p6(t17.source).then((t18) => this.client = t18);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(t17, e13) {
    await this._portsOpen;
    const r9 = await this.client.invoke("queryFeatures", t17.toJSON(), e13);
    return u5.fromFeatureSet(r9, this._metadata);
  }
};
var d8 = class extends c9 {
  async executeQuery(t17, e13) {
    const { data: r9 } = await d4(this.service.source, t17, e13), a12 = !t17.quantizationParameters;
    return m6.fromBuffer(r9, this._metadata, a12);
  }
};
var f6 = class extends c9 {
  async executeQuery(t17, s18) {
    var _a;
    const { source: i12, queryMetadata: u8 } = this.service;
    if (null != t17.quantizationParameters && !u8.supportsQuantization) {
      const u9 = t17.clone(), c11 = s5(u9.quantizationParameters);
      u9.quantizationParameters = null;
      const { data: m9 } = await c3(i12, u9, this._metadata.spatialReference, s18), p7 = ct(m9, this._metadata.objectIdField);
      return ft(c11, p7), u5.fromOptimizedFeatureSet(p7, this._metadata);
    }
    const { data: c10 } = await c3(i12, t17, this._metadata.spatialReference, s18);
    return "esriGeometryPoint" === this._metadata.geometryType && (c10.features = (_a = c10.features) == null ? void 0 : _a.filter((t18) => {
      if (null != t18.geometry) {
        const e13 = t18.geometry;
        return Number.isFinite(e13.x) && Number.isFinite(e13.y);
      }
      return true;
    })), u5.fromFeatureSet(c10, this._metadata);
  }
};
var y6 = class extends c9 {
  async executeQuery(t17, r9) {
    if (t17.quantizationParameters && !this.service.queryMetadata.supportsQuantization) {
      const i13 = t17.clone(), o16 = s5(i13.quantizationParameters);
      i13.quantizationParameters = null;
      const u8 = await $2(this.service.source, t17, r9);
      return ft(o16, u8), u5.fromOptimizedFeatureSet(u8, this._metadata);
    }
    const i12 = await $2(this.service.source, t17, r9);
    return u5.fromOptimizedFeatureSet(i12, this._metadata);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/AFetchLoadStrategy.js
var i9 = class extends r6 {
  constructor(e13, t17, r9, n17, i12) {
    super(r9), this._serviceInfo = e13, this._queryInfo = t17, this._metadata = n17, this._connection = i12, this._queue = new _({ concurrency: 16, process: async (e14) => {
      var _a;
      const t18 = { signal: (_a = e14.options) == null ? void 0 : _a.signal, query: e14.query.customParameters };
      return this._adapter.executeQuery(e14.query.inner, t18);
    } }), this._adapter = m7(e13, n17);
  }
  unsafeSetQueryHistoricMoment(e13) {
    this._queryInfo.updateHistoricMoment(e13);
  }
  async updateFields(r9) {
    this._queryInfo.updateFields(r9);
    const s18 = Array.from(this._store.chunks()).map(async (e13) => {
      const r10 = b.fromJSON(e13.queryInfo.queryJSON);
      if (r10) try {
        return await this._tryUpdateFields(e13.reader, r10), null;
      } catch (s19) {
        return s19;
      }
    }), n17 = (await Promise.all(s18)).filter((e13) => e13);
    if (n17.length) throw new s("featurelayer-query", "Encountered errors when downloading fields", { errors: n17 });
  }
  async queryByObjectId(e13) {
    if (0 === e13.length) return u5.empty(this._metadata);
    const t17 = this._queryInfo.createQuery({ objectIds: e13 });
    return this._fetch(t17);
  }
  async _fetch(e13, t17) {
    const r9 = await this._enqueue(e13, t17);
    return await this._tryUpdateFields(r9, e13.inner), r9;
  }
  async _tryUpdateFields(e13, t17) {
    const r9 = this._queryInfo.createPatchFieldsQuery(t17, e13);
    if (!r9) return;
    const s18 = await this._enqueue(r9, this._options);
    e13.joinAttributes(s18);
  }
  async _enqueue(e13, t17) {
    return this._connection.onEvent({ type: "fetchStart" }), this._queue.push({ query: e13, options: t17 }).finally(() => {
      this._connection.onEvent({ type: "fetchEnd", done: 0 === this._queue.length });
    });
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ATileLoadStrategy.js
var s15 = class extends i9 {
  constructor() {
    super(...arguments), this._chunksById = /* @__PURE__ */ new Map();
  }
  unload(e13) {
    this._removeChunks(e13.tile);
  }
  _addChunk(e13) {
    const s18 = e13.tile.id;
    this._chunksById.has(s18) || this._chunksById.set(s18, []);
    const t17 = e13.size();
    (t17 || e13.first || e13.end) && (has("esri-2d-update-debug") && console.debug(`Chunk[${e13.chunkId}] ATileLoadStrategy.addChunk [count=${t17}]`), this._chunksById.get(s18).push(e13), this._store.insert(e13));
  }
  _removeChunks(e13) {
    const s18 = this._chunksById.get(e13.key.id) ?? [];
    for (const t17 of s18) has("esri-2d-update-debug") && console.debug(`Tile[${e13.key.id}] Chunk[${t17.chunkId}] ATileLoadStrategy.removeChunk`), this._store.remove(t17);
    this._chunksById.delete(e13.key.id);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/DrillDownTileSourceChunk.js
var i10 = class extends i8 {
  constructor(e13, i12, t17, r9, s18, h6) {
    var _a, _b;
    super(), this._reader = e13, this._queryJSON = i12, this._tile = t17, this._sourceTile = r9, this._sourceTileDepth = s18, this._end = h6, this.chunkId = `${this._tile.key.id}.${(_a = this._sourceTile) == null ? void 0 : _a.key.id}${this._end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${(_b = this._sourceTile) == null ? void 0 : _b.key.normalizedId}${this._end ? "e" : ""}`;
  }
  get queryInfo() {
    var _a;
    return { type: "drill-down-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, sourceTileDepth: this._sourceTileDepth, sourceTileId: (_a = this._sourceTile) == null ? void 0 : _a.key.id, size: this.size(), end: this.end };
  }
  get first() {
    return 0 === this._sourceTileDepth;
  }
  get reader() {
    return this._reader;
  }
  get end() {
    return this._end;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e13) {
    return this._tile.key.id === e13.key.id ? this.reader : null;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/DrillDownTileLoadStrategy.js
var l7 = class {
  constructor(e13, o16) {
    this.subscription = e13, this._tileIdToResult = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._handles = o([m(e13.signal, () => this._controller.abort()), m(o16, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get(t17) {
    return this._tileIdToResult.get(t17);
  }
  set(t17, e13) {
    this._tileIdToResult.set(t17, e13);
  }
  get options() {
    return { signal: this._controller.signal };
  }
};
var a10 = class extends s15 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t17 of this._loadStates.values()) t17.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(t17) {
    this._loadStates.has(t17.key.id) || this._loadStates.set(t17.key.id, new l7(t17, this._options));
    const s18 = this._loadStates.get(t17.key.id);
    let o16;
    try {
      for await (const o17 of this._fetchChunkInfos(s18, t17.tile, 0)) {
        const { queryJSON: t18, reader: i12, sourceTile: l9, sourceTileDepth: a13, tile: n17 } = o17, h6 = new i10(i12, t18, n17, l9, a13, false);
        s2(s18.options), this._addChunk(h6);
      }
    } catch (n17) {
      o16 = n17;
    }
    const a12 = new i10(u5.empty(this._metadata), null, t17.tile, null, -1, true);
    if (this._addChunk(a12), o16) throw o16;
  }
  unload(t17) {
    var _a2;
    super.unload(t17), (_a2 = this._loadStates.get(t17.key.id)) == null ? void 0 : _a2.destroy(), this._loadStates.delete(t17.key.id);
  }
  async *_fetchChunkInfos(t17, e13, s18) {
    let o16 = t17.get(e13.id);
    const r9 = !!o16;
    if (o16 || (o16 = await this._fetchChunkInfo(t17, e13, s18), t17.set(e13.id, o16)), o16.reader.exceededTransferLimit && s18 < has("featurelayer-query-max-depth")) for (const i12 of e13.createChildTiles()) yield* this._fetchChunkInfos(t17, i12, s18 + 1);
    else r9 || (yield o16);
  }
  async _fetchChunkInfo(t17, e13, s18) {
    const o16 = t17.subscription.tile.getQuantizationParameters(), r9 = this._queryInfo.createTileQuery(e13, { returnExceededLimitFeatures: false, quantizationParameters: o16 });
    return { reader: await this._fetch(r9, t17.options), queryJSON: r9.inner.toJSON(), tile: t17.subscription.tile, sourceTile: e13, sourceTileDepth: s18 };
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/PagedTileSourceChunk.js
var t13 = class extends i8 {
  constructor(e13, t17, i12, r9, s18) {
    super(), this._reader = e13, this._queryJSON = t17, this._tile = i12, this._page = r9, this._end = s18, this.chunkId = `${this._tile.key.id}.${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._page}${this.end ? "e" : ""}`;
  }
  get queryInfo() {
    return { type: "paged-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get page() {
    return this._page;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e13) {
    return this._tile.key.id === e13.key.id ? this.reader : null;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/PagedTileLoadStrategy.js
var n15 = class {
  constructor(e13, s18) {
    this.subscription = e13, this._pages = /* @__PURE__ */ new Set(), this._controller = new AbortController(), this._done = false, this._handles = o([m(e13.signal, () => this._controller.abort()), m(s18, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get pageStart() {
    let t17 = -1;
    for (const e13 of this._pages.values()) t17 = Math.max(t17, e13);
    return t17 + 1;
  }
  get done() {
    return this._done;
  }
  get options() {
    return { signal: this._controller.signal };
  }
  add(t17, e13) {
    this._pages.add(t17), this._done = this._done || e13;
  }
};
var l8 = class extends s15 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t17 of this._loadStates.values()) t17.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(t17) {
    this._loadStates.has(t17.key.id) || this._loadStates.set(t17.key.id, new n15(t17, this._options));
    const s18 = this._loadStates.get(t17.key.id);
    let o16;
    try {
      await this._fetchPages(s18);
    } catch (l9) {
      o16 = l9;
    }
    const r9 = new t13(u5.empty(this._metadata), null, t17.tile, -1, true);
    if (c(s18.options) || this._addChunk(r9), o16) throw o16;
  }
  unload(t17) {
    var _a;
    super.unload(t17), (_a = this._loadStates.get(t17.key.id)) == null ? void 0 : _a.destroy(), this._loadStates.delete(t17.key.id);
  }
  async _fetchPages(t17) {
    const e13 = 4, o16 = 20;
    let r9 = 0, a12 = t17.pageStart, i12 = 1;
    for (; r9 < o16 && !t17.done; ) {
      const o17 = [];
      for (let e14 = 0; e14 < i12; e14++) o17.push(this._fetchChunk(t17, a12++));
      const n17 = await Promise.all(o17);
      for (const e14 of n17) (0 !== e14.size() || e14.first) && (t17.add(e14.page, !e14.reader.exceededTransferLimit), s2(t17.options), this._addChunk(e14));
      r9++, i12 = Math.min(i12 + 1, e13);
    }
  }
  async _fetchChunk(t17, e13) {
    const s18 = t17.subscription.tile, o16 = this._queryInfo.createPagedTileQuery(s18, e13), r9 = await this._fetch(o16, t17.options);
    return new t13(r9, o16.inner.toJSON(), s18, e13, false);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/FeatureSnapshotSourceChunk.js
var t14 = class extends i8 {
  constructor(e13, t17, r9, s18) {
    super(), this._reader = e13, this._queryJSON = t17, this._page = r9, this._end = s18, this.chunkId = `${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = this.chunkId;
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get queryInfo() {
    return { type: "snapshot", chunkId: this.chunkId, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e13) {
    const t17 = this.queryFeaturesInBounds(e13.bounds);
    return t17.setTransformForDisplay(e13.transform), t17;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/SnapshotLoadStrategy.js
var a11 = class extends i9 {
  constructor(t17, e13, o16, s18, n17, a12) {
    super(t17, e13, o16, n17, a12), this._random = new t(1e3), this._featureCount = s18;
  }
  get about() {
    return { willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  load(t17) {
    return null == this._promise && (this._promise = this._downloadPages(this._featureCount)), this._promise;
  }
  unload(t17) {
  }
  async _downloadPages(e13) {
    const r9 = Math.ceil(e13 / this._queryInfo.pageSize), o16 = Array.from({ length: r9 }, (t17, e14) => e14).sort((t17, e14) => this._random.getInt() - this._random.getInt()), a12 = await Promise.all(o16.map((t17) => this._downloadPage(t17))), i12 = new t14(u5.empty(this._metadata), null, -1, true);
    this._store.insert(i12);
    const u8 = a12.filter((t17) => t17);
    if (u8.length) throw new s("featurelayer-query", "Encountered errors when downloading data", { errors: u8 });
  }
  async _downloadPage(t17) {
    try {
      const r9 = this._queryInfo.createPagedQuery(t17), o16 = await this._fetch(r9, this._options), n17 = new t14(o16, r9.inner.toJSON(), t17, false);
      return s2(this._options), this._store.insert(n17), null;
    } catch (r9) {
      return r9;
    }
  }
};

// ../node_modules/@arcgis/core/layers/graphics/data/StreamFeatureManager.js
var s16 = "__esri_stream_id__";
var i11 = "__esri_timestamp__";
var r7 = 1e3;
var o15 = class {
  constructor(t17, e13, i12, r9, o16 = 128) {
    this._trackIdToObservations = /* @__PURE__ */ new Map(), this._idCounter = 0, this._lastPurge = performance.now(), this._addOrUpdated = /* @__PURE__ */ new Map(), this._removed = [], this._maxAge = 0, this._timeInfo = i12, this._purgeOptions = r9, this.store = t17, this.objectIdField = e13, this.purgeInterval = o16, this._useGeneratedIds = this.objectIdField === s16;
  }
  removeById(t17) {
    this._removed.push(t17);
  }
  removeByTrackId(t17) {
    const e13 = this._trackIdToObservations.get(t17);
    if (e13) for (const s18 of e13.entries) this._removed.push(s18);
  }
  add(s18) {
    var _a;
    if (this._useGeneratedIds) {
      const t17 = this._nextId();
      s18.attributes[this.objectIdField] = t17, s18.objectId = t17;
    } else s18.objectId = s18.attributes[this.objectIdField];
    const i12 = s18.objectId;
    if (this._addOrUpdated.set(i12, s18), this._maxAge = Math.max(this._maxAge, s18.attributes[this._timeInfo.startTimeField]), !this._timeInfo.trackIdField) return null == this._trackIdLessObservations && (this._trackIdLessObservations = new t4(1e5)), void this._trackIdLessObservations.enqueue(i12);
    const o16 = s18.attributes[this._timeInfo.trackIdField];
    if (!this._trackIdToObservations.has(o16)) {
      const s19 = null != ((_a = this._purgeOptions) == null ? void 0 : _a.maxObservations) ? this._purgeOptions.maxObservations : r7, i13 = e2(s19, 0, r7);
      this._trackIdToObservations.set(o16, new t4(i13));
    }
    const d9 = this._trackIdToObservations.get(o16), a12 = d9 == null ? void 0 : d9.enqueue(i12);
    null != a12 && (this._addOrUpdated.has(a12) ? this._addOrUpdated.delete(a12) : this._removed.push(a12));
  }
  checkForUpdates() {
    const t17 = this._getToAdd(), e13 = this._getToRemove(), s18 = performance.now();
    s18 - this._lastPurge >= this.purgeInterval && (this._purge(s18), this._lastPurge = s18);
    const r9 = [];
    if (null != e13) for (const i12 of e13) {
      const t18 = this.store.removeById(i12);
      null != t18 && r9.push(t18);
    }
    const o16 = [];
    if (null != t17) {
      const r10 = new Set(e13 ?? []);
      for (const e14 of t17) r10.has(e14.objectId) || (e14.attributes[i11] = s18, this.store.add(e14), o16.push(e14));
    }
    return !(!o16.length && !(r9 == null ? void 0 : r9.length)) && (this.store.update(o16, r9), true);
  }
  _getToAdd() {
    if (!this._addOrUpdated.size) return null;
    const t17 = new Array(this._addOrUpdated.size);
    let e13 = 0;
    return this._addOrUpdated.forEach((s18) => t17[e13++] = s18), this._addOrUpdated.clear(), t17;
  }
  _getToRemove() {
    const t17 = this._removed;
    return this._removed.length ? (this._removed = [], t17) : null;
  }
  _nextId() {
    const t17 = this._idCounter;
    return this._idCounter = (this._idCounter + 1) % 4294967294 + 1, t17;
  }
  _purge(t17) {
    const e13 = this._purgeOptions;
    null != e13 && (this._purgeSomeByDisplayCount(e13), this._purgeByAge(e13), this._purgeByAgeReceived(t17, e13), this._purgeTracks());
  }
  _purgeSomeByDisplayCount(t17) {
    if (!t17.displayCount) return;
    let e13 = this.store.size;
    if (e13 > t17.displayCount) {
      if (this._timeInfo.trackIdField) {
        for (const s18 of this._trackIdToObservations.values()) if (e13 > t17.displayCount && s18.size) {
          const t18 = s18.dequeue();
          this._removed.push(t18), e13--;
        }
      }
      if (null != this._trackIdLessObservations) {
        let s18 = e13 - t17.displayCount;
        for (; s18-- > 0; ) {
          const t18 = this._trackIdLessObservations.dequeue();
          null != t18 && this._removed.push(t18);
        }
      }
    }
  }
  _purgeByAge(t17) {
    var _a;
    const e13 = (_a = this._timeInfo) == null ? void 0 : _a.startTimeField;
    if (!t17.age || !e13) return;
    const s18 = 60 * t17.age * 1e3, i12 = this._maxAge - s18;
    this.store.forEach((t18) => {
      t18.attributes[e13] < i12 && this._removed.push(t18.objectId);
    });
  }
  _purgeByAgeReceived(t17, e13) {
    if (!e13.ageReceived) return;
    const s18 = t17 - 60 * e13.ageReceived * 1e3;
    this.store.forEach((t18) => {
      t18.attributes[i11] < s18 && this._removed.push(t18.objectId);
    });
  }
  _purgeTracks() {
    this._trackIdToObservations.forEach((t17, e13) => {
      0 === t17.size && this._trackIdToObservations.delete(e13);
    });
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s17 = class extends S {
  constructor(r9) {
    super(r9);
  }
  get connectionStatus() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.errorString;
  }
};
e([y()], s17.prototype, "connection", void 0), e([y()], s17.prototype, "connectionStatus", null), e([y()], s17.prototype, "errorString", null), s17 = e([a("esri.views.2d.layers.features.sources.StreamConnectionState")], s17);

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/StreamFeatureStore.js
var t15 = class {
  constructor(e13, t17) {
    this._metadata = e13, this._onUpdate = t17, this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._objectIdToFeature.size;
  }
  get reader() {
    return u5.fromFeatures([...this._objectIdToFeature.values()], this._metadata);
  }
  add(e13) {
    this._objectIdToFeature.set(e13.objectId, e13);
  }
  forEach(e13) {
    this._objectIdToFeature.forEach(e13);
  }
  removeById(e13) {
    const t17 = this._objectIdToFeature.get(e13);
    return t17 ? (this._objectIdToFeature.delete(e13), t17) : null;
  }
  clear() {
    this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  update(e13, t17) {
    this._onUpdate((e13 == null ? void 0 : e13.length) ?? 0);
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/StreamSourceChunk.js
var r8 = class extends i8 {
  constructor(e13) {
    super(), this._reader = e13, this.chunkId = "stream-chunk", this.normalizedChunkId = "stream-chunk";
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return true;
  }
  get end() {
    return true;
  }
  get queryInfo() {
    return { type: "stream", chunkId: this.chunkId, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e13) {
    const r9 = this.queryFeaturesInBounds(e13.bounds);
    return r9.setTransformForDisplay(e13.transform), r9;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/StreamLoadStrategy.js
var h5 = class extends r6 {
  constructor(t17, s18, o16, a12, c10) {
    super(o16), this._service = t17, this._dataFilter = s18, this._streamOptions = a12, this._metadata = c10, this._connectionState = new s17(), this._forceRefresh = false, this.events = new o2();
    const { objectIdField: h6, timeInfo: m9 } = this._metadata, { purgeOptions: d9 } = s18;
    this._stagingStore = new t15(this._metadata, (e13) => this.events.emit("features-updated", e13)), this._manager = new o15(this._stagingStore, h6, m9, d9), this.connect();
  }
  destroy() {
    super.destroy(), this.disconnect();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this._connectionState) == null ? void 0 : _a.errorString;
  }
  async refresh() {
    const e13 = null != this._chunk;
    this._manager.checkForUpdates() || !e13 || this._forceRefresh ? (this._chunk && this._store.remove(this._chunk), this._forceRefresh = false, this._chunk = new r8(this._stagingStore.reader), this._store.insert(this._chunk), this.events.emit("tick")) : this.events.emit("tick");
  }
  async updateFields(e13) {
    throw new Error("Updating available fields not supported for StreamLayer");
  }
  async load(e13) {
  }
  unload(e13) {
  }
  disconnect() {
    var _a;
    this._connection = u2(this._connection), this._connectionState.connection = null, (_a = this._handlesGroup) == null ? void 0 : _a.remove();
  }
  connect() {
    if (null != this._connection) return;
    const { geometryType: e13, spatialReference: s18 } = this._metadata, { maxReconnectionAttempts: n17, maxReconnectionInterval: i12, geometryDefinition: r9, definitionExpression: a12, customParameters: c10 } = this._dataFilter;
    this._connection = r2(this._service.source, s18, this._streamOptions.outSR, e13, a12, r9, n17, i12, c10), this._handlesGroup = o([this._connection.on("data-received", (e14) => this._onFeature(e14)), this._connection.on("message-received", (e14) => this._onWebSocketMessage(e14))]), this._connectionState.connection = this._connection;
  }
  clear() {
    this._manager.checkForUpdates(), this._stagingStore.clear(), this._forceRefresh = true;
  }
  updateCustomParameters(e13) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.updateCustomParameters(e13);
  }
  sendMessageToSocket(e13) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.sendMessageToSocket(e13);
  }
  sendMessageToClient(e13) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.sendMessageToClient(e13);
  }
  _onWebSocketMessage(e13) {
    if ("type" in e13) switch (e13.type) {
      case "delete":
        if (e13.objectIds) for (const t17 of e13.objectIds) this._manager.removeById(t17);
        if (e13.trackIds) for (const t17 of e13.trackIds) this._manager.removeByTrackId(t17);
        break;
      case "clear":
        this.clear();
    }
    this.events.emit("message-received", e13);
  }
  _onFeature(e13) {
    try {
      this._manager.add(e13), this.events.emit("data-received", e13);
    } catch (t17) {
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/SourceChunkStore.js
var n16 = class {
  constructor(s18) {
    this._onChange = s18, this._chunks = /* @__PURE__ */ new Map(), this._chunksToRemove = [], this.events = new o2(), this.featureAdapter = new t3();
  }
  destroy() {
    this.clear();
  }
  clear() {
    for (const e13 of this._chunks.values()) this._chunksToRemove.push(e13);
    this._chunks.clear(), null != this._localEditChunk && this._chunksToRemove.push(this._localEditChunk), this._localEditChunk = null;
  }
  *chunks() {
    this._localEditChunk && (yield this._localEditChunk), this._localOverridesChunk && (yield this._localOverridesChunk), yield* this._chunks.values();
  }
  insert(e13) {
    var _a, _b;
    has("esri-2d-update-debug") && console.debug(`Chunk[${e13.chunkId}] SourceChunkStore.insert`), ((_a = this._localOverridesChunk) == null ? void 0 : _a.overriddenIds.size) && (e13.reader.removeIds(this._localOverridesChunk.overriddenIds), e13.invalidate()), ((_b = this._localEditChunk) == null ? void 0 : _b.overriddenIds.size) && this._localEditChunk.removeOverrides(e13), this._chunks.set(e13.chunkId, e13), this.events.emit("changed"), this._onChange();
  }
  remove(e13) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e13.chunkId}] SourceChunkStore.remove`), this._chunks.delete(e13.chunkId), this._chunksToRemove.push(e13);
  }
  cleanupRemovedChunks() {
    const e13 = this._chunksToRemove;
    return this._chunksToRemove = [], e13;
  }
  applyLocalOverrides(e13, s18) {
    null == this._localOverridesChunk && (this._localOverridesChunk = new r5(s18, "localOverride")), this._localOverridesChunk.applyOverrides(e13);
    for (const o16 of this._chunks.values()) o16.reader.removeIds(this._localOverridesChunk.overriddenIds), o16.invalidate();
  }
  applyLocalEdit(e13, s18) {
    null == this._localEditChunk && (this._localEditChunk = new r5(s18, "localEdit")), this._localEditChunk.applyOverrides(e13);
    for (const o16 of this._chunks.values()) o16.reader.removeIds(this._localEditChunk.overriddenIds), o16.invalidate();
  }
  forEach(e13) {
    const s18 = /* @__PURE__ */ new Set();
    for (const o16 of this.chunks()) {
      const t17 = o16.reader.getCursor();
      for (; t17.next(); ) {
        const o17 = t17.getObjectId();
        s18.has(o17) || (e13(t17.copy()), s18.add(o17));
      }
    }
  }
  forEachUnsafe(e13) {
    const s18 = /* @__PURE__ */ new Set();
    for (const o16 of this.chunks()) {
      const t17 = o16.reader.getCursor();
      for (; t17.next(); ) {
        const o17 = t17.getObjectId();
        s18.has(o17) || (e13(t17), s18.add(o17));
      }
    }
  }
  forEachInBounds(e13, s18) {
    const o16 = /* @__PURE__ */ new Set();
    for (const t17 of this.chunks()) {
      const n17 = t17.queryFeaturesInBounds(e13);
      for (; n17.next(); ) {
        const e14 = n17.getObjectId();
        o16.has(e14) || (s18(n17.copy()), o16.add(e14));
      }
    }
  }
  forEachBounds(e13, o16) {
    const t17 = i();
    for (const s18 of e13) {
      s18.getBounds(t17) && o16(t17);
    }
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSource.js
var S5 = class {
  constructor(e13, t17, s18, r9, a12) {
    this.service = e13, this._aggregateAdapter = t17, this._subscriptions = s18, this._onChange = r9, this._connection = a12, this._updateTracking = new d5({ debugName: "FeatureSource" }), this._didInvalidateData = false, this._store = new n16(this._onChange), this._metadata = new i2(e13.metadata);
  }
  destroy() {
    var _a, _b;
    (_a = this._strategy) == null ? void 0 : _a.destroy(), this._store.destroy(), (_b = this._streamMessenger) == null ? void 0 : _b.destroy(), "memory" === this.service.type && this.service.source.map((e13) => e13.close());
  }
  get metadata() {
    if (!this._metadata) throw new Error("InternalError: Metadata not defined. Was update called?");
    return this._metadata;
  }
  get store() {
    return this._store;
  }
  get streamMessenger() {
    return null == this._streamMessenger && this._initStreamMessenger(), this._streamMessenger;
  }
  get statistics() {
    return t12.from(this._store);
  }
  get updateTracking() {
    return this._updateTracking;
  }
  get queryEngine() {
    if (!this._queryEngine) {
      if (!this._schema) return null;
      const { dataFilter: e13 } = this._schema.mutable, t17 = this._schema.mutable.availableFields, s18 = this._metadata;
      this._queryEngine = new $({ featureStore: this._store, fieldsIndex: s18.fieldsIndex, geometryType: s18.geometryType, objectIdField: s18.objectIdField, hasM: false, hasZ: false, spatialReference: this.service.outSpatialReference, cacheSpatialQueries: true, aggregateAdapter: this._aggregateAdapter, timeInfo: s18.timeInfo, definitionExpression: e13.definitionExpression, availableFields: t17 });
    }
    return this._queryEngine;
  }
  get isStream() {
    return "stream" === this._schema.type;
  }
  chunks() {
    return Array.from(this._store.chunks());
  }
  cleanupRemovedChunks() {
    return this._store.cleanupRemovedChunks();
  }
  onSubscribe(e13) {
    var _a;
    this._connection.onEvent({ type: "subscribe", tile: e13.tile.id });
    const t17 = (_a = this._strategy) == null ? void 0 : _a.load(e13);
    t17 && (t17.then(() => this._connection.onEvent({ type: "loaded", tile: e13.tile.id })).catch((t18) => this._connection.onEvent({ type: "error", tile: e13.tile.id, error: t18 })), this._updateTracking.addPromise(t17));
  }
  onResume(e13) {
    var _a;
    this._updateTracking.addPromise(d((_a = this._strategy) == null ? void 0 : _a.load(e13)));
  }
  onUnsubscribe(e13) {
    var _a;
    this._connection.onEvent({ type: "unsubscribe", tile: e13.tile.id }), (_a = this._strategy) == null ? void 0 : _a.unload(e13);
  }
  getLocalEdit(e13) {
    return this._updateTracking.addPromise(this._getGetLocalEdit(e13));
  }
  applyLocalEdit(e13) {
    this._didInvalidateData = true, this._store.applyLocalEdit(e13, this.metadata);
  }
  async update(e13, t17) {
    var _a, _b, _c;
    const s18 = e13.source, o16 = d3((_a = this._schema) == null ? void 0 : _a.mutable, s18.mutable);
    if (!o16) return false;
    if (has("esri-2d-update-debug") && console.debug(`Version[${t17}] FeatureSource.update`, { changes: o16 }), this._schema = s18, (_b = this._queryEngine) == null ? void 0 : _b.destroy(), this._queryEngine = null, "feature-service" === this.service.type && null != this.service.queryMetadata.lastEditDate && (this._lastEditDate = this.service.queryMetadata.lastEditDate), null == this._streamMessenger && "stream" === this._schema.type && this._initStreamMessenger(), y2(o16, "sourceRefreshVersion") && ((_c = this._strategy) == null ? void 0 : _c.refresh)) return await this._strategy.refresh(), true;
    if ("feature" === s18.type && y2(o16, "availableFields")) {
      if (await this._queryLastEditDateChanged() || this._didInvalidateData) this._didInvalidateData = false, await this._updateStrategy(t17);
      else {
        this._connection.onEvent({ type: "updateFieldsStart" });
        try {
          await this._strategy.updateFields(s18.mutable.availableFields), this._connection.onEvent({ type: "updateFieldsEnd" });
        } catch (n17) {
          this._connection.onEvent({ type: "updateFieldsError", error: n17 });
        }
      }
      return false;
    }
    return !(!s6(o16, "dataFilter") && !s6(o16, "sourceRefreshVersion")) && (await this._updateStrategy(t17), true);
  }
  _initStreamMessenger() {
    null == this._streamMessenger && (this._streamMessenger = new o12(this._connection));
  }
  async _getGetLocalEdit(e13) {
    if (e13.historicMoment && "feature" === this._schema.type && (this._schema.mutable.dataFilter.historicMoment = e13.historicMoment, this._strategy.unsafeSetQueryHistoricMoment(new Date(e13.historicMoment))), "edit-by-feature" === e13.type) {
      const t18 = [...e13.added, ...e13.updated].map((e14) => e4.fromJSON(e14, this.metadata.objectIdField));
      return { reader: u5.fromOptimizedFeatures(t18, this.metadata), removed: this._resolveIdentifiers(e13.removed) };
    }
    const t17 = this._resolveIdentifiers(e13.removed);
    if (!e13.updated.length && !e13.added.length) return { reader: u5.empty(this.metadata), removed: t17 };
    const s18 = this._resolveIdentifiers([...e13.added, ...e13.updated]);
    return { reader: await this._strategy.queryByObjectId(s18), removed: t17 };
  }
  _resolveIdentifiers(e13) {
    const t17 = [], s18 = [];
    for (const r9 of e13) null != r9.objectId && -1 !== r9.objectId ? s18.push(r9.objectId) : t17.push(r9.globalId);
    if (t17.length) {
      const e14 = new Set(t17), r9 = this.metadata.globalIdField;
      if (null == r9) throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");
      this._store.forEachUnsafe((t18) => {
        const a12 = t18.readAttribute(r9);
        e14.has(a12) && s18.push(t18.getObjectId());
      });
    }
    return s18;
  }
  async _queryLastEditDateChanged() {
    if (null == this._lastEditDate) return false;
    const t17 = this.service.source, s18 = { ...t17.query, f: "json" }, r9 = (await U(t17.path, { query: s18, responseType: "json" })).data.editingInfo.lastEditDate;
    return r9 !== this._lastEditDate && (this._lastEditDate = r9, true);
  }
  async _createStrategy() {
    const e13 = "isSourceHosted" in this.service && this.service.isSourceHosted, t17 = Array.isArray(this.service.source), s18 = this.service.source && "collection" in this.service.source, r9 = e13 || t17 || s18;
    if ("stream" === this._schema.type) {
      const e14 = new h5(this.service, this._schema.mutable.dataFilter, this._store, { outSR: this.service.outSpatialReference }, this.metadata);
      return this._streamMessenger.strategy = e14, e14;
    }
    const a12 = this.service, i12 = n13.fromSchema(a12, this._schema, this._metadata), o16 = await this._supportSnapshotMode(a12, i12);
    return o16 ? new a11(a12, i12, this._store, o16.featureCount, this.metadata, this._connection) : r9 ? new l8(a12, i12, this._store, this.metadata, this._connection) : new a10(a12, i12, this._store, this.metadata, this._connection);
  }
  async _updateStrategy(e13) {
    var _a;
    const t17 = await this._createStrategy();
    this._connection.onEvent({ type: "updateStrategyStart", about: t17.about });
    const r9 = !!this._strategy;
    this._store.clear(), (_a = this._strategy) == null ? void 0 : _a.destroy(), this._strategy = t17, has("esri-2d-update-debug") && console.debug(`Version[${e13}] FeatureSource.updateStrategy`, { strategy: t17 });
    const a12 = Array.from(this._subscriptions.values());
    if (!a12.length) return void this._connection.onEvent({ type: "updateStrategyEnd" });
    const i12 = Promise.all(a12.map((e14) => this._strategy.load(e14).then(() => this._connection.onEvent({ type: "loaded", tile: e14.tile.id })).catch((t18) => this._connection.onEvent({ type: "error", tile: e14.tile.id, error: t18 }))));
    this._updateTracking.addPromise(i12);
    try {
      r9 && await i12;
    } catch (o16) {
      f(o16);
    }
    this._connection.onEvent({ type: "updateStrategyEnd" }), has("esri-2d-update-debug") && console.debug(`Version[${e13}] FeatureSource.updateStrategyEnd`, { strategy: t17 });
  }
  async _supportSnapshotMode(e13, t17) {
    const { queryMetadata: s18 } = e13, r9 = s18.snapshotInfo;
    if (!r9 || !r9.supportsSnapshotMinThreshold || !r9.snapshotCountThresholds) return null;
    const a12 = e13.source, i12 = t17.createQuery();
    i12.inner.orderByFields = [], i12.inner.returnGeometry = false;
    const o16 = (await S2(a12, i12.inner, { query: i12.customParameters })).data.count, { min: n17, max: h6 } = r9.snapshotCountThresholds;
    return o16 <= n17 || r9.supportsSnapshotMaxThreshold && o16 < h6 ? { featureCount: o16 } : null;
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureTileSubscription.js
var t16 = class {
  constructor(t17, r9) {
    this.tile = t17, this.version = r9, this._abortController = new AbortController();
  }
  get key() {
    return this.tile.key;
  }
  get signal() {
    return this._abortController.signal;
  }
  abort() {
    this._abortController.abort();
  }
};

// ../node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorker.js
var m8 = class {
  constructor(e13) {
    this.inner = e13, this.resolver = L();
  }
};
var y7 = class {
  constructor() {
    this._aggregateAdapter = { getFeatureObjectIds: (e13) => this._processor.getFeatureObjectIdsForAggregate(e13) }, this._subscriptions = /* @__PURE__ */ new Map(), this._updateRequested = false, this._updateSubscriptionRequests = [], this._updateHighlightRequests = [];
  }
  destroy() {
    this._subscriptions.clear(), this._processor.destroy(), this._source.destroy(), this._handles.remove(), this._updateLocalEditsRequest = null, this._tileInfoView = null;
  }
  onAttach(e13) {
    has("esri-2d-update-debug") && console.debug("Pipeline.onAttach");
    const s18 = this._connection, i12 = z.fromJSON(e13.tileInfoJSON);
    this._tileInfoView = new h2(i12), this._source = new S5(e13.service, this._aggregateAdapter, this._subscriptions, () => this._requestUpdate(), s18), this._processor = new f4(s18, this._source), this._handles = o([d2(() => this._source.updateTracking.updating, () => {
      this._requestUpdate(), d(this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: true }));
    })]);
  }
  onDetach() {
    has("esri-2d-update-debug") && console.debug("Pipeline.onDetach"), this.destroy();
  }
  set remoteClient(e13) {
    this._connection = new t5(e13);
  }
  get features() {
    var _a;
    const t17 = (_a = this._source) == null ? void 0 : _a.queryEngine;
    if (!t17) throw new s("no-queryEngine", "No query engine defined");
    return t17;
  }
  get aggregates() {
    var _a;
    const t17 = (_a = this._processor) == null ? void 0 : _a.aggregateQueryEngine;
    if (!t17) throw new s("no-queryEngine", "No aggregate query engine defined");
    return t17;
  }
  get processor() {
    return this._processor;
  }
  get streamMessenger() {
    return this._source.streamMessenger;
  }
  getDisplayFeatures(e13) {
    return this._processor.getDisplayFeatures(e13);
  }
  async updateSchema(e13, t17) {
    return has("esri-2d-update-debug") && this._updateSchemaRequest && console.error("InternalError: Schema already updating"), this._updateSchemaRequest = new m8({ schema: e13, version: t17 }), this._requestUpdate(), this._updateSchemaRequest.resolver.promise;
  }
  updateSubscriptions(e13) {
    const t17 = new m8(e13);
    return this._updateSubscriptionRequests.push(t17), this._requestUpdate(), t17.resolver.promise;
  }
  updateHighlight(e13) {
    const t17 = new m8(e13);
    return this._updateHighlightRequests.push(t17), this._requestUpdate(), t17.resolver.promise;
  }
  async onEdits(t17) {
    if (null != this._updateLocalEditsRequest) throw new s("InternalError - Already processing an edit");
    this._updateLocalEditsRequest = new m8(t17);
    const s18 = this._updateLocalEditsRequest.resolver.promise;
    return this._requestUpdate(), s18;
  }
  queryStatistics() {
    return this._source.statistics.toJSON();
  }
  async queryVisibleFeatures(e13, t17) {
    return this.features.executeQuery(e13, t17);
  }
  async queryHeatmapStatistics(e13) {
    const t17 = Math.round(u3(e13.radius));
    let s18 = Number.POSITIVE_INFINITY, i12 = Number.NEGATIVE_INFINITY;
    const r9 = "string" == typeof e13.fieldOffset, o16 = e13.fieldOffset ?? 0, n17 = Array.from(this._subscriptions.values()), u8 = this._source.chunks(), d9 = t17 ** 2, c10 = 3 / (Math.PI * d9), p7 = 2 * t17, h6 = Math.ceil(a2 / p7);
    for (const a12 of n17) {
      const t18 = a12.tile, n18 = new Float64Array(h6 * h6);
      for (const s19 of u8) {
        const i13 = s19.getTileReader(t18);
        if (!i13) continue;
        const u9 = i13.getCursor();
        for (; u9.next(); ) {
          let t19 = 1;
          if (null != e13.field) {
            const s21 = u9.readAttribute(e13.field);
            t19 = r9 ? -1 * +s21 : +s21 + o16;
          }
          const s20 = u9.readXForDisplay() / p7, i14 = u9.readYForDisplay() / p7, a13 = Math.floor(s20), l9 = Math.floor(i14);
          if (a13 < 0 || l9 < 0 || a13 >= h6 || l9 >= h6) continue;
          const g5 = ((0.5 + a13 - s20) * p7) ** 2 + ((0.5 + l9 - i14) * p7) ** 2;
          if (g5 > d9) continue;
          const _5 = t19 * (c10 * (1 - g5 / d9) ** 2);
          n18[l9 + a13 * h6] += _5;
        }
      }
      for (let e14 = 0; e14 < n18.length; e14++) s18 = Math.min(s18, n18[e14]), i12 = Math.max(i12, n18[e14]);
    }
    return { max: i12, min: s18 };
  }
  async getSampleFeatures(e13) {
    const t17 = this._source.chunks();
    if (t17.reduce((e14, t18) => e14 + t18.size(), 0) <= e13.minFeatureCount) {
      if (!this._source.updateTracking.updating) {
        const e14 = [];
        return this._source.store.forEachUnsafe((t18) => e14.push(t18.readLegacyFeatureWorldSpace())), e14;
      }
      return null;
    }
    const s18 = /* @__PURE__ */ new Set(), i12 = [], r9 = t17.map((e14) => e14.reader.getCursor()), o16 = new t(), u8 = 3 * e13.sampleSize;
    for (let n17 = 0; n17 < u8 && i12.length < e13.sampleSize; n17++) {
      const e14 = r9[o16.getIntRange(0, t17.length - 1)];
      if (0 === e14.getSize()) continue;
      const n18 = o16.getIntRange(0, e14.getSize() - 1);
      e14.setIndex(n18);
      const u9 = e14.getObjectId();
      s18.has(u9) || (s18.add(u9), i12.push(e14.readLegacyFeatureWorldSpace()));
    }
    return i12.length >= e13.sampleSize ? i12 : null;
  }
  _requestUpdate() {
    this._updateRequested || (this._updateRequested = true, t2(() => this._scheduleNextUpdate()));
  }
  _scheduleNextUpdate() {
    this._updateRequested && (this._ongoingUpdate || (this._ongoingUpdate = O2(this._doUpdate()).finally(() => {
      this._ongoingUpdate = null, this._scheduleNextUpdate();
    }), this._updateRequested = false));
  }
  _subscribe(e13) {
    const t17 = e13.tileId;
    if (this._subscriptions.has(t17)) return;
    has("esri-2d-update-debug") && console.debug(`Tile[${t17}] Pipeline.subscribe`);
    const s18 = new n7(this._tileInfoView, t17), i12 = new t16(s18, e13.version);
    this._subscriptions.set(t17, i12), this._source.onSubscribe(i12), this._processor.onSubscribe(i12);
  }
  _unsubscribe(e13) {
    const t17 = this._subscriptions.get(e13);
    t17 && (has("esri-2d-update-debug") && console.debug(`Tile[${e13}] Pipeline.unsubscribe`), t17.abort(), this._source.onUnsubscribe(t17), this._processor.onUnsubscribe(t17), this._subscriptions.delete(t17.key.id));
  }
  async _doUpdate() {
    if (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateStart"), await this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: true }), this._updateSubscriptionRequests.length) {
      const e14 = this._updateSubscriptionRequests;
      this._updateSubscriptionRequests = [];
      for (const t18 of e14) this._doUpdateSubscriptions(t18.inner), t18.resolver.resolve();
    }
    const e13 = this._updateSchemaRequest;
    if (this._updateSchemaRequest = null, null != e13) {
      const { schema: t18, version: s19 } = e13.inner;
      await this._doUpdateSchema(t18, s19);
    }
    const t17 = this._updateLocalEditsRequest;
    if (this._updateLocalEditsRequest = null, null != t17) {
      has("esri-2d-update-debug") && console.debug("Pipeline.applyEditOverride", t17.inner);
      const e14 = await this._source.getLocalEdit(t17.inner);
      await this._processor.applyLocalEdit(e14), this._source.applyLocalEdit(e14), has("esri-2d-update-debug") && console.debug("Pipeline.endEditOverride", t17.inner);
    }
    if (this._updateHighlightRequests.length) {
      const e14 = this._updateHighlightRequests;
      this._updateHighlightRequests = [];
      for (const t18 of e14) this._processor.updateHighlight(t18.inner), t18.resolver.resolve();
    }
    const s18 = this._source.cleanupRemovedChunks();
    this._processor.removeChunks(s18);
    try {
      this._subscriptions.size && (has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksStart"), await this._processor.updateChunks(), has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksEnd"));
    } catch (r9) {
      f(r9);
    }
    null != t17 && t17.resolver.resolve(), null != e13 && e13.resolver.resolve(), this._updateRequested ? (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=true]"), await this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: true })) : (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=false, After flush]"), await this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: this._updateRequested }));
  }
  async _doUpdateSchema(e13, t17) {
    var _a;
    has("esri-2d-update-debug") && console.debug(`Version[${t17}] Pipeline.updateStart`, { schema: e13 });
    const s18 = { tileInfo: (_a = this._tileInfoView) == null ? void 0 : _a.tileInfo }, i12 = await this._source.update(e13, t17), r9 = Array.from(this._subscriptions.values());
    await this._processor.update(e13, t17, s18, i12, r9), has("esri-2d-update-debug") && console.debug(`Version[${t17}] Pipeline.updateEnd`);
  }
  _doUpdateSubscriptions(e13) {
    has("esri-2d-update-debug") && console.debug("Pipeline.updateSubscriptions", e13);
    for (const t17 of e13.subscribe) this._subscribe(t17);
    for (const t17 of e13.unsubscribe) this._unsubscribe(t17);
  }
};
export {
  y7 as default
};
//# sourceMappingURL=FeaturePipelineWorker-MQRYXNFX.js.map
