var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import React, { useCallback, useEffect, useMemo, useState, } from "react";
import deepmerge from "deepmerge";
import Editor, { loader } from "@monaco-editor/react";
import * as monaco from "monaco-editor";
import { tss } from "tss-react";
loader.config({ monaco: monaco });
var useStyles = tss.create(function () { return ({
    root: {
        height: "100%",
        "&>div": {
            height: "100%",
            overflow: "hidden",
        },
    },
    hidden: {
        display: "none",
    },
}); });
var XmlEditor = function (props) {
    var _a;
    var _b = useStyles(), classes = _b.classes, cx = _b.cx;
    var xml = props.xml, onChanged = props.onChanged, active = props.active, monacoOptions = props.monacoOptions, className = props.className;
    var _c = useState(false), xmlEditorShown = _c[0], setXmlEditorShown = _c[1];
    var onEditorMount = useCallback(function (editor) {
        var _a;
        (_a = monacoOptions === null || monacoOptions === void 0 ? void 0 : monacoOptions.refs) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {
            e.current = editor;
        });
    }, [monacoOptions]);
    var onXmlChanged = useCallback(function (value) {
        if (active) {
            var xmlValue = value !== null && value !== void 0 ? value : xml; // value is empty when the editor initialized
            onChanged(xmlValue);
        }
    }, [xml, active, onChanged]);
    /**
     * Initializes the editor when it is visible for the first time. If it is shown when it is
     * first mounted, the size is wrong.
     */
    useEffect(function () {
        if (active && !xmlEditorShown) {
            setXmlEditorShown(true);
        }
    }, [xmlEditorShown, active]);
    var options = useMemo(function () {
        var _a;
        return deepmerge({
            theme: "vs-light",
            wordWrap: "on",
            wrappingIndent: "deepIndent",
            scrollBeyondLastLine: false,
            minimap: {
                enabled: false,
            },
        }, (_a = monacoOptions === null || monacoOptions === void 0 ? void 0 : monacoOptions.options) !== null && _a !== void 0 ? _a : {});
    }, [monacoOptions === null || monacoOptions === void 0 ? void 0 : monacoOptions.options]);
    /**
     * Only show the editor once it has become active or the editor size will be wrong.
     */
    if (!xmlEditorShown) {
        return null;
    }
    return (React.createElement("div", { className: cx(classes.root, !active && classes.hidden) },
        React.createElement(Editor, __assign({ height: "100%", language: "xml", value: xml, options: options, className: className, onChange: onXmlChanged, onMount: onEditorMount }, ((_a = monacoOptions === null || monacoOptions === void 0 ? void 0 : monacoOptions.props) !== null && _a !== void 0 ? _a : {})))));
};
export default React.memo(XmlEditor);
